This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-27T01:51:24.891Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.github/
  workflows/
    cron-tests.yml
    tests.yml
    tutorials.yml
    wheels.yml
  dependabot.yml
  pull_request_template.md
docs/
  _static/
    gala.css
  _templates/
    autosummary/
      base.rst
      class.rst
      module.rst
  coordinates/
    greatcircle.rst
    index.rst
  dynamics/
    actionangle.rst
    index.rst
    mockstreams.rst
    nbody.rst
    nd-representations.rst
    nonlinear.rst
    orbits-in-detail.rst
    references.txt
  integrate/
    index.rst
  potential/
    compositepotential.rst
    define-new-potential.rst
    hamiltonian-reference-frames.rst
    index.rst
    origin-rotation.rst
    scf-examples.rst
    scf.rst
  tutorials/
    data/
      MW_mass_enclosed.csv
    .gitignore
    Arbitrary-density-SCF.py
    circ-restricted-3body.rst
    define-milky-way-model.py
    integrate-potential-example.rst
    integrate-rotating-frame.rst
    Milky-Way-model.py
    mock-stream-heliocentric.rst
    nb_setup
    pyia-gala-orbit.py
  whatsnew/
    1.0.rst
    index.rst
  _static_animations.py
  .gitignore
  conf.py
  contributing.rst
  conventions.rst
  docs.rst
  getting_started.rst
  glossary.rst
  index.rst
  install.rst
  interop.rst
  make.bat
  Makefile
  references.txt
  refs.bib
  testing.rst
  tutorials.rst
  units.rst
  user_guide.rst
  util.rst
gala/
  coordinates/
    tests/
      gd1_coord.txt
      idl_vgsr_vhel.txt
      sergey_orphan.txt
      SgrCoord_data
      SgrCoord.cpp
      SgrCoord.h
      test_all_streamframes.py
      test_gd1.py
      test_greatcircle.py
      test_jhelum.py
      test_orphan.py
      test_pal5.py
      test_pm_cov_transform.py
      test_reflex.py
      test_sgr.py
      test_velocity_frame_transforms.py
      Vasiliev2020-Sagittarius-subset.csv
    __init__.py
    gd1.py
    greatcircle.py
    helpers.py
    jhelum.py
    magellanic_stream.py
    oph.py
    orphan.py
    pal13.py
    pal5.py
    pm_cov_transform.py
    poincarepolar.py
    reflex.py
    sgr.py
    velocity_frame_transforms.py
  dynamics/
    actionangle/
      _genfunc/
        genfunc_3d.py
        solver.py
        test_potentials.py
        toy_potentials.py
        visualize_surfaces.py
      tests/
        helpers.py
        staeckel_helpers.py
        test_actionangle_o2gf.py
        test_actionangle_staeckel.py
        test_analyticactionangle.py
      __init__.py
      actionangle_o2gf.py
      actionangle_staeckel.py
      analyticactionangle.py
    lyapunov/
      __init__.py
      dop853_lyapunov.pyx
    mockstream/
      tests/
        test_coord.py
        test_df.py
        test_mockstream_class.py
        test_mockstream.py
      __init__.py
      _coord.pxd
      _coord.pyx
      core.py
      df.pxd
      df.pyx
      mockstream_generator.py
      mockstream.pyx
    nbody/
      tests/
        test_nbody.py
      __init__.py
      core.py
      nbody_helper.h
      nbody.pxd
      nbody.pyx
    tests/
      test_core.py
      test_nonlinear.py
      test_orbit.py
      test_plot.py
      test_representation_nd.py
      test_util.py
    __init__.py
    core.py
    nonlinear.py
    orbit.py
    plot.py
    representation_nd.py
    setup_package.py
    util.py
  integrate/
    cyintegrators/
      dopri/
        dop853.c
        dop853.h
        licence.txt
      __init__.py
      dop853.pxd
      dop853.pyx
      leapfrog.pxd
      leapfrog.pyx
      ruth4.pxd
      ruth4.pyx
    pyintegrators/
      __init__.py
      dopri853.py
      leapfrog.py
      rk5.py
      ruth4.py
    tests/
      test_cyintegrators.py
      test_pyintegrators.py
      test_timespec.py
    __init__.py
    core.py
    setup_package.py
    timespec.py
  potential/
    frame/
      builtin/
        __init__.py
        builtin_frames.c
        builtin_frames.h
        frames.pyx
        transformations.py
      src/
        cframe.c
        cframe.h
      tests/
        test_builtin.py
        test_transformations.py
      __init__.py
      cframe.pxd
      cframe.pyx
      core.py
      setup_package.py
    hamiltonian/
      src/
        chamiltonian.c
        chamiltonian.h
      tests/
        helpers.py
        test_hamiltonian.py
        test_with_frame_potential.py
      __init__.py
      chamiltonian.pyx
      setup_package.py
    potential/
      builtin/
        __init__.py
        builtin_potentials.c
        builtin_potentials.h
        core.py
        cybuiltin.pyx
        multipole.c
        multipole.h
        pybuiltin.py
        special.py
      src/
        cpotential.c
        cpotential.h
      tests/
        ccomposite.yml
        Composite.yml
        generate_agama.py
        HarmonicOscillator1D.yml
        helpers.py
        lm10.yml
        Plummer.yml
        pot_disk_506151.pot
        test_all_builtin.py
        test_composite.py
        test_core.py
        test_cpotential.py
        test_interop_agama.py
        test_interop_galpy.py
        test_io.py
        test_special.py
        test_util.py
      __init__.py
      ccompositepotential.pyx
      core.py
      cpotential.pxd
      cpotential.pyx
      interop.py
      io.py
      setup_package.py
      util.py
    scf/
      src/
        bfe_helper.c
        bfe_helper.h
        bfe.c
        bfe.h
        coeff_helper.c
        coeff_helper.h
      tests/
        data/
          computed-hernquist.coeff
          multi-hernquist.coeff
          plummer_coeff_nmax10_lmax5.txt
          plummer_coeff_var_nmax10_lmax5.txt
          random.coeff
          README.md
          simple-hernquist.coeff
          simple-nonsph.coeff
          Snlm-mathematica.csv
          wang-zhao.coeff
        test_accp_fortran.py
        test_bfe_interp.py
        test_bfe.py
        test_class.py
        test_computecoeff_discrete.py
        test_computecoeff_fortran.py
        test_computecoeff.py
      __init__.py
      bfe_class.pyx
      bfe.pyx
      computecoeff.pyx
      core.py
      setup_package.py
    src/
      funcdefs.h
    __init__.py
    common.py
  tests/
    optional_deps.py
    setup_package.py
    test_units.py
    test_util.py
  __init__.py
  _compat_utils.py
  cconfig.pyx
  conftest.py
  io.py
  logging.py
  setup_package.py
  units.py
  util.py
paper/
  paper.bib
  paper.md
.gitignore
.readthedocs.yml
.rtd-environment.yml
AUTHORS.rst
CHANGES.rst
CODE_OF_CONDUCT.md
codemeta.json
LICENSE
pyproject.toml
README.rst
setup.py
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".github/workflows/cron-tests.yml">
name: Cron tests

on:
  schedule:
    - cron: "0 10 * * 1"  # Mondays @ 6AM Eastern
  pull_request:
    # We also want this workflow triggered if the 'Extra CI' label is added
    # or present when PR is updated
    types:
      - synchronize
      - labeled

jobs:
  tests:
    name: Python ${{ matrix.python }} on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    if: (github.event_name == 'schedule' || contains(github.event.pull_request.labels.*.name, 'Extra CI'))
    strategy:
      fail-fast: true
      matrix:
        os: [ubuntu-latest, macos-latest]  # TODO: re-enable windows-latest
        python: ['3.9', '3.10', '3.11']
        include:
          # These set options for each python version. So, for example, when any
          # python 3.11 job in the matrix runs, it should use this toxenv
          - python: '3.11'
            toxenv: py311-test

          - python: '3.10'
            toxenv: py310-test

          - python: 3.9
            toxenv: py39-test-cov

          - python: 3.11
            toxenv: py311-test-extradeps

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # For animation tests
      - uses: FedericoCarboni/setup-ffmpeg@v3
        with:
          # Not strictly necessary, but it may prevent rate limit
          # errors especially on GitHub-hosted macos machines.
          token: ${{ secrets.GITHUB_TOKEN }}
        id: setup-ffmpeg

      - name: Set up Python ${{ matrix.python-version }} on ${{ matrix.os }}
        if: "!startsWith(matrix.os, 'windows')"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      # Windows:
      - uses: conda-incubator/setup-miniconda@v3
        if: startsWith(matrix.os, 'windows')
        with:
          auto-update-conda: true
          python-version: ${{ matrix.python-version }}

      - name: Install Python dependencies - Windows
        if: startsWith(matrix.os, 'windows')
        shell: bash -l {0}
        run: |
          conda install -c conda-forge -q gsl libpython
          python -m pip install -e .[test]
          python -m pip install tox

      - name: Run tests - Windows
        if: startsWith(matrix.os, 'windows')
        shell: bash -l {0}
        run: |
          tox ${{ matrix.toxargs }} -e ${{ matrix.toxenv }} ${{ matrix.toxposargs }}

      # Mac:
      - name: Setup Mac - GSL
        if: startsWith(matrix.os, 'mac')
        run: |
          brew install gsl

      # Ubuntu:
      - name: Setup Linux - GSL
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install gsl-bin libgsl0-dev build-essential

      # Any *nix:
      - name: Install Python dependencies - nix
        if: "!startsWith(matrix.os, 'windows')"
        run: python -m pip install --upgrade tox codecov

      - name: Run tests - nix
        if: "!startsWith(matrix.os, 'windows')"
        run: tox ${{ matrix.toxargs }} -e ${{ matrix.toxenv }} -- ${{ matrix.toxposargs }}
</file>

<file path=".github/workflows/tests.yml">
name: Tests

on:
  push:
    branches:
    - main
    tags:
    - '*'
  pull_request:

jobs:
  check_skip_flags:
    name: Check skip flags
    runs-on: ubuntu-latest
    outputs:
      head-commit-message: ${{ steps.get_head_commit_message.outputs.HEAD_COMMIT_MESSAGE }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GITHUB_SHA }}
      - name: Get head commit message
        id: get_head_commit_message
        run: echo "HEAD_COMMIT_MESSAGE=$(git show -s --format=%s)" >> "$GITHUB_OUTPUT"

  tests:
    name: Python ${{ matrix.python-version }} on ${{ matrix.os }} with numpy ${{ matrix.numpy-version }}, no gsl ${{ matrix.gala-nogsl }}, deps ${{ matrix.pip-test-deps }}
    runs-on: ${{ matrix.os }}
    needs: check_skip_flags
    if: ${{ github.event.pull_request.draft == false && !contains(github.event.pull_request.labels.*.name, 'docs only') && !contains(needs.check_skip_flags.outputs.head-commit-message, '[skip tests]') }}
    strategy:
      fail-fast: true
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: ["ubuntu-latest", "macos-latest"]
        numpy-version: ["latest"]
        gala-nogsl: ["0"]
        pip-test-deps: ["test"]
        include:

          - name: Oldest numpy version supported
            os: ubuntu-latest
            python-version: "3.11"
            numpy-version: "1.24"
            gala-nogsl: "0"
            pip-test-deps: "test"

          - name: Install without GSL
            os: ubuntu-latest
            python-version: "3.11"
            numpy-version: "latest"
            gala-nogsl: "1"
            pip-test-deps: "test"

          - name: With optional dependencies
            os: ubuntu-latest  # note: galpy install failed on macos here
            python-version: "3.11"
            numpy-version: "latest"
            gala-nogsl: "0"
            pip-test-deps: "test,extra"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          allow-prereleases: true

      # For animation tests
      - uses: FedericoCarboni/setup-ffmpeg@v3
        if: ${{ !startsWith(matrix.os, 'mac') }}
        continue-on-error: true
        with:
          # Not strictly necessary, but it may prevent rate limit
          # errors especially on GitHub-hosted macos machines.
          github-token: ${{ secrets.GITHUB_TOKEN }}
          ffmpeg-version: "6.1.0"
        id: setup-ffmpeg

      # Mac:
      - name: Setup Mac - GSL
        if: startsWith(matrix.os, 'mac')
        run: |
          brew install gsl

      # Ubuntu:
      - name: Setup Linux - GSL
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install gsl-bin libgsl0-dev build-essential
          sudo apt-get install libhdf5-serial-dev  # TODO: remove when h5py has 3.11 wheels

      - name: Install package and dependencies
        run: python -m pip install -e ".[${{ matrix.pip-test-deps }}]"
        env:
          GALA_NOGSL: ${{ matrix.gala-nogsl }}

      - name: Update versions if testing min versions
        if: matrix.numpy-version != 'latest'
        run: |
          python -m pip install numpy~=${{ matrix.numpy-version }}

      - name: Run tests
        run: >-
          python -m pytest -ra --cov --cov-report=xml --cov-report=term
          --durations=20 .

      - name: Upload coverage report
        uses: codecov/codecov-action@v4.5.0
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
</file>

<file path=".github/workflows/tutorials.yml">
name: Tutorials
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  release:
    types:
      - published

jobs:
  check_skip_flags:
    name: Check skip flags
    runs-on: ubuntu-latest
    outputs:
      head-commit-message: ${{ steps.get_head_commit_message.outputs.HEAD_COMMIT_MESSAGE }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GITHUB_SHA }}
      - name: Get head commit message
        id: get_head_commit_message
        run: echo "HEAD_COMMIT_MESSAGE=$(git show -s --format=%s)" >> "$GITHUB_OUTPUT"

  notebooks:
    name: "Build the notebooks for the docs"
    runs-on: ubuntu-latest
    needs: check_skip_flags
    if: ${{ github.event.pull_request.draft == false && !contains(needs.check_skip_flags.outputs.head-commit-message, '[skip docs]') }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install -U pip wheel
          python -m pip install ".[tutorials]"

      - name: Execute the notebooks
        run: |
          cd docs
          make exectutorials

      - uses: actions/upload-artifact@v3
        with:
          name: notebooks-for-${{ github.sha }}
          path: docs/tutorials

      - name: Trigger RTDs build
        if: ${{ github.event_name != 'pull_request' }}
        uses: dfm/rtds-action@v1.1.0
        with:
          webhook_url: ${{ secrets.RTDS_WEBHOOK_URL }}
          webhook_token: ${{ secrets.RTDS_WEBHOOK_TOKEN }}
          commit_ref: ${{ github.ref }}
</file>

<file path=".github/workflows/wheels.yml">
name: Wheels
on:
  release:
    types:
      - published
      - edited
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build_nix_wheels:
    name: Build wheels on ${{ matrix.os }} - ${{ matrix.python[1] }}
    runs-on: ${{ matrix.os }}
    if: github.event.pull_request.draft == false && !contains(github.event.pull_request.labels.*.name, 'docs only')
    strategy:
      fail-fast: false
      matrix:
        # Building wheels on linux takes too much time: split wheels into multiple runs
        python:
          - ["1", "cp310-*"]
          - ["2", "cp311-*"]
          - ["3", "cp312-*"]
        os:
          - "macos-14"
          - "ubuntu-latest"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build wheels
        uses: pypa/cibuildwheel@v2.21.1
        env:
          CIBW_ARCHS_LINUX: "x86_64"
          CIBW_ARCHS_MACOS: "x86_64 arm64"
          CIBW_BUILD: ${{ matrix.python[1] }}
          CIBW_MANYLINUX_X86_64_IMAGE: manylinux_2_28
          CIBW_MANYLINUX_AARCH64_IMAGE: manylinux_2_28
          CIBW_SKIP: "*-win32 *musllinux* pp* *i686"
          CIBW_BEFORE_ALL_LINUX: dnf install -y gsl gsl-devel || apt-get install gsl-bin libgsl0-dev
          CIBW_BEFORE_ALL_MACOS: brew install gsl pipx
          MACOSX_DEPLOYMENT_TARGET: 14.0

      - uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.os }}-${{ matrix.python[0] }}
          path: ./wheelhouse/*.whl

  build_sdist:
    name: Build source distribution
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        name: Install Python
        with:
          python-version: "3.11"

      - name: Build sdist
        run: |
          sudo apt-get update
          sudo apt-get install gsl-bin libgsl0-dev
          pip install build
          python -m build -s .

      - uses: actions/upload-artifact@v4
        with:
          name: wheels-sdist
          path: dist/*.tar.gz

  test_upload_pypi:
    needs: [build_nix_wheels, build_sdist]
    # Only test upload to pypi on push to main:
    environment: release
    permissions:
      id-token: write
    runs-on: ubuntu-latest
    if:
      github.repository_owner == 'adrn' && github.event_name == 'push' &&
      github.ref == 'refs/heads/main'
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: wheels*
          path: dist
          merge-multiple: true

      - name: Upload package to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/


  upload_pypi:
    needs: [build_nix_wheels, build_sdist]
    runs-on: ubuntu-latest
    if:
      github.event_name == 'release' &&
      (github.event.action == 'published' || github.event.action == 'edited')
    environment:
      name: release
      url: https://pypi.org/p/gala
    permissions:
      id-token: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: wheels*
          path: dist
          merge-multiple: true

      - name: Publish package distributions to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
</file>

<file path=".github/pull_request_template.md">
### Describe your changes


### Checklist

* [ ] Did you add tests?
* [ ] Did you add documentation for your changes?
* [ ] Did you reference any relevant issues?
* [ ] Did you add a changelog entry? (see `CHANGES.rst`)
* [ ] Are the CI tests passing?
* [ ] Is the milestone set?
</file>

<file path="docs/_static/gala.css">
span#logotext2 {
    color: #764099;
}

/* Taken from NumPy */

@import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&family=Open+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap');

.navbar-brand img {
   height: 60px;
}
.navbar-brand {
   height: 75px;
}

body {
  font-family: 'Open Sans', sans-serif;
}

pre, code {
  font-size: 100%;
  line-height: 155%;
}

div.output_area div[class*=highlight] pre {
  white-space: pre-wrap;
}

/* Make output lighter gray and no italics for the love of all that is holy! */
html[data-theme="light"] .highlight .go {
  color: #555555;
  font-style: normal;
}

html[data-theme="dark"] .highlight .go {
  font-style: normal;
}

/* OMG why would you bold numbers */
.highlight .mf, .highlight .mi {
  font-weight: 300;
}

/* Override some aspects of the pydata-sphinx-theme: taken from Pandas */

:root {
  /* Use softer blue from bootstrap's default info color */
  /* --pst-color-info: 23, 162, 184; */
  --pst-color-primary: 118, 63, 152;
  --pst-color-success: 40, 167, 69;
  --pst-color-info: 0, 123, 255;
  --pst-color-warning: 255, 193, 7;
  --pst-color-danger: 220, 53, 69;
  --pst-color-text-base: 51, 51, 51;

  --pst-font-size-base: 15px;

  --pst-color-link: 118, 63, 152;
  --pst-color-headerlink-hover: 118, 63, 152;

  /* heading font sizes */
  --pst-font-size-h1: 28px;
  --pst-font-size-h2: 25px;
  --pst-font-size-h3: 20px;
  --pst-font-size-h4: 18px;
  --pst-font-size-h5: 16px;
  --pst-font-size-h6: 15px;
}
</file>

<file path="docs/_templates/autosummary/base.rst">
{% if referencefile %}
.. include:: {{ referencefile }}
{% endif %}

{{ objname }}
{{ underline }}

.. currentmodule:: {{ module }}

.. auto{{ objtype }}:: {{ objname }}
</file>

<file path="docs/_templates/autosummary/class.rst">
{% if referencefile %}
.. include:: {{ referencefile }}
{% endif %}

{{ objname }}
{{ underline }}

.. currentmodule:: {{ module }}

.. autoclass:: {{ objname }}
   :show-inheritance:

   {% if '__init__' in methods %}
     {% set caught_result = methods.remove('__init__') %}
   {% endif %}

   {% block attributes_summary %}
   {% if attributes %}

   .. rubric:: Attributes Summary

   .. autosummary::
   {% for item in attributes %}
      ~{{ name }}.{{ item }}
   {%- endfor %}

   {% endif %}
   {% endblock %}

   {% block methods_summary %}
   {% if methods %}

   .. rubric:: Methods Summary

   .. autosummary::
   {% for item in methods %}
      ~{{ name }}.{{ item }}
   {%- endfor %}

   {% endif %}
   {% endblock %}

   {% block attributes_documentation %}
   {% if attributes %}

   .. rubric:: Attributes Documentation

   {% for item in attributes %}
   .. autoattribute:: {{ item }}
   {%- endfor %}

   {% endif %}
   {% endblock %}

   {% block methods_documentation %}
   {% if methods %}

   .. rubric:: Methods Documentation

   {% for item in methods %}
   .. automethod:: {{ item }}
   {%- endfor %}

   {% endif %}
   {% endblock %}
</file>

<file path="docs/_templates/autosummary/module.rst">
{% if referencefile %}
.. include:: {{ referencefile }}
{% endif %}

{{ objname }}
{{ underline }}

.. automodule:: {{ fullname }}

   {% block functions %}
   {% if functions %}
   .. rubric:: Functions

   .. autosummary::
   {% for item in functions %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}

   {% block classes %}
   {% if classes %}
   .. rubric:: Classes

   .. autosummary::
   {% for item in classes %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}

   {% block exceptions %}
   {% if exceptions %}
   .. rubric:: Exceptions

   .. autosummary::
   {% for item in exceptions %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}
</file>

<file path="docs/coordinates/greatcircle.rst">
For the examples below, we assume the following imports have already been
executed::

    >>> import astropy.units as u
    >>> import astropy.coordinates as coord
    >>> import numpy as np
    >>> import gala.coordinates as gc

.. _greatcircle:

*************************************************
Great circle and stellar stream coordinate frames
*************************************************


Introduction
============

Great circle coordinate systems are defined as a rotation from another spherical
coordinate system, such as the ICRS. The great circle system is defined by a specified
(north) pole and spherical origin -- i.e. a specification of the new coordinate system x
and z axes in components of the old coordinate system.

`gala` currently supports great circle frames that are defined as a rotation away from
the ICRS (RA, Dec) through the `~gala.coordinates.GreatCircleICRSFrame` class. To create
a new great circle frame with the default initializer, you must specify a pole using the
``pole`` keyword argument and the spherical origin with the ``origin`` argument.
However, this frame also supports other initialization paths through the ``from_``
classmethods (see API below). These classmethods are the most useful initialization
methods. For example, to define a great circle system with the pole at (RA, Dec) =
(32.5, 19.8)º and a longitude 0 at RA=100º, we first have to create a coordinate object
for the pole::

    >>> pole = coord.SkyCoord(ra=32.5*u.deg, dec=19.8*u.deg)

We can then pass this pole to the `~gala.coordinates.GreatCircleICRSFrame.from_pole_ra0`
classmethod to define our coordinate frame::

    >>> frame = gc.GreatCircleICRSFrame.from_pole_ra0(pole=pole, ra0=100*u.deg)

This frame instance acts like any other Astropy coordinate frame. For example, we can
transform other coordinates to this new coordinate system using::

    >>> c = coord.SkyCoord(ra=[160, 53]*u.deg, dec=[-11, 9]*u.deg)
    >>> c_fr = c.transform_to(frame)
    >>> c_fr # doctest: +FLOAT_CMP
    <SkyCoord (GreatCircleICRSFrame: pole=<ICRS Coordinate: (ra, dec) in deg
        (32.5, 19.8)>, origin=<ICRS Coordinate: (ra, dec) in deg
        (280., 46.74765478)>, priority=origin): (phi1, phi2) in deg
        [(-127.59199268, -38.82050866), (-154.93887946,  67.43382209)]>

The spherical coordinate components of the resulting great circle frame are
always named ``phi1`` and ``phi2``, so to access the longitude and latitude in
the new system, we use::

    >>> c_fr.phi1 # doctest: +FLOAT_CMP
    <Longitude [-127.59199268, -154.93887946] deg>
    >>> c_fr.phi2 # doctest: +FLOAT_CMP
    <Latitude [-38.82050866,  67.43382209] deg>

The transformation also works for velocity components. For example, if we have a
sky position and proper motions, we can transform to the great circle frame in
the same way::

    >>> c2 = coord.SkyCoord(
    ...     ra=160*u.deg,
    ...     dec=-11*u.deg,
    ...     pm_ra_cosdec=5*u.mas/u.yr,
    ...     pm_dec=0.3*u.mas/u.yr
    ... )
    >>> c2_fr = c2.transform_to(frame)
    >>> c2_fr.phi1 # doctest: +FLOAT_CMP
    <Longitude -127.59199268 deg>
    >>> c2_fr.pm_phi1_cosphi2 # doctest: +FLOAT_CMP
    <Quantity 1.71997614 mas / yr>
    >>> c2_fr.pm_phi2 # doctest: +FLOAT_CMP
    <Quantity -4.70443217 mas / yr>

The generic great circle frame can also handle transforming from great circle
coordinates to other coordinate frames. For example, to transform a grid of points along
a great circle to the ICRS system, we would define a frame with positional data and a
specified pole::

    >>> c3_fr = gc.GreatCircleICRSFrame(
    ...     phi1=np.linspace(0, 360, 8)*u.deg,
    ...     phi2=0*u.deg,
    ...     pole=frame.pole,
    ...     origin=frame.origin
    ... )
    >>> c3 = c3_fr.transform_to(coord.ICRS())
    >>> c3.ra # doctest: +FLOAT_CMP
    <Longitude [280.        , 302.73861084, 326.04009238,  67.95460569,
                113.51995793, 132.05271289, 180.05477998, 280.        ] deg>


Creating a coordinate frame from two points along a great circle
================================================================

It is sometimes convenient to define a great circle coordinate frame by specifying two
endpoints of an arc segment along a great circle (instead of the pole). For these use
cases, the `~gala.coordinates.GreatCircleICRSFrame.from_endpoints` provides a
convenience classmethod for creating a great circle frame with endpoints::

    >>> endpoints = coord.SkyCoord(
    ...     ra=[-38.8, 4.7]*u.deg,
    ...     dec=[-45.1, -51.7]*u.deg
    ... )
    >>> frame2 = gc.GreatCircleICRSFrame.from_endpoints(endpoints[0], endpoints[1])
    >>> frame2
    <GreatCircleICRSFrame Frame (pole=<ICRS Coordinate: (ra, dec) in deg
        (359.1291976, 38.16814051)>, origin=<ICRS Coordinate: (ra, dec) in deg
        (341.46580563, -50.48035324)>, priority=origin)>

Without specifying a longitude zeropoint, the default behavior of the above classmethod
is to take the spherical midpoint of the two endpoints as the longitude zeropoint.
However, a custom zeropoint can be specified using the ``ra0`` keyword argument. For
example::

    >>> frame3 = gc.GreatCircleICRSFrame.from_endpoints(
    ...     endpoints[0], endpoints[1], ra0=150*u.deg
    ... )
    >>> frame3
    <GreatCircleICRSFrame Frame (pole=<ICRS Coordinate: (ra, dec) in deg
        (359.1291976, 38.16814051)>, origin=<ICRS Coordinate: (ra, dec) in deg
        (330., -48.01820335)>, priority=origin)>


Creating a coordinate frame from endpoints and an origin
========================================================

When working with stellar streams, it is sometimes useful to create a stream-aligned
coordinate frame by specifying an exact origin for the new great circle coordinate frame
(e.g., set to the progenitor system) along with the endpoints of the stream (which are
often close to defining a great circle). In these cases, the great circle defined by the
endpoints and the great circle defined by the origin may not be orthogonal. You can
still use these to create a `~gala.coordinates.GreatCircleICRSFrame`, but by default the
pole location will be adjusted to be orthogonal to the input origin::

    >>> endpoints = coord.SkyCoord(
    ...     ra=[-38.8, 4.7]*u.deg,
    ...     dec=[-45.1, -51.7]*u.deg
    ... )
    >>> origin = coord.SkyCoord(330., -48., unit=u.deg)
    >>> frame4 = gc.GreatCircleICRSFrame.from_endpoints(  # doctest: +IGNORE_WARNINGS
    ...     endpoints[0], endpoints[1], origin=origin
    ... )
    >>> frame4
    <GreatCircleICRSFrame Frame (pole=<ICRS Coordinate: (ra, dec) in deg
        (359.13616655, 38.18404071)>, origin=<ICRS Coordinate: (ra, dec) in deg
        (330., -48.)>, priority=origin)>


Creating a coordinate frame from a pole and longitude zero point
================================================================

Another common way of initializing great circle coordinate systems is with a pole and a
longitude zero point (as was previously — prior to v1.7 — allowed in the initializer
`~gala.coordinates.GreatCircleICRSFrame`). This can now be done with the
`~gala.coordinates.GreatCircleICRSFrame.from_pole_ra0` classmethod::

    >>> frame5 = gc.GreatCircleICRSFrame.from_pole_ra0(
    ...     pole=pole, ra0=100*u.deg
    ... )
    >>> frame5
    <GreatCircleICRSFrame Frame (pole=<ICRS Coordinate: (ra, dec) in deg
        (32.5, 19.8)>, origin=<ICRS Coordinate: (ra, dec) in deg
        (280., 46.74765478)>, priority=origin)>

With just these inputs, there is an ambiguity in the definition of the coordinate frame
because the great circles defined by the pole and longitude zero point intersect at two
locations (so there are two possible origins, one being the negative of the other). The
convention here is to pick the origin closest to (0, 0). To have finer control over
which origin is picked, you can also pass in a sky coordinate object with the
``origin_disambiguate`` argument, and the origin closest to this coordinate will be used
to define the coordinate frame.


.. _greatcircle-api:

API
===

.. automodapi:: gala.coordinates.greatcircle
    :no-inheritance-diagram:
</file>

<file path="docs/coordinates/index.rst">
.. module:: gala.coordinates

.. _gala-coordinates:

*********************************************
Coordinate Systems (`gala.coordinates`)
*********************************************

Introduction
============

The `~gala.coordinates` subpackage primarily provides specialty
:mod:`astropy.coordinates` frame classes for coordinate systems defined by the
stellar streams, and for other common Galactic dynamics tasks like removing
solar reflex motion from proper motions or radial velocities, and transforming
a proper motion covariance matrix from one frame to another.

For the examples below the following imports have already been executed::

    >>> import numpy as np
    >>> import astropy.coordinates as coord
    >>> import astropy.units as u
    >>> import gala.coordinates as gc

We will also set the default Astropy Galactocentric frame parameters to the
values adopted in Astropy v4.0:

    >>> _ = coord.galactocentric_frame_defaults.set('v4.0')

Stellar stream coordinate frames
================================

`gala` provides Astropy coordinate frame classes for transforming to several
built-in stellar stream stream coordinate frames (as defined in the references
below), and for transforming positions and velocities to and from coordinate
systems defined by great circles or poles. These classes behave like the
built-in astropy coordinates frames (e.g., :class:`~astropy.coordinates.ICRS` or
:class:`~astropy.coordinates.Galactic`) and can be transformed to and from other
astropy coordinate frames. For example, to convert a set of
`~astropy.coordinates.ICRS` (RA, Dec) coordinates to a coordinate system aligned
with the Sagittarius stream with the `~gala.coordinates.SagittariusLaw10`
frame::

    >>> c = coord.ICRS(ra=100.68458*u.degree, dec=41.26917*u.degree)
    >>> sgr = c.transform_to(gc.SagittariusLaw10())
    >>> (sgr.Lambda, sgr.Beta) # doctest: +FLOAT_CMP
    (<Longitude 179.58511053544734 deg>, <Latitude -12.558450192162654 deg>)

Or, to transform from `~gala.coordinates.SagittariusLaw10` coordinates to the
`~astropy.coordinates.Galactic` frame::

    >>> sgr = gc.SagittariusLaw10(Lambda=156.342*u.degree, Beta=1.1*u.degree)
    >>> c = sgr.transform_to(coord.Galactic())
    >>> (c.l, c.b) # doctest: +FLOAT_CMP
    (<Longitude 182.5922090437946 deg>, <Latitude -9.539692094685893 deg>)

These transformations also handle velocities so that proper motion components
can be transformed between the systems. For example, to transform from
`~gala.coordinates.GD1Koposov10` proper motions to
`~astropy.coordinates.Galactic` proper motions::

    >>> gd1 = gc.GD1Koposov10(phi1=-35*u.degree, phi2=0*u.degree,
    ...                       pm_phi1_cosphi2=-12.20*u.mas/u.yr,
    ...                       pm_phi2=-3.10*u.mas/u.yr)
    >>> gd1.transform_to(coord.Galactic()) # doctest: +FLOAT_CMP
    <Galactic Coordinate: (l, b) in deg
        (181.28968151, 54.84972806)
     (pm_l_cosb, pm_b) in mas / yr
        (12.03209393, -3.69847479)>

As with the other Astropy coordinate frames, with a full specification of the 3D
position and velocity, we can transform to a
`~astropy.coordinates.Galactocentric` frame::

    >>> gd1 = gc.GD1Koposov10(phi1=-35.00*u.degree, phi2=0.04*u.degree,
    ...                       distance=7.83*u.kpc,
    ...                       pm_phi1_cosphi2=-12.20*u.mas/u.yr,
    ...                       pm_phi2=-3.10*u.mas/u.yr,
    ...                       radial_velocity=-32*u.km/u.s)
    >>> gd1.transform_to(coord.Galactocentric()) # doctest: +FLOAT_CMP
    <Galactocentric Coordinate (galcen_coord=<ICRS Coordinate: (ra, dec) in deg
        (266.4051, -28.936175)>, galcen_distance=8.122 kpc, galcen_v_sun=(12.9, 245.6, 7.78) km / s, z_sun=20.8 pc, roll=0.0 deg): (x, y, z) in kpc
        (-12.61622659, -0.09870921, 6.43179403)
    (v_x, v_y, v_z) in km / s
        (-71.14675268, -203.01648654, -97.12884319)>

For custom great circle coordinate systems, and for more information about the
stellar stream frames, see :ref:`greatcircle`.


Correcting velocities for solar reflex motion
---------------------------------------------

The `~gala.coordinates.reflex_correct` function accepts an Astropy
`~astropy.coordinates.SkyCoord` object with position and velocity information,
and returns a coordinate object with the solar motion added back in to the
velocity components. This is useful for computing velocities in a Galactocentric
reference frame, rather than a solar system barycentric frame.

The `~gala.coordinates.reflex_correct` function accepts a coordinate object with
scalar or array values::

    >>> c = coord.SkyCoord(ra=[180.323, 1.523]*u.deg,
    ...                    dec=[-17, 29]*u.deg,
    ...                    distance=[172, 412]*u.pc,
    ...                    pm_ra_cosdec=[-11, 3]*u.mas/u.yr,
    ...                    pm_dec=[4, 8]*u.mas/u.yr,
    ...                    radial_velocity=[114, -21]*u.km/u.s)
    >>> gc.reflex_correct(c) # doctest: +FLOAT_CMP
    <SkyCoord (ICRS): (ra, dec, distance) in (deg, deg, pc)
        [(180.323, -17., 172.), (  1.523,  29., 412.)]
    (pm_ra_cosdec, pm_dec, radial_velocity) in (mas / yr, mas / yr, km / s)
        [(139.47001884, 175.45769809, -47.09032586),
        (-61.01738781,  61.51055793, 163.36721898)]>

By default, this uses the solar location and velocity from the
`astropy.coordinates.Galactocentric` frame class. To modify these parameters,
for example, to change the solar velocity, or the sun's height above the
Galactic midplane, use the arguments of the `astropy.coordinates.Galactocentric`
class and pass in an instance of the `astropy.coordinates.Galactocentric`
frame::

    >>> vsun = coord.CartesianDifferential([11., 245., 7.]*u.km/u.s)
    >>> gc_frame = coord.Galactocentric(galcen_v_sun=vsun, z_sun=0*u.pc)
    >>> gc.reflex_correct(c, gc_frame) # doctest: +FLOAT_CMP
    <SkyCoord (ICRS): (ra, dec, distance) in (deg, deg, pc)
        [(180.323, -17., 172.), (  1.523,  29., 412.)]
    (pm_ra_cosdec, pm_dec, radial_velocity) in (mas / yr, mas / yr, km / s)
        [(136.93481249, 175.37627916, -47.6177433 ),
        (-59.96484921,  61.41044742, 163.90707073)]>

If you don't have radial velocity information and want to correct the proper
motions, pass in zeros for the radial velocity (and ignore the output value of
the radial velocity)::

    >>> c = coord.SkyCoord(ra=162*u.deg,
    ...                    dec=-17*u.deg,
    ...                    distance=172*u.pc,
    ...                    pm_ra_cosdec=-11*u.mas/u.yr,
    ...                    pm_dec=4*u.mas/u.yr,
    ...                    radial_velocity=0*u.km/u.s)
    >>> gc.reflex_correct(c) # doctest: +FLOAT_CMP
    <SkyCoord (ICRS): (ra, dec, distance) in (deg, deg, pc)
        (162., -17., 172.)
    (pm_ra_cosdec, pm_dec, radial_velocity) in (mas / yr, mas / yr, km / s)
        (88.20380175, 163.68500525, -192.48721942)>

Similarly, if you don't have proper motion information and want to correct the
proper motions, pass in zeros for the proper motions (and ignore the output
values of the proper motions) -- this is sometimes called "v_GSR"::

    >>> c = coord.SkyCoord(ra=162*u.deg,
    ...                    dec=-17*u.deg,
    ...                    distance=172*u.pc,
    ...                    pm_ra_cosdec=0*u.mas/u.yr,
    ...                    pm_dec=0*u.mas/u.yr,
    ...                    radial_velocity=127*u.km/u.s)
    >>> gc.reflex_correct(c) # doctest: +FLOAT_CMP
    <SkyCoord (ICRS): (ra, dec, distance) in (deg, deg, pc)
        (162., -17., 172.)
    (pm_ra_cosdec, pm_dec, radial_velocity) in (mas / yr, mas / yr, km / s)
        (99.20380175, 159.68500525, -65.48721942)>


Transforming a proper motion covariance matrix to a new coordinate frame
------------------------------------------------------------------------

When working with Gaia or other astrometric data sets, you may need to transform
the reported covariance matrix between proper motion components into a new
coordinate system. For example, Gaia data are provided in the
`~astropy.coordinates.ICRS` (equatorial) coordinate frame, but for Galactic
science, we often want to instead work in the `~astropy.coordinates.Galactic`
coordinate system. For this and other transformations that only require a
rotation (i.e. the origin doesn't change), the astrometric covariance matrix can
be transformed exactly through a projection of the rotation onto the tangent
plane at a given location. The details of this procedure are explained in `this
document from the Gaia data processing team
<https://gea.esac.esa.int/archive/documentation/GDR2/Data_processing/chap_cu3ast/sec_cu3ast_intro/ssec_cu3ast_intro_tansforms.html>`_,
and this functionality is implemented in `gala`. Let's first create a coordinate
object to transform::

    >>> c = coord.SkyCoord(ra=62*u.deg,
    ...                    dec=17*u.deg,
    ...                    pm_ra_cosdec=1*u.mas/u.yr,
    ...                    pm_dec=3*u.mas/u.yr)

and a covariance matrix for the proper motion components, for example, as would
be constructed from a single row from a Gaia data release source catalog::

    >>> cov = np.array([[0.53510132, 0.16637034],
    ...                 [0.16637034, 1.1235292 ]])

This matrix specifies the 2D error distribution for the proper motion
measurement *in the ICRS frame*. To transform this matrix to, e.g., the Galactic
coordinate system, use the function
`~gala.coordinates.transform_pm_cov`::

    >>> gc.transform_pm_cov(c, cov, coord.Galactic()) # doctest: +FLOAT_CMP
    array([[ 0.69450047, -0.309945  ],
           [-0.309945  ,  0.96413005]])

Note that this also works for all of the great circle or stellar stream
coordinate frames implemented in `gala`::

    >>> gc.transform_pm_cov(c, cov, gc.GD1Koposov10()) # doctest: +FLOAT_CMP
    array([[1.10838914, 0.19067958],
           [0.19067958, 0.55024138]])

This works for array-valued coordinates as well, so try to avoid looping over
this function and instead apply it to array-valued coordinate objects.


References
----------

* `A 2MASS All-Sky View of the Sagittarius Dwarf Galaxy: I. Morphology of the
  Sagittarius Core and Tidal Arms <http://arxiv.org/abs/astro-ph/0304198>`_
* `The Orbit of the Orphan Stream <http://arxiv.org/abs/1001.0576>`_
* `Constraining the Milky Way potential with a 6-D phase-space map of the GD-1
  stellar stream <https://arxiv.org/abs/0907.1085>`_


Using gala.coordinates
======================

More details are provided in the linked pages below:

.. toctree::
   :maxdepth: 1

   greatcircle


.. _gala-coordinates-api:

API
===

.. automodapi:: gala.coordinates
    :no-inheritance-diagram:
    :no-main-docstr:
</file>

<file path="docs/dynamics/actionangle.rst">
.. _gala-actionangle:

************************************************
Transforming to actions, angles, and frequencies
************************************************

Introduction
============

Regular orbits permit a (local) transformation to a set of canonical coordinates
such that the momenta are independent, isolating integrals of motion (the
actions, :math:`\boldsymbol{J}`) and the conjugate coordinate variables (the
angles, :math:`\boldsymbol{\theta}`) linearly increase with time. Action-angle
coordinates are useful for a number of applications because the equations of motion are very simple:

.. math::

    H &= H(\boldsymbol{J})\\
    \dot{\boldsymbol{J}} &= -\frac{\partial H}{\partial \boldsymbol{\theta}} = 0\\
    \dot{\boldsymbol{\theta}} &= \frac{\partial H}{\partial \boldsymbol{J}} = \boldsymbol{\Omega}(\boldsymbol{J}) = {\rm constant}

Analytic transformations from phase-space to action-angle coordinates are only
known for a few simple cases where the gravitational potential is separable or
has many symmetries. However, astronomical systems can often be approximately axisymmetric or triaxial, or have complex radial profiles that are not captured by these simple gravitational potentials where the transformations are known.

Several numerical methods have been developed over recent years to enable
approximate transformations between ordinary position and velocity to
action-angle coordinates -- see [sanders16]_ for a summary of these methods.
In Gala, we have implemented the method described in [sanders14]_ -- later in
[sanders16]_ named the "O2GF" method -- for computing actions and angles from
numerically integrated orbits. Gala also provides an interface to the `galpy
<https://github.com/jobovy/galpy>`_ implementation of the "Staeckel Fudge"
method, which is much faster but only useful for axisymmetric or spherical
potentials.

The O2GF action solver
======================

As mentioned above, this method was first introduced in [sanders14]_ and later
described in [sanders16]_. This method is very general in that it works with any
numerically-integrated orbital time series. However, it is slower than other
approximate methods: If your system is spherical or axisymmetric, other methods
will perform much better. If your system is triaxial, this method is your best
option. We demonstrate this method below with two qualitatively different
orbits:

* :ref:`tube-axisymmetric`
* :ref:`tube-triaxial`

(see also [binneytremaine]_ and [mcgill90]_ for more context). For the examples
below, we will use the `~gala.units.galactic` unit system and assume the
following imports have been executed::

    >>> import astropy.coordinates as coord
    >>> import astropy.units as u
    >>> import matplotlib.pyplot as plt
    >>> import numpy as np
    >>> import gala.dynamics as gd
    >>> import gala.integrate as gi
    >>> import gala.potential as gp
    >>> from gala.units import galactic

For many more options for action calculation, see
`tact <https://github.com/jls713/tact>`_.

.. _tube-axisymmetric:

A tube orbit in an axisymmetric potential
-----------------------------------------

For an example of an axisymmetric potential, we use a flattened logarithmic
potential:

.. math::

    \Phi(x,y,z) = \frac{1}{2}v_{\rm c}^2\ln (x^2 + y^2 + (z/q)^2 + r_h^2)

with parameters

.. math::

    v_{\rm c} &= 150~{\rm km}~{\rm s}^{-1}\\
    q &= 0.9\\
    r_h &= 0

For the orbit, we use initial conditions

.. math::

    \boldsymbol{r} &= (8, 0, 0)~{\rm kpc}\\
    \boldsymbol{v} &= (75, 150, 50)~{\rm km}~{\rm s}^{-1}

We first create a potential and set up our initial conditions::

    >>> pot = gp.LogarithmicPotential(
    ...     v_c=150*u.km/u.s, q1=1., q2=1., q3=0.9, r_h=0,
    ...     units=galactic)
    >>> w0 = gd.PhaseSpacePosition(pos=[8, 0, 0.]*u.kpc,
    ...                            vel=[75, 150, 50.]*u.km/u.s)

We will now integrate the orbit and plot it in the meridional plane::

    >>> w = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.5, n_steps=10000)
    >>> cyl = w.represent_as('cylindrical')
    >>> fig = cyl.plot(['rho', 'z'], linestyle='-') # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.coordinates as coord
    import astropy.units as u
    import matplotlib.pyplot as plt
    import numpy as np
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, q1=1., q2=1., q3=0.9, r_h=0,
                                  units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[8, 0, 0.]*u.kpc,
                               vel=[75, 150, 50.]*u.km/u.s)

    w = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.5, n_steps=10000)
    cyl = w.represent_as('cylindrical')
    cyl.plot(['rho', 'z'], linestyle='-')

To solve for the actions in the true potential, we first compute the actions in
a "toy" potential -- a potential in which we can compute the actions and angles
analytically. The two simplest potentials for which this is possible are the
`~gala.potential.potential.IsochronePotential` and
`~gala.potential.potential.HarmonicOscillatorPotential`. We will use the
Isochrone potential as our toy potential for tube orbits and the harmonic
oscillator for box orbits.

We start by finding the parameters of the toy potential (Isochrone in this case)
by minimizing the dispersion in energy for the orbit::

    >>> toy_potential = gd.fit_isochrone(w)
    >>> toy_potential
    <IsochronePotential: m=1.24e+11, b=4.02 (kpc,Myr,solMass,rad)>

The actions and angles in this potential are not the true actions, but will only
serve as an approximation. This can be seen in the angles: the orbit in the true
angles would be perfectly straight lines with slope equal to the frequencies.
Instead, the orbit is wobbly in the toy potential angles::

    >>> toy_actions,toy_angles,toy_freqs = toy_potential.action_angle(w)
    >>> fig,ax = plt.subplots(1,1,figsize=(5,5))
    >>> ax.plot(toy_angles[0], toy_angles[2], linestyle='none', marker=',') # doctest: +SKIP
    >>> ax.set_xlim(0,2*np.pi) # doctest: +SKIP
    >>> ax.set_ylim(0,2*np.pi) # doctest: +SKIP
    >>> ax.set_xlabel(r"$\theta_1$ [rad]") # doctest: +SKIP
    >>> ax.set_ylabel(r"$\theta_3$ [rad]") # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    toy_potential = gd.fit_isochrone(w)
    toy_actions,toy_angles,toy_freqs = toy_potential.action_angle(w)
    fig,ax = plt.subplots(1,1,figsize=(5,5))
    ax.plot(toy_angles[0], toy_angles[2], linestyle='none', marker=',')
    ax.set_xlim(0,2*np.pi)
    ax.set_ylim(0,2*np.pi)
    ax.set_xlabel(r"$\theta_1$ [rad]")
    ax.set_ylabel(r"$\theta_3$ [rad]")
    fig.tight_layout()

This can also be seen in the value of the action variables, which are not
time-independent in the toy potential::

    >>> fig,ax = plt.subplots(1,1)
    >>> ax.plot(w.t, toy_actions[0], marker='') # doctest: +SKIP
    >>> ax.set_xlabel(r"$t$ [Myr]") # doctest: +SKIP
    >>> ax.set_ylabel(r"$J_1$ [rad]") # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    fig,ax = plt.subplots(1,1)
    ax.plot(w.t, toy_actions[0].to(u.km/u.s*u.kpc), marker='')
    ax.set_xlabel(r"$t$ [Myr]")
    ax.set_ylabel(r"$J_1$ [kpc km/s]")
    fig.tight_layout()

We can now find approximations to the actions in the true potential. We have to
choose the maximum integer vector norm, `N_max`, which here we arbitrarily set
to 8. This will change depending on the convergence of the action correction
(the properties of the orbit and potential) and the accuracy desired::

    >>> result = gd.find_actions_o2gf(w, N_max=8, toy_potential=toy_potential) # doctest: +SKIP
    >>> result.keys() # doctest: +SKIP
    dict_keys(['Sn', 'nvecs', 'freqs', 'dSn_dJ', 'angles', 'actions'])

The value of the actions, frequencies, and the angles at t=0 are returned in
the result dictionary::

    >>> result['actions'] # doctest: +SKIP
    <Quantity [ 0.12472277, 1.22725461, 0.05847431] kpc2 solMass / Myr>

To visualize how the actions are computed, we again plot the actions in the
toy potential and then plot the "corrected" actions -- the approximation to the
actions computed using this machinery::

    >>> nvecs = gd.generate_n_vectors(8, dx=1, dy=2, dz=2) # doctest: +SKIP
    >>> act_correction = nvecs.T[...,None] * result['Sn'][None,:,None] * np.cos(nvecs.dot(toy_angles))[None] # doctest: +SKIP
    >>> action_approx = toy_actions - 2*np.sum(act_correction, axis=1)*u.kpc**2/u.Myr # doctest: +SKIP
    >>>
    >>> fig,ax = plt.subplots(1,1) # doctest: +SKIP
    >>> ax.plot(w.t, toy_actions[0].to(u.km/u.s*u.kpc), marker='', label='$J_1$') # doctest: +SKIP
    >>> ax.plot(w.t, action_approx[0].to(u.km/u.s*u.kpc), marker='', label="$J_1'$") # doctest: +SKIP
    >>> ax.set_xlabel(r"$t$ [Myr]") # doctest: +SKIP
    >>> ax.set_ylabel(r"[kpc ${\rm M}_\odot$ km/s]") # doctest: +SKIP
    >>> ax.legend() # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import warnings
    with warnings.catch_warnings(record=True):
        warnings.simplefilter("ignore")
        result = gd.find_actions_o2gf(w, N_max=8, toy_potential=toy_potential)

    nvecs = gd.generate_n_vectors(8, dx=1, dy=2, dz=2)
    act_correction = nvecs.T[...,None] * result['Sn'][0][None,:,None] * np.cos(nvecs.dot(toy_angles))[None]
    action_approx = toy_actions - 2*np.sum(act_correction, axis=1)*u.kpc**2/u.Myr
    fig,ax = plt.subplots(1,1)
    ax.plot(w.t, toy_actions[0].to(u.km/u.s*u.kpc), marker='', label='$J_1$')
    ax.plot(w.t, action_approx[0].to(u.km/u.s*u.kpc), marker='', label="$J_1'$")
    ax.set_xlabel(r"$t$ [Myr]")
    ax.set_ylabel(r"[kpc ${\rm M}_\odot$ km/s]")
    ax.legend()

Above the blue line represents the approximation of the actions in the true
potential.

.. _tube-triaxial:

A tube orbit in a triaxial potential
------------------------------------

The same procedure works for regular orbits in more complex potentials. We
demonstrate this below by repeating the above in a triaxial potential. We again
use a logarithmic potential, but with flattening along two dimensions:

.. math::

    \Phi(x,y,z) = \frac{1}{2}v_{\rm c}^2\ln ((x/q_1)^2 + (y/q_2)^2 + (z/q_3)^2)

with parameter values:

.. math::

    v_{\rm c} &= 150~{\rm km}~{\rm s}^{-1}\\
    q_1 &= 1\\
    q_2 &= 0.9\\
    q_3 &= 0.8\\
    r_h &= 0

and the same initial conditions as above:

.. math::

    \boldsymbol{r} &= (8, 0, 0)~{\rm kpc}\\
    \boldsymbol{v} &= (75, 150, 50)~{\rm km}~{\rm s}^{-1}

.. plot::
    :align: center
    :include-source:
    :width: 60%

    import astropy.coordinates as coord
    import astropy.units as u
    import matplotlib.pyplot as plt
    import numpy as np
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    # define potential
    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, q1=1., q2=0.9, q3=0.8, r_h=0,
                                  units=galactic)

    # define initial conditions
    w0 = gd.PhaseSpacePosition(pos=[8, 0, 0.]*u.kpc,
                               vel=[75, 150, 50.]*u.km/u.s)

    # integrate orbit
    w = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.5, n_steps=10000)

    # solve for toy potential parameters
    toy_potential = gd.fit_isochrone(w)

    # compute the actions,angles in the toy potential
    toy_actions,toy_angles,toy_freqs = toy_potential.action_angle(w)

    # find approximations to the actions in the true potential
    import warnings
    with warnings.catch_warnings(record=True):
        warnings.simplefilter("ignore")
        result = gd.find_actions_o2gf(w, N_max=8, toy_potential=toy_potential)

    # for visualization, compute the action correction used to transform the
    #   toy potential actions to the approximate true potential actions
    nvecs = gd.generate_n_vectors(8, dx=1, dy=2, dz=2)
    act_correction = nvecs.T[...,None] * result['Sn'][0][None,:,None] * np.cos(nvecs.dot(toy_angles))[None]
    action_approx = toy_actions - 2*np.sum(act_correction, axis=1)*u.kpc**2/u.Myr

    fig,axes = plt.subplots(3,1,figsize=(6,14))

    for i,ax in enumerate(axes):
        ax.plot(w.t, toy_actions[i].to(u.km/u.s*u.kpc), marker='', label='$J_{}$'.format(i+1))
        ax.plot(w.t, action_approx[i].to(u.km/u.s*u.kpc), marker='', label="$J_{}'$".format(i+1))
        ax.set_ylabel(r"[kpc ${\rm M}_\odot$ km/s]")
        ax.legend(loc='upper left')

    ax.set_xlabel(r"$t$ [Myr]")
    fig.tight_layout()


Using the Staeckel Fudge in Galpy
=================================

Gala can transform its ``Orbit`` and ``Potential`` objects into `Galpy <https://github.com/jobovy/galpy>`_ ``Orbit`` and ``Potential`` objects, making it possible to easily use the "Staeckel Fudge" [binney12]_ implementation in Galpy. This method, as
implemented, is only applicable for axisymmetric systems, but is *much* faster
than the O2GF method for estimating actions, angles, and frequencies from
phase-space positions. As an example of this functionality, below we will
compute the vertical frequency as a function of action for a grid of orbits in a
two-component model for a galactic potential (a disk + halo model).

We will start by defining the potential model::

    >>> halo = gp.NFWPotential.from_M200_c(
    ...     M200=1e12*u.Msun, c=15,
    ...     units=galactic
    ... )
    >>> disk = gp.MN3ExponentialDiskPotential(
    ...     m=8e10*u.Msun, h_R=3.5*u.kpc, h_z=0.4*u.kpc,
    ...     units=galactic
    ... )
    >>> pot = halo + disk

We next define a grid of orbital initial conditions with close to the circular
velocity but varying vertical velocities::

    >>> vcirc = pot.circular_velocity([8, 0, 0])
    >>> vz_grid = np.linspace(0.5, 200, 64) * u.km/u.s
    >>> xyz = np.repeat([[8., 0, 0]], len(vz_grid), axis=0).T * u.kpc
    >>> vxyz = np.repeat([[0, 1.1, 0]], len(vz_grid), axis=0).T * vcirc
    >>> vxyz[2] = vz_grid
    >>> w0 = gd.PhaseSpacePosition(xyz, vxyz)

We can now integrate these orbits in the total potential::

    >>> orbits = pot.integrate_orbit(
    ...     w0, dt=1, t1=0, t2=4*u.Gyr,
    ...     Integrator=gi.DOPRI853Integrator
    ... )
    >>> orbits.cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',')  # doctest: +SKIP

.. plot::
    :align: center
    :width: 60%
    :context: close-figs

    import astropy.coordinates as coord
    import astropy.units as u
    import matplotlib.pyplot as plt
    import numpy as np
    import gala.potential as gp
    import gala.integrate as gi
    import gala.dynamics as gd
    from gala.units import galactic

    halo = gp.NFWPotential.from_M200_c(
        M200=1e12*u.Msun, c=15,
        units=galactic
    )
    disk = gp.MN3ExponentialDiskPotential(
        m=8e10*u.Msun, h_R=3.5*u.kpc, h_z=0.4*u.kpc,
        units=galactic
    )
    pot = halo + disk

    vcirc = pot.circular_velocity([8, 0, 0])
    vz_grid = np.linspace(0.5, 200, 64) * u.km/u.s
    xyz = np.repeat([[8., 0, 0]], len(vz_grid), axis=0).T * u.kpc
    vxyz = np.repeat([[0, 1.1, 0]], len(vz_grid), axis=0).T * vcirc
    vxyz[2] = vz_grid
    w0 = gd.PhaseSpacePosition(xyz, vxyz)

    orbits = pot.integrate_orbit(
        w0, dt=1, t1=0, t2=4*u.Gyr,
        Integrator=gi.DOPRI853Integrator
    )
    orbits.cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',')


With the orbits in hand, we can compute the approximate actions, angles, and
frequencies with the Staeckel Fudge using Galpy (for more information, see the
`Galpy documentation <https://docs.galpy.org/en/v1.7.2/actionAngle.html>`_):

.. doctest-requires:: galpy

    >>> from gala.dynamics.actionangle import get_staeckel_fudge_delta
    >>> from galpy.actionAngle import actionAngleStaeckel
    >>> galpy_potential = pot.to_galpy_potential()
    >>> J = np.zeros((3, orbits.norbits))
    >>> Omega = np.zeros((3, orbits.norbits))
    >>> for n, orbit in enumerate(orbits.orbit_gen()): # doctest: +SKIP
    ...     o = orbit.to_galpy_orbit()
    ...     delta = get_staeckel_fudge_delta(pot, orbit)
    ...     staeckel = actionAngleStaeckel(pot=galpy_potential, delta=delta)
    ...     af = staeckel.actionsFreqs(o)
    ...     af = np.mean(np.stack(af), axis=1)
    ...     J[:3, n] = af[:3]
    ...     Omega[:3, n] = af[3:]

Let's visualize the dependence of the vertical action on the value of the
vertical velocity we used as initial conditions:

.. doctest-requires:: galpy

    >>> plt.plot(w0.v_z, J[2])  # doctest: +SKIP

.. plot::
    :align: center
    :width: 60%
    :context: close-figs

    from gala.dynamics.actionangle import get_staeckel_fudge_delta
    from galpy.actionAngle import actionAngleStaeckel

    galpy_potential = pot.to_galpy_potential()
    J = np.zeros((3, orbits.norbits))
    Omega = np.zeros((3, orbits.norbits))
    for n, orbit in enumerate(orbits.orbit_gen()):
        o = orbit.to_galpy_orbit()
        delta = get_staeckel_fudge_delta(pot, orbit)
        staeckel = actionAngleStaeckel(pot=galpy_potential, delta=delta)
        af = staeckel.actionsFreqs(o)
        af = np.mean(np.stack(af), axis=1)

        J[:3, n] = af[:3]
        Omega[:3, n] = af[3:]

    fig, ax = plt.subplots(figsize=(6, 6), constrained_layout=True)
    ax.plot(w0.v_z, J[2])
    ax.set_xlabel(f"$v_z$ [{w0.v_z.unit:latex_inline}]")
    ax.set_ylabel(rf"$J_z$")


The overall trend looks right, but what is that weird break that occurs around
:math:`v_z` ~ 120 km/s? Let's visualize orbits with initial conditions just next to and
within this region:

.. doctest-requires:: galpy

    >>> i1 = np.abs(w0.v_z.value - 120).argmin()
    >>> i2 = np.abs(w0.v_z.value - 100).argmin()
    >>> orbits[:, i1].cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',')  # doctest: +SKIP
    >>> orbits[:, i2].cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',')  # doctest: +SKIP

.. plot::
    :align: center
    :width: 90%
    :context: close-figs

    fig, axes = plt.subplots(1, 2, figsize=(10, 5),
                             sharex=True, sharey=True,
                             constrained_layout=True)

    i1 = np.abs(w0.v_z.value - 120).argmin()
    i2 = np.abs(w0.v_z.value - 100).argmin()
    orbits[:, i1].cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',', axes=[axes[0]]);
    orbits[:, i2].cylindrical.plot(['rho', 'z'], alpha=0.5, marker=',', axes=[axes[1]]);

Aha! This region is special: it is a resonance in the potential. Orbits in this region
of phase-space have qualitatively different behavior than those outside of this region
because they are trapped by the resonance. For these orbits, where strong potential
resonances occur, the Staeckel Fudge approximation will return incorrect and potentially
misleading action, angle, and frequency values.


References
==========

.. [binney12] Binney (2012) `Actions for axisymmetric potentials
 <https://ui.adsabs.harvard.edu/abs/2012MNRAS.426.1324B/abstract>`_
.. [sanders14] Sanders & Binney (2014) `Actions, angles and frequencies for numerically integrated orbits <http://arxiv.org/abs/1401.3600>`_
.. [sanders16] Sanders & Binney (2016) `A review of action estimation methods for galactic dynamics <https://ui.adsabs.harvard.edu/abs/2016MNRAS.457.2107S/abstract>`_
.. [binneytremaine] Binney & Tremaine (2008) `Galactic Dynamics <http://press.princeton.edu/titles/8697.html>`_
.. [mcgill90] McGill & Binney (1990) `Torus construction in general gravitational potentials <http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1990MNRAS.244..634M&amp;data_type=PDF_HIGH&amp;whole_paper=YES&amp;type=PRINTER&amp;filetype=.pdf>`_
</file>

<file path="docs/dynamics/index.rst">
.. include:: references.txt

.. _gala-dynamics:

********************************
Dynamics (`gala.dynamics`)
********************************

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> from gala.units import galactic

Introduction
============

This subpackage contains functions and classes useful for gravitational
dynamics. There are utilities for transforming orbits in phase-space to
action-angle coordinates, tools for visualizing and computing dynamical
quantities from orbits, tools to generate mock stellar streams, and tools useful
for nonlinear dynamics such as Lyapunov exponent estimation.

The fundamental objects used by many of the functions and utilities in this and
other subpackages are the |psp| and |orb| classes.

Getting started: Working with orbits
====================================

As a demonstration of how to use these objects, we'll start by integrating an
orbit using the :mod:`gala.potential` and :mod:`gala.integrate` subpackages::

    >>> pot = gp.MiyamotoNagaiPotential(m=2.5E11*u.Msun, a=6.5*u.kpc,
    ...                                 b=0.26*u.kpc, units=galactic)
    >>> w0 = gd.PhaseSpacePosition(pos=[11., 0., 0.2]*u.kpc,
    ...                            vel=[0., 200, 100]*u.km/u.s)
    >>> orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=1000)

This numerically integrates an orbit from the specified initial conditions,
``w0``, and returns an |orb| object. By default, the position and velocity are
assumed to be Cartesian coordinates but other coordinate systems are supported
(see the :ref:`orbits-in-detail` and :ref:`nd-representations` pages for more
information).

The |orb| object that is returned contains many useful methods, and can be
passed to many of the analysis functions implemented in Gala. For example, we
can easily visualize the orbit by plotting the time series in all Cartesian
projections using the :meth:`~gala.dynamics.Orbit.plot` method::

    >>> fig = orbit.plot()

.. plot::
    :align: center

    import astropy.units as u
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic
    pot = gp.MiyamotoNagaiPotential(m=2.5E11, a=6.5, b=0.26, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[11., 0., 0.2]*u.kpc,
                               vel=[0., 200, 100]*u.km/u.s)
    orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=1000)
    fig = orbit.plot()

Or, we can visualize the orbit in just one projection of some transformed
coordinate representation, for example, cylindrical radius :math:`\rho` and
:math:`z`::

    >>> fig = orbit.represent_as('cylindrical').plot(['rho', 'z'])

.. plot::
    :align: center
    :width: 60%

    import astropy.units as u
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic
    pot = gp.MiyamotoNagaiPotential(m=2.5E11, a=6.5, b=0.26, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[11., 0., 0.2]*u.kpc,
                               vel=[0., 200, 100]*u.km/u.s)
    orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=1000)
    _ = orbit.represent_as('cylindrical').plot(['rho', 'z'])

From the |orb| object, we can also easily compute dynamical quantities such as
the energy or angular momentum (we take the 0th element because these functions
return the quantities computed at every timestep)::

    >>> E = orbit.energy()
    >>> E[0] # doctest: +SKIP
    <Quantity −0.060740198 kpc2 / Myr2>

Let's see how well the integrator conserves energy and the ``z`` component of
angular momentum::

    >>> Lz = orbit.angular_momentum()[2]
    >>> np.std(E), np.std(Lz) # doctest: +FLOAT_CMP
    (<Quantity 4.654233175716351e-06 kpc2 / Myr2>,
     <Quantity 9.675900603446092e-16 kpc2 / Myr>)

We can access the position and velocity components of the orbit separately using
attributes that map to the underlying `~astropy.coordinates.BaseRepresentation`
and `~astropy.coordinates.BaseDifferential` subclass instances that store the
position and velocity data. The attribute names depend on the representation.
For example, for a Cartesian representation, the position components are ``['x',
'y', 'z']`` and the velocity components are ``['v_x', 'v_y', 'v_z']``. With a
|orb| or |psp| instance, you can check the valid compnent names using the
attributes ``.pos_components`` and ``.vel_components``::

    >>> orbit.pos_components.keys() # doctest: +SKIP
    odict_keys(['x', 'y', 'z'])
    >>> orbit.vel_components.keys() # doctest: +SKIP
    odict_keys(['v_x', 'v_y', 'v_z'])

Meaning, we can access these components by doing, e.g.::

    >>> orbit.v_x # doctest: +FLOAT_CMP
    <Quantity [ 0.        ,-0.00567589,-0.01129934,...,  0.18751756,
                0.18286687, 0.17812762] kpc / Myr>

For a Cylindrical representation, these are instead::

    >>> cyl_orbit = orbit.represent_as('cylindrical')
    >>> cyl_orbit.pos_components.keys() # doctest: +SKIP
    odict_keys(['rho', 'phi', 'z'])
    >>> cyl_orbit.vel_components.keys() # doctest: +SKIP
    odict_keys(['v_rho', 'pm_phi', 'v_z'])
    >>> cyl_orbit.v_rho # doctest: +FLOAT_CMP
    <Quantity [ 0.        ,-0.00187214,-0.00369183,...,  0.01699321,
                0.01930216, 0.02159477] kpc / Myr>

Continue to the :ref:`orbits-in-detail` page for more information.

Using gala.dynamics
===================

More details are provided in the linked pages below:

.. toctree::
   :maxdepth: 2

   orbits-in-detail
   nd-representations
   actionangle
   mockstreams
   nonlinear
   nbody


API
===

.. automodapi:: gala.dynamics
    :include: PhaseSpacePosition
    :include: Orbit
    :no-inheritance-diagram:
</file>

<file path="docs/dynamics/mockstreams.rst">
.. _gala-mockstreams:

*******************************
Generating mock stellar streams
*******************************

Introduction
============

This module contains functions for generating mock stellar streams using a
variety of methods that approximate the formation of streams in N-body
simulations. Mock streams are generated by specifying time-stepping and release
time information (i.e., when should stream particles be generated), and by
specifying the stream distribution function (DF) to use to generate initial
conditions for the stream particles. The former is customizable, and a number of
popular stream DFs are implemented.

Some imports needed for the code below::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> from gala.dynamics import mockstream as ms
    >>> from gala.units import galactic

We will also set the default Astropy Galactocentric frame parameters to the
values adopted in Astropy v4.0:

    >>> import astropy.coordinates as coord
    >>> _ = coord.galactocentric_frame_defaults.set('v4.0')

Getting started
===============

All mock stream generation done using the built-in gravitational potential
models implemented in `gala.potential`, so we must first specify a gravitational
potential to integrate orbits in. For the examples below, we will use a
spherical NFW potential with a circular velocity at the scale radius of 220
km/s, and a scale radius of 15 kpc::

    >>> pot = gp.NFWPotential.from_circular_velocity(v_c=220*u.km/u.s,
    ...                                              r_s=15*u.kpc,
    ...                                              units=galactic)

The mock stream generation supports any of the reference frames implemented in
``gala`` (e.g., non-static / rotating reference frames), so we must create a
`~gala.potential.hamiltonian.Hamiltonian` object to use when generating streams.
By default, this will use a static reference frame::

    >>> H = gp.Hamiltonian(pot)

Next, we will create initial conditions for the progenitor system. In this case,
we will generate the mock stream starting from this position going forward in
time. However, this is customizable: if you instead have the *final* position of
the progenitor system, there is a convenient way of doing this described below
(see :ref:`gala-mockstream-final-conditions`). Let's specify a position and
velocity that we think will produce a mildly eccentric orbit in the x-y plane of
our coordinate system::

    >>> prog_w0 = gd.PhaseSpacePosition(pos=[10, 0, 0.] * u.kpc,
    ...                                 vel=[0, 170, 0.] * u.km/u.s)

We now have to specify the method for generating stream particles, i.e., the
stream distribution function (DF). For this example, we will use the method
implemented in [fardal15]_, incuded in ``gala`` as
`~gala.dynamics.mockstream.FardalStreamDF`. Other methods of note are
`~gala.dynamics.mockstream.StreaklineStreamDF` from [kuepper12]_,
`~gala.dynamics.mockstream.LagrangeCloudStreamDF` based on [gibbons14]_, and
`~gala.dynamics.mockstream.ChenStreamDF` based on [chen24]_. Each of
the ``StreamDF`` classes take a few common arguments, such as ``lead`` and
``trail``, which are boolean arguments that control whether to generate both
leading and trailing tails, or just one or the other. By default, both are set
to True (i.e., both leading and trailing tails are generated by default). Some
other ``StreamDF`` classes may require other parameters. Let's create a
`~gala.dynamics.mockstream.FardalStreamDF` instance and accept the default
argument values. We will also need to specify the progenitor mass, which is
passed in to any ``StreamDF`` and is used to scale the particle release
distribution::

    >>> df = ms.FardalStreamDF(gala_modified=True)
    >>> prog_mass = 2.5E4 * u.Msun

.. warning::

    The parameter values of the FardalStreamDF have been updated (fixed) in v1.9 to
    match the parameter values in the final published version of [fardal15]_. For now,
    this class uses the Gala modified parameter values that have been adopted over the
    last several years in Gala. In the future, the default behavior of this class will
    use the [fardal15]_ parameter values instead, breaking backwards compatibility for
    mock stream simulations. To use the [fardal15]_ parameters now, set
    ``gala_modified=False``. To continue to use the Gala modified parameter values, set
    ``gala_modified=True``.

The final step before actually generating the stream is to create a
`~gala.dynamics.mockstream.MockStreamGenerator` instance, which we will use to
actually generate the stream. This takes the ``StreamDF`` and the external
potential (Hamiltonian) as arguments::

    >>> gen = ms.MockStreamGenerator(df, H)

We are now ready to run the generator and create a mock stream. To do this, we use the `~gala.dynamics.mockstream.MockStreamGenerator.run()` method. This accepts the progenitor orbit initial conditions (we defined above as ``prog_w0``), the progenitor mass (we defined as ``prog_mass``), and time-stepping information. We will integrate the progenitor orbit for 1000 steps with a timestep of 1 Myr::

    >>> stream, prog = gen.run(prog_w0, prog_mass,
    ...                        dt=1 * u.Myr, n_steps=1000)

Let's plot the stream::

    >>> stream.plot(['x', 'y'])  # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.units as u
    import numpy as np
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.dynamics import mockstream as ms
    from gala.units import galactic

    pot = gp.NFWPotential.from_circular_velocity(v_c=220*u.km/u.s,
                                                 r_s=15*u.kpc,
                                                 units=galactic)
    H = gp.Hamiltonian(pot)
    prog_w0 = gd.PhaseSpacePosition(pos=[10, 0, 0.] * u.kpc,
                                    vel=[0, 170, 0.] * u.km/u.s)

    df = ms.FardalStreamDF(gala_modified=True)
    prog_mass = 2.5E4 * u.Msun

    gen = ms.MockStreamGenerator(df, H)

    stream, prog = gen.run(prog_w0, prog_mass,
                           dt=1 * u.Myr, n_steps=1000)

    stream.plot(['x', 'y'], marker='o', s=4, color='k', alpha=0.1, linewidth=0)


By default, two stream particles are generated at every timestep in the
integration of the progenitor orbit (specified above by the timestep ``dt`` and
number of steps ``n_steps``). We can control the frequency of releasing
particles, and the number of particles released using the ``release_every`` and
``n_particles`` arguments. For example, setting ``release_every=8`` and
``n_particles=2`` will instead release 4 particles (2 for each tail) every 8th
timestep.


Self-gravity of the progenitor
==============================

Also by default, the progenitor system is assumed to be massless, and the stream
particles are treated as test particles in the specified external potential or
Hamiltonian. It is possible to include a potential object for the progenitor
system to account for the self-gravity of the progenitor as stream star
particles are released. We can use any of the ``gala.potential`` potential
objects to represent the progenitor system, but here we will use a simple
`~gala.potential.potential.PlummerPotential`. We pass this in to the
`~gala.dynamics.mockstream.MockStreamGenerator` - let's see what the stream
looks like when generated including self-gravity::

    >>> prog_pot = gp.PlummerPotential(m=prog_mass, b=4*u.pc, units=galactic)
    >>> gen2 = ms.MockStreamGenerator(df, H, progenitor_potential=prog_pot)
    >>> stream2, prog = gen2.run(prog_w0, prog_mass,
    ...                          dt=1 * u.Myr, n_steps=1000)
    >>> stream2.plot(['x', 'y'])  # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    prog_pot = gp.PlummerPotential(m=prog_mass, b=2*u.pc, units=galactic)
    gen2 = ms.MockStreamGenerator(df, H, progenitor_potential=prog_pot)
    stream2, prog = gen2.run(prog_w0, prog_mass,
                             dt=1 * u.Myr, n_steps=1000)
    stream2.plot(['x', 'y'], marker='o', s=4,
                 color='k', alpha=0.1, linewidth=0)


.. _gala-mockstream-final-conditions:

Generating a stream from the present-day progenitor location
============================================================

In the examples above, we pass in initial conditions for the progenitor and
generate the mock stream going forward in time. However, we often may want to
generate a stream such that the final progenitor location ends up at some
specified phase-space position. By convention, when a negative timestep is
passed in to `~gala.dynamics.mockstream.MockStreamGenerator.run()`, this is
interpreted to mean that the input progenitor phase-space position should be the
*final* position. Internally, this position is integrated backwards to the
earliest time, then a stream is generated forward from the past time. This is particularly useful when trying to reproduce observed streams, such as the Pal 5 stream::

    >>> import astropy.coordinates as coord
    >>> pal5_c = coord.SkyCoord(ra=229.018*u.degree, dec=-0.124*u.degree,
    ...                         distance=22.9*u.kpc,
    ...                         pm_ra_cosdec=-2.296*u.mas/u.yr,
    ...                         pm_dec=-2.257*u.mas/u.yr,
    ...                         radial_velocity=-58.7*u.km/u.s)
    >>> rep = pal5_c.transform_to(coord.Galactocentric).data
    >>> pal5_w0 = gd.PhaseSpacePosition(rep)
    >>> pal5_mass = 2.5e4 * u.Msun
    >>> pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)
    >>> mw = gp.MilkyWayPotential()
    >>> gen_pal5 = ms.MockStreamGenerator(df, mw, progenitor_potential=pal5_pot)
    >>> pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
    ...                               dt=-1 * u.Myr, n_steps=4000)
    >>> pal5_stream_c = pal5_stream.to_coord_frame(coord.ICRS)

.. plot::
    :align: center
    :context: close-figs

    import astropy.coordinates as coord
    coord.galactocentric_frame_defaults.set('v4.0')
    pal5_c = coord.SkyCoord(ra=229.018*u.degree, dec=-0.124*u.degree,
                            distance=22.9*u.kpc,
                            pm_ra_cosdec=-2.296*u.mas/u.yr,
                            pm_dec=-2.257*u.mas/u.yr,
                            radial_velocity=-58.7*u.km/u.s)
    rep = pal5_c.transform_to(coord.Galactocentric).data
    pal5_w0 = gd.PhaseSpacePosition(rep)
    pal5_mass = 2.5e4 * u.Msun
    pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)
    mw = gp.MilkyWayPotential()
    gen_pal5 = ms.MockStreamGenerator(df, mw, progenitor_potential=pal5_pot)
    pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
                                  dt=-1 * u.Myr, n_steps=4000)
    pal5_stream_c = pal5_stream.to_coord_frame(coord.ICRS)

    fig, ax = plt.subplots(1, 1, figsize=(6, 4))
    ax.scatter(pal5_stream_c.ra.degree, pal5_stream_c.dec.degree,
               marker='o', s=4, color='k', lw=0, alpha=0.1)
    ax.set_xlim(250, 215)
    ax.set_ylim(-10, 10)
    ax.set_xlabel('RA [deg]')
    ax.set_ylabel('Dec [deg]')
    fig.tight_layout()


References
==========

.. [fardal15] `Fardal, Huang, Weinberg (2015) <http://arxiv.org/abs/1410.1861>`_
.. [kuepper12] `Küpper, Lane, Heggie (2012) <http://arxiv.org/abs/1111.5013>`_
.. [gibbons14] `Gibbons et al. (2014) <https://arxiv.org/abs/1406.2243>`_
.. [chen24] `Chen et al. (2024) <https://arxiv.org/abs/2408.01496>`_

API
---
.. automodapi:: gala.dynamics.mockstream
    :no-heading:
    :headings: ^^
</file>

<file path="docs/dynamics/nbody.rst">
.. _gala-nbody:

******************************
N-body (`gala.dynamics.nbody`)
******************************

Introduction
============

With the `~gala.potential.hamiltonian.Hamiltonian` and potential classes
(:ref:`potential`), Gala contains functionality for integrating test particle
orbits in background gravitational fields. To supplement this, Gala also now
contains some limited functionality for performing N-body orbit integrations
through direct N-body force calculations between particles. With the
`gala.dynamics.nbody` subpackage, gravitational fields (i.e., any potential
class from :mod:`gala.potential`) can be sourced by particles that interact, and
optionally feel a background/external potential. To use this functionality, the
core class is `~gala.dynamics.nbody.DirectNBody`. Below, we'll go through a few
examples of using this class to perform orbit integrations

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> from gala.dynamics.nbody import DirectNBody
    >>> from gala.units import galactic, UnitSystem


Getting started
===============

The `~gala.dynamics.nbody.DirectNBody`, at minimum, must be instantiated with a
set of particle orbital initial conditions along with a specification of the
gravitational fields sourced by each particle --- that is, the number of initial
conditions must match the input list of gravitational potential objects that
specify the particle mass distributions. Other optional arguments to
`~gala.dynamics.nbody.DirectNBody` allow you to set the unit system (i.e., to
improve numerical precision when time-stepping the orbit integration), or to
specify a background gravitational potential. Let's now go through a few
examples of using this class in practice.


Example: Mixed test particle and massive particle orbit integration
===================================================================

Like with `~gala.potential.hamiltonian.Hamiltonian` orbit integration, orbital
initial conditions are passed in to `~gala.dynamics.nbody.DirectNBody` by
passing in a single `~gala.dynamics.PhaseSpacePosition` object. Let's create two
initial conditions by specifying the position and velocity of two particles,
then combine them into a single `~gala.dynamics.PhaseSpacePosition` object::

    >>> w0_1 = gd.PhaseSpacePosition(pos=[0, 0, 0] * u.pc,
    ...                              vel=[0, 1.5, 0] * u.km/u.s)
    >>> w0_2 = gd.PhaseSpacePosition(pos=w0_1.xyz + [100., 0, 0] * u.pc,
    ...                              vel=w0_1.v_xyz + [0, 5, 0] * u.km/u.s)
    >>> w0 = gd.combine((w0_1, w0_2))
    >>> w0.shape
    (2,)

We'll then treat particle 1 as a massive object by sourcing a
`~gala.potential.potential.HernquistPotential` at the location of the particle,
and particle 2 as a test particle: To treat some particles as test particles,
you can pass ``None`` or a `~gala.potential.potential.NullPotential` instance
for the corresponding particle potential::

    >>> pot1 = gp.HernquistPotential(m=1e7*u.Msun, c=0.5*u.kpc, units=galactic)
    >>> particle_pot = [pot1, None]

Let's now create an N-body instance and try integrating the orbits of the two
particles. Here, there is no external potential, so particle 1 (the massive
particle) will move off in a straight line. We've created the initial conditions
for particle 2 so that it will remain bound to the potential sourced by particle
1, and so will orbit it as it moves. Let's create the object and integrate the
orbits::

    >>> nbody = DirectNBody(w0, particle_pot)
    >>> orbits = nbody.integrate_orbit(dt=1e-2*u.Myr, t1=0, t2=1*u.Gyr)
    >>> fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    >>> _ = orbits[:, 0].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP
    >>> _ = orbits[:, 1].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.units as u
    import numpy as np
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.dynamics.nbody import DirectNBody
    from gala.units import galactic, UnitSystem
    import matplotlib.pyplot as plt

    w0_1 = gd.PhaseSpacePosition(pos=[0, 0, 0] * u.pc,
                                 vel=[0, 1.5, 0] * u.km/u.s)
    w0_2 = gd.PhaseSpacePosition(pos=w0_1.xyz + [100., 0, 0] * u.pc,
                                 vel=w0_1.v_xyz + [0, 5, 0] * u.km/u.s)
    w0 = gd.combine((w0_1, w0_2))

    pot1 = gp.HernquistPotential(m=1e7*u.Msun, c=0.5*u.kpc, units=galactic)
    particle_pot = [pot1, None]

    nbody = DirectNBody(w0, particle_pot)
    orbits = nbody.integrate_orbit(dt=1e-2*u.Myr, t1=0, t2=1*u.Gyr)
    fig, ax = plt.subplots(1, 1, figsize=(5, 5))
    _ = orbits[:, 0].plot(['x', 'y'], axes=[ax])
    _ = orbits[:, 1].plot(['x', 'y'], axes=[ax])
    fig.tight_layout()

Example: N-body integration with a background potential
=======================================================

With `~gala.dynamics.nbody.DirectNBody`, we can also specify a background or
external potential to integrate all orbits in. To do this, you can optionally
pass in an external potential as a potential object to
`~gala.dynamics.nbody.DirectNBody`. Here, as an example, we'll repeat a similar
integration as above, but (1) add a positional offset of the initial conditions
from the origin, and (2) specify an external potential using the
`~gala.potential.potential.MilkyWayPotential` class as an external potential::

    >>> external_pot = gp.MilkyWayPotential()
    >>> w0_1 = gd.PhaseSpacePosition(pos=[10, 0, 0] * u.kpc,
    ...                              vel=[0, 200, 0] * u.km/u.s)
    >>> w0_2 = gd.PhaseSpacePosition(pos=w0_1.xyz + [10., 0, 0] * u.pc,
    ...                              vel=w0_1.v_xyz + [0, 5, 0] * u.km/u.s)
    >>> w0 = gd.combine((w0_1, w0_2))
    >>> pot1 = gp.HernquistPotential(m=1e7*u.Msun, c=0.5*u.kpc, units=galactic)
    >>> particle_pot = [pot1, None]
    >>> nbody = DirectNBody(w0, particle_pot, external_potential=external_pot)
    >>> orbits = nbody.integrate_orbit(dt=1e-2*u.Myr, t1=0, t2=1*u.Gyr)
    >>> fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    >>> _ = orbits[:, 0].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP
    >>> _ = orbits[:, 1].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    external_pot = gp.MilkyWayPotential()
    w0_1 = gd.PhaseSpacePosition(pos=[10, 0, 0] * u.kpc,
                                 vel=[0, 200, 0] * u.km/u.s)
    w0_2 = gd.PhaseSpacePosition(pos=w0_1.xyz + [10., 0, 0] * u.pc,
                                 vel=w0_1.v_xyz + [0, 5, 0] * u.km/u.s)
    w0 = gd.combine((w0_1, w0_2))
    pot1 = gp.HernquistPotential(m=1e7*u.Msun, c=0.5*u.kpc, units=galactic)
    particle_pot = [pot1, None]
    nbody = DirectNBody(w0, particle_pot, external_potential=external_pot)
    orbits = nbody.integrate_orbit(dt=1e-2*u.Myr, t1=0, t2=1*u.Gyr)

    fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    _ = orbits[:, 0].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP
    _ = orbits[:, 1].plot(['x', 'y'], axes=[ax]) # doctest: +SKIP

In this case, the orbits are so similar that it is hard to tell whether the test
particle is actually bound to the secondary mass. Let's instead now plot the
position in the x-y plane of particle 2 relative to particle 1. This will look
strange because we have not transformed to the frame of particle 1, but it
should give us a sense of whether particle 2 is bound or unbound to this mass::

    >>> dxyz = orbits[:, 0].xyz - orbits[:, 1].xyz
    >>> fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    >>> ax.plot(dxyz[0], dxyz[1]) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    dxyz = orbits[:, 0].xyz - orbits[:, 1].xyz

    fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    ax.plot(dxyz[0], dxyz[1]) # doctest: +SKIP
    ax.set_xlim(-0.1, 0.1)
    ax.set_ylim(-0.1, 0.1)

From this, it looks like particle 2 is indeed still bound to particle 1 as they
both orbit within the external potential.


.. automodapi:: gala.dynamics.nbody
</file>

<file path="docs/dynamics/nd-representations.rst">
.. include:: references.txt

.. _nd-representations:

************************************
N-dimensional representation classes
************************************

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.dynamics as gd

Introduction
============

The Astropy |astropyrep|_ presently only support 3D positions and differential
objects. The `~gala.dynamics.representation_nd.NDCartesianRepresentation` and
`~gala.dynamics.representation_nd.NDCartesianDifferential` classes add Cartesian
representation classes that can handle arbitrary numbers of dimensions. For
example, 2D coordinates::

    >>> xy = np.arange(16).reshape(2, 8) * u.kpc
    >>> rep = gd.NDCartesianRepresentation(xy)
    >>> rep
    <NDCartesianRepresentation (x1, x2) in kpc
        [(0.,  8.), (1.,  9.), (2., 10.), (3., 11.), (4., 12.), (5., 13.),
         (6., 14.), (7., 15.)]>

4D coordinates::

    >>> x = np.arange(16).reshape(4, 4) * u.kpc
    >>> rep = gd.NDCartesianRepresentation(x)
    >>> rep
    <NDCartesianRepresentation (x1, x2, x3, x4) in kpc
        [(0., 4.,  8., 12.), (1., 5.,  9., 13.), (2., 6., 10., 14.),
         (3., 7., 11., 15.)]>

These can be passed in to the |psp| or |orb| classes as with any of the Astropy
core representation objects::

    >>> xy = np.arange(16).reshape(2, 8) * u.kpc
    >>> vxy = np.arange(16).reshape(2, 8) / 10. * u.kpc / u.Myr
    >>> w = gd.PhaseSpacePosition(pos=xy, vel=vxy)
    >>> fig = w.plot()

.. plot::
    :align: center
    :width: 60%

    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd
    xy = np.arange(16).reshape(2, 8) * u.kpc
    vxy = np.arange(16).reshape(2, 8) / 10. * u.kpc / u.Myr
    w = gd.PhaseSpacePosition(pos=xy, vel=vxy)
    fig = w.plot()

However, certain functionality such as representation transformations, dynamical
quantity calculation, and coordinate frame transformations are disabled when the
number of dimensions is not 3 (i.e. when not using the Astropy core
representation classes).

N-dimensional representations API
---------------------------------
.. automodapi:: gala.dynamics.representation_nd
    :no-heading:
    :headings: ^^
</file>

<file path="docs/dynamics/nonlinear.rst">
.. _gala-nonlinear-dynamics:

******************
Nonlinear Dynamics
******************

Introduction
============

This module contains utilities for nonlinear dynamics. Currently, the only
implemented features enable you to compute estimates of the maximum
Lyapunov exponent for an orbit. In future releases, there will be features
for creating surface of sections and computing the full Lyapunov spectrum.

Some imports needed for the code below::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> from gala.units import galactic

Computing Lyapunov exponents
============================

Chaotic orbit
-------------

There are two ways to compute Lyapunov exponents implemented in `gala.dynamics`.
In most cases, you'll want to use the
`~gala.dynamics.nonlinear.fast_lyapunov_max` function because the integration is
implemented in C and is quite fast. This function only works if the potential
you are working with is implemented in C (e.g., it is a
`~gala.potential.potential.CPotentialBase` subclass). With a potential object
and a set of initial conditions::

    >>> pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, r_h=0.1*u.kpc,
    ...                               q1=1., q2=0.8, q3=0.6, units=galactic)
    >>> w0 = gd.PhaseSpacePosition(pos=[5.5,0.,5.5]*u.kpc,
    ...                            vel=[0.,100.,0]*u.km/u.s)
    >>> lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=2., n_steps=100000) # doctest: +SKIP

This returns two objects: an `~astropy.units.Quantity` object that
contains the maximum Lyapunov exponent estimate for each offset orbit,
(we can control the number of offset orbits with the ``noffset_orbits``
argument) and an `~gala.dynamics.Orbit` object that contains
the parent orbit and each offset orbit. Let's plot the parent orbit::

    >>> fig = orbit[:,0].plot(marker=',', alpha=0.25, linestyle='none') # doctest: +SKIP

.. plot::
    :align: center

    import astropy.units as u
    import matplotlib.pyplot as plt
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, r_h=0.1*u.kpc,
                                  q1=1., q2=0.8, q3=0.6, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[5.5,0.,5.5]*u.kpc,
                               vel=[0.,100.,0]*u.km/u.s)
    lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=2., n_steps=100000)
    fig = orbit[:,0].plot(marker=',', linestyle='none', alpha=0.25)

Visually, this looks like a chaotic orbit. This means the Lyapunov exponent
should saturate to some value. We'll now plot the estimate of the Lyapunov
exponent as a function of time -- because the algorithm re-normalizes every
several time-steps (controllable with the ``n_steps_per_pullback`` argument),
we have to down-sample the time array to align it with the Lyapunov exponent
array. This plots one line per offset orbit::

    >>> plt.figure() # doctest: +SKIP
    >>> plt.loglog(orbit.t[11::10], lyap, marker='') # doctest: +SKIP
    >>> plt.xlabel("Time [{}]".format(orbit.t.unit)) # doctest: +SKIP
    >>> plt.ylabel(r"$\lambda_{{\rm max}}$ [{}]".format(lyap.unit)) # doctest: +SKIP
    >>> plt.tight_layout() # doctest: +SKIP

.. plot::
    :align: center
    :width: 60%

    import astropy.units as u
    import matplotlib.pyplot as plt
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, r_h=0.1*u.kpc,
                                  q1=1., q2=0.8, q3=0.6, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[5.5,0.,5.5]*u.kpc,
                               vel=[0.,100.,0]*u.km/u.s)
    lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=2., n_steps=100000)

    plt.figure()
    plt.loglog(orbit.t[11::10], lyap, marker='')
    plt.xlabel("Time [{}]".format(orbit.t.unit))
    plt.ylabel(r"$\lambda_{{\rm max}}$ [{}]".format(lyap.unit))
    plt.tight_layout()

The estimate is clearly starting to diverge from a simple power law decay.

Regular orbit
-------------

To compare, we will compute the estimate for a regular orbit as well::

    >>> w0 = gd.PhaseSpacePosition(pos=[5.5,0.,0.]*u.kpc,
    ...                            vel=[0.,140.,25]*u.km/u.s)
    >>> lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=2., n_steps=100000) # doctest: +SKIP
    >>> fig = orbit[:,0].plot(marker=',', alpha=0.1, linestyle='none') # doctest: +SKIP

.. plot::
    :align: center

    import astropy.units as u
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, r_h=0.1*u.kpc,
                                  q1=1., q2=0.8, q3=0.6, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[5.5,0.,0.]*u.kpc,
                               vel=[0.,140.,25]*u.km/u.s)
    lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=1., n_steps=200000)
    fig = orbit[:,0].plot(marker=',', linestyle='none', alpha=0.1)

Because this is a regular orbit, the estimate continues decreasing,
following a characteristic power-law (a straight line in a log-log plot)::

    >>> pl.figure() # doctest: +SKIP
    >>> pl.loglog(orbit.t[11::10], lyap, marker='') # doctest: +SKIP
    >>> pl.xlabel("Time [{}]".format(orbit.t.unit)) # doctest: +SKIP
    >>> pl.ylabel(r"$\lambda_{{\rm max}}$ [{}]".format(lyap.unit)) # doctest: +SKIP
    >>> pl.tight_layout() # doctest: +SKIP

.. plot::
    :align: center
    :width: 60%

    import astropy.units as u
    import matplotlib.pyplot as pl
    import gala.potential as gp
    import gala.dynamics as gd
    from gala.units import galactic

    pot = gp.LogarithmicPotential(v_c=150*u.km/u.s, r_h=0.1*u.kpc,
                                  q1=1., q2=0.8, q3=0.6, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[5.5,0.,0.]*u.kpc,
                               vel=[0.,140.,25]*u.km/u.s)
    lyap,orbit = gd.fast_lyapunov_max(w0, pot, dt=1., n_steps=200000)

    pl.figure()
    pl.loglog(orbit.t[11::10], lyap, marker='')
    pl.xlabel("Time [{}]".format(orbit.t.unit))
    pl.ylabel(r"$\lambda_{{\rm max}}$ [{}]".format(lyap.unit))
    pl.tight_layout()

API
---
.. automodapi:: gala.dynamics.nonlinear
    :no-heading:
    :headings: ^^
</file>

<file path="docs/dynamics/orbits-in-detail.rst">
.. include:: references.txt

.. _orbits-in-detail:

*****************************************************
Orbit and phase-space position objects in more detail
*****************************************************

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> from astropy.coordinates import (CylindricalRepresentation,
    ...                                  CylindricalDifferential)
    >>> from gala.units import galactic
    >>> np.random.seed(42)

We will also set the default Astropy Galactocentric frame parameters to the
values adopted in Astropy v4.0:

    >>> import astropy.coordinates as coord
    >>> _ = coord.galactocentric_frame_defaults.set('v4.0')

Introduction
============

The `astropy.units` subpackage is excellent for working with numbers and
associated units, but dynamical quantities often contain many quantities with
mixed units. An example is a position in phase-space, which may contain some
quantities with length units and some quantities with velocity or momentum
units. The |psp| and |orb| classes are designed to work with these data
structures and provide a consistent API for visualizing and computing further
dynamical quantities. Click these shortcuts to jump to a section below, or start
reading below:

 * :ref:`phase-space-position`
 * :ref:`orbit`

.. _phase-space-position:

Phase-space Positions
=====================

The |psp| class provides an interface for representing full phase-space
positions--coordinate positions and momenta (velocities). This class is useful
as a container for initial conditions and for transforming phase-space positions
to new coordinate representations or reference frames.

The easiest way to create a |psp| object is to pass in a pair of
`~astropy.units.Quantity` objects that represent the Cartesian position and
velocity vectors::

    >>> gd.PhaseSpacePosition(pos=[4., 8., 15.] * u.kpc,
    ...                       vel=[-150., 50., 15.] * u.km/u.s)
    <PhaseSpacePosition cartesian, dim=3, shape=()>

By default, passing in `~astropy.units.Quantity`'s are interpreted as Cartesian
coordinates and velocities. This works with arrays of positions and velocities
as well::

    >>> x = np.arange(24).reshape(3, 8)
    >>> v = np.arange(24).reshape(3, 8)
    >>> w = gd.PhaseSpacePosition(pos=x * u.kpc,
    ...                           vel=v * u.km/u.s)
    >>> w
    <PhaseSpacePosition cartesian, dim=3, shape=(8,)>

This is interpreted as 8, 6-dimensional phase-space positions.

The class internally stores the positions and velocities as
`~astropy.coordinates.BaseRepresentation` and
`~astropy.coordinates.BaseDifferential` subclasses; in this case,
`~astropy.coordinates.CartesianRepresentation` and
`~astropy.coordinates.CartesianDifferential`::

    >>> w.pos
    <CartesianRepresentation (x, y, z) in kpc
        [(0.,  8., 16.), (1.,  9., 17.), (2., 10., 18.), (3., 11., 19.),
         (4., 12., 20.), (5., 13., 21.), (6., 14., 22.), (7., 15., 23.)]>
    >>> w.vel
    <CartesianDifferential (d_x, d_y, d_z) in km / s
        [(0.,  8., 16.), (1.,  9., 17.), (2., 10., 18.), (3., 11., 19.),
         (4., 12., 20.), (5., 13., 21.), (6., 14., 22.), (7., 15., 23.)]>

All of the components of these classes are mapped to attributes of the
phase-space position class for convenience, but with more user-friendly names.
These mappings are defined in the class definition of
`~gala.dynamics.PhaseSpacePosition`. For example, to access the ``x`` component
of the position and the ``v_x`` component of the velocity::

    >>> w.x  # doctest: +FLOAT_CMP
    <Quantity [0.,1.,2.,3.,4.,5.,6.,7.] kpc>
    >>> w.v_x  # doctest: +FLOAT_CMP
    <Quantity [0.,1.,2.,3.,4.,5.,6.,7.] km / s>

The default representation is Cartesian, but the class can also be instantiated
with representation objects instead of `~astropy.units.Quantity`'s -- this is
useful for creating |psp| or |orb| instances from non-Cartesian
representations of the position and velocity::

    >>> pos = CylindricalRepresentation(rho=np.linspace(1., 4, 4) * u.kpc,
    ...                                 phi=np.linspace(0, np.pi, 4) * u.rad,
    ...                                 z=np.linspace(-1, 1., 4) * u.kpc)
    >>> vel = CylindricalDifferential(d_rho=np.linspace(100, 150, 4) * u.km/u.s,
    ...                               d_phi=np.linspace(-1, 1, 4) * u.rad/u.Myr,
    ...                               d_z=np.linspace(-15, 15., 4) * u.km/u.s)
    >>> w = gd.PhaseSpacePosition(pos=pos, vel=vel)
    >>> w
    <PhaseSpacePosition cylindrical, dim=3, shape=(4,)>
    >>> w.rho
    <Quantity [1., 2., 3., 4.] kpc>

We can easily transform the full phase-space vector to new representations or
coordinate frames. These transformations use the :mod:`astropy.coordinates`
|astropyrep|_::

    >>> cart = w.represent_as('cartesian')
    >>> cart.x
    <Quantity [ 1. ,  1. , -1.5, -4. ] kpc>
    >>> sph = w.represent_as('spherical')
    >>> sph.distance
    <Distance [1.41421356, 2.02758751, 3.01846171, 4.12310563] kpc>

There is also support for transforming the positions and velocities (assumed to
be in a `~astropy.coordinates.Galactocentric` frame) to any of the other
coordinate frames. For example, to transform to
:class:`~astropy.coordinates.Galactic` coordinates::

    >>> from astropy.coordinates import Galactic
    >>> gal_c = w.to_coord_frame(Galactic)
    >>> gal_c # doctest: +FLOAT_CMP
    <Galactic Coordinate: (l, b, distance) in (deg, deg, kpc)
        [(4.40971301e-05, -6.23850462, 9.17891228),
        (1.07501936e+01, -2.04017409, 9.29170644),
        (2.14246214e+01,  2.65220588, 7.12026744),
        (7.35169893e-05, 13.50991169, 4.23668468)]
    (pm_l_cosb, pm_b, radial_velocity) in (mas / yr, mas / yr, km / s)
        [( -28.11596908, -0.297625  ,    89.093095  ),
        ( -13.077309  ,  0.15891073,   511.60269726),
        (  -7.04751509,  1.33976418, -1087.52574084),
        (-206.97042166,  2.22471526,  -156.82064814)]>

We can easily plot projections of the phase-space positions using the
`~gala.dynamics.PhaseSpacePosition.plot` method::

    >>> np.random.seed(42)
    >>> x = np.random.uniform(-10, 10, size=(3,128))
    >>> v = np.random.uniform(-200, 200, size=(3,128))
    >>> w = gd.PhaseSpacePosition(pos=x * u.kpc,
    ...                           vel=v * u.km/u.s)
    >>> fig = w.plot() # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd

    np.random.seed(42)
    x = np.random.uniform(-10,10,size=(3,128))
    v = np.random.uniform(-200,200,size=(3,128))
    w = gd.PhaseSpacePosition(pos=x*u.kpc,
                              vel=v*u.km/u.s)
    fig = w.plot()

This is a thin wrapper around the `~gala.dynamics.plot_projections`
function and any keyword arguments are passed through to that function::

    >>> fig = w.plot(components=['x', 'v_z'], color='r',
    ...              facecolor='none', marker='o', s=20, alpha=0.5) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    fig = w.plot(components=['x', 'v_z'], color='r',
                 facecolor='none', marker='o', s=20, alpha=0.5)


.. _orbit:

Orbits
======

The |orb| class inherits much of the functionality from |psp| (described above)
and adds some additional features that are useful for time-series orbits.

An |orb| instance is initialized like the |psp|--with arrays of positions and
velocities-- but usually also requires specifying a time array as well. Also,
the extra axes in these arrays hold special meaning for the |orb| class. The
position and velocity arrays passed to |psp| can have arbitrary numbers of
dimensions as long as the 0th axis specifies the dimensionality. For the |orb|
class, the 0th axis remains the axis of dimensionality, but the 1st axis now is
always assumed to be the time axis. For example, an input position with shape
``(2,128)`` to a |psp| represents 128 independent 2D positions, but to a |orb|
it represents a single orbit's positions at 128 times::

    >>> t = np.linspace(0, 100, 128) * u.Myr
    >>> Om = 1E-1 * u.rad / u.Myr
    >>> pos = np.vstack((5*np.cos(Om*t), np.sin(Om*t))).value * u.kpc
    >>> vel = np.vstack((-5*np.sin(Om*t), np.cos(Om*t))).value * u.kpc/u.Myr
    >>> orbit = gd.Orbit(pos=pos, vel=vel)
    >>> orbit
    <Orbit ndcartesian, dim=2, shape=(128,)>

To create a single object that contains multiple orbits, the input position
object should have 3 axes. The last axis (``axis=2``) specifies the number of
orbits. So, an input position with shape ``(2,128,16)`` would represent 16, 2D
orbits, each with the same 128 times::

    >>> t = np.linspace(0, 100, 128) * u.Myr
    >>> Om = np.random.uniform(size=16) * u.rad / u.Myr
    >>> angle = Om[None] * t[:, None]
    >>> pos = np.stack((5*np.cos(angle), np.sin(angle))).value * u.kpc
    >>> vel = np.stack((-5*np.sin(angle), np.cos(angle))).value * u.kpc/u.Myr
    >>> orbit = gd.Orbit(pos=pos, vel=vel)
    >>> orbit
    <Orbit ndcartesian, dim=2, shape=(128, 16)>

To make full use of the orbit functionality, you must also pass in an array with
the time values and an instance of a `~gala.potential.potential.PotentialBase`
subclass that represents the potential that the orbit was integrated in::

    >>> pot = gp.PlummerPotential(m=1E10, b=1., units=galactic)
    >>> orbit = gd.Orbit(pos=pos*u.kpc, vel=vel*u.km/u.s,
    ...                  t=t*u.Myr, potential=pot)

(note, in this case ``pos`` and ``vel`` were not generated from integrating
an orbit in the potential ``pot``!). However, most of the time you won't need to
create |orb| objects from scratch! They are returned from any of the numerical
integration routines provided in `gala`. For example, they are returned by the
`~gala.potential.potential.PotentialBase.integrate_orbit` method of potential
objects and will automatically contain the ``time`` array and ``potential``
object. For example::

    >>> pot = gp.PlummerPotential(m=1E10 * u.Msun, b=1. * u.kpc, units=galactic)
    >>> w0 = gd.PhaseSpacePosition(pos=[10.,0,0] * u.kpc,
    ...                            vel=[0.,75,0] * u.km/u.s)
    >>> orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=5000)
    >>> orbit
    <Orbit cartesian, dim=3, shape=(5001,)>
    >>> orbit.t
    <Quantity [0.000e+00, 1.000e+00, 2.000e+00, ..., 4.998e+03, 4.999e+03,
               5.000e+03] Myr>
    >>> orbit.potential
    <PlummerPotential: m=1.00e+10, b=1.00 (kpc,Myr,solMass,rad)>

Just like for |psp|, we can quickly visualize an orbit using the
`~gala.dynamics.Orbit.plot` method::

    >>> fig = orbit.plot() # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import astropy.units as u
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    pot = gp.PlummerPotential(m=1E10 * u.Msun, b=1. * u.kpc, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[2.,0,0] * u.kpc,
                               vel=[0.,75,15] * u.km/u.s)
    orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=5000)
    fig = orbit.plot()

Again, this is a thin wrapper around the `~gala.dynamics.plot_projections`
function and any keyword arguments are passed through to that function::

    >>> fig = orbit.plot(linewidth=4., alpha=0.5, color='r') # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    fig = orbit.plot(linewidth=4., alpha=0.5, color='r')

Alternatively, for three-dimensional orbits, we can visualize the orbit using
the 3D projection capabilities in `matplotlib`::

    >>> fig = orbit.plot_3d(alpha=0.5, color='k')  # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    fig = orbit.plot_3d(alpha=0.5, color='k')

We can also quickly create an animation of the progression of an orbit using the
`~gala.dynamics.Orbit.animate` method, which animated projections of the orbit::

    >>> fig, anim = orbit[:1000].animate(stride=10)  # doctest: +SKIP

.. raw:: html

    <video controls src="../_static/orbit-anim1.mp4" width=650 autoplay loop></video>

The animate method acts like `~gala.dynamics.Orbit.plot`, in that it works for
any coordinate representation (Cartesian, cylindrical, etc.) and supports only
animating subsets of the phase-space components. For example, to make an
animation of an orbit in cylindrical coordinates, showing the orbit proress in
the R,z meridional plane::

    >>> fig, anim = orbit[:1000].cylindrical.animate(components=['rho', 'z'],  # doctest: +SKIP
    ...                                              stride=10)

.. raw:: html

    <video controls src="../_static/orbit-anim2.mp4" width=450 autoplay loop></video>

We can also quickly compute quantities like the angular momentum, and estimates
for the pericenter, apocenter, eccentricity of the orbit. Estimates for the
latter few get better with smaller timesteps::

    >>> orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.1, n_steps=100000)
    >>> np.mean(orbit.angular_momentum(), axis=1) # doctest: +FLOAT_CMP
    <Quantity [0.        ,0.        ,0.76703412] kpc2 / Myr>
    >>> orbit.eccentricity() # doctest: +FLOAT_CMP
    <Quantity 0.31951765618193967>
    >>> orbit.pericenter() # doctest: +FLOAT_CMP
    <Quantity 10.00000005952518 kpc>
    >>> orbit.apocenter() # doctest: +FLOAT_CMP
    <Quantity 19.390916871970223 kpc>


More information
================

Internally, both of the above classes rely on the Astropy representation
transformation framework (i.e. the subclasses of
`~astropy.coordinates.BaseRepresentation` and
`~astropy.coordinates.BaseDifferential`). However, at present these classes only
support 3D positions and differentials (velocities). The |psp| and |orb| classes
both support arbitrary numbers of dimensions and, when relevant, rely on custom
subclasses of the representation classes to handle such cases. See the
:ref:`nd-representations` page for more information about these classes.
</file>

<file path="docs/dynamics/references.txt">
.. |psp| replace:: `~gala.dynamics.PhaseSpacePosition`
.. |orb| replace:: `~gala.dynamics.Orbit`
.. |astropyrep| replace:: representations framework
.. _astropyrep: http://docs.astropy.org/en/latest/coordinates/skycoord.html#astropy-skycoord-representations
</file>

<file path="docs/integrate/index.rst">
.. include:: ../references.txt

.. module:: gala.integrate

************************************
Integration (`gala.integrate`)
************************************

Introduction
============

:mod:`scipy` provides numerical ODE integration functions (e.g.,
:func:`scipy.integrate.odeint` and :func:`scipy.integrate.solve_ivp`), but these
functions are not object-oriented or accessible from C. The
:mod:`gala.integrate` subpackage implements the Leapfrog integration scheme (not
available in Scipy) and provides C wrappers for higher order integration schemes
such as a 5th order Runge-Kutta and the Dormand-Prince 85(3) method.

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.dynamics as gd
    >>> import gala.integrate as gi
    >>> from gala.units import galactic, UnitSystem

Getting Started
===============

All of the integrator classes in :mod:`gala.integrate` have the same basic call
structure. To create an integrator object, you pass in a function that evaluates
derivatives of, for example, phase-space coordinates, then you call the
`~gala.integrate.Integrator.run` method while specifying timestep information.

The integration function must accept, at minimum, two arguments: the current
time, ``t``, and the current position in phase-space, ``w``. The time is a
single floating-point number and the phase-space position will have shape
``(ndim, norbits)`` where ``ndim`` is the full dimensionality of the phase-space
(e.g., 6 for a 3D coordinate system) and ``norbits`` is the number of orbits.
These inputs will *not* have units associated with them (e.g., they are not
:class:`astropy.units.Quantity` objects). An example of such a function (that
represents a simple harmonic oscillator) is::

    >>> def F(t, w):
    ...     x, x_dot = w
    ...     return np.array([x_dot, -x])

Even though time does not explicitly enter into the equation, the function must
still accept a time argument. We can now create an instance of
`~gala.integrate.LeapfrogIntegrator` to integrate an orbit in a harmonic
oscillator potential::

    >>> integrator = gi.LeapfrogIntegrator(F)

To run the integrator, we need to specify a set of initial conditions. The
simplest way to do this is to specify an array::

    >>> w0 = np.array([1., 0.])

This causes the integrator to work without units, so the orbit object returned
by the integrator will then also have no associated units. For example, to
integrate from these initial conditions with a time step of 0.5 for 100 steps::

    >>> orbit = integrator.run(w0, dt=0.5, n_steps=100)
    >>> orbit.t.unit
    Unit(dimensionless)
    >>> orbit.pos.xyz.unit
    Unit(dimensionless)

We could instead specify the unit system that the function (``F``) expects, and
then pass in a `~gala.dynamics.PhaseSpacePosition` object with arbitrary units
as initial conditions::

    >>> usys = UnitSystem(u.m, u.s, u.kg, u.radian)
    >>> integrator = gi.LeapfrogIntegrator(F, func_units=usys)
    >>> w0 = gd.PhaseSpacePosition(pos=[100.]*u.cm, vel=[0]*u.cm/u.yr)
    >>> orbit = integrator.run(w0, dt=0.5, n_steps=100)

The returned orbit object has quantities in the specified unit system, for
example::

    >>> orbit.t.unit
    Unit("s")
    >>> orbit.x1.unit
    Unit("m")


Example: Forced pendulum
-------------------------

Here we will demonstrate how to use the Dormand-Prince integrator to compute the
orbit of a forced pendulum. We will use the variable ``q`` as the angle of the
pendulum with respect to the vertical and ``p`` as the conjugate momentum. Our
Hamiltonian is

.. math::

    H(q, p) = \frac{1}{2} \, p^2 + \cos(q) + A \, \sin(\omega_D \, t)

so that

.. math::

    \dot{q} &= p\\
    \dot{p} &= -\sin(q) + A\, \omega_D \, \cos(\omega_D \, t)

For numerical integration, the function to compute the time derivatives of our
phase-space coordinates is then::

    >>> def F(t, w, A, omega_D):
    ...     q, p = w
    ...     wdot = np.zeros_like(w)
    ...     wdot[0] = p
    ...     wdot[1] = -np.sin(q) + A * omega_D * np.cos(omega_D * t)
    ...     return wdot

This function has two arguments: :math:`A` (``A``), the amplitude of the
forcing,and :math:`\omega_D` (``omega_D``), the driving frequency. We define an
integrator object by specifying this function along with values for the function
arguments::

    >>> integrator = gi.DOPRI853Integrator(F, func_args=(0.07, 0.75))

To integrate an orbit, we use the `~gala.integrate.Integrator.run` method. We
have to specify the initial conditions along with information about how long to
integrate and with what step size. There are several options for how to specify
the time step information. We could pre-generate an array of times and pass that
in, or pass in an initial time, end time, and timestep. Or, we could simply pass
in the number of steps to run for and a timestep. For this example, we will use
the last option. See the API below under *"Other Parameters"* for more
information.::

    >>> orbit = integrator.run([3., 0.], dt=0.1, n_steps=10000)

We can plot the integrated (chaotic) orbit::

    >>> fig = orbit.plot(subplots_kwargs=dict(figsize=(8, 4))) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import astropy.units as u
    import matplotlib.pyplot as pl
    import numpy as np
    import gala.integrate as gi

    def F(t, w, A, omega_D):
        q, p = w
        wdot = np.zeros_like(w)
        wdot[0] = p
        wdot[1] = -np.sin(q) + A*omega_D*np.cos(omega_D*t)
        return wdot

    integrator = gi.DOPRI853Integrator(F, func_args=(0.07, 0.75))
    orbit = integrator.run([3., 0.], dt=0.1, n_steps=10000)
    fig = orbit.plot(subplots_kwargs=dict(figsize=(8,4)))

Example: Lorenz equations
-------------------------

Here's another example of numerical ODE integration using the
`Lorenz equations <https://en.wikipedia.org/wiki/Lorenz_system>`_, a 3D
nonlinear system::

    >>> def F(t, w, sigma, rho, beta):
    ...     x, y, z, *_ = w
    ...     wdot = np.zeros_like(w)
    ...     wdot[0] = sigma * (y - x)
    ...     wdot[1] = x * (rho-z) - y
    ...     wdot[2] = x*y - beta*z
    ...     return wdot
    >>> sigma, rho, beta = 10., 28., 8/3.
    >>> integrator = gi.DOPRI853Integrator(F, func_args=(sigma, rho, beta))
    >>> orbit = integrator.run([0.5, 0.5, 0.5, 0, 0, 0], dt=1E-2, n_steps=1E4)
    >>> fig = orbit.plot() # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    def F(t, w, sigma, rho, beta):
        x, y, z, *_ = w
        wdot = np.zeros_like(w)
        wdot[0] = sigma * (y - x)
        wdot[1] = x * (rho-z) - y
        wdot[2] = x*y - beta*z
        return wdot

    sigma, rho, beta = 10., 28., 8/3.
    integrator = gi.DOPRI853Integrator(F, func_args=(sigma, rho, beta))

    orbit = integrator.run([0.5, 0.5, 0.5, 0, 0, 0], dt=1E-2, n_steps=1E4)
    fig = orbit.plot()

API
===

.. automodapi:: gala.integrate
    :no-main-docstr:

.. NOTE : The no-main-docstr option above is so that .. automodule:: is not
.. run, and therefore no .. module:: gala.integrate is defined here, which would
.. duplicate the module definition at the top of this page
</file>

<file path="docs/potential/compositepotential.rst">
.. _compositepotential:

*************************************************
Creating a composite (multi-component ) potential
*************************************************

Potential objects can be combined into more complex *composite* potentials
using the :class:`~gala.potential.potential.CompositePotential` or
:class:`~gala.potential.potential.CCompositePotential` classes. These classes
operate like a Python dictionary in that each component potential must be named,
and the potentials can either be passed in to the initializer or added after the
composite potential container is already created.

For composing any of the built-in potentials or any external potentials
implemented in C, it is always faster to use
:class:`~gala.potential.potential.CCompositePotential`, where the composition is
done at the C layer rather than in Python.

With either class, interaction with the class (e.g., by calling methods) is
identical to the individual potential classes. To compose potentials with unique
but arbitrary names, you can also simply add pre-defined potential class
instances::

    >>> import numpy as np
    >>> import gala.potential as gp
    >>> from gala.units import galactic
    >>> disk = gp.MiyamotoNagaiPotential(m=1E11, a=6.5, b=0.27, units=galactic)
    >>> bulge = gp.HernquistPotential(m=3E10, c=0.7, units=galactic)
    >>> pot = disk + bulge
    >>> print(pot.__class__.__name__)
    CCompositePotential
    >>> list(pot.keys()) # doctest: +SKIP
    ['c655f07d-a1fe-4905-bdb2-e8a202d15c81',
     '8098cb0b-ebad-4388-b685-2f93a874296e']

The two components are assigned unique names and composed into a
:class:`~gala.potential.potential.CCompositePotential` instance because the two
component potentials are implemented in C (i.e. are
:class:`~gala.potential.potential.CPotential`subclass instances). If any of the
individual potential components are Python-only, the resulting object will be
an instance of :class:`~gala.potential.potential.CompositePotential` instead.

Alternatively, the potentials can be composed directly into the object by
treating it like a dictionary. This allows you to specify the keys or names of
the components in the resulting
:class:`~gala.potential.potential.CCompositePotential` instance::

    >>> disk = gp.MiyamotoNagaiPotential(m=1E11, a=6.5, b=0.27, units=galactic)
    >>> bulge = gp.HernquistPotential(m=3E10, c=0.7, units=galactic)
    >>> pot = gp.CCompositePotential(disk=disk, bulge=bulge)
    >>> list(pot.keys()) # doctest: +SKIP
    ['disk', 'bulge']

is equivalent to::

    >>> pot = gp.CCompositePotential()
    >>> pot['disk'] = disk
    >>> pot['bulge'] = bulge

The order of insertion is preserved, and sets the order that the potentials are
called. In the above example, the disk potential would always be called first
and the bulge would always be called second.

The resulting potential object has all of the same properties as individual
potential objects::

    >>> pot.energy([1., -1., 0.]) # doctest: +FLOAT_CMP
    <Quantity [-0.12887588] kpc2 / Myr2>
    >>> pot.acceleration([1., -1., 0.]) # doctest: +FLOAT_CMP
    <Quantity [[-0.02270876],
               [ 0.02270876],
               [-0.        ]] kpc / Myr2>
    >>> grid = np.linspace(-3., 3., 100)
    >>> fig = pot.plot_contours(grid=(grid, 0, grid)) # doctest: +SKIP

.. plot::
    :align: center
    :width: 60%

    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    disk = gp.MiyamotoNagaiPotential(m=1E11, a=6.5, b=0.27, units=galactic)
    bulge = gp.HernquistPotential(m=3E10, c=0.7, units=galactic)
    pot = gp.CompositePotential(disk=disk, bulge=bulge)

    grid = np.linspace(-3.,3.,100)
    fig = pot.plot_contours(grid=(grid,0,grid))
</file>

<file path="docs/potential/define-new-potential.rst">
.. _define-new-potential:

*********************************
Defining your own potential class
*********************************

Introduction
============

There are two ways to define a new potential class: with pure-Python, or with C
and Cython. The advantage to writing a new class in Cython is that the
computations can execute with C-like speeds, however only certain integrators
support using this functionality (Leapfrog and DOP853) and it is a bit more
complicated to set up the code to build the C+Cython code properly. If you are
not familiar with Cython, you probably want to stick to a pure Python class for
initial testing. If there is a potential class that you think should be
included as a built-in Cython potential, feel free to suggest the new addition
as a `GitHub issue <https://github.com/adrn/gala/issues>`_!

For the examples below the following imports have already been executed::

    >>> import numpy as np
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd

========================================
Implementing a new potential with Python
========================================

New Python potentials are implemented by subclassing
:class:`~gala.potential.potential.PotentialBase` and defining functions that
compute (at minimum) the energy and gradient of the potential. We will work
through an example below for adding the `Henon-Heiles potential
<http://en.wikipedia.org/wiki/H%C3%A9non-Heiles_System>`_.

The expression for the potential is:

.. math::

    \Phi(x,y) = \frac{1}{2}(x^2 + y^2) + A\,(x^2 y - \frac{y^3}{3})

With this parametrization, there is only one free parameter (``A``), and the
potential is two-dimensional.

At minimum, the subclass must implement the following methods:

- ``__init__()``
- ``_energy()``
- ``_gradient()``

The ``_energy()`` method should compute the potential energy at a given position
and time. The ``_gradient()`` method should compute the gradient of the
potential. Both of these methods must accept two arguments: a position, and a
time. These internal methods are then called by the
:class:`~gala.potential.potential.PotentialBase` superclass methods
:meth:`~gala.potential.potential.PotentialBase.energy` and
:meth:`~gala.potential.potential.PotentialBase.gradient`. The superclass methods
convert the input position to an array in the unit system of the potential for
fast evaluation. The input to these superclass methods can be
:class:`~astropy.units.Quantity` objects,
:class:`~gala.dynamics.PhaseSpacePosition` objects, or :class:`~numpy.ndarray`.

Because this potential has a parameter, the ``__init__`` method must accept
a parameter argument and store this in the ``parameters`` dictionary attribute
(a required attribute of any subclass). Let's write it out, then work through
what each piece means in detail::

    >>> class CustomHenonHeilesPotential(gp.PotentialBase):
    ...     A = gp.PotentialParameter("A")
    ...     ndim = 2
    ...
    ...     def _energy(self, xy, t):
    ...         A = self.parameters['A'].value
    ...         x,y = xy.T
    ...         return 0.5*(x**2 + y**2) + A*(x**2*y - y**3/3)
    ...
    ...     def _gradient(self, xy, t):
    ...         A = self.parameters['A'].value
    ...         x,y = xy.T
    ...
    ...         grad = np.zeros_like(xy)
    ...         grad[:,0] = x + 2*A*x*y
    ...         grad[:,1] = y + A*(x**2 - y**2)
    ...         return grad

The internal energy and gradient methods compute the numerical value and
gradient of the potential. The ``__init__`` method must take a single argument,
``A``, and store this to a parameter dictionary. The expected shape of the
position array (``xy``) passed to the internal ``_energy()`` and ``_gradient()``
methods is always 2-dimensional with shape ``(n_points, n_dim)`` where
``n_points >= 1`` and ``n_dim`` must match the dimensionality of the potential
specified in the initializer. Note that this is different from the shape
expected when calling the public methods ``energy()`` and ``gradient()``!

Let's now create an instance of the class and see how it works. For now, let's
pass in ``None`` for the unit system to designate that we'll work with
dimensionless quantities::

    >>> pot = CustomHenonHeilesPotential(A=1., units=None)

That's it! We now have a potential object with all of the same functionality as
the built-in potential classes. For example, we can integrate an orbit in this
potential (but note that this potential is two-dimensional, so we only have to
specify four coordinate values)::

    >>> w0 = gd.PhaseSpacePosition(pos=[0., 0.3],
    ...                            vel=[0.38, 0.])
    >>> orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.05, n_steps=10000)
    >>> fig = orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import matplotlib.pyplot as pl
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp

    class CustomHenonHeilesPotential(gp.PotentialBase):
        A = gp.PotentialParameter("A")
        ndim = 2
        def _energy(self, xy, t):
            A = self.parameters['A'].value
            x,y = xy.T
            return 0.5*(x**2 + y**2) + A*(x**2*y - y**3/3)
        def _gradient(self, xy, t):
            A = self.parameters['A'].value
            x,y = xy.T
            grad = np.zeros_like(xy)
            grad[:,0] = x + 2*A*x*y
            grad[:,1] = y + A*(x**2 - y**2)
            return grad

    pot = CustomHenonHeilesPotential(A=1., units=None)
    w0 = gd.PhaseSpacePosition(pos=[0.,0.3],
                               vel=[0.38,0.])
    orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.05, n_steps=10000)
    fig = orbit.plot(marker=',', linestyle='none', alpha=0.5)

We could also, for example, create a contour plot of equipotentials::

    >>> grid = np.linspace(-1., 1., 100)
    >>> from matplotlib import colors
    >>> import matplotlib.pyplot as plt
    >>> fig, ax = plt.subplots(1, 1, figsize=(5,5))
    >>> fig = pot.plot_contours(grid=(grid, grid),
    ...                         levels=np.logspace(-3, 1, 10),
    ...                         norm=colors.LogNorm(),
    ...                         cmap='Blues', ax=ax)

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    from matplotlib import colors
    import matplotlib.pyplot as plt

    grid = np.linspace(-1., 1., 100)
    fig, ax = plt.subplots(1, 1, figsize=(5,5))
    fig = pot.plot_contours(grid=(grid,grid), cmap='Blues',
                            levels=np.logspace(-3, 1, 10),
                            norm=colors.LogNorm(), ax=ax)

=====================================
Adding a custom potential with Cython
=====================================

Adding a new Cython potential class is a little more involved as it requires
writing C-code and setting it up properly to compile when the code is built.
For this example, we'll work through how to define a new C-implemented potential
class representation of a Keplerian (point-mass) potential. Because this example
requires using Cython to build code, we provide a separate
`demo GitHub repository <https://github.com/adrn/gala-cpotential-demo>`_ with an
implementation of this potential with a demonstration of a build system that
successfully sets up the code.

New Cython potentials are implemented by subclassing
:class:`~gala.potential.potential.CPotentialBase`, subclassing
:class:`~gala.potential.potential.CPotentialWrapper`, and defining C functions
that compute (at minimum) the energy and gradient of the potential. This
requires creating (at minimum) a Cython file (.pyx), a C header file (.h), and a
C source file (.c).
</file>

<file path="docs/potential/hamiltonian-reference-frames.rst">
.. _hamiltonian-reference-frames:

****************************************
Hamiltonian objects and reference frames
****************************************

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> import gala.potential as gp
    >>> import gala.dynamics as gd
    >>> import gala.integrate as gi
    >>> from gala.units import galactic

Introduction
============

When :ref:`integrating orbits using the potential classes directly
<integrate_potential_example>`, for example::

    >>> pot = gp.HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc,
    ...                             units=galactic)
    >>> w0 = gd.PhaseSpacePosition(pos=[5.,0,0]*u.kpc,
    ...                            vel=[0,0,50.]*u.km/u.s)
    >>> orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=0.5, n_steps=1000)

it is implicitly assumed that the initial conditions and orbit are in an
inertial (static) reference frame. In this case, the total energy or value
of the Hamiltonian (per unit mass) is simply

.. math::

    H(\boldsymbol{x}, \boldsymbol{v}) = E
        = \frac{1}{2}\,|\boldsymbol{v}|^2 + \Phi(\boldsymbol{x})

It is sometimes useful to transform to alternate, non-inertial reference frames
to do the numerical orbit integration. In this case, the _effective_ Hamiltonian
may include other terms. For example, in the case of a rotating reference frame
constantly rotating with frequency vector :math:`\boldsymbol{\Omega}`, the
effective potential can be written

.. math::

    \Phi_{\rm eff}(\boldsymbol{x}, \boldsymbol{v}) = \Phi(\boldsymbol{x})
        - \boldsymbol{\Omega} \cdot \boldsymbol{L}

where :math:`\boldsymbol{L}` is the angular momentum. For working in
non-inertial reference frames, Gala provides a way to compose potential objects
(which define just the static component of the effective potential) with
reference frame objects into a :class:`~gala.potential.hamiltonian.Hamiltonian`
object, which can then be used for orbit integration, evaluating the full
symplectic gradient of the effective Hamiltonian, and computing the value
(pseudo-energy) of the effective Hamiltonian.

Creating a Hamiltonian object with a specified reference frame
==============================================================

Using the potential objects and
:meth:`~gala.potential.potential.PotentialBase.integrate_orbit()` to integrate
an orbit is equivalent to defining a
:class:`~gala.potential.hamiltonian.Hamiltonian` object with the potential
object and a :class:`~gala.potential.frame.builtin.Staticframe` instance::

    >>> pot = gp.HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc,
    ...                             units=galactic)
    >>> frame = gp.StaticFrame(units=galactic)
    >>> H = gp.Hamiltonian(potential=pot, frame=frame)
    >>> w0 = gd.PhaseSpacePosition(pos=[5.,0,0]*u.kpc,
    ...                            vel=[0,0,50.]*u.km/u.s)
    >>> orbit = H.integrate_orbit(w0, dt=0.5, n_steps=1000)

In this case, the ``orbit`` object returned from integration knows what
reference frame it is in and we can therefore transform it to other reference
frames. For example, we can change to a constantly rotating frame with a
frequency vector that determines the axis of rotation and angular velocity of
rotation around that axis::

    >>> rotation_axis = np.array([8.2, -1.44, 3.25])
    >>> rotation_axis /= np.linalg.norm(rotation_axis) # make a unit vector
    >>> frame_freq = 42. * u.km/u.s/u.kpc
    >>> rot_frame = gp.ConstantRotatingFrame(Omega=frame_freq * rotation_axis,
    ...                                      units=galactic)
    >>> orbit_to_rot = orbit.to_frame(rot_frame)
    >>> fig1 = orbit.plot(marker='') # doctest: +SKIP
    >>> fig1.suptitle("Static frame") # doctest: +SKIP
    >>> fig2 = rot_orbit.plot(marker='') # doctest: +SKIP
    >>> fig2.suptitle("Rotating frame") # doctest: +SKIP

.. plot::
    :align: center

    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    pot = gp.HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc,
                                units=galactic)
    frame = gp.StaticFrame(units=galactic)
    H = gp.Hamiltonian(potential=pot, frame=frame)
    w0 = gd.PhaseSpacePosition(pos=[5.,0,0]*u.kpc,
                               vel=[0,0,50.]*u.km/u.s)
    orbit = H.integrate_orbit(w0, dt=0.5, n_steps=1000)

    rotation_axis = np.array([8.2, -1.44, 3.25])
    rotation_axis /= np.linalg.norm(rotation_axis) # make a unit vector
    frame_freq = 42. * u.km/u.s/u.kpc
    rot_frame = gp.ConstantRotatingFrame(Omega=frame_freq * rotation_axis,
                                         units=galactic)
    orbit_to_rot = orbit.to_frame(rot_frame)

    fig1 = orbit.plot(marker='')
    fig1.suptitle("Static frame", fontsize=20, y=0.96)
    fig1.subplots_adjust(top=0.92)
    fig1.tight_layout()

    fig2 = orbit_to_rot.plot(marker='')
    fig2.suptitle("Rotating frame", fontsize=20, y=0.96)
    fig2.subplots_adjust(top=0.92)
    fig2.tight_layout()


We can also integrate the orbit in the rotating frame directly by creating a
:class:`~gala.potential.hamiltonian.Hamiltonian` object with the rotating
frame::

    >>> H_rot = gp.Hamiltonian(potential=pot, frame=rot_frame)
    >>> rot_orbit = H_rot.integrate_orbit(w0, dt=0.5, n_steps=1000)
    >>> _ = rot_orbit.plot(marker='') # doctest: +SKIP

.. plot::
    :align: center

    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    pot = gp.HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc,
                                units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[5.,0,0]*u.kpc,
                               vel=[0,0,50.]*u.km/u.s)

    rotation_axis = np.array([8.2, -1.44, 3.25])
    rotation_axis /= np.linalg.norm(rotation_axis) # make a unit vector
    frame_freq = 42. * u.km/u.s/u.kpc
    rot_frame = gp.ConstantRotatingFrame(Omega=frame_freq * rotation_axis,
                                         units=galactic)

    H_rot = gp.Hamiltonian(potential=pot, frame=rot_frame)
    rot_orbit = H_rot.integrate_orbit(w0, dt=0.5, n_steps=1000)
    _ = rot_orbit.plot(marker='') # doctest: +SKIP

In this case, because the potential is spherical, the orbit should look the same
whether we integrate it in the rotating frame or in a static frame and then
transform to a rotating frame. In the example below, we consider the case of
integrating orbits in an asymmetric, time-dependent bar potential.

See the :ref:`integrate_rotating_frame` example for more information.
</file>

<file path="docs/potential/index.rst">
.. include:: ../references.txt

.. module:: gala.potential

*************************************************
Gravitational potentials (`gala.potential`)
*************************************************

Introduction
============

This subpackage provides a number of classes for working with parametric models
of gravitational potentials. There are a number of built-in potentials
implemented in C and Cython (for speed), and there are base classes that allow
for easy creation of `new custom potential classes <define-new-potential.html>`_
in pure Python or by writing custom C/Cython extensions. The ``Potential``
objects have convenience methods for computing common dynamical quantities, for
example: potential energy, spatial gradient, density, or mass profiles. These
are particularly useful in combination with the `~gala.integrate` and
`~gala.dynamics` subpackages.

Also defined in this subpackage are a set of reference frames which can be used
for numerical integration of orbits in non-static reference frames. See the page
on :ref:`hamiltonian-reference-frames` for more information. ``Potential``
objects can be combined with a reference frame and stored in a
`~gala.potential.hamiltonian.Hamiltonian` object that provides an easy interface
to numerical orbit integration.

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import matplotlib.pyplot as plt
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> from gala.units import galactic, solarsystem, dimensionless

Getting Started: Built-in Methods of Potential Classes
======================================================

Any of the built-in ``Potential`` classes are initialized by passing in keyword
argument parameter values as :class:`~astropy.units.Quantity` objects or as
numeric values in a specified unit system. To see what parameters are available
for a given potential, check the documentation for the individual classes below.
You must also specify a `~gala.units.UnitSystem` when initializing a potential.
A unit system is a set of non-reducible units that define (at minimum) the
length, mass, time, and angle units. A few common unit systems are built in to
the package (e.g., ``galactic``, ``solarsystem``, ``dimensionless``). For
example, to create an object to represent a Kepler potential (point mass) at the
origin with mass = 1 solar mass, we would instantiate a
:class:`~gala.potential.potential.KeplerPotential` object:

    >>> ptmass = gp.KeplerPotential(m=1.*u.Msun, units=solarsystem)
    >>> ptmass
    <KeplerPotential: m=1.00 (AU,yr,solMass,rad)>

If you pass in parameters with different units, they will be converted to the
specified unit system::

    >>> gp.KeplerPotential(m=1047.6115*u.Mjup, units=solarsystem)
    <KeplerPotential: m=1.00 (AU,yr,solMass,rad)>

If no units are specified for a parameter (i.e. a parameter value is passed in
as a Python numeric value or array), it is assumed to be in the specified
`~gala.units.UnitSystem`::

    >>> gp.KeplerPotential(m=1., units=solarsystem)
    <KeplerPotential: m=1.00 (AU,yr,solMass,rad)>

The potential classes work well with the :mod:`astropy.units` framework, but to
ignore units you can use the `~gala.units.DimensionlessUnitSystem` or pass
`None` as the unit system::

    >>> gp.KeplerPotential(m=1., units=None)
    <KeplerPotential: m=1.00 (dimensionless)>

All of the built-in potential objects have defined methods to evaluate the
potential energy and the gradient/acceleration at a given position or array of
positions. For example, to evaluate the potential energy at the 3D position
``(x, y, z) = (1, -1, 0) AU``::

    >>> ptmass.energy([1., -1., 0.] * u.au)
    <Quantity [-27.91440236] AU2 / yr2>

These functions also accept both :class:`~astropy.units.Quantity` objects or
plain :class:`~numpy.ndarray`-like objects (in which case the position is
assumed to be in the unit system of the potential)::

    >>> ptmass.energy([1., -1., 0.])
    <Quantity [-27.91440236] AU2 / yr2>

This also works for multiple positions by passing in a 2D position (but see
:ref:`conventions` for a description of the interpretation of different axes)::

    >>> pos = np.array([[1., -1. ,0],
    ...                 [2., 3., 0]]).T
    >>> ptmass.energy(pos * u.au)
    <Quantity [-27.91440236, -10.94892941] AU2 / yr2>

We can also compute the gradient or acceleration::

    >>> ptmass.gradient([1., -1., 0] * u.au) # doctest: +FLOAT_CMP
    <Quantity [[ 13.95720118],
               [-13.95720118],
               [  0.        ]] AU / yr2>
    >>> ptmass.acceleration([1., -1., 0] * u.au) # doctest: +FLOAT_CMP
    <Quantity [[-13.95720118],
               [ 13.95720118],
               [ -0.        ]] AU / yr2>

Most of the potential objects also have methods implemented for computing the
corresponding mass density and the Hessian of the potential (the matrix of 2nd
derivatives) at given locations. For example, with the
:class:`~gala.potential.potential.HernquistPotential`, we can evaluate both the
mass density and Hessian at the position ``(x, y, z) = (1, -1, 0) kpc``::

    >>> pot = gp.HernquistPotential(m=1E9*u.Msun, c=1.*u.kpc, units=galactic)
    >>> pot.density([1., -1., 0] * u.kpc) # doctest: +FLOAT_CMP
    <Quantity [7997938.82200887] solMass / kpc3>
    >>> pot.hessian([1., -1., 0] * u.kpc) # doctest: +SKIP
    <Quantity [[[ -4.68318131e-05],
                [  5.92743432e-04],
                [  0.00000000e+00]],

               [[  5.92743432e-04],
                [ -4.68318131e-05],
                [  0.00000000e+00]],

               [[  0.00000000e+00],
                [  0.00000000e+00],
                [  5.45911619e-04]]] 1 / Myr2>

Another useful method is
:meth:`~gala.potential.potential.PotentialBase.mass_enclosed`, which numerically
estimates the mass enclosed within a spherical shell defined by the specified
position. This numerically estimates :math:`\frac{d \Phi}{d r}` along the vector
pointing at the specified position and estimates the enclosed mass simply as
:math:`M(<r)\approx\frac{r^2}{G} \frac{d \Phi}{d r}`. This function can be used
to compute, for example, a mass profile::

    >>> pot = gp.NFWPotential(m=1E11*u.Msun, r_s=20.*u.kpc, units=galactic)
    >>> pos = np.zeros((3,100)) * u.kpc
    >>> pos[0] = np.logspace(np.log10(20./100.), np.log10(20*100.), pos.shape[1]) * u.kpc
    >>> m_profile = pot.mass_enclosed(pos)
    >>> plt.loglog(pos[0], m_profile, marker='') # doctest: +SKIP
    >>> plt.xlabel("$r$ [{}]".format(pos.unit.to_string(format='latex'))) # doctest: +SKIP
    >>> plt.ylabel("$M(<r)$ [{}]".format(m_profile.unit.to_string(format='latex'))) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.units as u
    import numpy as np
    import gala.potential as gp
    from gala.units import galactic, solarsystem
    import matplotlib.pyplot as plt

    pot = gp.NFWPotential(m=1E11*u.Msun, r_s=20.*u.kpc, units=galactic)
    pos = np.zeros((3,100)) * u.kpc
    pos[0] = np.logspace(np.log10(20./100.), np.log10(20*100.), pos.shape[1]) * u.kpc
    m_profile = pot.mass_enclosed(pos)

    plt.figure()
    plt.loglog(pos[0], m_profile, marker='') # doctest: +SKIP
    plt.xlabel("$r$ [{}]".format(pos.unit.to_string(format='latex')))
    plt.ylabel("$M(<r)$ [{}]".format(m_profile.unit.to_string(format='latex')))
    plt.tight_layout()

Plotting Equipotential and Isodensity contours
==============================================

Potential objects provide specialized methods for visualizing the isopotential
(:meth:`~gala.potential.potential.PotentialBase.plot_contours`) or isodensity
(:meth:`~gala.potential.potential.PotentialBase.plot_density_contours`) contours
of a given potential object. These methods plot either 1D slices or 2D contour
plots of isopotentials and isodensities. To plot a 1D slice over the dimension
of interest, pass in a grid of values for that dimension and numerical values
for the others. For example, to make a 1D plot of the potential value as a
function of :math:`x` position at :math:`y=0, z=1`::

    >>> p = gp.MiyamotoNagaiPotential(m=1E11, a=6.5, b=0.27, units=galactic)
    >>> fig, ax = plt.subplots() # doctest: +SKIP
    >>> p.plot_contours(grid=(np.linspace(-15,15,100), 0., 1.), marker='', ax=ax) # doctest: +SKIP
    >>> E_unit = p.units['energy'] / p.units['mass']
    >>> ax.set_xlabel("$x$ [{}]".format(p.units['length'].to_string(format='latex'))) # doctest: +SKIP
    >>> ax.set_ylabel("$\Phi(x,0,1)$ [{}]".format(E_unit.to_string(format='latex'))) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 90%

    pot = gp.MiyamotoNagaiPotential(m=1E11, a=6.5, b=0.27, units=galactic)

    fig, ax = plt.subplots(1,1) # doctest: +SKIP
    pot.plot_contours(grid=(np.linspace(-15,15,100), 0., 1.), marker='', ax=ax) # doctest: +SKIP
    E_unit = pot.units['energy'] / pot.units['mass']
    ax.set_xlabel("$x$ [{}]".format(pot.units['length'].to_string(format='latex'))) # doctest: +SKIP
    ax.set_ylabel("$\Phi(x,0,1)$ [{}]".format(E_unit.to_string(format='latex'))) # doctest: +SKIP
    fig.tight_layout()

To instead make a 2D contour plot over :math:`x` and :math:`z` along with
:math:`y=0`, pass in a 1D grid of values for :math:`x` and a 1D grid of values
for :math:`z` (the meshgridding is taken care of internally). Here, we choose
to draw on a pre-defined `matplotlib` axes object so we can set the labels and
aspect ratio of the plot::

    >>> fig,ax = plt.subplots(1, 1, figsize=(12, 4))
    >>> x = np.linspace(-15, 15, 100)
    >>> z = np.linspace(-5, 5, 100)
    >>> p.plot_contours(grid=(x, 1., z), ax=ax) # doctest: +SKIP
    >>> ax.set_xlabel("$x$ [kpc]") # doctest: +SKIP
    >>> ax.set_ylabel("$z$ [kpc]") # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    x = np.linspace(-15,15,100)
    z = np.linspace(-5,5,100)

    fig,ax = plt.subplots(1, 1, figsize=(12,4))
    pot.plot_contours(grid=(x, 1., z), ax=ax)
    ax.set_xlabel("$x$ [{}]".format(pot.units['length'].to_string(format='latex')))
    ax.set_ylabel("$z$ [{}]".format(pot.units['length'].to_string(format='latex')))
    fig.tight_layout()

Saving / loading potential objects
==================================

Potential objects can be `pickled <https://docs.python.org/3/library/pickle.html>`_
and can therefore be stored for later use. However, pickles are saved as binary
files. It may be useful to save to or load from text-based specifications of
Potential objects. This can be done with the
:meth:`~gala.potential.potential.PotentialBase.save` method and the
:func:`~gala.potential.potential.load` function, which serialize and
de-serialize (respectively) a ``Potential`` object to a `YAML
<https://yaml.org/>`_ file::

    >>> from gala.potential import load
    >>> pot = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
    ...                       units=galactic)
    >>> pot.save("potential.yml")
    >>> load("potential.yml")
    <NFWPotential: m=6.00e+11, r_s=20.00, a=1.00, b=1.00, c=1.00 (kpc,Myr,solMass,rad)>

Exporting potentials as ``sympy`` expressions
=============================================

Most of the potential classes can be exported to a `sympy` expression that can
be used to manipulate or evaluate the form of the potential. To access this
functionality, the potential classes have a
`~gala.potential.potential.PotentialBase.to_sympy` classmethod (note: this
requires `sympy` to be installed):

.. doctest-requires:: sympy

    >>> expr, vars_, pars = gp.LogarithmicPotential.to_sympy()
    >>> str(expr)
    '0.5*v_c**2*log(r_h**2 + z**2/q3**2 + y**2/q2**2 + x**2/q1**2)'

This method also returns a dictionary containing the coordinate variables used
in the expression as ``sympy`` symbols, here defined as ``vars_``:

.. doctest-requires:: sympy

    >>> vars_
    {'x': x, 'y': y, 'z': z}

A second dictionary containing the potential parameters as `sympy` symbols is
also returned, here defined as ``pars``:

.. doctest-requires:: sympy

    >>> pars
    {'v_c': v_c, 'r_h': r_h, 'q1': q1, 'q2': q2, 'q3': q3, 'phi': phi, 'G': G}

The expressions and variables returned can be used to perform operations on the
potential expression. For example, to create a `sympy` expression for the
gradient of the potential:

.. doctest-requires:: sympy

    >>> import sympy as sy
    >>> grad = sy.derive_by_array(expr, list(vars_.values()))
    >>> grad[0]  # dPhi/dx
    1.0*v_c**2*x/(q1**2*(r_h**2 + z**2/q3**2 + y**2/q2**2 + x**2/q1**2))


Using gala.potential
====================
More details are provided in the linked pages below:

.. toctree::
   :maxdepth: 1

   define-new-potential
   compositepotential
   origin-rotation
   hamiltonian-reference-frames
   scf

API
===

.. automodapi:: gala.potential.potential

.. automodapi:: gala.potential.frame.builtin

.. automodapi:: gala.potential.hamiltonian
</file>

<file path="docs/potential/origin-rotation.rst">
.. _rotate-origin-potential:

**************************************************************
Specifying rotations or origin shifts in ``Potential`` classes
**************************************************************

Most of the gravitational potential classes implemented in `gala` support
shifting the origin of the potential relative to the coordinate system, and
specifying a rotation of the potential relative to the coordinate system.
By default, the origin is assumed to be at (0,0,0) or (0,0), and there is no
rotation assumed.

For the examples below the following imports have already been executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.potential as gp
    >>> from gala.units import galactic, solarsystem

Origin shifts
=============

For potential classes that support these options, origin shifts are specified by
passing in a `~astropy.units.Quantity` to set the origin of the potential in the
given coordinate system. For example, if we are working with two
`~gala.potential.KeplerPotential` objects, and we want them to be offset from
one another such that one potential is at ``(1, 0, 0)`` AU and the other is at
``(-2, 0, 0)`` AU, we would define the two objects as::

    >>> p1 = gp.KeplerPotential(m=1*u.Msun, origin=[1, 0, 0]*u.au,
    ...                         units=solarsystem)
    >>> p2 = gp.KeplerPotential(m=0.5*u.Msun, origin=[-2, 0, 0]*u.au,
    ...                         units=solarsystem)

To see that these are shifted from the coordinate system origin, let's combine
these two objects into a `~gala.potential.potential.CCompositePotential` and
visualize the potential::

    >>> pot = gp.CCompositePotential(p1=p1, p2=p2)
    >>> fig, ax = plt.subplots(1, 1, figsize=(5, 5)) # doctest: +SKIP
    >>> grid = np.linspace(-5, 5, 100)
    >>> p.plot_contours(grid=(grid, grid, 0.), ax=ax) # doctest: +SKIP
    >>> ax.set_xlabel("$x$ [kpc]") # doctest: +SKIP
    >>> ax.set_ylabel("$y$ [kpc]") # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.units as u
    import matplotlib.pyplot as plt
    import numpy as np
    import gala.potential as gp
    from gala.units import galactic, solarsystem

    p1 = gp.KeplerPotential(m=1*u.Msun, origin=[1, 0, 0]*u.au,
                            units=solarsystem)
    p2 = gp.KeplerPotential(m=0.5*u.Msun, origin=[-2, 0, 0]*u.au,
                            units=solarsystem)

    pot = gp.CCompositePotential(p1=p1, p2=p2)
    fig, ax = plt.subplots(1, 1, figsize=(5, 5))
    grid = np.linspace(-5, 5, 100)
    pot.plot_contours(grid=(grid, grid, 0.), ax=ax) # doctest: +SKIP
    ax.set_xlabel("$x$ [kpc]") # doctest: +SKIP
    ax.set_ylabel("$y$ [kpc]") # doctest: +SKIP
    fig.tight_layout()


Rotations
=========

Rotations can be specified either by passing in a
`scipy.spatial.transform.Rotation` instance, or by passing in a 2D `numpy` array
specifying a rotation matrix. For example, let's see what happens if we rotate a
bar potential using these two possible inputs. First, we'll define a rotation
matrix specifying a 30 degree rotation around the z axis (i.e.
counter-clockwise) using `astropy.coordinates.matrix_utilities.rotation_matrix`.
Next, we'll define a rotation using a `scipy`
`~scipy.spatial.transform.Rotation` object::

    >>> from astropy.coordinates.matrix_utilities import rotation_matrix
    >>> from scipy.spatial.transform import Rotation
    >>> R_arr = rotation_matrix(30*u.deg, 'z')
    >>> R_scipy = Rotation.from_euler('z', 30, degrees=True)

.. warning::

    Note that astropy and scipy have different rotation conventions, so even
    though both of the above look like identical 30 degree rotations around the
    z axis, they result in different (i.e. transposed or inverse) rotation
    matrices::

        >>> R_arr # doctest: +FLOAT_CMP
        array([[ 0.8660254,  0.5      ,  0.       ],
               [-0.5      ,  0.8660254,  0.       ],
               [ 0.       ,  0.       ,  1.       ]])
        >>> R_scipy.as_matrix()
        array([[ 0.8660254, -0.5      ,  0.       ],
               [ 0.5      ,  0.8660254,  0.       ],
               [ 0.       ,  0.       ,  1.       ]])

Let's see what happens to the bar potential when we specify these rotations::

    >>> bar1 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
    ...                                  units=galactic)
    >>> bar2 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
    ...                                  units=galactic, R=R_arr)
    >>> bar3 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
    ...                                  units=galactic, R=R_scipy)

.. plot::
    :align: center
    :context: close-figs

    from astropy.coordinates.matrix_utilities import rotation_matrix
    from scipy.spatial.transform import Rotation
    R_arr = rotation_matrix(30*u.deg, 'z')
    R_scipy = Rotation.from_euler('z', 30, degrees=True)

    fig, axes = plt.subplots(1, 3, figsize=(15, 5), sharex=True, sharey=True)

    grid = np.linspace(-5, 5, 100)

    bar1 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
                                     units=galactic)
    bar2 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
                                     units=galactic, R=R_arr)
    bar3 = gp.LongMuraliBarPotential(m=1e10, a=3.5, b=0.5, c=0.5,
                                     units=galactic, R=R_scipy)

    bar1.plot_contours(grid=(grid, grid, 0.), ax=axes[0])
    bar2.plot_contours(grid=(grid, grid, 0.), ax=axes[1])
    bar3.plot_contours(grid=(grid, grid, 0.), ax=axes[2])

    axes[0].set_xlabel("$x$ [kpc]") # doctest: +SKIP
    axes[0].set_ylabel("$y$ [kpc]") # doctest: +SKIP
    axes[1].set_xlabel("$x$ [kpc]") # doctest: +SKIP
    axes[2].set_xlabel("$x$ [kpc]") # doctest: +SKIP

    fig.tight_layout()
</file>

<file path="docs/potential/scf-examples.rst">
********
Examples
********

For the examples below the following imports have already been executed::

    import astropy.units as u
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import numpy as np
    from gala.potential import scf

.. _coeff-particle:

Computing expansion coefficients from particle positions
--------------------------------------------------------

To compute expansion coefficients for a distribution of particles or discrete
samples from a density distribution, use
`~gala.potential.scf.compute_coeffs_discrete`. In this example, we will generate
particle positions from a Plummer density profile, compute the expansion
coefficients assuming spherical symmetry, then re-compute the expansion
coefficients and variances (Weinberg 1996; [W96]_) allowing for non-spherical
terms (e.g., :math:`l,m>0`).

We'll start by generating samples from a Plummer sphere (see Section 3 of
[HMV11]_ for more details). To do this, we will use inverse transform sampling
by inverting the cumulative mass function (in this case, the mass enclosed):

.. math::

    \rho(r) &= \frac{M}{\frac{4}{3}\pi a^3} \, \left(1 + \frac{r^2}{a^2}\right)^{-5/2}

    m(<r) &= \frac{M \, r^3}{(r^2 + a^2)^{3/2}}

    r(\mu) &= a \, (\mu^{-2/3} - 1)^{-1/2}

    \mu &= m(<r) / M

For simplicity, we will work with units in which :math:`a=1` and :math:`M=1`. To
generate radii, we first randomly generate values of :math:`\mu` uniformly
distributed between 0 and 1, then compute the value of :math:`r` for each
sample; the radii will then be distributed following a Plummer profile. For this
example, we'll use 16384 samples::

    def sample_r(size=1):
        mu = np.random.random(size=size)
        return 1 / np.sqrt(mu**(-2/3) - 1)

    n_samples = 16384
    r = sample_r(size=n_samples)

Let's plot the density profile derived from these samples vs. the true profile:

.. plot::
    :align: center
    :context:

    import astropy.units as u
    import numpy as np
    import matplotlib.pyplot as plt
    import gala.potential as gp
    from gala.units import dimensionless

    pot = gp.PlummerPotential(m=1., b=1., units=dimensionless)

    def sample_r(size=1):
        mu = np.random.random(size=size)
        return 1 / np.sqrt(mu**(-2/3) - 1)

    n_samples = 16384
    r = sample_r(size=n_samples)

    bins = np.logspace(-2, 3, 128)
    bin_cen = (bins[1:] + bins[:-1]) / 2.
    H,edges = np.histogram(r, bins=bins, weights=np.zeros_like(r) + pot.parameters['m']/r.size)

    V = 4/3.*np.pi*(bins[1:]**3 - bins[:-1]**3)

    _r = np.logspace(-2, 2, 1024)
    q = np.zeros((3,_r.size))
    q[0] = _r

    fig = plt.figure(figsize=(6,4))
    plt.loglog(_r, pot.density(q), marker=None, label='True profile', color='#cccccc', lw=3)
    plt.loglog(bin_cen, H / V, marker=None, label='Particles', color='k')
    plt.legend(loc='lower left')
    plt.xlim(1E-2, 1E2)
    plt.xlabel('$r$')
    plt.ylabel(r'$\rho(r)$')
    fig.tight_layout()

With the above, we now have sampled spherical radii that follow the desired
density profile. To compute the expansion coefficients needed to represent this
density using SCF with Hernquist radial functions, we first need to convert to
3D cartesian positions. We will distribute these particles uniformly in angles::

    phi = np.random.uniform(0, 2*np.pi, size=n_samples)
    theta = np.arccos(2*np.random.random(size=n_samples) - 1)

    xyz = np.zeros((n_samples, 3))
    xyz[:,0] = r * np.cos(phi) * np.sin(theta)
    xyz[:,1] = r * np.sin(phi) * np.sin(theta)
    xyz[:,2] = r * np.cos(theta)

    plt.figure(figsize=(5,5))
    plt.plot(xyz[:,0], xyz[:,1], linestyle='none',
             marker=',', alpha=0.25, color='k')
    plt.xlim(-5, 5)
    plt.ylim(-5, 5)
    plt.xlabel('$x$')
    plt.ylabel('$y$')

.. plot::
    :align: center
    :context: close-figs

    phi = np.random.uniform(0, 2*np.pi, size=n_samples)
    theta = np.arccos(2*np.random.random(size=n_samples) - 1)

    xyz = np.zeros((n_samples, 3))
    xyz[:,0] = r * np.cos(phi) * np.sin(theta)
    xyz[:,1] = r * np.sin(phi) * np.sin(theta)
    xyz[:,2] = r * np.cos(theta)

    plt.figure(figsize=(5,5))
    plt.plot(xyz[:,0], xyz[:,1], linestyle='none',
             marker=',', alpha=0.25, color='k')
    plt.xlim(-5, 5)
    plt.ylim(-5, 5)
    plt.xlabel('$x$')
    plt.ylabel('$y$')

To compute the expansion coefficients, we then pass the positions ``xyz`` and
masses of each "particle" to `~gala.potential.scf.compute_coeffs_discrete`. We
will generate an array of masses that sum to 1, per our choice of units above.
To start, we'll assume that the particle distribution has spherical symmetry and
ignore terms with :math:`l>0`. We'll then plot the magnitude of the coefficients
as a function of :math:`n` (but we'll ignore the sine terms, :math:`T_{nlm}` for
this example)::

    mass = np.ones(n_samples) / n_samples
    S,T = scf.compute_coeffs_discrete(xyz, mass=mass, nmax=16, lmax=0, r_s=1.)

    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel("$n$")
    plt.ylabel("$S_{n00}$")
    plt.tight_layout()

.. plot::
    :align: center
    :context: close-figs

    from gala.potential import scf

    mass = np.ones(n_samples) / n_samples
    S,T = scf.compute_coeffs_discrete(xyz, mass=mass, nmax=20, lmax=0, r_s=1.)

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel("$n$")
    plt.ylabel("$S_{n00}$")
    plt.tight_layout()

In addition to computing the coefficient values, we can also compute the
variances of the coefficients. Here we will relax the assumption about spherical
symmetry by setting :math:`l_{\rm max}=4`. By computing the variance of each
coefficient, we can estimate the signal-to-noise ratio of each expansion term
and use this to help decide when to truncate the expansion (see [W96]_ for the
methodology and reasoning behind this)::

    S, T, Cov = scf.compute_coeffs_discrete(
        xyz, mass=mass, r_s=1.,
        nmax=10, lmax=4, skip_m=True,
        compute_var=True
    )

    signal_to_noise = np.sqrt(S**2 / Cov[0, 0])

    for l in range(S.shape[1]):
        plt.semilogy(signal_to_noise[:,l,0], marker=None, lw=2,
                     alpha=0.5, label='l={}'.format(l))

    plt.axhline(1., linestyle='dashed')
    plt.xlabel("$n$")
    plt.ylabel("$S/N$")
    plt.legend()

.. plot::
    :align: center
    :context: close-figs

    S, T, Cov = scf.compute_coeffs_discrete(
        xyz, mass=mass, r_s=1.,
        nmax=10, lmax=4, skip_m=True,
        compute_var=True
    )

    signal_to_noise = np.sqrt(S**2 / Cov[0, 0])

    plt.figure(figsize=(6,4))
    for l in range(S.shape[1]):
        plt.semilogy(signal_to_noise[:,l,0], marker=None, lw=2,
                     alpha=0.5, label='l={}'.format(l))
    plt.axhline(1., linestyle='dashed')
    plt.xlabel("$n$")
    plt.ylabel("$S/N$")
    plt.legend()
    plt.tight_layout()

The horizontal line in the plot above is for a signal-to-noise ratio of 1 -- any
coefficients with a SNR near or below this line are suspect and likely just
adding noise to the expansion. Note that all of the SNR values for :math:`l > 0`
hover around 1 -- this is a good indication that we only need the :math:`l=0`
terms to accurately represent the density distribution of the particles.

.. _coeff-analytic:

Computing expansion coefficients for an analytic density
--------------------------------------------------------

To compute expansion coefficients for an analytic density profile, use
`~gala.potential.scf.compute_coeffs`. In this example, we will write a function
to evaluate an oblate density distribution and compute the expansion
coefficients.

We'll use a flattened Hernquist profile as our density profile:

.. math::

    \rho(s) &= \frac{M \, a}{2\pi} \, \frac{1}{s (s+a)^3}

    s^2 &= x^2 + y^2 + \frac{z^2}{q^2}

In code::

    def hernquist_density(r, M, a):
        return M*a / (2*np.pi) / (r*(r+a)**3)

    def flattened_hernquist_density(x, y, z, M, a, q):
        s = np.sqrt(x**2 + y**2 + (z/q)**2)
        return hernquist_density(s, M, a)

The function to evaluate the density must take at least 3 arguments: the
cartesian coordinates ``x``, ``y``, ``z``.

We'll again set :math:`M=a=1` and we'll use a flattening :math:`q=0.8`. Let's
visualize this by plotting isodensity contours in the :math:`x`-:math:`z` plane:

.. plot::
    :align: center
    :context: reset

    import astropy.units as u
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    from matplotlib import ticker
    import numpy as np
    from gala.potential import scf

    def hernquist_density(r, M, a):
        return M*a / (2*np.pi) / (r*(r+a)**3)

    def flattened_hernquist_density(x, y, z, M, a, q):
        s = np.sqrt(x**2 + y**2 + (z/q)**2)
        return hernquist_density(s, M, a)

    M = 1.
    a = 1.
    q = 0.8

    x,z = np.meshgrid(np.linspace(-10., 10., 128),
                      np.linspace(-10., 10., 128))
    y = np.zeros_like(x)

    dens = flattened_hernquist_density(x, y, z, M, a, q)

    plt.figure(figsize=(6,6))
    plt.contourf(x, z, dens, cmap='magma',
                 levels=np.logspace(np.log10(dens.min()), np.log10(dens.max()), 32),
                 locator=ticker.LogLocator())
    plt.title("Isodensity")
    plt.xlabel("$x$", fontsize=22)
    plt.ylabel("$z$", fontsize=22)
    plt.tight_layout()

To compute the expansion coefficients, we pass the
``flattened_hernquist_density()`` function in to
`~gala.potential.scf.compute_coeffs`.  Because this is an axisymmetric density,
we will ignore terms with :math:`m>0` by setting ``skip_m=True``::

    M = 1.
    a = 1.
    q = 0.8
    coeff = scf.compute_coeffs(flattened_hernquist_density, nmax=8, lmax=8,
                                M=M, r_s=a, args=(M,a,q), skip_m=True)
    (S,Serr),(T,Terr) = coeff

Computing the coefficients involves a numerical integration that uses
`scipy.integrate.quad`, which simultaneously estimates the error in the computed
integral. `~gala.potential.scf.compute_coeffs` returns the coefficient arrays
and these error estimates.

Now that we have the coefficients in hand, we can visualize their magnitudes::

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel("$n$")
    plt.ylabel("$S_{n00}$")

.. plot::
    :align: center
    :context: close-figs

    nmax = 8
    lmax = 8
    coeff = scf.compute_coeffs(flattened_hernquist_density, nmax=nmax, lmax=lmax,
                               M=M, r_s=a, args=(M,a,q), skip_m=True)
    (S,Serr),(T,Terr) = coeff

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel("$n$")
    plt.ylabel("$S_{n00}$")
    plt.tight_layout()

Because we ignored any :math:`m` terms, the coefficients are computed in a 2D
grid in :math:`n,l`: we can visualize their magnitude by coloring points on such
a grid::

    nl_grid = np.mgrid[0:lmax+1, 0:nmax+1]

    plt.figure(figsize=(5,4))
    plt.scatter(nl_grid[0].ravel(), nl_grid[1].ravel(),
                c=np.abs(S[:,:,0].ravel()), norm=mpl.colors.LogNorm(),
                cmap='viridis', s=80)
    plt.xlabel('$n$')
    plt.ylabel('$l$')
    plt.colorbar()

.. plot::
    :align: center
    :context: close-figs

    nl_grid = np.mgrid[0:lmax+1, 0:nmax+1]

    plt.figure(figsize=(5,4))
    plt.scatter(nl_grid[0].ravel(), nl_grid[1].ravel(),
                c=np.abs(S[:,:,0].ravel()), norm=mpl.colors.LogNorm(),
                cmap='viridis', s=80)
    plt.xlabel('$n$')
    plt.ylabel('$l$')
    plt.colorbar()
    plt.tight_layout()

.. _potential-class:

Using `~gala.potential.scf.SCFPotential` to evaluate the density, potential, gradient
-------------------------------------------------------------------------------------

In this example we'll continue where the :ref:`previous example
<coeff-analytic>` left off: we now have computed expansion coefficients for a
given density function and we would like to evaluate the gradient of the
gravitational potential at various locations. We will use `gala` to integrate
an orbit in the expansion potential.

From the previous example, we have a set of cosine and sine coefficients (``S``
and ``T``) for an SCF representation of a flattened (oblate) Hernquist density
profile. First, we'll create an `~gala.potential.scf.SCFPotential` object using
these coefficients::

    potential = scf.SCFPotential(Snlm=S, Tnlm=T, m=M, r_s=a) # M=a=1

Let's compare how our expansion density to the true density by
recreating the above isodensity contour figure with SCF density contours
overlaid::

    x,z = np.meshgrid(np.linspace(-10., 10., 128),
                      np.linspace(-10., 10., 128))
    y = np.zeros_like(x)
    true_dens = flattened_hernquist_density(x, y, z, M, a, q)

    # we need an array of positions with shape (3,n_samples) for SCFPotential
    xyz = np.vstack((x.ravel(),y.ravel(),z.ravel()))
    scf_dens = potential.density(xyz).value

    # log-spaced contour levels
    levels = np.logspace(np.log10(true_dens.min()), np.log10(true_dens.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contourf(x, z, true_dens, cmap='magma',
                 levels=levels, locator=ticker.LogLocator())
    plt.contour(x, z, scf_dens.reshape(x.shape), colors='w',
                levels=levels, locator=ticker.LogLocator())

    plt.title("Isodensity")
    plt.xlabel("$x$", fontsize=22)
    plt.ylabel("$z$", fontsize=22)

.. plot::
    :align: center
    :context: close-figs

    potential = scf.SCFPotential(Snlm=S, Tnlm=T, m=M, r_s=a) # M=a=1

    # we need an array of positions with shape (3,n_samples) for SCFPotential
    xyz = np.vstack((x.ravel(),y.ravel(),z.ravel()))
    scf_dens = potential.density(xyz).value

    # log-spaced contour levels
    true_dens = flattened_hernquist_density(x, y, z, M, a, q)
    levels = np.logspace(np.log10(true_dens.min()), np.log10(true_dens.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contourf(x, z, true_dens, cmap='magma',
                 levels=levels, locator=ticker.LogLocator())
    plt.contour(x, z, scf_dens.reshape(x.shape), colors='w',
                levels=levels, locator=ticker.LogLocator())

    plt.title("Isodensity")
    plt.xlabel("$x$", fontsize=22)
    plt.ylabel("$z$", fontsize=22)
    plt.tight_layout()

By eye, the SCF representation looks pretty good. Let's now create a plot of
equipotential contours using the `~gala.potential.scf.SCFPotential` instance::

    scf_pot = np.abs(potential.energy(xyz))
    scf_pot = scf_pot.value # get numerical value from `~astropy.units.Quantity`

    # log-spaced contour levels
    levels = np.logspace(np.log10(scf_pot.min()), np.log10(scf_pot.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contour(x, z, scf_pot.reshape(x.shape), cmap='inferno_r',
                levels=levels, locator=ticker.LogLocator())

    plt.title("Equipotential")
    plt.xlabel("$x$", fontsize=22)
    plt.ylabel("$z$", fontsize=22)

.. plot::
    :align: center
    :context: close-figs

    scf_pot = np.abs(potential.energy(xyz))
    scf_pot = scf_pot.value # get numerical value from Astropy Quantity

    # log-spaced contour levels
    levels = np.logspace(np.log10(scf_pot.min()), np.log10(scf_pot.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contour(x, z, scf_pot.reshape(x.shape), cmap='inferno_r',
                levels=levels, locator=ticker.LogLocator())

    plt.title("Equipotential")
    plt.xlabel("$x$", fontsize=22)
    plt.ylabel("$z$", fontsize=22)
    plt.tight_layout()

(the above is actually provided as a convenience method of any
`~gala.potential.PotentialBase` subclass -- see
`~gala.potential.PotentialBase.plot_contours`).

Now let's integrate an orbit in this potential. We'll use the orbit integration
framework from `gala.integrate` and the convenience method
`~gala.potential.scf.SCFPotential.integrate_orbit` to do this::

    import gala.dynamics as gd

    # when using dimensionless units, we don't need to specify units for the
    # initial conditions
    w0 = gd.PhaseSpacePosition(pos=[1.,0,0.25],
                               vel=[0.,0.3,0.])

    # by default this uses Leapfrog integration
    orbit = potential.integrate_orbit(w0, dt=0.1, n_steps=10000)

    fig = orbit_l.plot(marker=',', linestyle='none', alpha=0.5)

.. plot::
    :align: center
    :context: close-figs

    import gala.dynamics as gd

    # when using dimensionless units, we don't need to specify units for the
    # initial conditions
    w0 = gd.PhaseSpacePosition(pos=[1.,0,0.25],
                               vel=[0.,0.3,0.])

    # by default this uses Leapfrog integration
    orbit = potential.integrate_orbit(w0, dt=0.1, n_steps=10000)

    fig = orbit.plot(marker=',', linestyle='none', alpha=0.5)

References
----------
.. [W96] http://dx.doi.org/10.1086/177902
.. [HMV11] http://www.artcompsci.org/kali/vol/plummer/volume11.pdf
</file>

<file path="docs/potential/scf.rst">
.. _scf:

Self-consistent field (SCF)
===========================

``gala.scf`` contains utilities for evaluating basis function expansions of mass
densities and gravitational potentials with the Self-Consistent Field (SCF)
method of Hernquist & Ostriker (1992; [HO92]_). SCF uses Hernquist radial
functions and spherical harmonics for angular functions. This implementation is
based on the formalism described in the original paper but using the notation of
Lowing et al. (2011; [L11]_).

.. raw:: html

   <video controls src="../_static/anim-prof.mp4" width=450 height=320 autoplay loop></video>


Introduction
------------

The two main ways to use `gala.potential.scf` are:

#. to compute the expansion coefficients given a continuous density distribution
   or discrete samples from a density distribution, then
#. to evaluate the density, potential, and gradients of a basis function
   expansion representation of a density distribution given this set of
   coefficients.


To compute expansion coefficients, the relevant functions are
`~gala.potential.scf.compute_coeffs` and
`~gala.potential.scf.compute_coeffs_discrete`. This implementation uses the
notation from [L11]_: all expansion coefficients are real, :math:`S_{nlm}` are
the cosine coefficients, and :math:`T_{nlm}` are the sine coefficients.

Once you have coefficients, there are two ways to evaluate properties of the
potential or the density of the expansion representation. `gala` provides a
class-based interface :class:`~gala.potential.scf.SCFPotential` that utilizes
the gravitational potential machinery implemented in `gala.potential` (and
supports all of the standard potential functionality, such as orbit integration
and plotting). The examples below use this interface.

Examples
--------
- :ref:`coeff-particle`
- :ref:`coeff-analytic`
- :ref:`potential-class`

.. toctree::
  :hidden:

  scf-examples

API
---

.. automodapi:: gala.potential.scf


----------
References
----------
.. [HO92] http://dx.doi.org/10.1086/171025
.. [L11] http://dx.doi.org/10.1111/j.1365-2966.2011.19222.x
</file>

<file path="docs/tutorials/data/MW_mass_enclosed.csv">
r,Menc,Menc_err_neg,Menc_err_pos,ref
0.01,30000000.0,10000000.0,10000000.0,Feldmeier et al. (2014)
0.12,800000000.0,200000000.0,200000000.0,Launhardt et al. (2002)
8.1,89502860861.52429,4994562473.797714,4858963492.608627,Bovy et al. (2012)
8.3,110417867208.19055,4475949382.696884,4387023236.020782,McMillan (2011)
8.4,102421035406.90356,16733918715.629944,15468328224.531876,Koposov et al. (2010)
19.0,208023299175.30438,44317988008.38101,34833267089.920685,Kuepper et al. (2015)
50.0,539884832748.48975,19995734543.31433,268490735257.4718,Wilkinson & Evans (1999)
50.0,529886965173.18726,9997867269.659302,38536752776.21277,Sakamoto et al. (2003)
50.0,399914690706.92847,109976539940.53711,72696676468.2511,Smith et al. (2007)
50.0,419910425325.7268,39991469076.968506,38172735113.64386,Deason et al. (2012)
60.0,399914690957.5188,69985070910.63354,64344945146.92987,Xue et al. (2008)
80.0,689852841359.0248,299936018002.3314,110361048549.1029,Gnedin et al. (2010)
100.0,1399701417307.7747,899808054059.3811,831336271726.1903,Watkins et al. (2010)
120.0,539884832260.29584,199957345314.72906,123854764645.32489,Battaglia et al. (2005)
150.0,750000000000.0,250000000000.0,250000000000.0,Deason et al. (2012)
200.0,679854974257.2006,409912558030.05396,313652012195.06256,Bhattacherjee et al. (2014)
</file>

<file path="docs/tutorials/.gitignore">
*.ipynb
</file>

<file path="docs/tutorials/Arbitrary-density-SCF.py">
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx="hidden"
# %matplotlib inline

# + nbsphinx="hidden"
# %run nb_setup
# -

# # Compute an SCF representation of an arbitrary density distribution
#
# Basis function expansions are a useful tool for computing gravitational
# potentials and forces from an arbitrary density function that may not have an
# analytic solution to Poisson's equation. They are also useful for generating
# smoothed or compressed representations of gravitational potentials from
# discrete particle distributions. For astronomical density distributions, a
# useful expansion technique is the Self-Consistent Field (SCF) method, as
# initially developed by [Hernquist & Ostriker
# (1992)](http://dx.doi.org/10.1086/171025). In this method, using the notation
# of [Lowing et al. 2011](http://dx.doi.org/10.1111/j.1365-2966.2011.19222.x),
# the density and potential functions are expressed as:
#
# $$
# \rho(r, \phi, \theta) = \sum_{l=0}^{l_{\rm max}} \sum_{m=0}^{l} \sum_{n=0}^{n_{\rm max}}
#     Y_{lm}(\theta) \, \rho_{nl}(r) \, \left[S_{nlm}\,\cos(m\phi) + T_{nlm}\,\sin(m\phi) \right] \\
# \Phi(r, \phi, \theta) = \sum_{l=0}^{l_{\rm max}} \sum_{m=0}^{l} \sum_{n=0}^{n_{\rm max}}
#     Y_{lm}(\theta) \, \Phi_{nl}(r) \, \left[S_{nlm}\,\cos(m\phi) + T_{nlm}\,\sin(m\phi) \right]
# $$
#
# where $Y_{lm}(\theta)$ are the usual spherical harmonics, $\rho_{nlm}(r)$ and
# $\Phi_{nlm}(r)$ are bi-orthogonal radial basis functions, and $S_{nlm}$ and
# $T_{nlm}$ are expansion coefficients, which need to be computed from a given
# density function. In this notebook, we'll estimate low-order expansion
# coefficients for an analytic density distribution (written as a Python
# function).

# +
# Some imports we'll need later:

# Third-party
import matplotlib.pyplot as plt
import numpy as np

# Gala
import gala.dynamics as gd
import gala.potential as gp
from gala.potential.scf import compute_coeffs

# -

# ## SCF representation of an analytic density distribution
#
# ### Custom spherical density function
#
# For this example, we'll assume that we want a potential representation of the
# spherical density function:
# $$
# \rho(r) = \frac{1}{r^{1.8} \, (1 + r)^{2.7}}
# $$
#
# Let's start by writing a density function that takes a single set of Cartesian
# coordinates (x, y, z) and returns the (scalar) value of the density at that
# location:


def density_func(x, y, z):
    r = np.sqrt(x**2 + y**2 + z**2)
    return 1 / (r**1.8 * (1 + r) ** 2.7)


# Let's visualize this density function. For comparison, let's also over-plot
# the Hernquist density distribution. The SCF expansion uses the Hernquist
# density for radial basis functions, so the similarity of the density we want
# to represent and the Hernquist function gives us a sense of how many radial
# terms we will need in the expansion:

hern = gp.HernquistPotential(m=1, c=1)

# +
x = np.logspace(-1, 1, 128)
plt.plot(x, density_func(x, 0, 0), marker="", label="custom density")

# need a 3D grid for the potentials in Gala
xyz = np.zeros((3, len(x)))
xyz[0] = x
plt.plot(x, hern.density(xyz), marker="", label="Hernquist")

plt.xscale("log")
plt.yscale("log")

plt.xlabel("$r$")
plt.ylabel(r"$\rho(r)$")

plt.legend(loc="best")
# -

# These functions are not *too* different, implying that we probably don't need
# too many radial expansion terms in order to well represent the
# density/potential from this custom function. As an arbitrary number, let's
# choose to compute radial terms up to and including $n = 10$. In this case,
# because the density we want to represent is spherical, we don't need any $l,
# m$ terms, so we set `lmax=0`. We can also neglect the sin() terms of the
# expansion ($T_{nlm}$):

(S, Serr), _ = compute_coeffs(
    density_func, nmax=10, lmax=0, M=1.0, r_s=1.0, S_only=True
)

# The above variable `S` will contain the expansion coefficients, and the
# variable `Serr` will contain an estimate of the error in this coefficient
# value. Let's now construct an `SCFPotential` object with the coefficients we
# just computed:

S

pot = gp.SCFPotential(m=1.0, r_s=1, Snlm=S, Tnlm=np.zeros_like(S))

# Now let's visualize the SCF estimated density with the true density:

# +
x = np.logspace(-1, 1, 128)
plt.plot(x, density_func(x, 0, 0), marker="", label="custom density")

# need a 3D grid for the potentials in Gala
xyz = np.zeros((3, len(x)))
xyz[0] = x
plt.plot(x, pot.density(xyz), marker="", label="SCF density")

plt.xscale("log")
plt.yscale("log")

plt.xlabel("$r$")
plt.ylabel(r"$\rho(r)$")

plt.legend(loc="best")


# -

# This does a pretty good job of capturing the radial fall-off of our custom
# density function, but you may want to iterate a bit to satisfy your own
# constraints. For example, you may want the density to be represented with a
# less than 1% deviation over some range of radii, or whatever.
#
# As a second example, let's now try a custom axisymmetric density distribution:

# ### Custom axisymmetric density function
#
# For this example, we'll assume that we want a potential representation of the
# flattened Hernquist density function:
# $$
# \rho(R, z) = \frac{1}{r \, (1 + r)^{3}}\\
# r^2 = R^2 + \frac{z^2}{q^2}
# $$
#
# where $q$ is the flattening, which we'll set to $q=0.6$.
#
# Let's again start by writing a density function that takes a single set of
# Cartesian coordinates (x, y, z) and returns the (scalar) value of the density
# at that location:


def density_func_flat(x, y, z, q):
    r = np.sqrt(x**2 + y**2 + (z / q) ** 2)
    return 1 / (r * (1 + r) ** 3) / (2 * np.pi)


# Let's compute the density along a diagonal line for a few different
# flattenings and again compare to the non-flattened Hernquist profile:

# +
x = np.logspace(-1, 1, 128)
xyz = np.zeros((3, len(x)))
xyz[0] = x
xyz[2] = x

for q in np.arange(0.6, 1 + 1e-3, 0.2):
    plt.plot(
        x,
        density_func_flat(xyz[0], 0.0, xyz[2], q),
        marker="",
        label=f"custom density: q={q}",
    )

plt.plot(x, hern.density(xyz), marker="", ls="--", label="Hernquist")

plt.xscale("log")
plt.yscale("log")

plt.xlabel("$r$")
plt.ylabel(r"$\rho(r)$")

plt.legend(loc="best")
# -

# Because this is an axisymmetric density distribution, we need to also compute
# $l$ terms in the expansion, so we set `lmax=6`, but we can skip the $m$ terms
# using `skip_m=True`. Because this computes more coefficients, we might want to
# see the progress in real time - if you install the Python package `tqdm` and
# pass `progress=True`, it will also display a progress bar:

q = 0.6
(S_flat, Serr_flat), _ = compute_coeffs(
    density_func_flat,
    nmax=4,
    lmax=6,
    args=(q,),
    M=1.0,
    r_s=1.0,
    S_only=True,
    skip_m=True,
    progress=True,
)

pot_flat = gp.SCFPotential(m=1.0, r_s=1, Snlm=S_flat, Tnlm=np.zeros_like(S_flat))

# +
x = np.logspace(-1, 1, 128)
xyz = np.zeros((3, len(x)))
xyz[0] = x
xyz[2] = x

plt.plot(
    x,
    density_func_flat(xyz[0], xyz[1], xyz[2], q),
    marker="",
    label=f"true density q={q}",
)

plt.plot(x, pot_flat.density(xyz), marker="", ls="--", label="SCF density")

plt.xscale("log")
plt.yscale("log")

plt.xlabel("$r$")
plt.ylabel(r"$\rho(r)$")

plt.legend(loc="best")
# -

# The SCF potential object acts like any other `gala.potential` object, meaning
# we can, e.g., plot density or potential contours:

# +
grid = np.linspace(-8, 8, 128)

fig, axes = plt.subplots(1, 2, figsize=(10, 5), sharex=True, sharey=True)
_ = pot_flat.plot_contours((grid, grid, 0), ax=axes[0])
axes[0].set_xlabel("$x$")
axes[0].set_ylabel("$y$")

_ = pot_flat.plot_contours((grid, 0, grid), ax=axes[1])
axes[1].set_xlabel("$x$")
axes[1].set_ylabel("$z$")

for ax in axes:
    ax.set_aspect("equal")
# -

# And numerically integrate orbits by passing in initial conditions and
# integration parameters:

w0 = gd.PhaseSpacePosition(pos=[3.5, 0, 1], vel=[0, 0.4, 0.05])

orbit_flat = pot_flat.integrate_orbit(w0, dt=1.0, n_steps=5000)
_ = orbit_flat.plot()
</file>

<file path="docs/tutorials/circ-restricted-3body.rst">
.. _restricted_three_body:

======================================
Circular restricted three-body problem
======================================

As a demonstration of the flexibility of the potential clases and reference
frame machinery, below we'll demonstrate how to integrate orbits in the
`circular restricted three-body problem <https://en.wikipedia.org/wiki/Three-body_problem#Circular_restricted_three-body_problem>`_.

We first need to import some relevant packages::

   >>> import astropy.units as u
   >>> import matplotlib.pyplot as plt
   >>> import numpy as np
   >>> from scipy.optimize import root
   >>> import gala.integrate as gi
   >>> import gala.dynamics as gd
   >>> import gala.potential as gp

The "restricted three-body problem" is the problem of solving for the orbit of a
test particle interacting with a binary bass system, typically also in the
rotating frame of the binary. We'll assume that the binary consists of a more
massive component :math:`m_1` and a secondary mass :math:`m_2`. If the binary
components are on circular orbits, and we restict to the plane of motion of the
binary, we can change to a rotating reference frame that rotates with the
angular frequency of the binary, and cast the problem in terms of scaled units
that simplify the expressions and math. In detail, we'll work in units such that
the masses of the two components are :math:`1 - \mu` and :math:`\mu`, where
:math:`\mu = \frac{m_2}{m_1+m_2}`. We'll also set :math:`G=1` and the orbital
frequency of the binary to :math:`\Omega=1`. For more information about the
problem setup, see, e.g., `this paper <https://arxiv.org/abs/1511.04881>`_.

For our example, we'll use the value :math:`\mu = 1/11`, corresponding to a 1:10
mass ratio between the two components of the central binary. In the units
defined above, and assuming that the binary components lie on the coordinate
:math:`x`-axis in the rotating frame, the positions and masses of the two binary
components are :math:`x_1 = -\mu`, :math:`m_1 = 1-\mu` and :math:`x_2 = 1-\mu`,
:math:`m_2 = \mu`, respectively. Let's start by defining these quantities::

   >>> mu = 1/11.
   >>> x1 = -mu
   >>> m1 = 1-mu
   >>> x2 = 1-mu
   >>> m2 = mu

Since the potential classes in ``Gala`` work with 3-dimensional quantities,
we'll define the frequency of the binary as a 3D vector::

   >>> Omega = np.array([0, 0, 1.])

We'll now define the gravitational potential of the binary. To do this, we have
to make use of the ``origin`` keyword in the potential class initializer to
shift the positions of the component masses to the values defined above. We'll
store the potentials of the two masses together in a
`~gala.potential.CCompositePotential`::

   >>> pot = gp.CCompositePotential()
   >>> pot['m1'] = gp.KeplerPotential(m=m1, origin=[x1, 0, 0.])
   >>> pot['m2'] = gp.KeplerPotential(m=m2, origin=[x2, 0, 0.])

We now have to define the rotating reference frame::

   >>> frame = gp.ConstantRotatingFrame(Omega=Omega)

And finally, we combine the potential and frame into a
`~gala.potential.Hamiltonian` object::

   >>> H = gp.Hamiltonian(pot, frame)

We're now ready to start integrating orbits! But before we do that, let's look
at the geometry of phase-space to get a sense for what the orbits will look like
with different choices of the Jacobi energy. We'll make a grid of x and y
positions and evalutes the Jacobi energy at each position in the grid assuming
a zero velocity. We'll draw filled contours at each value of 4 chosen Jacobi
energy values, which will visualize "forbidden regions" of the plane at each
value of the Jacobi energy (see Section 3.3.2 in Binney and Tremaine 2008)::

   >>> grid = np.linspace(-1.75, 1.75, 128)
   >>> x_grid, y_grid = np.meshgrid(grid, grid)
   >>> xyz = np.vstack((x_grid.ravel(),
   ...                  y_grid.ravel(),
   ...                  np.zeros_like(x_grid.ravel())))
   >>> Om_cross_x = np.cross(Omega, xyz.T)
   >>> E_J = H.potential.energy(xyz) - 0.5*np.sum(Om_cross_x**2, axis=1)
   >>> E_J_levels = [-1.82, -1.73, -1.7, -1.5]

.. plot::
   :align: center
   :context: close-figs

   import astropy.units as u
   import matplotlib.pyplot as plt
   import numpy as np
   import gala.integrate as gi
   import gala.dynamics as gd
   import gala.potential as gp

   mu = 1/11.
   x1 = -mu
   m1 = 1-mu
   x2 = 1-mu
   m2 = mu

   Omega = np.array([0, 0, 1.])

   pot = (gp.KeplerPotential(m=1-mu, origin=[x1, 0, 0]) +
          gp.KeplerPotential(m=mu, origin=[x2, 0, 0]))

   frame = gp.ConstantRotatingFrame(Omega=Omega)
   static = gp.StaticFrame()
   H = gp.Hamiltonian(pot, frame)

   grid = np.linspace(-1.75, 1.75, 128)
   x_grid, y_grid = np.meshgrid(grid, grid)
   xyz = np.vstack((x_grid.ravel(),
                    y_grid.ravel(),
                    np.zeros_like(x_grid.ravel())))
   Om_cross_x = np.cross(Omega, xyz.T)
   E_J = H.potential.energy(xyz) - 0.5*np.sum(Om_cross_x**2, axis=1)

   fig,axes = plt.subplots(2, 2, figsize=(8,8), sharex=True, sharey=True)

   E_J_levels = [-1.82, -1.73, -1.7, -1.5]

   for ax, level in zip(axes.flat, E_J_levels):
       ax.contourf(x_grid, y_grid, E_J.reshape(128,128).value,
                   levels=[level,0], colors='#aaaaaa')
       ax.scatter(-mu, 0, c='k')
       ax.scatter(1-mu, 0, c='k')
       ax.set_title(r'$E_{{\rm J}} = {:.2f}$'.format(level))

   ax.set_xlim(-1.6, 1.6)
   ax.set_ylim(-1.6, 1.6)

   axes[0,0].set_ylabel('$y$')
   axes[1,0].set_ylabel('$y$')
   axes[1,0].set_xlabel('$x$')
   axes[1,1].set_xlabel('$x$')

   fig.tight_layout()


At each of the values of the Jacobi energy chosen above, we'll now integrate
an orbit. To do this, we have to solve for the initial conditions given the
Jacobi energy, and convert from rotating frame (Lagrangian) coordinates to
canonical coordinates. Let's define some functions to help with this::

   >>> def func_ydot(val, x, H, E_J):
   ...    ydot = val[0]
   ...    Om_cross_x = np.cross(H.frame.parameters['Omega'].value, x)
   ...    eff_pot = H.potential.energy(x).value[0] - 0.5*Om_cross_x.dot(Om_cross_x)
   ...    return E_J - 0.5*ydot**2 - eff_pot
   >>> def xxdot_to_qp(x, xdot, Omega):
   ...     q = x
   ...     p = np.array(xdot) + np.cross(Omega, x)
   ...     return q, p

Now we'll integrate the orbits at each energy level. We'll assert that the orbit
starts from the y axis at :math:`x = 0.5` and solve for the y velocity,
:math:`\dot{y}`, then convert to canonical coordinates::

   >>> x0 = [0.5, 0, 0]
   >>> orbits = []
   >>> for level in E_J_levels:
   ...     res = root(func_ydot, x0=0.3, args=(x0, H, level))
   ...     xdot0 = [0, res.x[0], 0.]
   ...     w0 = np.concatenate(xxdot_to_qp(x0, xdot0, Omega))
   ...     orbit = H.integrate_orbit(w0, dt=1E-2, n_steps=100000,
   ...                               Integrator=gi.DOPRI853Integrator)
   ...     orbits.append(orbit)

.. plot::
   :align: center
   :context: close-figs

   from scipy.optimize import root

   def func_ydot(val, x, H, E_J):
      ydot = val[0]
      Om_cross_x = np.cross(H.frame.parameters['Omega'].value, x)
      eff_pot = H.potential.energy(x).value[0] - 0.5*Om_cross_x.dot(Om_cross_x)
      return E_J - 0.5*ydot**2 - eff_pot

   def xxdot_to_qp(x, xdot, Omega):
       q = x
       p = np.array(xdot) + np.cross(Omega, x)
       return q, p

   x0 = [0.5, 0., 0.]
   orbits = []
   for level in E_J_levels:
       res = root(func_ydot, x0=0.3, args=(x0, H, level))
       xdot0 = [0, res.x[0], 0.]
       w0 = np.concatenate(xxdot_to_qp(x0, xdot0, Omega))
       orbit = H.integrate_orbit(w0, dt=1E-2, n_steps=100000,
                                 Integrator=gi.DOPRI853Integrator)
       orbits.append(orbit)

   fig,axes = plt.subplots(2, 2, figsize=(8,8), sharex=True, sharey=True)

   for ax, level, orbit in zip(axes.flat, E_J_levels, orbits):
       ax.contourf(x_grid, y_grid, E_J.reshape(128,128).value,
                   levels=[level,0], colors='#aaaaaa')
       ax.scatter(-mu, 0, c='r')
       ax.scatter(1-mu, 0, c='r')
       ax.set_title(r'$E_{{\rm J}} = {:.2f}$'.format(level))

       ax.plot(orbit.x, orbit.y, marker='None', linewidth=1.)

   ax.set_xlim(-1.6, 1.6)
   ax.set_ylim(-1.6, 1.6)

   fig.tight_layout()
</file>

<file path="docs/tutorials/define-milky-way-model.py">
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx="hidden"
# %matplotlib inline

# + nbsphinx="hidden"
# %run nb_setup
# -

# # Defining a Milky Way potential model

# +
# Third-party dependencies
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
from astropy.io import ascii
from scipy.optimize import leastsq

# Gala
import gala.potential as gp
from gala.units import galactic

# -

# ## Introduction
#
# `gala` provides a simple and easy way to access and integrate orbits in an
# approximate mass model for the Milky Way. The parameters of the mass model are
# determined by least-squares fitting the enclosed mass profile of a pre-defined
# potential form to recent measurements compiled from the literature. These
# measurements are provided with the documentation of `gala` and are shown
# below. The radius units are kpc, and mass units are solar masses:

tbl = ascii.read("data/MW_mass_enclosed.csv")

tbl

# Let's now plot the above data and uncertainties:

# +
fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl["r"],
    tbl["Menc"],
    yerr=(tbl["Menc_err_neg"], tbl["Menc_err_pos"]),
    marker="o",
    markersize=2,
    color="k",
    alpha=1.0,
    ecolor="#aaaaaa",
    capthick=0,
    linestyle="none",
    elinewidth=1.0,
)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel("$r$ [kpc]")
ax.set_ylabel("$M(<r)$ [M$_\odot$]")

ax.set_xscale("log")
ax.set_yscale("log")

fig.tight_layout()


# -

# We now need to assume some form for the potential. For simplicity and within
# reason, we'll use a four component potential model consisting of a Hernquist
# ([1990](https://ui.adsabs.harvard.edu/#abs/1990ApJ...356..359H/abstract))
# bulge and nucleus, a Miyamoto-Nagai
# ([1975](https://ui.adsabs.harvard.edu/#abs/1975PASJ...27..533M/abstract))
# disk, and an NFW
# ([1997](https://ui.adsabs.harvard.edu/#abs/1997ApJ...490..493N/abstract))
# halo. We'll fix the parameters of the disk and bulge to be consistent with
# previous work ([Bovy
# 2015](https://ui.adsabs.harvard.edu/#abs/2015ApJS..216...29B/abstract) -
# please cite that paper if you use this potential model) and vary the scale
# mass and scale radius of the nucleus and halo, respectively. We'll fit for
# these parameters in log-space, so we'll first define a function that returns a
# `gala.potential.CCompositePotential` object given these four parameters:


def get_potential(log_M_h, log_r_s, log_M_n, log_a):
    mw_potential = gp.CCompositePotential()
    mw_potential["bulge"] = gp.HernquistPotential(m=5e9, c=1.0, units=galactic)
    mw_potential["disk"] = gp.MiyamotoNagaiPotential(
        m=6.8e10 * u.Msun, a=3 * u.kpc, b=280 * u.pc, units=galactic
    )
    mw_potential["nucl"] = gp.HernquistPotential(
        m=np.exp(log_M_n), c=np.exp(log_a) * u.pc, units=galactic
    )
    mw_potential["halo"] = gp.NFWPotential(
        m=np.exp(log_M_h), r_s=np.exp(log_r_s), units=galactic
    )

    return mw_potential


# We now need to specify an initial guess for the parameters - let's do that (by
# making them up), and then plot the initial guess potential over the data:

# Initial guess for the parameters- units are:
#     [Msun, kpc, Msun, pc]
x0 = [np.log(6e11), np.log(20.0), np.log(2e9), np.log(100.0)]
init_potential = get_potential(*x0)

# +
xyz = np.zeros((3, 256))
xyz[0] = np.logspace(-3, 3, 256)

fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl["r"],
    tbl["Menc"],
    yerr=(tbl["Menc_err_neg"], tbl["Menc_err_pos"]),
    marker="o",
    markersize=2,
    color="k",
    alpha=1.0,
    ecolor="#aaaaaa",
    capthick=0,
    linestyle="none",
    elinewidth=1.0,
)

fit_menc = init_potential.mass_enclosed(xyz * u.kpc)
ax.loglog(xyz[0], fit_menc.value, marker="", color="#3182bd", linewidth=2, alpha=0.7)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel("$r$ [kpc]")
ax.set_ylabel("$M(<r)$ [M$_\odot$]")

ax.set_xscale("log")
ax.set_yscale("log")

fig.tight_layout()


# -

# It looks pretty good already! But let's now use least-squares fitting to
# optimize our nucleus and halo parameters. We first need to define an error
# function:


def err_func(p, r, Menc, Menc_err):
    pot = get_potential(*p)
    xyz = np.zeros((3, len(r)))
    xyz[0] = r
    model_menc = pot.mass_enclosed(xyz).to(u.Msun).value
    return (model_menc - Menc) / Menc_err


# Because the uncertainties are all approximately but not exactly symmetric,
# we'll take the maximum of the upper and lower uncertainty values and assume
# that the uncertainties in the mass measurements are Gaussian (a bad but simple
# assumption):

err = np.max([tbl["Menc_err_pos"], tbl["Menc_err_neg"]], axis=0)
p_opt, ier = leastsq(err_func, x0=x0, args=(tbl["r"], tbl["Menc"], err))
assert ier in range(1, 4 + 1), "least-squares fit failed!"
fit_potential = get_potential(*p_opt)

# Now we have a best-fit potential! Let's plot the enclosed mass of the fit potential over the data:

# +
xyz = np.zeros((3, 256))
xyz[0] = np.logspace(-3, 3, 256)

fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl["r"],
    tbl["Menc"],
    yerr=(tbl["Menc_err_neg"], tbl["Menc_err_pos"]),
    marker="o",
    markersize=2,
    color="k",
    alpha=1.0,
    ecolor="#aaaaaa",
    capthick=0,
    linestyle="none",
    elinewidth=1.0,
)

fit_menc = fit_potential.mass_enclosed(xyz * u.kpc)
ax.loglog(xyz[0], fit_menc.value, marker="", color="#3182bd", linewidth=2, alpha=0.7)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel("$r$ [kpc]")
ax.set_ylabel("$M(<r)$ [M$_\odot$]")

ax.set_xscale("log")
ax.set_yscale("log")

fig.tight_layout()
# -

# This potential is already implemented in `gala` in `gala.potential.special`,
# and we can import it with:

from gala.potential import MilkyWayPotential

potential = MilkyWayPotential()
potential
</file>

<file path="docs/tutorials/integrate-potential-example.rst">
.. _integrate_potential_example:

=====================================================
Integrating and plotting an orbit in an NFW potential
=====================================================

We first need to import some relevant packages::

   >>> import astropy.units as u
   >>> import matplotlib.pyplot as plt
   >>> import numpy as np
   >>> import gala.integrate as gi
   >>> import gala.dynamics as gd
   >>> import gala.potential as gp
   >>> from gala.units import galactic

In the examples below, we will work use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

We first create a potential object to work with. For this example, we'll
use a spherical NFW potential, parametrized by a scale radius and the
circular velocity at the scale radius::

   >>> pot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,
   ...                                              r_s=10.*u.kpc,
   ...                                              units=galactic)

As a demonstration, we're going to first integrate a single orbit in this
potential.

The easiest way to do this is to use the
`~gala.potential.PotentialBase.integrate_orbit` method of the potential object,
which accepts a set of initial conditions and a specification for the
time-stepping. We'll define the initial conditions as a
`~gala.dynamics.PhaseSpacePosition` object::

   >>> ics = gd.PhaseSpacePosition(pos=[10,0,0.] * u.kpc,
   ...                             vel=[0,175,0] * u.km/u.s)
   >>> orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000)

This method returns a `~gala.dynamics.Orbit` object that contains an
array of times and the (6D) position at each time-step. By default, this method
uses Leapfrog integration to compute the orbit
(:class:`~gala.integrate.LeapfrogIntegrator`), but you can optionally specify
a different (more precise) integrator class as a keyword argument::

   >>> orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000,
   ...                             Integrator=gi.DOPRI853Integrator)

We can integrate many orbits in parallel by passing in a 2D array of initial
conditions. Here, as an example, we'll generate some random initial
conditions by sampling from a Gaussian around the initial orbit (with a
positional scale of 100 pc, and a velocity scale of 1 km/s)::

   >>> norbits = 128
   >>> new_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,
   ...                            size=(norbits,3)).T * u.pc
   >>> new_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,
   ...                            size=(norbits,3)).T * u.km/u.s
   >>> new_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)
   >>> orbits = gp.Hamiltonian(pot).integrate_orbit(new_ics, dt=2., n_steps=2000)

We'll now plot the final positions of these orbits over isopotential contours.
We use the :meth:`~gala.potential.Potential.plot_contours` method of the potential
object to plot the potential contours. This function returns a
:class:`~matplotlib.figure.Figure` object, which we can then use to over-plot
the orbit points::

   >>> grid = np.linspace(-15,15,64)
   >>> fig,ax = plt.subplots(1, 1, figsize=(5,5))
   >>> fig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)
   >>> fig = orbits[-1].plot(['x', 'y'], color='#9ecae1', s=1., alpha=0.5,
   ...                       axes=[ax], auto_aspect=False) # doctest: +SKIP

.. plot::
   :align: center
   :context: close-figs

   import astropy.units as u
   import numpy as np
   import gala.integrate as gi
   import gala.dynamics as gd
   import gala.potential as gp
   from gala.units import galactic

   np.random.seed(42)

   pot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,
                                                r_s=10.*u.kpc,
                                                units=galactic)

   ics = gd.PhaseSpacePosition(pos=[10,0,0.]*u.kpc,
                               vel=[0,175,0]*u.km/u.s)
   orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000)

   norbits = 1024
   new_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,
                              size=(norbits,3)).T * u.pc
   new_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,
                              size=(norbits,3)).T * u.km/u.s
   new_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)
   orbits = gp.Hamiltonian(pot).integrate_orbit(new_ics, dt=2., n_steps=2000)

   grid = np.linspace(-15,15,64)
   fig,ax = plt.subplots(1, 1, figsize=(5,5))
   fig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)
   orbits[-1].plot(['x', 'y'], color='#9ecae1', s=1., alpha=0.5,
                   axes=[ax], auto_aspect=False)
   fig.tight_layout()
</file>

<file path="docs/tutorials/integrate-rotating-frame.rst">
.. _integrate_rotating_frame:

==================================================
Integrating an orbit in a rotating reference frame
==================================================

We first need to import some relevant packages::

   >>> import astropy.units as u
   >>> import matplotlib.pyplot as plt
   >>> import numpy as np
   >>> import gala.integrate as gi
   >>> import gala.dynamics as gd
   >>> import gala.potential as gp
   >>> from gala.units import galactic
   >>> from scipy.optimize import minimize

-----------------------------------
Orbits in a barred galaxy potential
-----------------------------------

In the example below, we will work use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

For this example, we'll use a simple, analytic representation of the potential
from a Galactic bar and integrate an orbit in the rotating frame of the bar,
which has some pattern speed :math:`\Omega`. We'll use a three-component
potential model consisting of the bar (an implementation of the model used in
`Long & Murali 1992 <http://adsabs.harvard.edu/abs/1992ApJ...397...44L>`_), a
Miyamoto-Nagai potential for the galactic disk, and a spherical NFW potential
for the dark matter distribution. We'll tilt the bar with respect to the x-axis
by 25 degrees (the angle ``alpha`` below). First, we'll define the disk and
halo potential components::

    >>> disk = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
    ...                                  a=3.5*u.kpc, b=280*u.pc,
    ...                                  units=galactic)
    >>> halo = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc, units=galactic)

We'll set the mass of the bar to be 1/6 the mass of the disk component, and
we'll set the long-axis scale length of the bar to :math:`4~{\rm kpc}`. We can
now define the bar component::

    >>> bar = gp.LongMuraliBarPotential(m=1E10*u.Msun, a=4*u.kpc,
    ...                                 b=0.8*u.kpc, c=0.25*u.kpc,
    ...                                 alpha=25*u.degree,
    ...                                 units=galactic)

The full potential is the composition of the three potential objects. We can
combine potential classes by defining a `~gala.potential.CCompositePotential`
class and adding named components::

    >>> pot = gp.CCompositePotential()
    >>> pot['disk'] = disk
    >>> pot['halo'] = halo
    >>> pot['bar'] = bar

Let's visualize the isopotential contours of the potential in the x-y plane to
see the bar perturbation::

    >>> grid = np.linspace(-15,15,128)
    >>> fig, ax = plt.subplots(1, 1, figsize=(5,5)) # doctest: +SKIP
    >>> fig = pot.plot_contours(grid=(grid,grid,0.), ax=ax) # doctest: +SKIP
    >>> ax.set_xlabel("$x$ [kpc]") # doctest: +SKIP
    >>> ax.set_ylabel("$y$ [kpc]") # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import matplotlib.pyplot as plt
    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    grid = np.linspace(-15,15,128)
    fig, ax = plt.subplots(1, 1, figsize=(5,5))
    fig = pot.plot_contours(grid=(grid,grid,0.), ax=ax)
    ax.set_xlabel("$x$ [kpc]")
    ax.set_ylabel("$y$ [kpc]")

We assume that the bar rotates around the z-axis so that the frequency vector is
just :math:`\boldsymbol{\Omega} = (0,0,42)~{\rm km}~{\rm s}^{-1}~{\rm
kpc}^{-1}`. We'll create a
:class:`~gala.potential.hamiltonian.chamiltonian.Hamiltonian` object with a
:class:`~gala.potential.frame.builtin.ConstantRotatingFrame` with this
frequency::

    >>> Om_bar = 42. * u.km/u.s/u.kpc
    >>> frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
    ...                                  units=galactic)
    >>> H = gp.Hamiltonian(potential=pot, frame=frame)

We can now numerically find the co-rotation radius in this potential and
integrate an orbit from a set of initial conditions near the co-rotation
radius::

    >>> import scipy.optimize as so
    >>> def func(r):
    ...     Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
    ...     return (Om - Om_bar).to(Om_bar.unit).value**2
    >>> res = so.minimize(func, x0=10., method='powell')
    >>>
    >>> r_corot = res.x[0] * u.kpc
    >>> v_circ = Om_bar * r_corot * u.kpc
    >>>
    >>> w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
    ...                            vel=[0, v_circ.value, 0.] * v_circ.unit)
    >>> orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
    ...                           Integrator=gi.DOPRI853Integrator)
    >>> fig = orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    >>> for ax in fig.axes: # doctest: +SKIP
    ...     ax.set_xlim(-15,15) # doctest: +SKIP
    ...     ax.set_ylim(-15,15) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import gala.integrate as gi
    import scipy.optimize as so

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    Om_bar = 42. * u.km/u.s/u.kpc
    frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
                                     units=galactic)
    H = gp.Hamiltonian(potential=pot, frame=frame)

    def func(r):
        Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
        return (Om - Om_bar).to(Om_bar.unit).value**2

    res = so.minimize(func, x0=10., method='powell')
    r_corot = res.x[0] * u.kpc
    v_circ = Om_bar * r_corot

    w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
                               vel=[0,v_circ.value, 0.] * v_circ.unit)

    orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
                              Integrator=gi.DOPRI853Integrator)

    fig = orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    for ax in fig.axes:
        ax.set_xlim(-15,15)
        ax.set_ylim(-15,15)

This is an orbit circulation around the Lagrange point L5! Let's see what this
orbit looks like in an inertial frame::

    >>> inertial_orbit = orbit.to_frame(gp.StaticFrame(galactic))
    >>> fig = inertial_orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    >>> for ax in fig.axes: # doctest: +SKIP
    ...     ax.set_xlim(-15,15) # doctest: +SKIP
    ...     ax.set_ylim(-15,15) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    Om_bar = 42. * u.km/u.s/u.kpc
    frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
                                     units=galactic)
    H = gp.Hamiltonian(potential=pot, frame=frame)

    def func(r):
        Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
        return (Om - Om_bar).to(Om_bar.unit).value**2

    res = so.minimize(func, x0=10., method='powell')
    r_corot = res.x[0] * u.kpc
    v_circ = Om_bar * r_corot

    w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
                               vel=[0,v_circ.value, 0.] * v_circ.unit)

    orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
                              Integrator=gi.DOPRI853Integrator)

    inertial_orbit = orbit.to_frame(gp.StaticFrame(galactic))
    fig = inertial_orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    for ax in fig.axes:
        ax.set_xlim(-15,15)
        ax.set_ylim(-15,15)
</file>

<file path="docs/tutorials/Milky-Way-model.py">
# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx="hidden"
# %matplotlib inline

# + nbsphinx="hidden"
# %run nb_setup
# -

# # Integrate an orbit with uncertainties in Milky Way model

# `gala` provides a simple mass model for the Milky Way based on recent
# measurements of the enclosed mass compiled from the literature. See the
# [Defining a Milky Way potential
# model](define-milky-way-model.html) documentation for more
# information about how this model was defined.
#
# In this example, we will use the position and velocity and uncertainties of
# the Milky Way satellite galaxy "Draco" to integrate orbits in a Milky Way mass
# model starting from samples from the error distribution over initial
# conditions defined by its observed kinematics. We will then compute
# distributions of orbital properties like orbital period, pericenter, and
# eccentricity.
#
# Let's start by importing packages we will need:

# +
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np

# Gala
import gala.dynamics as gd
import gala.potential as gp

# -

# We will also set the default Astropy Galactocentric frame parameters to the
# values adopted in Astropy v4.0:

coord.galactocentric_frame_defaults.set("v4.0")

# For the Milky Way model, we'll use the built-in potential class in `gala` (see
# above for definition):

potential = gp.MilkyWayPotential()

# For the sky position and distance of Draco, we'll use measurements from
# [Bonanos et al. 2004](https://arxiv.org/abs/astro-ph/0310477). For proper
# motion components, we'll use the recent HSTPROMO measurements ([Sohn et al.
# 2017](https://arxiv.org/abs/1707.02593)) and the line-of-sight velocity from
# [Walker et al. 2007](https://arxiv.org/abs/0708.0010).

# +
icrs = coord.SkyCoord(
    ra=coord.Angle("17h 20m 12.4s"),
    dec=coord.Angle("+57° 54′ 55″"),
    distance=76 * u.kpc,
    pm_ra_cosdec=0.0569 * u.mas / u.yr,
    pm_dec=-0.1673 * u.mas / u.yr,
    radial_velocity=-291 * u.km / u.s,
)

icrs_err = coord.SkyCoord(
    ra=0 * u.deg,
    dec=0 * u.deg,
    distance=6 * u.kpc,
    pm_ra_cosdec=0.009 * u.mas / u.yr,
    pm_dec=0.009 * u.mas / u.yr,
    radial_velocity=0.1 * u.km / u.s,
)
# -

# Let's start by transforming the measured values to a Galactocentric reference
# frame so we can integrate an orbit in our Milky Way model. We'll do this using
# the velocity transformation support in
# [`astropy.coordinates`](http://docs.astropy.org/en/stable/coordinates/velocities.html).
# We first have to define the position and motion of the sun relative to the
# Galactocentric frame, and create an
# [`astropy.coordinates.Galactocentric`](http://docs.astropy.org/en/stable/api/astropy.coordinates.Galactocentric.html#astropy.coordinates.Galactocentric)
# object with these parameters. We could specify these things explicitly, but
# instead we will use the default values that were recently updated in Astropy:

galcen_frame = coord.Galactocentric()
galcen_frame

# To transform the mean observed kinematics to this frame, we simply do:

galcen = icrs.transform_to(galcen_frame)

# That's it! Now we have to turn the resulting `Galactocentric` object into
# orbital initial conditions, and integrate the orbit in our Milky Way model.
# We'll use a timestep of 0.5 Myr and integrate the orbit backwards for 10000
# steps (5 Gyr):

w0 = gd.PhaseSpacePosition(galcen.data)
orbit = potential.integrate_orbit(w0, dt=-0.5 * u.Myr, n_steps=10000)

# Let's visualize the orbit:

fig = orbit.plot()

# With the `orbit` object, we can easily compute quantities like the pericenter,
# apocenter, or eccentricity of the orbit:

orbit.pericenter(), orbit.apocenter(), orbit.eccentricity()

# We can also use these functions to get the time of each pericenter or
# apocenter - let's plot the time of pericenter, and time of apocenter over the
# time series of the Galactocentric radius of the orbit:

# +
plt.plot(orbit.t, orbit.spherical.distance, marker="None")

per, per_times = orbit.pericenter(return_times=True, func=None)
apo, apo_times = orbit.apocenter(return_times=True, func=None)

for t in per_times:
    plt.axvline(t.value, color="#67a9cf")

for t in apo_times:
    plt.axvline(t.value, color="#ef8a62")

plt.xlabel("$t$ [{0}]".format(orbit.t.unit.to_string("latex")))
plt.ylabel("$r$ [{0}]".format(orbit.x.unit.to_string("latex")))
# -

# Now we'll sample from the error distribution over the distance, proper
# motions, and radial velocity, compute orbits, and plot distributions of mean
# pericenter and apocenter:

# +
n_samples = 128

dist = (
    np.random.normal(icrs.distance.value, icrs_err.distance.value, n_samples)
    * icrs.distance.unit
)

pm_ra_cosdec = (
    np.random.normal(icrs.pm_ra_cosdec.value, icrs_err.pm_ra_cosdec.value, n_samples)
    * icrs.pm_ra_cosdec.unit
)

pm_dec = (
    np.random.normal(icrs.pm_dec.value, icrs_err.pm_dec.value, n_samples)
    * icrs.pm_dec.unit
)

rv = (
    np.random.normal(
        icrs.radial_velocity.value, icrs_err.radial_velocity.value, n_samples
    )
    * icrs.radial_velocity.unit
)

ra = np.full(n_samples, icrs.ra.degree) * u.degree
dec = np.full(n_samples, icrs.dec.degree) * u.degree
# -

icrs_samples = coord.SkyCoord(
    ra=ra,
    dec=dec,
    distance=dist,
    pm_ra_cosdec=pm_ra_cosdec,
    pm_dec=pm_dec,
    radial_velocity=rv,
)

icrs_samples.shape

galcen_samples = icrs_samples.transform_to(galcen_frame)

w0_samples = gd.PhaseSpacePosition(galcen_samples.data)
orbit_samples = potential.integrate_orbit(w0_samples, dt=-1 * u.Myr, n_steps=4000)

orbit_samples.shape

# +
peris = orbit_samples.pericenter(approximate=True)

apos = orbit_samples.apocenter(approximate=True)

eccs = orbit_samples.eccentricity(approximate=True)

# +
fig, axes = plt.subplots(1, 3, figsize=(12, 4), sharey=True)

axes[0].hist(peris.to_value(u.kpc), bins=np.linspace(20, 80, 32))
axes[0].set_xlabel("pericenter [kpc]")

axes[1].hist(apos.to_value(u.kpc), bins=np.linspace(60, 140, 32))
axes[1].set_xlabel("apocenter [kpc]")

axes[2].hist(eccs.value, bins=np.linspace(0.3, 0.5, 41))
axes[2].set_xlabel("eccentricity")
</file>

<file path="docs/tutorials/mock-stream-heliocentric.rst">
.. _mockstream-heliocentric:

===========================================================================
Generating a mock stellar stream and converting to Heliocentric coordinates
===========================================================================

We first need to import some relevant packages::

   >>> import astropy.coordinates as coord
   >>> import astropy.units as u
   >>> import numpy as np
   >>> import gala.coordinates as gc
   >>> import gala.dynamics as gd
   >>> import gala.potential as gp
   >>> from gala.units import galactic

We will also set the default Astropy Galactocentric frame parameters to the
values adopted in Astropy v4.0:

    >>> _ = coord.galactocentric_frame_defaults.set('v4.0')

In the examples below, we will use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

We first create a potential object to work with. For this example, we'll
use a two-component potential: a Miyamoto-Nagai disk with a spherical NFW
potential to represent a dark matter halo.

   >>> pot = gp.CCompositePotential()
   >>> pot['disk'] = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
   ...                                         a=3.5*u.kpc, b=280*u.pc,
   ...                                         units=galactic)
   >>> pot['halo'] = gp.NFWPotential(m=7E11, r_s=15*u.kpc, units=galactic)

We'll use the Palomar 5 globular cluster and stream as a motivation for this
example. For the position and velocity of the cluster, we'll use
:math:`(\alpha, \delta) = (229, −0.124)~{\rm deg}` [odenkirchen02]_,
:math:`d = 22.9~{\rm kpc}` [bovy16]_,
:math:`v_r = -58.7~{\rm km}~{\rm s}^{-1}` [bovy16]_, and
:math:`(\mu_{\alpha,*}, \mu_\delta) = (-2.296,-2.257)~{\rm mas}~{\rm yr}^{-1}`
[fritz15]_::

   >>> c = coord.ICRS(ra=229 * u.deg, dec=-0.124 * u.deg,
   ...                distance=22.9 * u.kpc,
   ...                pm_ra_cosdec=-2.296 * u.mas/u.yr,
   ...                pm_dec=-2.257 * u.mas/u.yr,
   ...                radial_velocity=-58.7 * u.km/u.s)

We'll first convert this position and velocity to Galactocentric coordinates::

   >>> c_gc = c.transform_to(coord.Galactocentric).cartesian
   >>> c_gc
   <CartesianRepresentation (x, y, z) in kpc
      (7.86390455, 0.22748727, 16.41622487)
   (has differentials w.r.t.: 's')>
   >>> pal5_w0 = gd.PhaseSpacePosition(c_gc)

We can now use the position and velocity of the cluster to generate a :ref:`mock
stellar stream <mockstreams>` with a progenitor that ends up at the present-day
position of the cluster. We will generate a stream using the prescription
defined in [fardal15]_, but including the self-gravity of the cluster mass
itself. We will represent the cluster with a Plummer potential, with mass
:math:`2.5 \times 10^4~{\rm M}_\odot`::

    >>> pal5_mass = 2.5e4 * u.Msun
    >>> pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)

We now have to specify that we want to use the Fardal method for generating
stream particle initial conditions by creating a
`~gala.dynamics.mockstream.FardalStreamDF` instance::

    >>> from gala.dynamics import mockstream as ms
    >>> df = ms.FardalStreamDF()

Finally, we can generate the stream using the
`~gala.dynamics.mockstream.MockStreamGenerator`::

    >>> gen_pal5 = ms.MockStreamGenerator(df, pot,
    ...                                   progenitor_potential=pal5_pot)
    >>> pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
    ...                               dt=-1 * u.Myr, n_steps=4000)

Here the negative timestep tells the stream generator to first integrate the orbit of the progenitor (the Pal 5 cluster itself) backwards in time, then generate the stream forwards from the past until present day::

    >>> pal5_stream.plot(alpha=0.1) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import astropy.coordinates as coord
    import astropy.units as u
    import numpy as np
    import gala.coordinates as gc
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic
    from gala.dynamics import mockstream as ms

    coord.galactocentric_frame_defaults.set('v4.0')

    pot = gp.CCompositePotential()
    pot['disk'] = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
                                            a=3.5*u.kpc, b=280*u.pc,
                                            units=galactic)
    pot['halo'] = gp.NFWPotential(m=1E12, r_s=20*u.kpc, units=galactic)

    c = coord.ICRS(ra=229 * u.deg, dec=-0.124 * u.deg,
                   distance=22.9 * u.kpc,
                   pm_ra_cosdec=-2.296 * u.mas/u.yr,
                   pm_dec=-2.257 * u.mas/u.yr,
                   radial_velocity=-58.7 * u.km/u.s)

    c_gc = c.transform_to(coord.Galactocentric).cartesian
    pal5_w0 = gd.PhaseSpacePosition(c_gc)

    pal5_mass = 2.5e4 * u.Msun
    pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)

    df = ms.FardalStreamDF(gala_modified=True)
    gen_pal5 = ms.MockStreamGenerator(df, pot, progenitor_potential=pal5_pot)
    pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
                                 dt=-1 * u.Myr, n_steps=4000)

    pal5_stream.plot(alpha=0.1)

We now have the model stream particle positions and velocities in a
Galactocentric coordinate frame. To convert these to observable, Heliocentric
coordinates, we have to specify a desired coordinate frame. We'll convert to the
ICRS coordinate system and plot some of the Heliocentric kinematic quantities::

   >>> stream_c = pal5_stream.to_coord_frame(coord.ICRS)

.. plot::
   :align: center
   :context: close-figs

   stream_c = pal5_stream.to_coord_frame(coord.ICRS)

   style = dict(marker='.', s=1, alpha=0.5)

   fig, axes = plt.subplots(1, 2, figsize=(10,5), sharex=True)

   axes[0].scatter(stream_c.ra.degree,
                   stream_c.dec.degree, **style)
   axes[0].set_xlim(250, 220)
   axes[0].set_ylim(-15, 15)

   axes[1].scatter(stream_c.ra.degree,
                   stream_c.radial_velocity.to(u.km/u.s), **style)
   axes[1].set_xlim(250, 220)
   axes[1].set_ylim(-100, 0)

   axes[0].set_xlabel(r'$\alpha\,[{\rm deg}]$')
   axes[1].set_xlabel(r'$\alpha\,[{\rm deg}]$')
   axes[0].set_ylabel(r'$\delta\,[{\rm deg}]$')
   axes[1].set_ylabel(r'$v_r\,[{\rm km}\,{\rm s}^{-1}]$')

   fig.tight_layout()

References
==========

.. [odenkirchen02] `Odenkirchen et al. (2002) <https://arxiv.org/abs/astro-ph/0206276>`_
.. [fritz15] `Fritz & Kallivayalil (2015) <https://arxiv.org/abs/1508.06647>`_
.. [bovy16] `Bovy et al. (2016) <https://arxiv.org/abs/1609.01298>`_
</file>

<file path="docs/tutorials/nb_setup">
get_ipython().magic('config InlineBackend.figure_format = "retina"')  # noqa

import matplotlib.pyplot as plt

plt.style.use("default")

# NOTE: if you update these, also update docs/conf.py
plot_rcparams = {
    "image.cmap": "magma",
    # Fonts:
    "font.size": 16,
    "figure.titlesize": "x-large",
    "axes.titlesize": "large",
    "axes.labelsize": "large",
    "xtick.labelsize": "medium",
    "ytick.labelsize": "medium",
    # Axes:
    "axes.labelcolor": "k",
    "axes.axisbelow": True,
    # Ticks
    "xtick.color": "#333333",
    "xtick.direction": "in",
    "ytick.color": "#333333",
    "ytick.direction": "in",
    "xtick.top": True,
    "ytick.right": True,
    "figure.dpi": 300,
    "savefig.dpi": 300,
}

plt.rcParams.update(plot_rcparams)
</file>

<file path="docs/tutorials/pyia-gala-orbit.py">
# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx="hidden"
# %run nb_setup
# -

# %matplotlib inline

# # Compute a Galactic orbit for a star using Gaia data
#
# In this tutorial, we will retrieve the sky coordinates, astrometry, and radial velocity for a star — [Kepler-444](https://en.wikipedia.org/wiki/Kepler-444) — and compute its orbit in the default Milky Way mass model implemented in Gala. We will compare the orbit of Kepler-444 to the orbit of the Sun.
#
# ### Notebook Setup and Package Imports

# +
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
from pyia import GaiaData

# Gala
import gala.dynamics as gd
import gala.potential as gp

# -

# ## Define a Galactocentric Coordinate Frame
#
# We will start by defining a Galactocentric coordinate system using `astropy.coordinates` by adopting the latest parameter set for the Solar position and velocity with respect to the Galactic Center implemented in Astropy.

with coord.galactocentric_frame_defaults.set("v4.0"):
    galcen_frame = coord.Galactocentric()
galcen_frame

# ## Define the Solar Position and Velocity

# In this coordinate system, the sun is along the $x$-axis (at a negative $x$ value), and the Galactic rotation at this position is in the $+y$ direction. In this coordinate system, the 3D position of the sun is therefore given by:

sun_xyz = u.Quantity(
    [-galcen_frame.galcen_distance, 0 * u.kpc, galcen_frame.z_sun]  # x  # y  # z
)

# We can combine this with the solar velocity vector (set on the `astropy.coordinates.Galactocentric` frame) to define the sun's phase-space position, which we will use as initial conditions shortly to compute the orbit of the Sun:

sun_w0 = gd.PhaseSpacePosition(pos=sun_xyz, vel=galcen_frame.galcen_v_sun)

# To compute the sun's orbit, we need to specify a mass model for the Galaxy. Here, we will use the same default, four-component Milky Way mass model introduced in [Defining a Milky Way model](define-milky-way-model.html):

mw_potential = gp.MilkyWayPotential()

# We can now compute the Sun's orbit using the default integrator (Leapfrog integration): We will compute the orbit for 4 Gyr, which is about 16 orbital periods:

sun_orbit = mw_potential.integrate_orbit(sun_w0, dt=0.5 * u.Myr, t1=0, t2=4 * u.Gyr)

# ## Retrieve Gaia Data for Kepler-444

# For our comparison star, we will use the exoplanet-hosting star Kepler-444. To get Gaia data for this source, we first have to retrieve its sky coordinates so that we can do a positional cross-match query on the Gaia catalog. We can retrieve the sky position of Kepler-444 using the `SkyCoord.from_name()` classmethod, which queries Simbad under the hood to resolve the name:

star_sky_c = coord.SkyCoord.from_name("Kepler-444")
star_sky_c

# We happen to know a priori that Kepler-444 has a large proper motion, so the sky position reported by Simbad (unknown epoch) could be off from the Gaia sky position (epoch=2016) by many arcseconds. To run and retrieve the Gaia data, we will use the [pyia](http://pyia.readthedocs.io/) package: We can pass in an ADQL query, which `pyia` uses to query the Gaia science archive using `astroquery`, and returns the data as a `pyia` object that understands how to convert the Gaia data columns into a `astropy.coordinates.SkyCoord` object. To run the query, we will do a large sky position cross-match (with a radius of 15 arcseconds), and take the brightest cross-matched source within this region:

star_gaia = GaiaData.from_query(
    f"""
    SELECT TOP 1 * FROM gaiadr3.gaia_source
    WHERE 1=CONTAINS(
        POINT('ICRS', {star_sky_c.ra.degree}, {star_sky_c.dec.degree}),
        CIRCLE('ICRS', ra, dec, {(15*u.arcsec).to_value(u.degree)})
    )
    ORDER BY phot_g_mean_mag
    """
)
star_gaia

# We will assume (and hope!) that this source is Kepler-444, but we know that it is fairly bright compared to a typical Gaia source, so we should be safe.
#
# We can now use the returned `pyia.GaiaData` object to convert the Gaia astrometric and radial velocity measurements into an Astropy `SkyCoord` object (with all position and velocity data):

star_gaia_c = star_gaia.get_skycoord()

# To compute this star's Galactic orbit, we need to convert its observed, Heliocentric (actually solar system barycentric) data into the Galactocentric coordinate frame we defined above. To do this, we will use the `astropy.coordinates` transformation framework:

star_galcen = star_gaia_c.transform_to(galcen_frame)
star_galcen

# Now with Galactocentric position and velocity components for Kepler-444, we can create Gala initial conditions and compute its orbit on the time grid used to compute the Sun's orbit above:

star_w0 = gd.PhaseSpacePosition(star_galcen.data)
star_orbit = mw_potential.integrate_orbit(star_w0, t=sun_orbit.t)

# +
fig, axes = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)

sun_orbit.plot(["x", "y"], axes=axes[0])
star_orbit.plot(["x", "y"], axes=axes[0])
axes[0].set_xlim(-10, 10)
axes[0].set_ylim(-10, 10)

sun_orbit.cylindrical.plot(
    ["rho", "z"],
    axes=axes[1],
    auto_aspect=False,
    labels=["$R$ [kpc]", "$z$ [kpc]"],
    label="Sun",
)
star_orbit.cylindrical.plot(
    ["rho", "z"],
    axes=axes[1],
    auto_aspect=False,
    labels=["$R$ [kpc]", "$z$ [kpc]"],
    label="Kepler-444",
)
axes[1].set_xlim(0, 10)
axes[1].set_ylim(-5, 5)
axes[1].set_aspect("auto")
axes[1].legend(loc="best", fontsize=15)
# -
# ### Exercise: How does Kepler-444's orbit differ from the Sun's?
#
# What is the maximum $z$ height reached by each orbit? What are their eccentricities? What are the guiding center radii of the two orbits? Can you guess which star is older based on their kinematics? Which star do you think has a higher metallicity?


# ### Exercise: Comparing these orbits to the orbits of other Gaia stars
#
# Retrieve Gaia data for a set of 100 random Gaia stars within 200 pc of the sun with measured radial velocities and well-measured parallaxes using the query:
#
#     SELECT TOP 100 * FROM gaiadr3.gaia_source
#         WHERE radial_velocity IS NOT NULL AND
#             parallax_over_error > 10 AND
#             ruwe < 1.2 AND
#             parallax > 5
#         ORDER BY random_index

random_stars_g = GaiaData.from_query(
    """
    SELECT TOP 100 * FROM gaiadr3.gaia_source
    WHERE radial_velocity IS NOT NULL AND
        parallax_over_error > 10 AND
        ruwe < 1.2 AND
        parallax > 5
    ORDER BY random_index
    """
)

# Compute orbits for these stars for the same time grid used above to compute the sun's orbit:

random_stars_c = random_stars_g.get_skycoord()

random_stars_galcen = random_stars_c.transform_to(galcen_frame)
random_stars_w0 = gd.PhaseSpacePosition(random_stars_galcen.data)

random_stars_orbits = mw_potential.integrate_orbit(random_stars_w0, t=sun_orbit.t)

# Plot the initial (present-day) positions of all of these stars in Galactocentric Cartesian coordinates:

_ = random_stars_w0.plot()

# Plot the orbits of these stars in the x-y and R-z planes:

# +
fig, axes = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)

random_stars_orbits.plot(["x", "y"], axes=axes[0])
axes[0].set_xlim(-15, 15)
axes[0].set_ylim(-15, 15)

random_stars_orbits.cylindrical.plot(
    ["rho", "z"],
    axes=axes[1],
    auto_aspect=False,
    labels=["$R$ [kpc]", "$z$ [kpc]"],
)

axes[1].set_xlim(0, 15)
axes[1].set_ylim(-5, 5)
axes[1].set_aspect("auto")
# -

# Compute maximum $z$ heights ($z_\textrm{max}$) and eccentricities for all of these orbits. Compare the Sun, Kepler-444, and this random sampling of nearby stars. Where do the Sun and Kepler-444 sit relative to the random sample of nearby stars in terms of $z_\textrm{max}$ and eccentricity? (Hint: plot $z_\textrm{max}$ vs. eccentricity and highlight the Sun and Kepler-444!) Are either of them outliers in any way?

rand_zmax = random_stars_orbits.zmax()

rand_ecc = random_stars_orbits.eccentricity()

fig, ax = plt.subplots(figsize=(8, 6))
ax.scatter(
    rand_ecc, rand_zmax, color="k", alpha=0.4, s=14, lw=0, label="random nearby stars"
)
ax.scatter(sun_orbit.eccentricity(), sun_orbit.zmax(), color="tab:orange", label="Sun")
ax.scatter(
    star_orbit.eccentricity(), star_orbit.zmax(), color="tab:cyan", label="Kepler-444"
)
ax.legend(loc="best", fontsize=14)
ax.set_xlabel("eccentricity, $e$")
ax.set_ylabel(r"max. $z$ height, $z_{\rm max}$ [kpc]")
</file>

<file path="docs/whatsnew/1.0.rst">
.. doctest-skip-all

.. _whatsnew-1.0:

************************
What's New in gala v1.0?
************************

Overview
========

Gala 1.0 is a major release with significant new functionality (some of which is
described below).

This release includes (among other things):

* :ref:`whatsnew-1.0-greatcircle`
* :ref:`whatsnew-1.0-new-potentials`
* :ref:`whatsnew-1.0-scf`
* :ref:`whatsnew-1.0-stream-frame-naming`
* :ref:`whatsnew-1.0-cov-matrix`


.. _whatsnew-1.0-greatcircle:

Great circle coordinate systems
===============================

Great circle coordinate frames (GCFs) are heliocentric coordinate systems that are
typically specified as a rotation away from standard equatorial ICRS
coordinates. The resulting longitude and latitude components of a GCF specify
the angle along the great circle and the angle perpendicular (in gala, we use
:math:`\phi_1` / ``phi1`` to represent the longitude, and :math:`\phi_2` /
``phi2`` to represent the latitude). These frames are typically defined by
specifying the coordinate of the pole of the great circle, and either the
origin, :math:`(\phi_1, \phi_2) = (0, 0)`, or the longitude of the old system
(i.e. ICRS) to put at longitude :math:`\phi_1 = 0` in the new frame. The  new
``GreatCircleICRSFrame`` supports both of these options, along with two other
possible ways for defining a GCF: by specifying two points along the great
circle in the old frame, and by directly specifying the cartesian basis of the
GCF in the old coordinate system. For example, to create a GCF from a pole and
longitude zero-point::

    >>> import astropy.units as u
    >>> from astropy.coordinates import SkyCoord
    >>> from gala.coordinates import GreatCircleICRSFrame
    >>> pole = SkyCoord(ra=255*u.deg, dec=-11.5*u.deg)
    >>> gcf = GreatCircleICRSFrame(pole=pole, ra0=170*u.deg)

Or, to create a GCF from two endpoints along a great circle::

    >>> pt1 = SkyCoord(ra=170.*u.deg, dec=23.18*u.deg)
    >>> pt2 = SkyCoord(ra=125.7*u.deg, dec=-72.2*u.deg)
    >>> gcf2 = GreatCircleICRSFrame.from_endpoints(pt1, pt2)

However you define a great circle frame, these can be used with the Astropy
coordinate transformation machinery to transform positions and velocity
components to and from this and other coordinate frames. For example, to
transform a grid of points along latitude=0 in one of these systems to Galactic
coordinates to plot the great circle on the sky, we can do::

    >>> import numpy as np
    >>> grid_c = SkyCoord(phi1=np.linspace(0, 360, 128)*u.deg, phi2=0*u.deg,
    ...                   frame=gcf2)
    >>> grid_c = grid_c.galactic

When plotted, this would show the track of the great circle in Galactic
coordinates, i.e.:

.. plot::
    :context: reset
    :align: center

    import astropy.units as u
    from astropy.coordinates import SkyCoord
    from gala.coordinates import GreatCircleICRSFrame
    import matplotlib.pyplot as plt

    pt1 = SkyCoord(ra=170.*u.deg, dec=23.18*u.deg)
    pt2 = SkyCoord(ra=125.7*u.deg, dec=-72.2*u.deg)
    gcf2 = GreatCircleICRSFrame.from_endpoints(pt1, pt2)

    grid_c = SkyCoord(phi1=np.linspace(0, 360, 128)*u.deg, phi2=0*u.deg,
                     frame=gcf2)
    grid_c = grid_c.galactic

    plt.figure(figsize=(6, 4))
    plt.plot(grid_c.l.degree[grid_c.l.degree.argsort()],
            grid_c.b.degree[grid_c.l.degree.argsort()],
            ls='-', marker='')
    plt.xlabel('$l$ [deg]')
    plt.ylabel('$b$ [deg]')
    plt.tight_layout()


.. _whatsnew-1.0-new-potentials:

New potential models, including MWPotential2014
===============================================

Gala now contains an implementation of the Galpy / `Bovy 2015
<https://ui.adsabs.harvard.edu/#abs/2015ApJS..216...29B/abstract>`_
``MWPotential2014``, here called `~gala.potential.BovyMWPotential2014`. This
potential class can be used like any other potential object in Gala, for
example, for orbit integration. As a brief demo, here we compare the orbit of a
Milky Way halo object in `~gala.potential.BovyMWPotential2014` as compared to
the default Gala Milky Way model implemented as
`~gala.potential.MilkyWayPotential`::

    >>> import gala.dynamics as gd
    >>> import gala.potential as gp
    >>> mw_gala = gp.MilkyWayPotential()
    >>> mw_bovy = gp.BovyMWPotential2014()
    >>> w0 = gd.PhaseSpacePosition(pos=[25., 0, 0]*u.kpc,
    ...                            vel=[0, 0, 200.]*u.km/u.s)
    >>> orbit_gala = mw_gala.integrate_orbit(w0, dt=1., n_steps=1000)
    >>> orbit_bovy = mw_bovy.integrate_orbit(w0, dt=1., n_steps=1000)

Here is a comparison of the two orbits over-plotted on the same axes:

.. plot::
    :context: reset
    :align: center

    import astropy.units as u
    import matplotlib.pyplot as plt
    import gala.dynamics as gd
    import gala.potential as gp

    mw_gala = gp.MilkyWayPotential()
    mw_bovy = gp.BovyMWPotential2014()
    w0 = gd.PhaseSpacePosition(pos=[25., 0, 0]*u.kpc,
                               vel=[0, 0, 200.]*u.km/u.s)
    orbit_gala = mw_gala.integrate_orbit(w0, dt=1., n_steps=1000)
    orbit_bovy = mw_bovy.integrate_orbit(w0, dt=1., n_steps=1000)

    fig, ax = plt.subplots(1, 1, figsize=(6, 6))
    orbit_gala.plot(['x', 'z'], label='Gala', marker='', axes=[ax])
    orbit_bovy.plot(['x', 'z'], label='Bovy2015', marker='', axes=[ax])
    plt.legend(loc='best')
    plt.tight_layout()


.. _whatsnew-1.0-scf:

Basis function expansion potential models with the self-consistent field method
===============================================================================

Gala now contains support for constructing and using flexible (static)
gravitational potential models using the self-consistent field (SCF) basis
function expansion method. Expansion coefficients can be computed from both
analytic density distributions or from discrete particle distributions (e.g.,
from an N-body simulation). For more information about this new subpackage, see
the :ref:`scf` documentation.


.. _whatsnew-1.0-stream-frame-naming:

Stellar stream coordinate frame names now reflect the source reference
======================================================================

Each of the stellar stream coordinate frames now contains the name of the author
that defined the frame. For example, the ``GD1`` frame has been renamed to
`~gala.coordaintes.GD1Koposov10` to indicate that the frame was defined in
Koposov et al. 2010. This is true for each of the major stellar stream frames:

* ``GD1`` has been renamed `~gala.coordinates.GD1Koposov10`
* ``Sagittarius`` has been renamed `~gala.coordinates.SagittariusLaw10`
* ``Orphan`` has been renamed `~gala.coordinates.OrphanNewberg10`, and a new
  Orphan stream coordinate frame has been added:
  `~gala.coordinates.OrphanKoposov19`
* ``Ophiuchus`` has been renamed `~gala.coordinates.OphiuchusPriceWhelan16`
* ``Pal5`` has been renamed `~gala.coordinates.Pal5PriceWhelan18`
* ``MagellanicStream`` has been renamed
  `~gala.coordinates.MagellanicStreamNidever08`


.. _whatsnew-1.0-cov-matrix:

Transforming proper motion covariance matrices
==============================================

The Gaia mission provides full astrometric covariance matrices for each of its
sources, which not only specify the uncertainty in each parameter, but also
specify the correlations between the uncertainties of the astrometric
parameters. These covariance matrices are provided in the ICRS coordinate
system, but often it is useful to transform the Gaia data to other coordinate
systems when, e.g., modeling stellar streams. The proper motion covariance
matrix can be analytically and straightforwardly transformed along with the
positions and proper motions themselves if the transformation is a rotation away
from ICRS, such as the case for the new ``GreatCircleICRSFrame`` or stellar
stream coordinate frames described above. As an example, we will transform the
Gaia proper motion covariance matrix for a source to the ``GD1Koposov10``
coordinate frame::

    >>> from gala.coordinates import transform_pm_cov, GD1Koposov10
    >>> cov = np.array([[ 0.07567177, -0.01698125],
    ...                 [-0.01698125,  0.03907039]])
    >>> c = SkyCoord(ra=130.99*u.deg, dec=34.53*u.deg,
    ...              distance=454.76*u.pc,
    ...              pm_ra_cosdec=11.5*u.mas/u.yr,
    ...              pm_dec=-23.46661*u.mas/u.yr)
    >>> cov_gd1 = transform_pm_cov(c, cov, GD1Koposov10)
</file>

<file path="docs/whatsnew/index.rst">
*********************
Major Release History
*********************

.. toctree::
   :maxdepth: 1

   1.0
</file>

<file path="docs/_static_animations.py">
def make_orbit_animations(static_path):

    # orbits-in-derail.rst
    import astropy.units as u
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    file1 = static_path / 'orbit-anim1.mp4'
    file2 = static_path / 'orbit-anim2.mp4'

    if file1.exists() and file2.exists():
        print("Orbit animations exist - skipping...")
        return

    pot = gp.PlummerPotential(m=1E10 * u.Msun, b=1. * u.kpc, units=galactic)
    w0 = gd.PhaseSpacePosition(pos=[2., 0, 0] * u.kpc,
                               vel=[0., 75, 15] * u.km/u.s)
    orbit = gp.Hamiltonian(pot).integrate_orbit(w0, dt=1., n_steps=5000)

    # animation 1:
    fig, anim = orbit[:1000].animate(stride=10)
    anim.save(file1)

    # animation 2:
    fig, anim = orbit[:1000].cylindrical.animate(components=['rho', 'z'],
                                                 stride=10)
    anim.save(file2)


if __name__ == "__main__":
    import pathlib
    make_orbit_animations(pathlib.Path('./_static').resolve().absolute())
</file>

<file path="docs/.gitignore">
ZENODO.rst
_tutorials.rst
api/
_build
*.csv
</file>

<file path="docs/conf.py">
# -*- coding: utf-8 -*-

import datetime
import os
import pathlib
import re
import sys
import warnings
from importlib import import_module

# Load all of the global Astropy configuration
try:
    from sphinx_astropy.conf.v1 import *  # noqa
except ImportError:
    print(
        "ERROR: Building the documentation for Gala requires the "
        "sphinx-astropy package to be installed"
    )
    sys.exit(1)

# Get configuration information from setup.cfg
from configparser import ConfigParser

conf = ConfigParser()

docs_root = pathlib.Path(__file__).parent.resolve()

# -- General configuration ----------------------------------------------------

# By default, highlight as Python 3.
highlight_language = "python3"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build", "**.ipynb_checkpoints"]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
# source_suffix = ['.rst', '.md']
source_suffix = ".rst"

# Don't show summaries of the members in each class along with the
# class' docstring
numpydoc_show_class_members = False

# Whether to create cross-references for the parameter types in the
# Parameters, Other Parameters, Returns and Yields sections of the docstring.
numpydoc_xref_param_type = True

autosummary_generate = True

automodapi_toctreedirnm = "api"

# The reST default role (used for this markup: `text`) to use for all
# documents. Set to the "smart" one.
default_role = "obj"

# Class documentation should contain *both* the class docstring and
# the __init__ docstring
autoclass_content = "both"

# This is added to the end of RST files - a good place to put substitutions to
# be used globally.
rst_epilog = """
"""

# intersphinx
intersphinx_mapping = {
    "python": ("https://docs.python.org/3/", None),
    "numpy": ("https://numpy.org/doc/stable/", None),
    "scipy": ("https://docs.scipy.org/doc/scipy/reference/", None),
    "matplotlib": ("https://matplotlib.org/", None),
    "astropy": ("https://docs.astropy.org/en/stable/", None),
    "h5py": ("https://docs.h5py.org/en/stable/", None),
    "sympy": ("https://docs.sympy.org/latest/", None),
}

# Show / hide TODO blocks
todo_include_todos = True

# -- Project information ------------------------------------------------------

# This does not *have* to match the package name, but typically does
project = "gala"
author = "Adrian Price-Whelan"
copyright = "{0}, {1}".format(datetime.datetime.now().year, author)

package_name = "gala"
import_module(package_name)
package = sys.modules[package_name]

plot_formats = [("png", 200), ("pdf", 200)]
plot_apply_rcparams = True
# NOTE: if you update these, also update docs/tutorials/nb_setup
plot_rcparams = {
    "image.cmap": "magma",
    # Fonts:
    "font.size": 16,
    "figure.titlesize": "x-large",
    "axes.titlesize": "large",
    "axes.labelsize": "large",
    "xtick.labelsize": "medium",
    "ytick.labelsize": "medium",
    # Axes:
    "axes.labelcolor": "k",
    "axes.axisbelow": True,
    # Ticks
    "xtick.color": "#333333",
    "xtick.direction": "in",
    "ytick.color": "#333333",
    "ytick.direction": "in",
    "xtick.top": True,
    "ytick.right": True,
    "figure.dpi": 300,
    "savefig.dpi": 300,
}
plot_include_source = False

# The short X.Y version.
version = package.__version__.split("-", 1)[0]
# The full version, including alpha/beta/rc tags.
release = package.__version__


# -- Options for HTML output ---------------------------------------------------

html_theme = "pydata_sphinx_theme"
html_logo = "_static/Gala_Logo_RGB.png"

html_theme_options = {
    "logo": {
        "image_light": "Gala_Logo_RGB.png",
        "image_dark": "Gala_Logo_RGB.png",
    },
    "icon_links": [
        {
            "name": "GitHub",
            "url": "https://github.com/adrn/gala",
            "icon": "fab fa-github-square",
        },
        {
            "name": "Twitter",
            "url": "https://twitter.com/adrianprw",
            "icon": "fab fa-twitter-square",
        },
    ],
}

# Add any paths that contain custom themes here, relative to this directory.
# To use a different custom theme, add the directory containing the theme.
# html_theme_path = ['_themes/sphinx_rtd_theme']

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes. To override the custom theme, set this to the
# name of a builtin theme or the name of a custom theme in html_theme_path.
# html_theme = "sphinx_rtd_theme"

# Custom sidebar templates, maps document names to template names.
html_sidebars = {"**": ["search-field.html", "sidebar-nav-bs.html"]}

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = str(docs_root / "_static" / "m104.ico")

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = ''

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "{0} v{1}".format(project, release)

# Output file base name for HTML help builder.
htmlhelp_basename = project + "doc"

# Static files to copy after template files
html_static_path = ["_static"]
html_css_files = ["gala.css"]


# -- Options for LaTeX output --------------------------------------------------

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ("index", project + ".tex", project + " Documentation", author, "manual")
]

# show inherited members for classes
automodsumm_inherited_members = True

# Add nbsphinx
extensions += [
    "nbsphinx",
    "IPython.sphinxext.ipython_console_highlighting",
    "sphinxcontrib.bibtex",
    "rtds_action",
]

# Bibliography:
bibtex_bibfiles = ["refs.bib"]
bibtex_reference_style = "author_year"

# Custom setting for nbsphinx - timeout for executing one cell
nbsphinx_timeout = 300
nbsphinx_kernel_name = os.environ.get("NBSPHINX_KERNEL_NAME", "python3")

# nbsphinx hacks (thanks exoplanet)
import nbsphinx
from nbsphinx import markdown2rst as original_markdown2rst

nbsphinx.RST_TEMPLATE = nbsphinx.RST_TEMPLATE.replace(
    "{%- if width %}", "{%- if 0 %}"
).replace("{%- if height %}", "{%- if 0 %}")


def subber(m):
    return m.group(0).replace("``", "`")


prog = re.compile(r":(.+):``(.+)``")


def markdown2rst(text):
    return prog.sub(subber, original_markdown2rst(text))


nbsphinx.markdown2rst = markdown2rst

# rtds-action
if "GITHUB_TOKEN" in os.environ:
    print("GitHub Token found: retrieving artifact")

    # The name of your GitHub repository
    rtds_action_github_repo = "adrn/gala"

    # The path where the artifact should be extracted
    # Note: this is relative to the conf.py file!
    rtds_action_path = "tutorials"

    # The "prefix" used in the `upload-artifact` step of the action
    rtds_action_artifact_prefix = "notebooks-for-"

    # A GitHub personal access token is required, more info below
    rtds_action_github_token = os.environ["GITHUB_TOKEN"]

    # Whether or not to raise an error on ReadTheDocs if the
    # artifact containing the notebooks can't be downloaded (optional)
    rtds_action_error_if_missing = True

else:
    rtds_action_github_repo = ""
    rtds_action_github_token = ""
    rtds_action_path = ""

## -- Retrieve Zenodo record for most recent version of Gala:
zenodo_path = docs_root / "ZENODO.rst"
if not zenodo_path.exists():
    import textwrap

    try:
        import requests

        headers = {"accept": "application/x-bibtex"}
        response = requests.get(
            "https://zenodo.org/api/records/4159870", headers=headers
        )
        response.encoding = "utf-8"
        zenodo_record = ".. code-block:: bibtex\n\n" + textwrap.indent(
            response.text, " " * 4
        )
    except Exception as e:
        warnings.warn(f"Failed to retrieve Zenodo record for Gala: {str(e)}")
        zenodo_record = (
            "`Retrieve the Zenodo record here " "<https://zenodo.org/record/4159870>`_"
        )

    with open(zenodo_path, "w") as f:
        f.write(zenodo_record)

## -- Check for executed tutorials and only add to toctree if they exist:

tutorial_files = [
    "tutorials/Milky-Way-model.ipynb",
    "tutorials/integrate-potential-example.rst",
    "tutorials/pyia-gala-orbit.ipynb",
    "tutorials/integrate-rotating-frame.rst",
    "tutorials/mock-stream-heliocentric.rst",
    "tutorials/circ-restricted-3body.rst",
    "tutorials/define-milky-way-model.ipynb",
    "tutorials/Arbitrary-density-SCF.ipynb",
]

_not_executed = []
_tutorial_toctree_items = []
for fn in tutorial_files:
    if not pathlib.Path(fn).exists() and "GITHUB_TOKEN" not in os.environ:
        _not_executed.append(fn)
    else:
        _tutorial_toctree_items.append(fn)

if _tutorial_toctree_items:
    _tutorial_toctree_items = "\n    ".join(_tutorial_toctree_items)
    _tutorial_toctree = f"""
.. toctree::
    :maxdepth: 1
    :glob:

    {_tutorial_toctree_items}
    """

else:
    _tutorial_toctree_items = "No tutorials found!"

if _not_executed:
    print(
        "\n-------- Gala warning --------\n"
        "Some tutorial notebooks could not be found! This is likely because "
        "the tutorial notebooks have not been executed. If you are building "
        "the documentation locally, you may want to run 'make exectutorials' "
        "before running the sphinx build."
    )
    print(f"Missing tutorials: {', '.join(_not_executed)}\n")

with open("_tutorials.rst", "w") as f:
    f.write(_tutorial_toctree)
</file>

<file path="docs/contributing.rst">
.. include:: references.txt

*****************
How to contribute
*****************

We welcome contributions from anyone via pull requests on `GitHub
<https://github.com/adrn/gala>`_. If you don't feel comfortable modifying or
adding functionality, we also welcome feature requests and bug reports as
`GitHub issues <https://github.com/adrn/gala/issues>`_.

Developer documentation
=======================

.. toctree::
    :maxdepth: 1

    testing
    docs
</file>

<file path="docs/conventions.rst">
.. _conventions:

***********
Conventions
***********

.. _name-conventions:

Common variable names
=====================

Unless otherwise stated (in function or class docstrings), this package tries to
adhere to using standard variable names for function and class arguments, and in
example code. For shorthand, the variable ``w`` is used to represent arrays of
phase-space coordinates (e.g., positions _and_ velocities). When representing
only positions, the variable ``q`` is used. For just velocities or momenta, the
variables ``p`` or ``v`` are used.

.. _shape-conventions:

Array shapes
============

The arrays and :class:`~astropy.units.Quantity` objects expected as input and
returned as output throughout ``Gala`` have shapes that follow a particular
convention, unless otherwise specified in function or class docstrings.

For arrays containing coordinate or kinematic information, ``axis=0`` is assumed
to be the coordinate dimension. For example, for representing 128 different 3D
Cartesian positions, the object should have shape ``(3, 128)``.

For collections of orbits, arrays or array-valued objects have three axes: As
above, ``axis=0`` is assumed to be the coordinate dimension, ``axis=1`` is
interpreted as the time axis, and ``axis=2`` are the different orbits.

.. _energy-momentum:

Energy and momentum
===================

The `gala` documentation and functions often refer to energy and angular
momentum and the respective quantities *per unit mass* interchangeably. Unless
otherwise specified, all such quantities -- e.g., energy, angular momentum,
momenta, conjugate momenta -- are in fact used and returned *per unit mass*.
</file>

<file path="docs/docs.rst">
.. _gala-docs:

=================
Building the docs
=================

The documentation is built by Sphinx. To start, make sure you install all of the docs dependencies::

    pip install -e ".[docs]"

Then change directory into the ``docs/`` path. You now have to execute the
tutorials, make animations needed by the documentation, and run the docs build::

    make exectutorials
    make animations
    make html
</file>

<file path="docs/getting_started.rst">
.. _gala-getting-started:

***************
Getting Started
***************

Welcome to the `gala` documentation!

.. TODO: in the paragraph below, switch the matplotlib link to :mod:`matplotlib`
.. when they add a top-level module definition

For practical reasons, this documentation generally assumes that you are
familiar with the Python programming language, including numerical and
computational libraries like :mod:`numpy`, :mod:`scipy`, and `matplotlib
<https://matplotlib.org/>`_. If you need a refresher on Python programming, we
recommend starting with the `official Python tutorial
<https://docs.python.org/3/tutorial/>`_, but many other good resources are
available on the internet, such as tutorials and lectures specifically designed
for `using Python for scientific applications <https://scipy-lectures.org/>`_.

On this introductory page, we will demonstrate a few common use cases for `gala`
and give an overview of the package functionality. For the examples
below, we will assume that the following imports have already been executed
because these packages will be generally required::

    >>> import astropy.units as u
    >>> import numpy as np


Computing your first stellar orbit
==================================

One of the most common use cases for `gala` is to compute an orbit for a star
within a mass model for the Milky Way. To do this, we need to specify two
things: (1) the model of the Milky Way that we would like to use to represent
the mass distribution, and (2) the initial conditions of the star's orbit.

Mass models in `gala` are specified using Python classes that represent
standard gravitational potential models. For example, most of the standard,
parametrized gravitational potential models introduced in :cite:`Binney2008`
are available as classes in the :mod:`gala.potential` module. The standard Milky
Way model recommended for use in `gala` is the
`~gala.potential.potential.MilkyWayPotential`, which is a pre-defined,
multi-component mass model with parameters set to fiducial values that match the
rotation curve of the Galactic disk and the mass profile of the dark matter
halo. We can create an instance of this model with the fiducial parameters by
instantiating the `~gala.potential.potential.MilkyWayPotential` class without
any input::

    >>> import gala.potential as gp
    >>> mw = gp.MilkyWayPotential()
    >>> mw
    <CompositePotential disk,bulge,nucleus,halo>

This model, by default, contains four distinct potential components as listed in
the output above: disk, bulge, nucleus, and halo components. You can configure
any of the parameters of these components, or create your own "composite"
potential model using other potential models defined in :mod:`gala.potential`,
but for now we will use the fiducial model as we defined it, the variable
``mw``.

All of the :mod:`gala.potential` class instances have a set of standard methods
that enable fast calculations of computed or derived quantities. For example,
we could compute the potential energy or the acceleration at a Cartesian
position near the Sun::

    >>> xyz = [-8., 0, 0] * u.kpc
    >>> mw.energy(xyz)  # doctest: +FLOAT_CMP
    <Quantity [-0.16440296] kpc2 / Myr2>
    >>> mw.acceleration(xyz)  # doctest: +FLOAT_CMP
    <Quantity [[ 0.00702262],
               [-0.        ],
               [-0.        ]] kpc / Myr2>

The values that are returned by most methods in `gala` are provided as Astropy
`~astropy.units.Quantity` objects, which represent numerical data with
associated physical units. `~astropy.units.Quantity` objects can be
re-represented in any equivalent units, so, for example, we could display the
energy or acceleration in other units::

    >>> E = mw.energy(xyz)
    >>> E.to((u.km/u.s)**2)  # doctest: +FLOAT_CMP
    <Quantity [-157181.98979398] km2 / s2>
    >>> acc = mw.acceleration(xyz)
    >>> acc.to(u.km/u.s / u.Myr)  # doctest: +FLOAT_CMP
    <Quantity [[ 6.86666358],
               [-0.        ],
               [-0.        ]] km / (Myr s)>

Now that we have a potential model, if we want to compute an orbit, we need to
specify a set of initial conditions to initialize the numerical orbit
integration. In `gala`, initial conditions and other positions in phase-space
(locations in position and velocity space) are defined using the
`~gala.dynamics.PhaseSpacePosition` class. This class allows a number of
possible inputs, but one of the most common inputs are Cartesian position and
velocity vectors. As an example orbit, we will use a position and velocity that
is close to the Sun's Galactocentric position and velocity::

    >>> import gala.dynamics as gd
    >>> w0 = gd.PhaseSpacePosition(pos=[-8.1, 0, 0.02] * u.kpc,
    ...                            vel=[13, 245, 8.] * u.km/u.s)

By convention, I typically use the variable ``w`` to represent phase-space
positions, so here ``w0`` is meant to imply "initial conditions." Note that,
when passing in Cartesian position and velocity values, we typically have to
pass them in as `~astropy.units.Quantity` objects (i.e., with units). This is
required whenever the potential class you are using has a unit system, which you
can check by calling the `~gala.potential.potential.PotentialBase.units`
attribute of your potential object::

    >>> mw.units
    <UnitSystem (kpc, Myr, solMass, rad)>

Here, our Milky Way potential model has a unit system with dimensional units.
Note that we could have used any length unit for the position and any velocity
unit for the velocity, because `gala` handles the unit conversions internally.

Now with a potential model defined and a set of initial conditions, we are set
to compute an orbit! To do this, we use the numerical integration system defined
in `gala.integrate`, but do so using the convenience interface available on any
Potential object through the
`~gala.potential.potential.PotentialBase.integrate_orbit()` method::

    >>> orbit = mw.integrate_orbit(w0, dt=1*u.Myr, t1=0, t2=2*u.Gyr)

By default, this method uses Leapfrog integration , which is a fast, symplectic
integration scheme. The returned object is an instance of the
`~gala.dynamics.Orbit` class, which is similar to the
`~gala.dynamics.PhaseSpacePosition` but represents a collection of phase-space
positions at times::

    >>> orbit
    <Orbit cartesian, dim=3, shape=(2000,)>

`~gala.dynamics.Orbit` objects have many of their own useful methods for
performing common tasks, like plotting an orbit::

    >>> orbit.plot(['x', 'y'])  # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    import astropy.units as u
    import matplotlib.pyplot as plt
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp

    mw = gp.MilkyWayPotential()
    w0 = gd.PhaseSpacePosition(pos=[-8.1, 0, 0.02] * u.kpc,
                               vel=[13, 245, 8.] * u.km/u.s)
    orbit = mw.integrate_orbit(w0, dt=1*u.Myr, t1=0, t2=2*u.Gyr)

    orbit.plot(['x', 'y'])

`~gala.dynamics.Orbit` objects by default assume and use Cartesian coordinate
representations, but these can also be transformed into other representations,
like Cylindrical coordinates. For example, we could re-represent the orbit in
cylindrical coordinates and then plot the orbit in the "meridional plane"::

    >>> fig = orbit.cylindrical.plot(['rho', 'z'])  # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs
    :width: 60%

    fig = orbit.cylindrical.plot(['rho', 'z'])

Or estimate the pericenter, apocenter, and eccentricity of the orbit::

    >>> orbit.pericenter()  # doctest: +FLOAT_CMP
    <Quantity 8.00498069 kpc>
    >>> orbit.apocenter()  # doctest: +FLOAT_CMP
    <Quantity 9.30721946 kpc>
    >>> orbit.eccentricity()  # doctest: +FLOAT_CMP
    <Quantity 0.07522087>

`gala.potential` ``Potential`` objects and `~gala.dynamics.Orbit` objects have
many more possibilities, so please do check out the narrative documentation for
`gala.potential` and `gala.dynamics` if you would like to learn more!


What else can ``gala`` do?
==========================

This page is meant to demonstrate a few initial things you may want to do with
`gala`. There is much more functionality that you can discover either through
the :ref:`tutorials <tutorials>` or by perusing the :ref:`user guide
<gala-user-guide>`. Some other commonly-used functionality includes:

* :ref:`Generating simulated "mock" stellar stream models <gala-mockstreams>`
* :ref:`Stellar stream and great circle coordinate systems <gala-coordinates>`
* :ref:`Transformations to action-angle coordinates <gala-actionangle>`
* :ref:`Nonlinear dynamics and chaos indicators <gala-nonlinear-dynamics>`


Where to go from here
=====================

The two places to learn more are the tutorials and the user guide:

* The :ref:`gala-tutorials` are narrative demonstrations of functionality that
  walk through simplified, real-world use cases for the tools available in
  ``gala``.
* The :ref:`gala-user-guide` contains more exhaustive descriptions of all of the
  functions and classes available in ``gala``, and should be treated more like
  reference material.


Bibliography
============

.. bibliography::
    :cited:
</file>

<file path="docs/glossary.rst">
*******************************
Glossary of Documentation Terms
*******************************

.. glossary::

    (`n`,)
        A parenthesized number followed by a comma denotes a tuple with one
        element. The trailing comma distinguishes a one-element tuple from a
        parenthesized ``n``.
        This is from NumPy; see https://numpy.org/doc/stable/glossary.html.

    number
        Any numeric type. eg float or int or any of the ``numpy.number``.

    -like
        Used to indicate on object of that type or that can instantiate the type.
        E.g. :class:`~astropy.units.Quantity`-like includes ``"2 * u.km"``
        because ``astropy.units.Quantity("2 * u.km")`` works.

    unit-like
        Must be an :class:`~astropy.units.UnitBase` (subclass) instance or a
        string or other instance parseable by :class:`~astropy.units.Unit`.

    quantity-like
        Must be an `~astropy.units.Quantity` (or subclass) instance or a string
        parseable by `~astropy.units.Quantity`.
        Note that the interpretation of units in strings depends on the class --
        ``Quantity("180d")`` is 180 **days**, while ``Angle("180d")`` is 180
        **degrees** -- so check the string parses as intended for ``Quantity``.

    angle-like
        :term:`quantity-like`, but interpreted by an angular
        `~astropy.units.SpecificTypeQuantity`, like `~astropy.coordinates.Angle`
        or `~astropy.coordinates.Longitude` or `~astropy.coordinates.Latitude`.
        Note that the interpretation of units in strings depends on the class --
        ``Quantity("180d")`` is 180 days, while ``Angle("180d")`` is 180 degrees
        -- so make sure the string parses as intended for ``Angle``.

    length-like
        :term:`quantity-like`, but interpretable by
        :class:`~astropy.coordinates.Distance`.

    frame-like
        A :class:`~astropy.coordinates.BaseCoordinateFrame` subclass instance or a
        string that can be converted to a Frame by
        :class:`~astropy.coordinates.sky_coordinate_parsers._get_frame_class`.

    coordinate-like
        A Coordinate-type object such as a
        :class:`~astropy.coordinates.BaseCoordinateFrame` subclass instance or a
        :class:`~astropy.coordinates.SkyCoord` (or subclass) instance.

    table-like
        An astropy :class:`~astropy.table.Table` or any object that can
        initialize one. Anything marked as table-like will be processed through
        a :class:`~astropy.table.Table`.

    time-like
        :class:`~astropy.time.Time` or any valid initializer.

    buffer-like
        Anything that implements Python's buffer protocol. See
        https://docs.python.org/3/c-api/buffer.html#bufferobjects

    writable file-like object
        In the context of a :term:`python:file-like object` object, anything
        that supports writing with a method ``write``.

    readable file-like object
        In the context of a :term:`python:file-like object` object, anything
        that supports writing with a method ``read``.
</file>

<file path="docs/index.rst">
.. include:: references.txt

.. raw:: html

   <img src="_static/Gala_Logo_RGB.png" width="50%"
    style="margin-bottom: 32px;"/>

.. module:: gala

****
Gala
****

Galactic Dynamics is the study of the formation, history, and evolution of
galaxies using the *orbits* of objects — numerically-integrated trajectories of
stars, dark matter particles, star clusters, or galaxies themselves.

``gala`` is an Astropy-affiliated Python package that aims to provide efficient
tools for performing common tasks needed in Galactic Dynamics research. Much of
this code uses Python for flexible, user-friendly interfaces that interact with
wrappers around low-level code (primarily C) to enable fast computations.
Common operations include `gravitational potential and force evaluations
<potential/index.html>`_, `orbit integrations <integrate/index.html>`_,
`dynamical coordinate transformations <dynamics/index.html>`_, and computing
`chaos indicators for nonlinear dynamics <dynamics/nonlinear.html>`_. ``gala``
heavily uses the units and astronomical coordinate systems defined in the
Astropy core package (:ref:`astropy.units <astropy-units>` and
:ref:`astropy.coordinates <astropy-coordinates>`).

This package is being actively developed in `a public repository on GitHub
<https://github.com/adrn/gala>`_, and we are always looking for new
contributors! No contribution is too small, so if you have any trouble with this
code, find a typo, or have requests for new content (tutorials or features),
please `open an issue on GitHub <https://github.com/adrn/gala/issues>`_.

.. note::

   Welcome to the new Gala documentation! The documentation has a new theme and
   some new content. Use the links in the nav bar above, the page listing below,
   or the search bar on the left to dive in!

.. ---------------------
.. Nav bar (top of docs)

.. toctree::
   :maxdepth: 1
   :titlesonly:

   install
   getting_started
   tutorials
   user_guide
   contributing


Contributors
============

.. include:: ../AUTHORS.rst


Citation and Attribution
========================

|JOSS| |DOI|

`Here is a list of papers that use Gala
<https://ui.adsabs.harvard.edu/search/q=citations(bibcode%3A2017JOSS....2..388P)&sort=date%20desc%2C%20bibcode%20desc&p_=0>`_

If you make use of this code, please cite the `JOSS <http://joss.theoj.org>`_
paper:

.. code-block:: bibtex

    @article{gala,
      doi = {10.21105/joss.00388},
      url = {https://doi.org/10.21105%2Fjoss.00388},
      year = 2017,
      month = {oct},
      publisher = {The Open Journal},
      volume = {2},
      number = {18},
      author = {Adrian M. Price-Whelan},
      title = {Gala: A Python package for galactic dynamics},
      journal = {The Journal of Open Source Software}}

Please also cite the Zenodo DOI |DOI| of the version you used as a software
citation:

.. include:: ZENODO.rst

.. |JOSS| image:: http://joss.theoj.org/papers/10.21105/joss.00388/status.svg
   :target: http://joss.theoj.org/papers/10.21105/joss.00388
.. |DOI| image:: https://zenodo.org/badge/17577779.svg
   :target: https://zenodo.org/badge/latestdoi/17577779
</file>

<file path="docs/install.rst">
.. include:: references.txt

.. _gala-install:

************
Installation
************

With ``pip`` (recommended)
==========================

To install the latest stable version using ``pip``, use::

    python -m pip install gala

This is the recommended way to install ``gala``.

To install the development version::

    python -m pip install git+https://github.com/adrn/gala


With ``conda``
==============

To install the latest stable version with ``conda``, use the ``conda-forge``
channel with::

    conda install -c conda-forge gala


From Source: Cloning, Building, Installing
==========================================

The latest development version of gala can be cloned from
`GitHub <https://github.com/>`_ using ``git``::

    git clone git://github.com/adrn/gala.git

To build and install the project (from the root of the source tree, e.g., inside
the cloned ``gala`` directory)::

    python -m pip install .


Installing on Windows
=====================

We have successfully installed Gala on Windows within an Anaconda installation,
which installs and uses GCC to compile C code. Unfortunately, Gala will not work
with Microsoft Visual Studio's C compiler because it is not C99 compliant. With
Anaconda, you can install ``gsl`` (see below) and then install Gala with
``pip``::

    pip install gala


GSL support
===========

Some functionality in Gala depends on the GNU Scientific Library (GSL), a C
library for numerical and mathematical programming. By default, Gala will
determine whether to install with or without GSL support depending on whether it
can find a GSL installation on your machine. If you are not sure whether you
have GSL installed or not, try running::

    gsl-config --version

in your terminal. If that returns a version number, you likely have GSL
installed. If it errors, you will need to install it. Additionally, if your
version of GSL is <1.14, we recommend updating to a newer version, as Gala has
only been tested with GSL >= 1.14.

Installing with ``conda``
-------------------------

If you use a Mac computer, we recommend installing GSL using the `anaconda
<https://www.anaconda.com/download/>`_ Python package manager. Using ``conda``,
you can install GSL with::

    conda install -c conda-forge gsl


Installing with ``apt``
-----------------------

If you use Linux, you can install GSL with anaconda (see directions above), or
with ``apt``. To install with apt, make sure to install both ``gsl-bin`` and
``libgsl0-dev``::

    apt-get install gsl-bin libgsl0-dev


Forcing gala to install without GSL support
-------------------------------------------

You can force Gala to build without GSL support using the ``--nogsl`` flag
passed to setup.py. To use this flag, you must install Gala from source by
cloning the repository (see above) and running::

    python -m pip install gala --install-option="--nogsl"


Python Dependencies
===================

This packages has the following dependencies:

* `Python`_ >= 3.7
* `Numpy`_
* `Cython <http://www.cython.org/>`_
* `Astropy`_
* `PyYAML`_
* `scipy`_

Explicit version requirements are specified in the project `setup.cfg
<https://github.com/adrn/gala/blob/main/setup.cfg>`_. ``pip`` and ``conda``
should install and enforce these versions automatically.

Optional
--------

- `Sympy`_ for creating :class:`~gala.potential.potential.PotentialBase`
  subclass instances from a mathematical expression using
  :func:`~gala.potential.potential.from_equation()`.
- ``galpy``
- `h5py`
- `matplotlib`
-
</file>

<file path="docs/interop.rst">
.. _gala-interop:

*********************************************
Interoperability with Other Dynamics Packages
*********************************************

Gala provides interfaces with other common Galactic dynamics packages, which
enables easily converting objects between these packages. Some examples are
shown below. As always, if something does not work as expected or you would like
more interoperability with any of these packages, please `open an issue
<https://github.com/adrn/gala/issues/new>`_ on GitHub.

Here are some imports we will use below in examples::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> import gala.dynamics as gd
    >>> import gala.potential as gp
    >>> from gala.units import galactic

Galpy
=====

`Galpy <https://docs.galpy.org/en/>`_ is another popular Python package for
Galactic dynamics with similar functionality to Gala. For example, Galpy
supports creating gravitational potential objects and numerically integrating
orbits (among other things).

Gala provides an interface for converting representations of orbits from Gala to
Galpy, or from Galpy to Gala. To convert a Gala :class:`~gala.dynamics.Orbit`
object to a Galpy ``Orbit``, use the
:meth:`~gala.dynamics.Orbit.to_galpy_orbit()` method:

.. doctest-requires:: galpy

    >>> w0 = gd.PhaseSpacePosition(pos=[10., 0, 0] * u.kpc,
    ...                            vel=[0, 0, 200.] * u.km/u.s)
    >>> mw = gp.Hamiltonian(gp.MilkyWayPotential())
    >>> orbit = mw.integrate_orbit(w0, dt=1, n_steps=1000)
    >>> orbit
    <Orbit cartesian, dim=3, shape=(1001,)>
    >>> galpy_orbit = orbit.to_galpy_orbit()
    >>> galpy_orbit  # doctest: +SKIP
    <galpy.orbit.Orbits.Orbit object at 0x7f99b3c8fe80>

Similarly, a Galpy ``Orbit`` can be converted to a Gala
:class:`~gala.dynamics.Orbit` using the
:meth:`~gala.dynamics.Orbit.from_galpy_orbit()` classmethod:

.. doctest-requires:: galpy

    >>> import galpy.potential as galpy_p
    >>> import galpy.orbit as galpy_o
    >>> mp = galpy_p.MiyamotoNagaiPotential(a=0.5, b=0.0375, amp=1.,
    ...                                     normalize=1.)
    >>> galpy_orbit = galpy_o.Orbit([1., 0.1, 1.1, 0., 0.1, 1.])
    >>> ts = np.linspace(0, 100, 10000)
    >>> galpy_orbit.integrate(ts, mp, method='odeint')
    >>> orbit = gd.Orbit.from_galpy_orbit(galpy_orbit)
    >>> orbit
    <Orbit cylindrical, dim=3, shape=(10000,)>

Gala also provides tools for converting potential objects to `galpy` potential
objects, or creating Gala potential objects from existing `galpy` potentials.
To convert a Gala potential to a Galpy potential, use the
:meth:`~gala.potential.potential.PotentialBase.to_galpy_potential()` method on
any Gala potential object. For example:

.. doctest-requires:: galpy

    >>> pot = gp.HernquistPotential(m=1e10*u.Msun, c=1.5*u.kpc, units=galactic)
    >>> galpy_pot = pot.to_galpy_potential()
    >>> galpy_pot  # doctest: +SKIP
    <galpy.potential.TwoPowerSphericalPotential.HernquistPotential at 0x7faa00263b20>
    >>> galpy_pot.Rforce(1., 0.)  # doctest: +FLOAT_CMP
    -0.48737954713808573

To convert from a Galpy potential to a Gala potential, use the
:func:`~gala.potential.potential.interop.galpy_to_gala_potential()` function. For
example:

.. doctest-requires:: galpy

    >>> import galpy.potential as galpy_gp
    >>> from gala.potential.potential.interop import galpy_to_gala_potential
    >>> galpy_pot = galpy_gp.HernquistPotential(amp=1., a=0.5)
    >>> pot = galpy_to_gala_potential(galpy_pot)
    >>> pot
    <HernquistPotential: m=4.50e+10, c=4.00 (kpc,Myr,solMass,rad)>


Agama
=====

Coming soon, but we could use your help! Please leave a note `in this issue
<https://github.com/adrn/gala/issues/230>`_ if you would find interoperability
with Agama useful.
</file>

<file path="docs/make.bat">
@ECHO OFF

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set BUILDDIR=_build
set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
if NOT "%PAPER%" == "" (
	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
)

if "%1" == "" goto help

if "%1" == "help" (
	:help
	echo.Please use `make ^<target^>` where ^<target^> is one of
	echo.  html       to make standalone HTML files
	echo.  dirhtml    to make HTML files named index.html in directories
	echo.  singlehtml to make a single large HTML file
	echo.  pickle     to make pickle files
	echo.  json       to make JSON files
	echo.  htmlhelp   to make HTML files and a HTML help project
	echo.  qthelp     to make HTML files and a qthelp project
	echo.  devhelp    to make HTML files and a Devhelp project
	echo.  epub       to make an epub
	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
	echo.  text       to make text files
	echo.  man        to make manual pages
	echo.  changes    to make an overview over all changed/added/deprecated items
	echo.  linkcheck  to check all external links for integrity
	echo.  doctest    to run all doctests embedded in the documentation if enabled
	goto end
)

if "%1" == "clean" (
	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
	del /q /s %BUILDDIR%\*
	goto end
)

if "%1" == "html" (
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
	goto end
)

if "%1" == "dirhtml" (
	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
	goto end
)

if "%1" == "singlehtml" (
	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
	goto end
)

if "%1" == "pickle" (
	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the pickle files.
	goto end
)

if "%1" == "json" (
	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the JSON files.
	goto end
)

if "%1" == "htmlhelp" (
	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run HTML Help Workshop with the ^
.hhp project file in %BUILDDIR%/htmlhelp.
	goto end
)

if "%1" == "qthelp" (
	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run "qcollectiongenerator" with the ^
.qhcp project file in %BUILDDIR%/qthelp, like this:
	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\Astropy.qhcp
	echo.To view the help file:
	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\Astropy.ghc
	goto end
)

if "%1" == "devhelp" (
	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished.
	goto end
)

if "%1" == "epub" (
	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The epub file is in %BUILDDIR%/epub.
	goto end
)

if "%1" == "latex" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "text" (
	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The text files are in %BUILDDIR%/text.
	goto end
)

if "%1" == "man" (
	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The manual pages are in %BUILDDIR%/man.
	goto end
)

if "%1" == "changes" (
	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
	if errorlevel 1 exit /b 1
	echo.
	echo.The overview file is in %BUILDDIR%/changes.
	goto end
)

if "%1" == "linkcheck" (
	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
	if errorlevel 1 exit /b 1
	echo.
	echo.Link check complete; look for any errors in the above output ^
or in %BUILDDIR%/linkcheck/output.txt.
	goto end
)

if "%1" == "doctest" (
	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
	if errorlevel 1 exit /b 1
	echo.
	echo.Testing of doctests in the sources finished, look at the ^
results in %BUILDDIR%/doctest/output.txt.
	goto end
)

:end
</file>

<file path="docs/Makefile">
# Makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = sphinx-build
PAPER         =
BUILDDIR      = _build

# Internal variables.
PAPEROPT_a4     = -D latex_paper_size=a4
PAPEROPT_letter = -D latex_paper_size=letter
ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .

.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest

#This is needed with git because git doesn't create a dir if it's empty
$(shell [ -d "_static" ] || mkdir -p _static)

help:
	@echo "Please use \`make <target>' where <target> is one of"
	@echo "  html       to make standalone HTML files"
	@echo "  dirhtml    to make HTML files named index.html in directories"
	@echo "  singlehtml to make a single large HTML file"
	@echo "  pickle     to make pickle files"
	@echo "  json       to make JSON files"
	@echo "  htmlhelp   to make HTML files and a HTML help project"
	@echo "  qthelp     to make HTML files and a qthelp project"
	@echo "  devhelp    to make HTML files and a Devhelp project"
	@echo "  epub       to make an epub"
	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
	@echo "  text       to make text files"
	@echo "  man        to make manual pages"
	@echo "  changes    to make an overview of all changed/added/deprecated items"
	@echo "  linkcheck  to check all external links for integrity"
	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"

clean:
	-rm -rf $(BUILDDIR)
	-rm -rf api
	-rm -rf tutorials/*.ipynb

html:
	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."

dirhtml:
	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."

singlehtml:
	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
	@echo
	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."

pickle:
	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
	@echo
	@echo "Build finished; now you can process the pickle files."

json:
	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
	@echo
	@echo "Build finished; now you can process the JSON files."

htmlhelp:
	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
	@echo
	@echo "Build finished; now you can run HTML Help Workshop with the" \
	      ".hhp project file in $(BUILDDIR)/htmlhelp."

qthelp:
	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
	@echo
	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/Astropy.qhcp"
	@echo "To view the help file:"
	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/Astropy.qhc"

devhelp:
	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
	@echo
	@echo "Build finished."
	@echo "To view the help file:"
	@echo "# mkdir -p $$HOME/.local/share/devhelp/Astropy"
	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/Astropy"
	@echo "# devhelp"

epub:
	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
	@echo
	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."

latex:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo
	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
	@echo "Run \`make' in that directory to run these through (pdf)latex" \
	      "(use \`make latexpdf' here to do that automatically)."

latexpdf:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo "Running LaTeX files through pdflatex..."
	make -C $(BUILDDIR)/latex all-pdf
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

text:
	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
	@echo
	@echo "Build finished. The text files are in $(BUILDDIR)/text."

man:
	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
	@echo
	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."

changes:
	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
	@echo
	@echo "The overview file is in $(BUILDDIR)/changes."

linkcheck:
	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
	@echo
	@echo "Link check complete; look for any errors in the above output " \
	      "or in $(BUILDDIR)/linkcheck/output.txt."

doctest:
	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
	@echo "Testing of doctests in the sources finished, look at the " \
	      "results in $(BUILDDIR)/doctest/output.txt."

exectutorials:
	jupytext --to ipynb --execute tutorials/*.py
	@echo "Finished executing tutorial notebooks. Look at the executed " \
	      "notebooks in tutorials/"

animations:
	python _static_animations.py
	@echo "Finished generating animation files"
</file>

<file path="docs/references.txt">
.. _Astropy: http://astropy.org
.. _Matplotlib: http://www.matplotlib.org
.. _Numpy: http://www.numpy.org
.. _Python: http://www.python.org
.. _PyYAML: http://pyyaml.org/
.. _Sympy: http://docs.sympy.org/
.. _emcee: http://dan.iel.fm/emcee/current/
.. _scipy: https://docs.scipy.org
</file>

<file path="docs/refs.bib">
@book{Binney2008,
  title={Galactic Dynamics: Second Edition},
  author={Binney, J. and Tremaine, S.},
  isbn={9781400828722},
  lccn={2007937669},
  series={Princeton Series in Astrophysics},
  year={2008},
  publisher={Princeton University Press},
  url = {https://ui.adsabs.harvard.edu/abs/2008gady.book.....B},
}
</file>

<file path="docs/testing.rst">
.. _gala-test:

=================
Running the tests
=================

The tests are written assuming they will be run with `tox
<https://tox.readthedocs.io/en/latest/>`_ or `pytest <http://doc.pytest.org/>`_.

To run the tests with tox, first make sure that tox is installed;

    pip install tox

then run the basic test suite with:

    tox -e test

or run the test suite with all optional dependencies with:

    tox -e test-alldeps

You can see a list of available test environments with:

    tox -l -v

which will also explain what each of them does.

You can also run the tests directly with pytest. To do this, make sure to
install the testing requirements (from the cloned ``gala`` repository
directory)::

    pip install -e ".[test]"

Then you can run the tests with:

    pytest gala
</file>

<file path="docs/tutorials.rst">
.. _gala-tutorials:

*********
Tutorials
*********

The tutorials listed below are meant to be step-by-step demonstrations of common
functionality in `gala`. If you are interested in contributing a tutorial, or
requesting a tutorial about material that is not covered here, please `open an
issue on GitHub <https://github.com/adrn/gala/issues>`_.

.. The _tutorials.rst file is auto-generated in conf.py. Add new tutorials to
.. the list of files in conf.py

.. include:: _tutorials.rst
</file>

<file path="docs/units.rst">
.. include:: references.txt

.. _gala-units:

***************************
Unit Systems (`gala.units`)
***************************

Introduction
============

This module contains a class for handling systems of units, and provides a few
pre-defined unit systems that are useful for galactic dynamics.

For the examples below, I assume the following imports have already been
executed::

    >>> import astropy.units as u
    >>> import numpy as np
    >>> from gala.units import UnitSystem

Unit Systems
============

A unit system is defined by a set of base units that specify length, time, mass,
and angle units. A `~gala.units.UnitSystem` object is created by passing in
units with (at least) these four required physical types::

    >>> usys = UnitSystem(u.cm, u.millisecond, u.degree, u.gram)
    >>> usys
    <UnitSystem (cm, ms, g, deg)>

Astropy :class:`~astropy.units.Quantity` objects can be decomposed into this
unit system using :meth:`~astropy.units.Quantity.decompose`::

    >>> a = 15 * u.km/u.s
    >>> a.decompose(usys)
    <Quantity 1500. cm / ms>

`~gala.units.UnitSystem` objects can also act as a dictionary to look up a unit
for a given physical type. For example, if we want to know what a 'velocity'
unit is in a given unit system, pass the key ``'speed'`` or ``'velocity'``::

    >>> usys['speed']
    Unit("cm / ms")

This works for the base unit physical types and for more complex physical
types::

    >>> usys['length']
    Unit("cm")
    >>> usys['pressure']
    Unit("g / (cm ms2)")

In Astropy version 4.3 and later, units from `~gala.units.UnitSystem` objects
can also be retrieved by passing in Astropy ``PhysicalType`` instances as keys,
for example:

.. doctest-requires:: astropy>=4.3

    >>> ptype = u.get_physical_type('length')**2 / u.get_physical_type('time')
    >>> usys[ptype]
    Unit("cm2 / ms")


Creating unit systems with scaled base units
--------------------------------------------

It is sometimes useful to construct a unit system with base units that are
scaled versions of units. For example, you may want to create a unit system with
the base units (10 kpc, 200 Myr, 1000 Msun). To construct a
`~gala.units.UnitSystem` with scaled base units, pass in
`~astropy.units.Quantity` objects. For example::

    >>> usys = UnitSystem(10 * u.kpc, 200 * u.Myr, 1000 * u.Msun, u.radian)
    >>> usys
    <UnitSystem (10.0 kpc, 200.0 Myr, 1000.0 solMass, rad)>
    >>> q = 15.7 * u.kpc
    >>> q.decompose(usys)
    <Quantity 1.57 10.0 kpc>

Or, to create a unit system in which G=1, given length and mass units::

    >>> from astropy.constants import G
    >>> L_unit = 1 * u.kpc
    >>> M_unit = 1e6 * u.Msun
    >>> T_unit = np.sqrt((L_unit**3) / (G * M_unit))
    >>> usys = UnitSystem(L_unit, M_unit, T_unit.to(u.Myr), u.radian)
    >>> np.round(usys.get_constant('G'), 5)  # doctest: +FLOAT_CMP
    1.0


Custom display units
--------------------

It is sometimes useful to have default display units for physical types that are
not simple compositions of base units. For example, for kinematics within the
Milky Way, a common base unit system consists of (kpc, Myr, Msun), but
velocities are often expressed or displayed in km/s. To change the default
display unit of a composite unit, specify the preferred unit on creation::

    >>> usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun)
    >>> usys2 = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun, u.km/u.s)
    >>> usys['velocity'], usys2['velocity']
    (Unit("kpc / Myr"), Unit("km / s"))

For unit systems with specified composite units (e.g., ``usys2`` above),
the Astropy :meth:`~astropy.units.Quantity.decompose` method will fail because
it only uses the base units::

    >>> q = 150 * u.pc/u.Myr
    >>> q.decompose(usys2)
    <Quantity 0.15 kpc / Myr>

Because we specified a unit for quantities with a physical type = 'velocity', we
can instead use the `~gala.units.UnitSystem.decompose` method of the
`~gala.units.UnitSystem` object to retrieve the object in the desired display
unit::

    >>> usys2.decompose(q)
    <Quantity 146.66883325 km / s>


.. _gala-units-api:

API
===

.. automodapi:: gala.units
    :no-inheritance-diagram:
</file>

<file path="docs/user_guide.rst">
.. include:: references.txt

.. _gala-user-guide:

**********
User Guide
**********

The user guide contains exhaustive descriptions of all of the functions and
classes available in ``gala``, with some inline narrative descriptions and
demonstrations of functionality. This portion of the documentation should be
treated like reference material, whereas the :ref:`gala-tutorials` show how
pieces of ``gala`` work together to meet more realistic research needs.

.. toctree::
    :maxdepth: 1

    conventions
    coordinates/index
    integrate/index
    potential/index
    dynamics/index
    units
    util
    interop

.. toctree::
    :hidden:

    glossary


Recent additions and changes
============================

.. toctree::
    :maxdepth: 2

    whatsnew/index
</file>

<file path="docs/util.rst">
.. include:: references.txt

.. _util:

*****************************
Misc. Utilities (`gala.util`)
*****************************

Introduction
============

This subpackage contains miscellaneous utilities.

.. _util-api:

API
===

.. automodapi:: gala.util
    :no-inheritance-diagram:
</file>

<file path="gala/coordinates/tests/gd1_coord.txt">
# ra dec phi1 phi2
09:41:05.35 +31:51:11.6 -45.23 -0.04
09:47:05.26 +33:29:39.8 -43.17 -0.09
09:57:40.48 +36:23:33.0 -39.54 -0.07
09:59:10.43 +36:32:06.6 -39.25 -0.22
10:02:22.01 +37:41:13.3 -37.95 0.00
10:02:22.02 +37:40:49.2 -37.96 -0.00
10:10:33.02 +39:33:00.8 -35.49 -0.05
10:11:10.08 +39:44:53.9 -35.27 -0.02
10:12:54.83 +39:55:25.6 -34.92 -0.15
10:13:12.05 +40:06:13.3 -34.74 -0.08
10:17:02.15 +40:47:47.3 -33.74 -0.18
10:19:51.76 +41:27:01.5 -32.90 -0.15
10:22:16.20 +41:55:34.7 -32.25 -0.17
10:30:03.87 +43:43:51.7 -29.95 -0.00
10:43:41.92 +46:02:24.7 -26.61 -0.11
10:48:40.98 +46:49:22.1 -25.45 -0.14
10:50:36.96 +47:20:00.1 -24.86 0.01
11:07:11.27 +49:44:15.9 -21.21 -0.02
11:42:42.08 +53:38:41.4 -14.47 -0.15
11:47:24.59 +53:55:46.8 -13.73 -0.28
11:51:16.08 +54:21:42.7 -13.02 -0.21
11:53:26.06 +54:29:30.6 -12.68 -0.26
11:54:04.06 +54:35:11.4 -12.55 -0.23
</file>

<file path="gala/coordinates/tests/idl_vgsr_vhel.txt">
# Generated on Pluto with:
# cd ~/idl; .run gen_vgsr_vlsr.pro
vgsr vhelio lon lat vx vy vz vcirc
145.27689      -9.7038757       133.81944       8.3894563       10.000000       5.2500000       7.1700000       220.00000
169.04614       304.52197      -140.86899      -28.226425       10.000000       5.2500000       7.1700000       220.00000
133.27568       330.82190      -86.572759      -30.131925       10.000000       5.2500000       7.1700000       220.00000
87.451613       95.819095      -176.67310      -86.998226       10.000000       5.2500000       7.1700000       220.00000
112.44316       51.358363       134.93058       69.092835       10.000000       5.2500000       7.1700000       220.00000
168.52828       158.93319       62.899926       89.322302       10.000000       5.2500000       7.1700000       220.00000
103.84485       131.61956      -36.095688      -80.436729       10.000000       5.2500000       7.1700000       220.00000
82.072800       96.121045      -67.277774       84.037986       10.000000       5.2500000       7.1700000       220.00000
50.947523      -152.88408       79.862452      -22.441270       10.000000       5.2500000       7.1700000       220.00000
120.87593       142.44635      -174.48969      -61.029715       10.000000       5.2500000       7.1700000       220.00000
17.195083       9.5552317       175.16499      -9.9948549       10.000000       5.2500000       7.1700000       220.00000
76.202875      -65.174392       83.613896      -49.262701       10.000000       5.2500000       7.1700000       220.00000
137.01190       140.71996      -61.775447       86.784600       10.000000       5.2500000       7.1700000       220.00000
60.469735       33.176020       115.85167      -80.025637       10.000000       5.2500000       7.1700000       220.00000
161.75715       209.64615      -15.593086       13.336673       10.000000       5.2500000       7.1700000       220.00000
188.07985       25.653101       97.646441      -41.133322       10.000000       5.2500000       7.1700000       220.00000
46.447626      -30.983915       102.24765       71.090587       10.000000       5.2500000       7.1700000       220.00000
73.815143       258.81175      -127.24733       1.9942224       10.000000       5.2500000       7.1700000       220.00000
51.664239       10.716315       37.137716      -70.644772       10.000000       5.2500000       7.1700000       220.00000
170.25570       203.80804      -10.905401      -10.483135       10.000000       5.2500000       7.1700000       220.00000
77.269733      -14.850929       99.013510      -63.508146       10.000000       5.2500000       7.1700000       220.00000
78.440696       78.793989      -109.96917       87.997001       10.000000       5.2500000       7.1700000       220.00000
107.48701       138.66585      -172.87862      -46.689373       10.000000       5.2500000       7.1700000       220.00000
63.167393      -70.302844       34.186556      -5.6682158       10.000000       5.2500000       7.1700000       220.00000
4.4647414      -17.844732       64.992800      -81.886292       10.000000       5.2500000       7.1700000       220.00000
41.314867      -107.06390       40.135846       16.818459       10.000000       5.2500000       7.1700000       220.00000
72.410160      -84.928541       105.10391      -41.045592       10.000000       5.2500000       7.1700000       220.00000
160.79572       261.79841      -145.03000      -45.711338       10.000000       5.2500000       7.1700000       220.00000
152.14952       159.38269      -11.952353       67.889714       10.000000       5.2500000       7.1700000       220.00000
196.36809       379.21745      -76.688540       30.694277       10.000000       5.2500000       7.1700000       220.00000
171.36635       232.74057      -60.954552       69.240013       10.000000       5.2500000       7.1700000       220.00000
183.62998      -7.6627794       72.358081       30.451484       10.000000       5.2500000       7.1700000       220.00000
130.48239       143.47340      -121.13025      -88.314268       10.000000       5.2500000       7.1700000       220.00000
102.75310      -112.08993       94.981227      -14.291722       10.000000       5.2500000       7.1700000       220.00000
52.358925      -39.194184       40.822749      -51.139823       10.000000       5.2500000       7.1700000       220.00000
30.049574       26.190235      -3.1199348       48.467549       10.000000       5.2500000       7.1700000       220.00000
57.134712       84.472978      -10.235331      -41.575597       10.000000       5.2500000       7.1700000       220.00000
149.02765       201.12182      -159.78448       48.768793       10.000000       5.2500000       7.1700000       220.00000
98.847246      -38.562605       139.01894      -8.8301486       10.000000       5.2500000       7.1700000       220.00000
10.030560       145.93902      -47.149072      -33.558190       10.000000       5.2500000       7.1700000       220.00000
1.9450342       27.967519      -140.83172       77.286233       10.000000       5.2500000       7.1700000       220.00000
1.8910473      -52.645474       139.70198       69.738293       10.000000       5.2500000       7.1700000       220.00000
120.37269       87.554328       13.617768      -52.176325       10.000000       5.2500000       7.1700000       220.00000
52.171779      -122.69728       91.245596      -37.199509       10.000000       5.2500000       7.1700000       220.00000
125.68437       45.764112       43.554204       63.089311       10.000000       5.2500000       7.1700000       220.00000
17.516626       69.923546      -35.796461       61.646937       10.000000       5.2500000       7.1700000       220.00000
98.616129       221.55214      -144.23160       25.616620       10.000000       5.2500000       7.1700000       220.00000
85.392064       277.43480      -66.331394      -20.451608       10.000000       5.2500000       7.1700000       220.00000
28.926778       253.53562      -88.103957      -4.7928768       10.000000       5.2500000       7.1700000       220.00000
171.44415       88.082246       153.27198      -21.441295       10.000000       5.2500000       7.1700000       220.00000
63.469237       253.17133      -61.092739      -11.888114       10.000000       5.2500000       7.1700000       220.00000
56.194806       34.083141       96.410973       86.149206       10.000000       5.2500000       7.1700000       220.00000
69.060171       185.36066      -145.46325      -34.332013       10.000000       5.2500000       7.1700000       220.00000
88.575321       212.90764      -137.15085       36.745963       10.000000       5.2500000       7.1700000       220.00000
182.83077       95.538532       118.99421       65.140976       10.000000       5.2500000       7.1700000       220.00000
154.12424       204.18126      -44.269710       67.803186       10.000000       5.2500000       7.1700000       220.00000
103.77641       59.016087       41.335330       76.001465       10.000000       5.2500000       7.1700000       220.00000
184.73721       234.61932      -169.85702      -3.8651544       10.000000       5.2500000       7.1700000       220.00000
110.74874       322.56280      -75.752642       9.3689454       10.000000       5.2500000       7.1700000       220.00000
61.611992      -33.845084       22.953701      -6.9955122       10.000000       5.2500000       7.1700000       220.00000
59.878671      -128.92697       106.11553      -26.030983       10.000000       5.2500000       7.1700000       220.00000
50.308847       27.560162       18.396842      -68.582552       10.000000       5.2500000       7.1700000       220.00000
180.82055       252.34830      -116.69878       67.671179       10.000000       5.2500000       7.1700000       220.00000
65.158081       84.158616      -7.0217550      -24.356196       10.000000       5.2500000       7.1700000       220.00000
50.380176      -100.14121       71.356223      -44.119935       10.000000       5.2500000       7.1700000       220.00000
157.36456       228.76542      -93.951886       69.720097       10.000000       5.2500000       7.1700000       220.00000
120.85403       229.01125      -100.78955      -62.863590       10.000000       5.2500000       7.1700000       220.00000
127.49174       114.69633       123.77944      -83.704010       10.000000       5.2500000       7.1700000       220.00000
92.034221       149.84488      -156.13862      -58.982804       10.000000       5.2500000       7.1700000       220.00000
111.88915      -36.563154       124.11742      -32.634223       10.000000       5.2500000       7.1700000       220.00000
193.73622       183.31131       175.52644       39.505881       10.000000       5.2500000       7.1700000       220.00000
80.316168       299.36763      -87.484785      -14.712190       10.000000       5.2500000       7.1700000       220.00000
136.31881       327.07343      -113.60722       23.078424       10.000000       5.2500000       7.1700000       220.00000
65.155220       53.284689       129.85561       88.381330       10.000000       5.2500000       7.1700000       220.00000
12.517159       56.956210      -148.86380      -72.498268       10.000000       5.2500000       7.1700000       220.00000
11.832282       58.384103      -46.667122      -75.383374       10.000000       5.2500000       7.1700000       220.00000
35.120487       94.150053      -104.02142       72.655152       10.000000       5.2500000       7.1700000       220.00000
157.37199      -56.441566       104.49897      -5.6619394       10.000000       5.2500000       7.1700000       220.00000
158.67301      -18.910976       119.51456      -19.625375       10.000000       5.2500000       7.1700000       220.00000
197.48440       193.19573      -2.1077549       22.175560       10.000000       5.2500000       7.1700000       220.00000
150.88863       68.111994       133.41778       60.778180       10.000000       5.2500000       7.1700000       220.00000
156.35009       26.846421       62.251518       52.635691       10.000000       5.2500000       7.1700000       220.00000
165.21263       126.88079       129.66011       79.203004       10.000000       5.2500000       7.1700000       220.00000
190.70699       224.22333      -16.306844      -59.351988       10.000000       5.2500000       7.1700000       220.00000
11.083476      -105.34446       106.74743      -54.924197       10.000000       5.2500000       7.1700000       220.00000
79.980648       9.4684636       136.54562      -58.733007       10.000000       5.2500000       7.1700000       220.00000
85.608834      -4.1354889       82.771769       68.301766       10.000000       5.2500000       7.1700000       220.00000
117.99765      -36.171932       43.793886      -16.696665       10.000000       5.2500000       7.1700000       220.00000
12.968862       56.345430      -171.60231      -10.679145       10.000000       5.2500000       7.1700000       220.00000
190.09255       337.34509      -109.10203      -48.980455       10.000000       5.2500000       7.1700000       220.00000
185.22285       131.08997       13.086133      -21.007415       10.000000       5.2500000       7.1700000       220.00000
17.237936       8.9755399       14.344261       89.043417       10.000000       5.2500000       7.1700000       220.00000
56.840372       64.661369       178.27013      -70.898742       10.000000       5.2500000       7.1700000       220.00000
70.039821       217.82366      -135.76793      -28.515905       10.000000       5.2500000       7.1700000       220.00000
197.89181       326.80680      -147.69186      -5.7187754       10.000000       5.2500000       7.1700000       220.00000
66.007274       109.55954      -155.52948       60.891627       10.000000       5.2500000       7.1700000       220.00000
21.133356       155.62241      -94.341375      -55.204746       10.000000       5.2500000       7.1700000       220.00000
40.521133      -2.7274873       101.62888      -76.717379       10.000000       5.2500000       7.1700000       220.00000
168.93314       144.51827       158.95423       75.875916       10.000000       5.2500000       7.1700000       220.00000
182.01933       27.937780       116.30215      -36.692217       10.000000       5.2500000       7.1700000       220.00000
105.36193       308.93934      -76.388454      -21.929778       10.000000       5.2500000       7.1700000       220.00000
</file>

<file path="gala/coordinates/tests/sergey_orphan.txt">
ra dec heldist pmra pmdec
331.656268727199 -39.1494735064355 48.94275665283203 0.275502094564918 -1.90136163958481
293.207792053576 -72.1501688676437 23.54404067993164 -1.3184361011096 -3.05581782891287
276.187586857079 -74.2053120701785 22.482805252075195 -2.73889205791694 -2.93815838761522
150.647210839262 25.2475372502567 30.127817153930664 -1.14154408128601 0.11556699031599
337.491208968931 -35.9809553138202 65.90168762207031 0.308802278558686 -2.39162424650324
321.186789848392 -58.6864066475143 32.219417572021484 -0.0201789209868324 -3.1351474530663
312.652439082338 -64.4924261188689 26.433963775634766 -0.294161055956984 -3.17663203568946
151.355318100332 31.8214671652644 32.701927185058594 -1.38986708164431 -0.0624748870333711
328.873164663832 -46.2751928589657 41.209957122802734 0.58055590481148 -2.18649050997115
321.6763394678 -57.4584922673689 33.40642166137695 0.21922310431726 -2.59203742820928
139.253641805087 59.99006112678 51.32103729248047 -1.05569944272779 -0.529217864574912
163.830931646923 -7.17632329663041 20.638774871826172 -2.24310351642533 0.952962244335287
227.707942296213 -74.5751407345744 20.46157455444336 -4.49398440731588 -0.0504445582946376
322.460826733656 -53.3119852345322 31.669666290283203 -1.19697275065527 -2.49199751931073
144.271652120049 42.6033461257059 40.673301696777344 -0.921642544189141 -0.329184060812681
333.931325597367 -36.1278818683978 51.142250061035156 0.392143079100081 -1.29620938267014
331.024930582206 -46.4820572528627 40.502647399902344 0.646912650955056 -1.90001440775087
303.093499650652 -69.342947548902 24.661487579345703 -0.971822585078517 -3.44621427192038
305.875180966415 -69.2976345947213 25.77305793762207 -0.888956244162022 -3.47780110580793
167.347752830898 -15.075464717577 16.240188598632812 -2.2892922821692 2.06937239165835
151.505215906905 21.8255435446019 27.48371696472168 -0.785819004590304 -0.333674055085537
152.071670360829 23.9278787869736 30.73844337463379 -1.18730646461807 -0.353085892381391
164.396123120276 -11.1175043906765 18.07723617553711 -2.11267126036593 1.5123454120638
173.696689912493 -39.1855527815594 16.976722717285156 -2.6425840000258 2.77581360897632
145.026602904993 37.0093221822231 37.711158752441406 -0.879038660753651 -0.301319747126616
329.882858144102 -42.1832806382058 43.935791015625 0.227479963240135 -1.67182318539629
247.349266645387 -75.0976666324103 19.71449851989746 -3.82435532776039 -1.4917599122383
141.251727462669 47.4911157524096 45.669349670410156 -0.278242985109598 -0.307294228328076
319.785515336155 -59.6393302694962 31.54485511779785 0.047739431612579 -2.40414998706106
327.339698353149 -51.3576679680571 35.93385696411133 -0.220008264417831 -2.51701058290811
152.582826821556 30.0942988810024 28.22689437866211 -0.58865006685347 -0.340007941899313
320.988534580899 -57.7146011478339 29.099069595336914 -0.00958390800105136 -2.74560738568651
220.852803879764 -66.7156233432215 17.022340774536133 -5.18777178618725 -0.97646436084972
167.721883134802 -12.6323511530982 15.793251037597656 -2.83127757994372 1.54462685609338
147.546673452101 40.7438838995295 37.3227653503418 -0.821214597441585 -0.480256930835946
167.131444430117 -14.7717672020525 17.761720657348633 -2.1216105451589 1.7433114677517
331.186545167623 -43.0982906857441 50.890968322753906 -0.610206067378906 -1.41189295152624
328.194713983779 -54.7179905020298 38.57564926147461 -0.0462423261285688 -1.62430832304693
152.216507095956 24.6900514244275 30.889453887939453 -0.651694950266064 -0.416279187880993
158.493803400453 9.23572867234607 21.911914825439453 -1.46320930150025 0.257714602568118
133.767250366739 63.421955667313 60.80267333984375 0.112499522111556 0.316383090930176
267.792298438136 -76.5683647906811 22.964237213134766 -3.34683189339476 -2.67084505548613
175.508519462991 -35.6355189006247 16.952136993408203 -3.63595288158065 2.63146918902653
175.71430365816 -35.9059737865278 14.887802124023438 -3.23593395562877 2.67912110577346
146.05782226 40.220710513616 35.53816223144531 -0.490328757988808 -0.614686197975269
267.042326066391 -75.535904972213 22.184555053710938 -3.23887574250766 -2.50421707762825
304.197528543648 -68.8783485676048 26.610563278198242 -1.03126733560467 -3.68941994712539
331.528469068592 -40.1526580883535 49.20958709716797 0.771884448238906 -1.87558926441079
334.320920119124 -36.9923997777259 53.25858688354492 -1.73868585679 -1.42629873074948
176.611558291875 -42.0901937221425 16.994598388671875 -2.98034342610662 2.81674576466133
268.911282774028 -74.9033693787264 22.947551727294922 -2.94603037254696 -2.74431509606787
150.544325762388 24.2579579140146 28.53543472290039 -0.922626635857103 0.0551499801293074
327.549050560892 -51.2316417356703 39.85669708251953 -0.130252415711607 -2.40474378525471
277.274979991097 -74.5129426188047 23.65250015258789 -2.64959081741315 -3.3237918256725
334.471022977277 -40.034551896847 47.84756851196289 -0.699663676139994 -2.42654873147082
141.131353916363 49.3827280774458 44.929603576660156 -0.945642339734397 -0.177452337927581
171.190128111526 -27.7661291336537 16.469024658203125 -2.88244358402989 2.61476835724803
327.123824545822 -52.0011500934603 36.05494689941406 0.318899686944192 -1.95924813829475
144.528109788428 37.5810665084326 42.98106384277344 -0.986676828657994 -0.36530337233171
143.482582947134 39.1340164001215 43.57024002075195 -0.491155290464352 -0.395145775049435
147.342795310205 33.3916195331805 38.829017639160156 -0.890086521291787 -0.349427851524645
171.583614704294 -22.2226913600165 16.18654441833496 -2.7299976317042 1.98888975579952
320.693552236731 -57.2344959529479 30.61488151550293 -0.041732230070479 -2.20466059702778
241.991046389872 -75.4177099762491 21.731552124023438 -4.27061010736551 -1.02269959798722
248.453690386539 -76.0054384119753 22.36843490600586 -3.9289132586056 -1.78723558624701
169.221733207832 -19.063533544435 15.636909484863281 -2.46677738074977 2.11037669561487
304.191404303552 -70.2919997010971 25.4582462310791 -0.991560747640472 -3.56114107437359
318.52474048703 -62.094476954987 28.488649368286133 -0.13792348942345 -2.74599580635714
323.55587264487 -53.2674825396641 34.99247360229492 0.0831773389682677 -1.93242207864066
144.295039256419 43.4294338181809 42.850379943847656 -0.722842507984231 -0.480100444878437
322.958291893299 -48.219714300802 31.142953872680664 0.463740748369967 -2.24300403048729
335.156303783494 -33.6112047454209 71.57916259765625 -0.474563452735716 -1.73660771730043
167.30175659002 -17.8882894537849 16.78110694885254 -1.98405160997099 1.81563886372094
154.824907507749 18.2260249614617 26.938472747802734 -1.11771922828731 0.145513652389975
207.095243805969 -69.2916071233026 19.035900115966797 -4.62431522020742 1.50199462500962
253.1748346874 -75.8355883197752 21.842988967895508 -3.62503586421494 -1.60231398573103
334.263622909749 -42.9058343330995 58.21311569213867 0.0392271270893364 -1.63070161603448
114.553547848371 74.6587943369533 65.52909088134766 -0.877267840342211 0.853007624993862
178.474275795131 -43.6816569706336 16.64564323425293 -3.17291182925756 2.84282912830923
329.95072931208 -46.9623355161414 39.56492233276367 -0.0285605332440401 -2.61606556406385
330.337830168447 -40.4510112504214 45.7772331237793 -0.19345196182297 -2.37985170079177
170.885072935041 -25.0127518925711 16.357250213623047 -2.81841890440791 2.26621859788188
151.892513608016 24.8314953198482 28.448436737060547 -1.04019302641556 -0.415071605841914
294.105776263919 -70.9383939646023 25.22552490234375 -1.47870744415329 -3.29851132823831
251.05257440862 -75.4327557866322 20.823348999023438 -3.88485576084044 -1.75632189659296
262.382973531405 -75.112112612984 21.694849014282227 -3.44672014508187 -2.48450984862277
325.476833773279 -51.8413860676659 37.11676025390625 0.415320207444506 -2.13989036858248
328.79860468495 -40.2413375529223 39.092071533203125 0.241141208180398 -1.69217293341234
174.223814490934 -39.6480955046629 16.168621063232422 -3.44019687847852 2.3912615210134
335.047994202228 -37.761164463241 53.560089111328125 -0.63886325827331 -2.6173286275245
293.888023000471 -72.8506477956235 24.643474578857422 -1.74487701840178 -3.46839127156476
147.378997866161 38.736922992096 38.51921081542969 -0.574023368857901 -0.0972016594724718
334.171079321919 -32.9669577313105 62.985260009765625 -0.146607454911846 -1.78339941217577
333.465929342388 -29.9407695798036 58.635494232177734 -0.739486743788352 -0.972410346793908
143.085975568686 48.6342412605024 46.698524475097656 -0.489004199766334 -0.306851373213502
321.894898188485 -59.0889600406313 30.41132354736328 0.635148021296196 -2.9054525070692
145.985156824802 43.113887013814 42.95452880859375 -1.18614435719525 -0.251294436840299
150.57982949547 26.5980017685555 31.408964157104492 -0.76280730319545 -0.419197368507948
229.579888093682 -70.684555715814 18.78251075744629 -5.86788930045218 -0.293514674482599
142.596425247819 49.4408534432069 47.05882263183594 0.437290016028731 -0.034100016898537
160.481467351754 0.588999297660749 19.39857292175293 -1.76072785444136 1.0732018487449
206.993603024506 -69.2417779644621 20.374000549316406 -4.06902503388389 1.52594368287413
332.192457544903 -38.9627922666303 49.94127655029297 0.178330606808803 -2.04361295006038
164.408852142303 -7.64784553896387 18.94601058959961 -2.03320809763093 1.37753758006076
140.409682708163 48.0145216867802 44.545806884765625 -0.406949849029145 -0.284396943764083
173.14521858307 -32.1904810471076 16.879117965698242 -2.81165551145129 2.45360717035461
154.125880106466 15.4385626491427 24.616390228271484 -1.61996798974885 0.294800883921636
324.074335285375 -56.6715091653565 30.79861068725586 0.165515070836532 -2.70655223244457
166.804842876522 -13.8978067021033 17.22536277770996 -2.19343555621679 1.67887067837575
334.188789946946 -35.1367135276638 57.822120666503906 -0.0179573960051011 -1.26352830175094
315.741834661905 -61.1982758908799 30.109464645385742 -0.00842909925511814 -3.11197268012093
154.518851528449 17.1944519367271 24.422061920166016 -0.780532917511822 -0.132296479647955
132.383725246011 63.2921537387669 64.04721069335938 -0.710689651513906 -0.619402328738766
</file>

<file path="gala/coordinates/tests/SgrCoord_data">
# l,b,lambda,beta
111.413000,13.510000,168.128916,-72.827611
174.123000,10.120000,173.665905,-11.595970
18.340000,-19.124500,8.135988,-8.928467
272.435000,68.460000,255.400865,8.074558
14.341000,45.136000,302.340030,-16.922319
1.000000,81.512000,264.587983,-12.904682
71.450000,-71.235000,68.860235,-3.959954
50.130000,21.535000,328.558258,-47.760479
200.140000,1.641000,171.457470,15.524190
310.124000,-11.513460,346.920841,54.463997
</file>

<file path="gala/coordinates/tests/SgrCoord.cpp">
#include "SgrCoord.h"
#include <fstream>

int main()
{
    using namespace std;

    double l, b, r;
    double Xs, Ys, Zs, lambda, beta, lambda_gc, beta_gc, d;
    double Xsun = 8.0;

    r = 1.0;
    double ls[] = {111.413, 174.123, 18.34, 272.435, 14.341, 1.0, 71.45, 50.13, 200.14, 310.124};
    double bs[] = {13.51, 10.12, -19.1245, 68.46, 45.136, 81.512, -71.235, 21.535, 1.641, -11.51346};

    ofstream output_file;
    output_file.open ("SgrCoord_data");

    output_file << "# l,b,lambda,beta\n";
    for (int i=0; i < 10; i++) {
        char buffer [50];

        l = ls[i];
        b = bs[i];
        LBRtoSgr(l,b,r,Xs,Ys,Zs,lambda,beta,Xsun);

        sprintf(buffer, "%f,%f,%f,%f\n", l, b, lambda, beta);
        output_file << buffer;
    }

    output_file.close();

    return 0;
}
</file>

<file path="gala/coordinates/tests/SgrCoord.h">
// SgrCoord.h
// C++ header file of transformation code to the Sgr longitudinal coordinate systems
// defined by Majewski et al. 2003 (ApJ, 599, 1082).
// Author: David R. Law (drlaw@virginia.edu), University of Virginia
// June 2003
// http://www.astro.virginia.edu/~drl5n/Sgr/
//
// This transformation code has been made publically available to promote the use
// of the Sgr longitudinal coordinate system, and may be used freely.  However,
// please acknowledge this website when using this code, and leave all
// header information intact.
//
// Last modified Jan 2010.
// Modification revises Z_Sgr and Z_Sgr,GC to be positive in the direction of the
// orbital pole of Sgr (i.e., match the convention already used for beta)

#include <cmath>
#include <fstream>
using namespace std;

// Transform positions from standard left handed Galactocentric XYZ to
// the heliocentric Sgr system (lambda=0 at Sgr)
// Input must be in kpc of the form X Y Z
// Output is in kpc and degrees, of the form X_Sgr Y_Sgr Z_Sgr r lambda beta
void XYZtoSgr(double X,double Y,double Z,double &Xs,double &Ys,double &Zs,double &r,double &lambda,double &beta,double Xsun=7.0)  
  {
  double radpdeg=3.141592653589793/180.;
  // Define the Euler angles
  double phi=(180+3.75)*radpdeg;
  double theta=(90-13.46)*radpdeg;
  double psi=(180+14.111534)*radpdeg;

  // Define the rotation matrix from the Euler angles
  double rot11=cos(psi)*cos(phi)-cos(theta)*sin(phi)*sin(psi);
  double rot12=cos(psi)*sin(phi)+cos(theta)*cos(phi)*sin(psi);
  double rot13=sin(psi)*sin(theta);
  double rot21=-sin(psi)*cos(phi)-cos(theta)*sin(phi)*cos(psi);
  double rot22=-sin(psi)*sin(phi)+cos(theta)*cos(phi)*cos(psi);
  double rot23=cos(psi)*sin(theta);
  double rot31=sin(theta)*sin(phi);
  double rot32=-sin(theta)*cos(phi);
  double rot33=cos(theta);

  X=-X; // Make the input system right-handed
  X=X+Xsun; // Transform the input system to heliocentic right handed coordinates
  
  // Calculate X,Y,Z,distance in the Sgr system
  Xs=rot11*X+rot12*Y+rot13*Z;
  Ys=rot21*X+rot22*Y+rot23*Z;
  Zs=rot31*X+rot32*Y+rot33*Z;
  r=sqrt(Xs*Xs+Ys*Ys+Zs*Zs);

  Zs=-Zs;
  // Calculate the angular coordinates lambda,beta
  lambda=atan2(Ys,Xs)/radpdeg;
  if (lambda<0) lambda=lambda+360;
  beta=asin(Zs/sqrt(Xs*Xs+Ys*Ys+Zs*Zs))/radpdeg;
  }


// Transform positions from Galactic coordinates (l,b,r) to
// the heliocentric Sgr system (lambda=0 at Sgr)
// Input must be in degrees and kpc of the form l b r
// Output is in kpc and degrees, of the form X_Sgr Y_Sgr Z_Sgr r lambda beta
void LBRtoSgr(double l,double b,double r,double &Xs,double &Ys,double &Zs,double &lambda,double &beta,double Xsun=7.0)  
  {
  double radpdeg=3.141592653589793/180.;
  double X,Y,Z;

  // Transform l,b to radians
  l=l*radpdeg; b=b*radpdeg;
  
  // Transform to heliocentric Cartesian coordinates
  X=r*cos(b)*cos(l);
  Y=r*cos(b)*sin(l);
  Z=r*sin(b);

  // Transform to Galactocentric left handed frame
  X=-X;
  X=X+Xsun;

  // Transform from left handed Galactocentric to Sgr coordinates
  XYZtoSgr(X,Y,Z,Xs,Ys,Zs,r,lambda,beta,Xsun);
  }


// Transform positions from standard left handed Galactocentric XYZ to
// the Galactocentric Sgr system (lambda=0 at the Galactic plane)
// Input must be in kpc of the form X Y Z
// Output is in kpc and degrees, of the form X_Sgr,GC Y_Sgr,GC Z_Sgr,GC d_GC lambda_GC beta_GC
// Note that d is distance from Galactic Center
void XYZtoSgrGC(double X,double Y,double Z,double &Xs,double &Ys,double &Zs,double &d,double &lambda,double &beta,double Xsun=7.0)  
  {
  double radpdeg=3.141592653589793/180.;
  // Define the Euler angles
  double phi=(180+3.75)*radpdeg;
  double theta=(90-13.46)*radpdeg;
  double psiGC=(180+21.604399)*radpdeg;
  // Rotation angle of phiGC past 180degrees is a useful number
  double ang=21.604399*radpdeg;
  // Note that the plane does not actually include the G.C., although it is close
  double xcenter=-8.5227;
  double ycenter=-.3460;
  double zcenter=-.0828;
  double Temp,Temp2,Temp3;

  // Define the rotation matrix from the Euler angles
  double GCrot11=cos(psiGC)*cos(phi)-cos(theta)*sin(phi)*sin(psiGC);
  double GCrot12=cos(psiGC)*sin(phi)+cos(theta)*cos(phi)*sin(psiGC);
  double GCrot13=sin(psiGC)*sin(theta);
  double GCrot21=-sin(psiGC)*cos(phi)-cos(theta)*sin(phi)*cos(psiGC);
  double GCrot22=-sin(psiGC)*sin(phi)+cos(theta)*cos(phi)*cos(psiGC);
  double GCrot23=cos(psiGC)*sin(theta);
  double GCrot31=sin(theta)*sin(phi);
  double GCrot32=-sin(theta)*cos(phi);
  double GCrot33=cos(theta);

  X=-X; // Make the input system right-handed
  X=X+Xsun; // Transform the input system to heliocentric right handed coordinates

  // Calculate Z,distance in the SgrGC system
  Temp=GCrot11*(X+xcenter)+GCrot12*(Y-ycenter)+GCrot13*(Z-zcenter);
  Temp2=GCrot21*(X+xcenter)+GCrot22*(Y-ycenter)+GCrot23*(Z-zcenter);
  Zs=GCrot31*(X+xcenter)+GCrot32*(Y-ycenter)+GCrot33*(Z-zcenter);
  d=sqrt(Temp*Temp+Temp2*Temp2+Zs*Zs);

  Zs=-Zs;
  // Calculate the angular coordinates lambdaGC,betaGC
  Temp3=atan2(Temp2,Temp)/radpdeg;
  if (Temp3<0) Temp3=Temp3+360;
  Temp3=Temp3+ang/radpdeg;
  if (Temp3>360) Temp3=Temp3-360;
  lambda=Temp3;
  beta=asin(Zs/sqrt(Temp*Temp+Temp2*Temp2+Zs*Zs))/radpdeg;

  // Calculate X,Y in the SgrGC system
  Xs=Temp*cos(ang)-Temp2*sin(ang);
  Ys=Temp*sin(ang)+Temp2*cos(ang);
  }


// Transform positions from Galactic coordinates (l,b,r) to
// the Galactocentric Sgr system (lambda=0 at the Galactic plane)
// Input must be in degrees and kpc of the form l b r
// Output is in kpc and degrees, of the form X_Sgr,GC Y_Sgr,GC Z_Sgr,GC d_GC lambda_GC beta_GC
// Note that d is distance from Galactic Center
void LBRtoSgrGC(double l,double b,double r,double &Xs,double &Ys,double &Zs,double &d,double &lambda,double &beta,double Xsun=7.0)  
  {
  double radpdeg=3.141592653589793/180.;
  double X,Y,Z;

  // Transform l,b to radians
  l=l*radpdeg; b=b*radpdeg;
  
  // Transform to heliocentric Cartesian coordinates
  X=r*cos(b)*cos(l);
  Y=r*cos(b)*sin(l);
  Z=r*sin(b);

  // Transform to Galactocentric left handed frame
  X=-X;
  X=X+Xsun;

  // Transform from left handed Galactocentric to Sgr coordinates
  XYZtoSgrGC(X,Y,Z,Xs,Ys,Zs,d,lambda,beta);
  }
</file>

<file path="gala/coordinates/tests/test_all_streamframes.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# This package
from .. import (
    GD1Koposov10,
    MagellanicStreamNidever08,
    OphiuchusPriceWhelan16,
    OrphanKoposov19,
    OrphanNewberg10,
    Pal5PriceWhelan18,
    SagittariusLaw10,
)

stream_frames = (
    GD1Koposov10,
    MagellanicStreamNidever08,
    OphiuchusPriceWhelan16,
    OrphanKoposov19,
    OrphanNewberg10,
    Pal5PriceWhelan18,
    SagittariusLaw10,
)


@pytest.mark.parametrize("frame_cls", stream_frames)
def test_wrapping(frame_cls):
    c = frame_cls([-60, 300] * u.deg, [15, -15] * u.deg)
    lon_name = list(c.get_representation_component_names().keys())[0]
    lat_name = list(c.get_representation_component_names().keys())[1]
    assert np.allclose(getattr(c, lon_name).value, -60)

    # with velocity data:
    data = dict()
    data["pm_{}_cos{}".format(lon_name, lat_name)] = [1.0, 2.0] * u.mas / u.yr
    data["pm_{}".format(lat_name)] = [1.0, 2.0] * u.mas / u.yr
    c = frame_cls([-60, 300] * u.deg, [15, -15] * u.deg, **data)
    assert np.allclose(getattr(c, lon_name).value, -60)
</file>

<file path="gala/coordinates/tests/test_gd1.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..gd1 import GD1Koposov10


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    c = GD1Koposov10(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    # with distance
    c = GD1Koposov10(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)


def test_koposov():
    # Compare against Table 1 in Koposov et al. 2010

    filename = get_pkg_data_filename("gd1_coord.txt")
    k10_data = np.genfromtxt(filename, names=True, dtype=None, encoding='utf-8')

    k10_icrs = coord.SkyCoord(
        ra=k10_data["ra"].astype(str),
        dec=k10_data["dec"].astype(str),
        unit=(u.hourangle, u.degree),
    )

    k10_gd1 = GD1Koposov10(
        phi1=k10_data["phi1"] * u.degree, phi2=k10_data["phi2"] * u.degree
    )

    gala_gd1 = k10_icrs.transform_to(GD1Koposov10())

    # TODO: why are these so different from the values in Koposov?
    assert np.allclose(k10_gd1.phi1.degree, gala_gd1.phi1.degree, atol=1e-1)
    assert np.allclose(k10_gd1.phi2.degree, gala_gd1.phi2.degree, atol=0.2)
</file>

<file path="gala/coordinates/tests/test_greatcircle.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np
import pytest

# This project
from ..greatcircle import (
    GreatCircleICRSFrame,
    make_greatcircle_cls,
    pole_from_endpoints,
    sph_midpoint,
)

rng = np.random.default_rng(seed=42)
rand_lon = rng.uniform(0, 2 * np.pi, 15) * u.rad
rand_lat = np.arcsin(rng.uniform(-1, 1, size=15)) * u.rad
poles = [
    coord.SkyCoord(ra=0 * u.deg, dec=90 * u.deg),
    coord.SkyCoord(ra=0 * u.deg, dec=-90 * u.deg),
    coord.SkyCoord(ra=12.3 * u.deg, dec=45.6 * u.deg, distance=1 * u.kpc),
] + [coord.SkyCoord(lon, lat) for lon, lat in zip(rand_lon, rand_lat)]


def get_random_orthogonal(skycoord, rng):
    zhat = np.squeeze((skycoord.cartesian / skycoord.cartesian.norm()).xyz)

    # Random vector orthogonal to the pole:
    x = rng.uniform(size=3)
    x /= np.linalg.norm(x)
    xhat = x - (x @ zhat) * zhat
    xhat /= np.linalg.norm(xhat)
    return coord.SkyCoord(coord.CartesianRepresentation(xhat), frame=skycoord.frame)


@pytest.mark.parametrize("pole", poles)
def test_init_cls(pole):
    origin = get_random_orthogonal(pole, rng)

    GreatCircleICRSFrame(pole=pole, origin=origin)
    GreatCircleICRSFrame(pole=pole, origin=origin, priority="pole")

    with pytest.raises(ValueError):
        GreatCircleICRSFrame(pole=pole, ra0=origin.ra)

    # Slightly adjust the origin so it is not orthogonal:
    new_origin = origin.spherical_offsets_by(
        1.23 * u.deg, -2.42 * u.deg
    )  # random values

    with pytest.warns():
        f1 = GreatCircleICRSFrame(pole=pole, origin=new_origin)

    # default priority="origin"
    assert f1.origin.ra == new_origin.ra
    assert f1.origin.dec == new_origin.dec
    assert np.isclose(f1.origin.cartesian.xyz @ f1.pole.cartesian.xyz, 0.0)

    with pytest.warns():
        f2 = GreatCircleICRSFrame(pole=pole, origin=new_origin, priority="pole")

    assert f2.pole.ra == pole.ra
    assert f2.pole.dec == pole.dec
    assert np.isclose(f2.origin.cartesian.xyz @ f2.pole.cartesian.xyz, 0.0)


@pytest.mark.parametrize("pole", poles)
def test_init_from_pole_ra0(pole):
    GreatCircleICRSFrame.from_pole_ra0(pole, ra0=153 * u.deg)

    disamb = coord.SkyCoord(ra=210 * u.deg, dec=-17 * u.deg)
    GreatCircleICRSFrame.from_pole_ra0(
        pole, ra0=153 * u.deg, origin_disambiguate=disamb
    )


fail_poles = [
    coord.SkyCoord(ra=90 * u.deg, dec=0 * u.deg),
    coord.SkyCoord(ra=13.5399 * u.deg, dec=0 * u.deg),
]


@pytest.mark.parametrize("pole", fail_poles)
def test_init_from_pole_ra0_fail(pole):
    with pytest.raises(ValueError):
        test_init_from_pole_ra0(pole)


@pytest.mark.parametrize("c1", poles)
def test_init_from_endpoints(c1):
    # Random vector for other endpoint:
    x = rng.uniform(size=3)
    x /= np.linalg.norm(x)
    c2 = coord.SkyCoord(coord.CartesianRepresentation(x))

    midpt = coord.SkyCoord(sph_midpoint(c1.squeeze(), c2))
    origin_off = midpt.spherical_offsets_by(1.423 * u.deg, -2.182 * u.deg)

    f1 = GreatCircleICRSFrame.from_endpoints(c1, c2)
    f2 = GreatCircleICRSFrame.from_endpoints(c1, c2, origin=midpt)
    with pytest.warns():
        f3 = GreatCircleICRSFrame.from_endpoints(c1, c2, origin=origin_off)
    assert u.isclose(f3.origin.ra, origin_off.ra)
    assert u.isclose(f3.origin.dec, origin_off.dec)

    if np.abs(c1.dec) != 90 * u.deg:
        f4 = GreatCircleICRSFrame.from_endpoints(c1, c2, ra0=origin_off.ra)

    with pytest.warns():
        f5 = GreatCircleICRSFrame.from_endpoints(
            c1, c2, origin=origin_off, priority="pole"
        )
    assert u.isclose(f5.pole.ra, f1.pole.ra)
    assert u.isclose(f5.pole.dec, f1.pole.dec)


@pytest.mark.parametrize("pole", poles)
def test_make_function(pole):
    origin = get_random_orthogonal(pole, rng)

    cls = make_greatcircle_cls(
        "Michael", "This is the docstring header", pole=pole, origin=origin
    )
    fr = cls(phi1=100 * u.deg, phi2=10 * u.deg)
    fr.transform_to(coord.ICRS())


def test_pole_from_endpoints():
    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(90 * u.deg, 0 * u.deg)
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.dec, 90 * u.deg)

    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(0 * u.deg, 90 * u.deg)
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.ra, 270 * u.deg)
    assert u.allclose(pole.dec, 0 * u.deg)

    # Should work even if coord has velocities:
    c1 = coord.SkyCoord(
        0 * u.deg, 0 * u.deg, pm_ra_cosdec=10 * u.mas / u.yr, pm_dec=-0.5 * u.mas / u.yr
    )
    c2 = coord.SkyCoord(
        0 * u.deg,
        90 * u.deg,
        pm_ra_cosdec=10 * u.mas / u.yr,
        pm_dec=-0.5 * u.mas / u.yr,
    )
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.ra, 270 * u.deg)
    assert u.allclose(pole.dec, 0 * u.deg)


def test_init_pole_from_xyz():
    xnew = coord.UnitSphericalRepresentation(185 * u.deg, 32.5 * u.deg).to_cartesian()
    ynew = coord.UnitSphericalRepresentation(275 * u.deg, 0 * u.deg).to_cartesian()
    znew = xnew.cross(ynew)

    fr1 = GreatCircleICRSFrame.from_xyz(xnew, ynew, znew)
    fr2 = GreatCircleICRSFrame.from_xyz(xnew, ynew)
    fr3 = GreatCircleICRSFrame.from_xyz(xnew, znew=znew)
    fr4 = GreatCircleICRSFrame.from_xyz(ynew=ynew, znew=znew)

    for fr in [fr2, fr3, fr4]:
        assert np.isclose(fr1.pole.ra.degree, fr.pole.ra.degree)
        assert np.isclose(fr1.pole.dec.degree, fr.pole.dec.degree)
        assert np.isclose(fr1.origin.ra.degree, fr.origin.ra.degree)
        assert np.isclose(fr1.origin.dec.degree, fr.origin.dec.degree)

    with pytest.raises(ValueError):
        GreatCircleICRSFrame.from_xyz(xnew)


def test_sph_midpoint():
    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(90 * u.deg, 0 * u.deg)
    midpt = sph_midpoint(c1, c2)
    assert u.allclose(midpt.ra, 45 * u.deg)
    assert u.allclose(midpt.dec, 0 * u.deg)

    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(0 * u.deg, 90 * u.deg)
    midpt = sph_midpoint(c1, c2)
    assert u.allclose(midpt.ra, 0 * u.deg)
    assert u.allclose(midpt.dec, 45 * u.deg)


def test_init_from_R():
    from ..gd1 import GD1Koposov10
    from ..gd1 import R as gd1_R

    N = 128
    rnd = np.random.RandomState(42)

    gd1_gc_frame = GreatCircleICRSFrame.from_R(gd1_R)
    tmp_in = GD1Koposov10(
        phi1=rnd.uniform(0, 360, N) * u.deg, phi2=rnd.uniform(-90, 90, N) * u.deg
    )

    tmp_out = tmp_in.transform_to(gd1_gc_frame)

    assert u.allclose(tmp_in.phi1, tmp_out.phi1)
    assert u.allclose(tmp_in.phi2, tmp_out.phi2)
</file>

<file path="gala/coordinates/tests/test_jhelum.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np

# This package
from ..jhelum import JhelumBonaca19


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    c = JhelumBonaca19(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    # with distance
    c = JhelumBonaca19(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)
</file>

<file path="gala/coordinates/tests/test_orphan.py">
"""
Test the coordinates class that represents the plane of orbit of the Sgr dwarf galaxy.
"""

# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.io import ascii
from astropy.table import Table
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This project
from ..orphan import OrphanNewberg10, OrphanKoposov19


def test_table():
    """Test the transformation code against table 2 values from
    Newberg et al. 2010 (below)
    """

    names = ["l", "b", "db", "Lambda", "Beta", "g0", "dg0"]
    table = """255 48.5 0.7 22.34 0.08 17.1 0.1
245 52.0 0.7 15.08 0.56 0. 0.
235 53.5 0.7 8.86 0.21 0. 0.
225 54.0 0.7 2.95 -0.23 17.6 0.2
215 54.0 0.7 -2.93 -0.33 17.9 0.1
205 53.5 0.7 -8.85 -0.09 18.0 0.1
195 52.0 0.7 -15.08 0.05 0. 0.
185 50.5 0.7 -21.42 1.12 18.6 0.1
175 47.5 0.7 -28.59 1.88 0. 0.
171 45.8 1.0 -31.81 2.10 0. 0."""

    table = ascii.read(table, names=names)

    for line in table:
        galactic = coord.Galactic(l=line["l"] * u.deg, b=line["b"] * u.deg)

        orp = galactic.transform_to(OrphanNewberg10())
        true_orp = OrphanNewberg10(
            phi1=line["Lambda"] * u.deg, phi2=line["Beta"] * u.deg
        )

        # TODO: why does this suck so badly?
        assert true_orp.separation(orp) < 20 * u.arcsec


def test_kopsov():
    tbl = Table.read(get_pkg_data_filename("sergey_orphan.txt"), format="ascii")
    c = coord.SkyCoord(ra=tbl["ra"] * u.deg, dec=tbl["dec"] * u.deg)
    orp_gc = c.transform_to(OrphanKoposov19())
    assert np.percentile(orp_gc.phi2.degree, 95) < 5
</file>

<file path="gala/coordinates/tests/test_pal5.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np

# This package
from ..pal5 import Pal5PriceWhelan18


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    c = Pal5PriceWhelan18(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    # with distance
    c = Pal5PriceWhelan18(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)
</file>

<file path="gala/coordinates/tests/test_pm_cov_transform.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# This project
from ..orphan import OrphanKoposov19
from ..pm_cov_transform import transform_pm_cov

sky_offset_frame = coord.SkyOffsetFrame(
    origin=coord.ICRS(ra="20d", dec="30d"), rotation=135.7 * u.deg
)


def setup_function(fn):
    ra, dec, pmra, pmdec = np.load(get_pkg_data_filename("c_pm.npy"))
    c = coord.SkyCoord(
        ra=ra * u.deg,
        dec=dec * u.deg,
        pm_ra_cosdec=pmra * u.mas / u.yr,
        pm_dec=pmdec * u.mas / u.yr,
    )
    cov = np.load(get_pkg_data_filename("pm_cov.npy"))

    fn.c = c
    fn.cov = cov


@pytest.mark.parametrize(
    "to_frame",
    [
        coord.Galactic,
        coord.Galactic(),
        coord.Supergalactic,
        coord.Supergalactic(),
        OrphanKoposov19,
        OrphanKoposov19(),
        sky_offset_frame,
    ],
)
def test_transform(to_frame):
    c = test_transform.c
    cov = test_transform.cov

    # First, don't validate, just check input paths:
    transform_pm_cov(c[0], cov[0], to_frame)
    transform_pm_cov(c[:4], cov[:4], to_frame)

    with pytest.raises(ValueError):
        transform_pm_cov(c[:4], cov[:8], to_frame)

    with pytest.raises(ValueError):
        transform_pm_cov(c[0], cov[0, :1], to_frame)

    new_cov1 = transform_pm_cov(c[0], cov[0], to_frame)
    new_cov2 = np.squeeze(transform_pm_cov(c[0:1], cov[0:1], to_frame))
    assert np.allclose(new_cov1, new_cov2)


@pytest.mark.parametrize(
    "to_frame",
    [
        coord.Galactic,
        coord.Galactic(),
        coord.Supergalactic,
        coord.Supergalactic(),
        OrphanKoposov19,
        OrphanKoposov19(),
        sky_offset_frame,
    ],
)
def test_transform_correctness(to_frame):
    c = test_transform_correctness.c[:4]
    cov = test_transform_correctness.cov[:4]

    # generate proper motion samples and transform the samples:
    pm = np.vstack((c.pm_ra_cosdec.value, c.pm_dec.value)).T
    rnd = np.random.RandomState(42)

    for i in range(len(c)):
        pm_samples = rnd.multivariate_normal(pm[i], cov[i], size=2**16)
        c1 = coord.SkyCoord(
            ra=[c[i].ra.value] * pm_samples.shape[0] * u.deg,
            dec=[c[i].dec.value] * pm_samples.shape[0] * u.deg,
            pm_ra_cosdec=pm_samples[:, 0] * u.mas / u.yr,
            pm_dec=pm_samples[:, 1] * u.mas / u.yr,
        )
        new_c1 = c1.transform_to(to_frame)

        dsph = new_c1.represent_as(
            coord.SphericalRepresentation, coord.SphericalCosLatDifferential
        ).differentials["s"]
        new_pm_samples = np.vstack((dsph.d_lon_coslat.value, dsph.d_lat.value))
        cov_est = np.cov(new_pm_samples)
        cov_trans = transform_pm_cov(c[i], cov[i], to_frame)
        assert np.allclose(cov_est, cov_trans, atol=1e-2)
        assert np.allclose(
            np.sort(np.linalg.eigvals(cov[i])), np.sort(np.linalg.eigvals(cov_trans))
        )
</file>

<file path="gala/coordinates/tests/test_reflex.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u

# This package
from ..reflex import reflex_correct


def test_reflex():
    c = coord.SkyCoord(
        ra=162 * u.deg,
        dec=-17 * u.deg,
        distance=172 * u.pc,
        pm_ra_cosdec=-11 * u.mas / u.yr,
        pm_dec=4 * u.mas / u.yr,
        radial_velocity=110 * u.km / u.s,
    )

    # First, test execution but don't validate
    reflex_correct(c)
    with coord.galactocentric_frame_defaults.set("v4.0"):
        reflex_correct(c, coord.Galactocentric(z_sun=0 * u.pc))

    # Reflext correct the observed, Reid & Brunthaler (2004) Sgr A* measurements
    # and make sure the corrected velocity is close to zero
    # https://ui.adsabs.harvard.edu/abs/2004ApJ...616..872R/abstract
    # also using
    # https://ui.adsabs.harvard.edu/abs/2018RNAAS...2d.210D/abstract
    # https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G/abstract
    vsun = coord.CartesianDifferential([12.9, 245.6, 7.78] * u.km / u.s)
    with coord.galactocentric_frame_defaults.set("v4.0"):
        galcen_fr = coord.Galactocentric(
            galcen_distance=8.122 * u.kpc, galcen_v_sun=vsun, z_sun=20.8 * u.pc
        )

    sgr_Astar_obs = coord.SkyCoord(
        ra=galcen_fr.galcen_coord.ra,
        dec=galcen_fr.galcen_coord.dec,
        distance=galcen_fr.galcen_distance,
        pm_ra_cosdec=-3.151 * u.mas / u.yr,
        pm_dec=-5.547 * u.mas / u.yr,
        radial_velocity=-12.9 * u.km / u.s,
    )

    new_c = reflex_correct(sgr_Astar_obs, galcen_fr)
    assert u.allclose(new_c.pm_ra_cosdec, 0 * u.mas / u.yr, atol=1e-2 * u.mas / u.yr)
    assert u.allclose(new_c.pm_dec, 0 * u.mas / u.yr, atol=1e-2 * u.mas / u.yr)
    assert u.allclose(new_c.radial_velocity, 0 * u.km / u.s, atol=1e-1 * u.km / u.s)
</file>

<file path="gala/coordinates/tests/test_sgr.py">
"""
Test the coordinates class that represents the plane of orbit of the Sgr dwarf galaxy.
"""

# Third-party
import astropy.coordinates as coord
import astropy.table as at
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..sgr import SagittariusLaw10, SagittariusVasiliev21


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    c = SagittariusLaw10(
        coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree)
    )
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    # with distance
    c = SagittariusLaw10(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)


def test_against_David_Law():
    """Test my code against an output file from using David Law's cpp code. Do:

        g++ SgrCoord.cpp; ./a.out

    to generate the data file, SgrCoord_data.

    """
    filename = get_pkg_data_filename("SgrCoord_data")
    law_data = np.genfromtxt(filename, names=True, delimiter=",")

    c = coord.Galactic(law_data["l"] * u.deg, law_data["b"] * u.deg)
    sgr_coords = c.transform_to(SagittariusLaw10())

    law_sgr_coords = SagittariusLaw10(
        Lambda=law_data["lambda"] * u.deg, Beta=law_data["beta"] * u.deg
    )

    sep = sgr_coords.separation(law_sgr_coords).arcsec * u.arcsec
    assert np.all(sep < 1.0 * u.arcsec)


def test_v21():
    filename = get_pkg_data_filename("Vasiliev2020-Sagittarius-subset.csv")
    test_data = at.Table.read(filename, format="ascii.csv")

    c = coord.SkyCoord(test_data["ra"] * u.deg, test_data["dec"] * u.deg)
    sgr_c = c.transform_to(SagittariusVasiliev21())

    assert np.allclose(sgr_c.Lambda.degree, test_data["Lambda"], atol=1e-3)
    assert np.allclose(sgr_c.Beta.degree, test_data["Beta"], atol=1e-3)
</file>

<file path="gala/coordinates/tests/test_velocity_frame_transforms.py">
"""
    Test conversions in core.py
"""

# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..velocity_frame_transforms import vgsr_to_vhel, vhel_to_vgsr


def test_vgsr_to_vhel():
    filename = get_pkg_data_filename("idl_vgsr_vhel.txt")
    data = np.genfromtxt(filename, names=True, skip_header=2)

    # one row
    row = data[0]
    l = coord.Angle(row["lon"] * u.degree)
    b = coord.Angle(row["lat"] * u.degree)
    c = coord.Galactic(l, b)
    vgsr = row["vgsr"] * u.km / u.s
    vlsr = [row["vx"], row["vy"], row["vz"]] * u.km / u.s  # this is right
    vcirc = row["vcirc"] * u.km / u.s

    vsun = vlsr + [0, 1, 0] * vcirc
    vhel = vgsr_to_vhel(c, vgsr, vsun=vsun)
    assert np.allclose(vhel.value, row["vhelio"], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vhel = vgsr_to_vhel(c.transform_to(coord.ICRS()), vgsr, vsun=vsun)
    assert np.allclose(vhel.value, row["vhelio"], atol=1e-3)

    # all together now
    l = coord.Angle(data["lon"] * u.degree)
    b = coord.Angle(data["lat"] * u.degree)
    c = coord.Galactic(l, b)
    vgsr = data["vgsr"] * u.km / u.s
    vhel = vgsr_to_vhel(c, vgsr, vsun=vsun)
    assert np.allclose(vhel.value, data["vhelio"], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vhel = vgsr_to_vhel(c.transform_to(coord.ICRS()), vgsr, vsun=vsun)
    assert np.allclose(vhel.value, data["vhelio"], atol=1e-3)


def test_vgsr_to_vhel_misc():
    # make sure it works with longitude in 0-360 or -180-180
    l1 = coord.Angle(190.0 * u.deg)
    l2 = coord.Angle(-170.0 * u.deg)
    b = coord.Angle(30.0 * u.deg)

    c1 = coord.Galactic(l1, b)
    c2 = coord.Galactic(l2, b)

    vgsr = -110.0 * u.km / u.s
    vhel1 = vgsr_to_vhel(c1, vgsr)
    vhel2 = vgsr_to_vhel(c2, vgsr)

    assert np.allclose(vhel1.value, vhel2.value)


def test_vhel_to_vgsr():
    filename = get_pkg_data_filename("idl_vgsr_vhel.txt")
    data = np.genfromtxt(filename, names=True, skip_header=2)

    # one row
    row = data[0]
    l = coord.Angle(row["lon"] * u.degree)
    b = coord.Angle(row["lat"] * u.degree)
    c = coord.Galactic(l, b)
    vhel = row["vhelio"] * u.km / u.s
    vlsr = [row["vx"], row["vy"], row["vz"]] * u.km / u.s  # this is right
    vcirc = row["vcirc"] * u.km / u.s

    vsun = vlsr + [0, 1, 0] * vcirc
    vgsr = vhel_to_vgsr(c, vhel, vsun=vsun)
    assert np.allclose(vgsr.value, row["vgsr"], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vgsr = vhel_to_vgsr(c.transform_to(coord.ICRS()), vhel, vsun=vsun)
    assert np.allclose(vgsr.value, row["vgsr"], atol=1e-3)

    # all together now
    l = coord.Angle(data["lon"] * u.degree)
    b = coord.Angle(data["lat"] * u.degree)
    c = coord.Galactic(l, b)
    vhel = data["vhelio"] * u.km / u.s
    vgsr = vhel_to_vgsr(c, vhel, vsun=vsun)
    assert np.allclose(vgsr.value, data["vgsr"], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vgsr = vhel_to_vgsr(c.transform_to(coord.ICRS()), vhel, vsun=vsun)
    assert np.allclose(vgsr.value, data["vgsr"], atol=1e-3)
</file>

<file path="gala/coordinates/tests/Vasiliev2020-Sagittarius-subset.csv">
ra,dec,parallax,plxerr,pmra,pmraerr,pmdec,pmdecerr,g_mag,bp_rp,j_mag,h_mag,k_mag,ebv,dist,disterr,vlos,vloserr,FeH,FeHerr,src,Lambda,Beta
288.285,-33.9943,-0.012,0.042,-2.945,0.07,-1.327,0.062,15.39,1.76,13.19,12.39,12.25,0.08,26.16,0.71,nan,nan,nan,nan,0,-4.342,4.379
289.8917,-34.6561,-0.023,0.06,-2.533,0.095,-1.263,0.078,15.81,1.45,13.95,13.3,13.18,0.11,25.61,0.91,nan,nan,nan,nan,0,-5.747,4.866
283.6658,-30.9564,0.082,0.067,-2.689,0.082,-1.44,0.073,15.67,1.74,13.5,12.77,12.54,0.14,27.68,3.45,nan,nan,nan,nan,0,-0.017,1.979
286.7396,-29.7587,-0.05,0.045,-2.612,0.083,-1.42,0.069,15.39,1.85,13.09,12.3,12.04,0.13,26.36,2.24,nan,nan,nan,nan,0,-2.443,0.371
281.939,-28.3551,0.072,0.098,-2.606,0.145,-1.266,0.128,16.71,1.43,14.88,14.17,14.08,0.19,27.3,1.48,nan,nan,nan,nan,0,1.929,-0.309
279.3032,-29.7067,0.018,0.056,-2.705,0.094,-1.355,0.084,16.02,1.61,13.92,13.22,13.07,0.17,26.56,0.82,nan,nan,nan,nan,0,3.919,1.473
292.2863,-32.2551,0.081,0.047,-2.76,0.079,-1.629,0.071,15.67,1.71,13.55,12.74,12.58,0.08,28.0,1.0,nan,nan,nan,nan,0,-7.47,2.259
207.6631,0.3263,-0.117,0.171,-0.814,0.271,-0.331,0.197,17.6,1.36,15.87,15.21,15.03,0.03,49.26,2.64,nan,nan,nan,nan,0,78.26,2.749
276.4176,-28.8792,-0.019,0.059,-2.551,0.094,-1.204,0.085,15.58,2.32,12.77,11.81,11.57,0.44,26.89,1.19,nan,nan,nan,nan,0,6.557,1.221
282.8943,-30.6772,0.02,0.036,-2.62,0.076,-1.324,0.068,14.67,2.22,11.99,11.11,10.88,0.14,26.96,0.87,147.76,0.02,-0.88,0.02,1,0.685,1.821
285.9609,-33.7155,0.024,0.054,-2.674,0.089,-1.115,0.082,14.85,2.35,12.1,11.22,10.95,0.09,26.84,0.51,132.1,nan,nan,nan,4,-2.386,4.383
297.9801,-31.1381,0.066,0.139,-2.403,0.223,-1.319,0.135,17.67,1.35,15.92,15.26,15.09,0.17,29.67,0.69,nan,nan,nan,nan,0,-12.219,0.782
228.7228,-12.0126,-0.058,0.17,-0.972,0.282,-0.648,0.225,17.73,1.46,15.99,15.15,14.96,0.11,49.24,1.16,nan,nan,nan,nan,0,53.953,2.885
280.4156,-31.3219,0.073,0.077,-2.416,0.115,-1.071,0.099,16.18,1.66,14.09,13.37,13.22,0.16,25.45,0.93,nan,nan,nan,nan,0,2.65,2.858
289.1025,-31.9789,-0.233,0.189,-2.116,0.334,-1.562,0.342,18.17,1.26,16.57,15.74,15.54,0.12,27.56,1.88,nan,nan,nan,nan,0,-4.758,2.291
284.7918,-29.9314,0.096,0.118,-3.151,0.158,-1.484,0.143,16.81,1.55,14.85,14.12,13.9,0.17,27.25,2.03,nan,nan,nan,nan,0,-0.801,0.805
292.0548,-32.9769,0.063,0.077,-2.983,0.127,-1.753,0.106,16.33,1.49,14.46,13.81,13.64,0.1,28.26,1.61,nan,nan,nan,nan,0,-7.349,2.997
39.9652,3.8957,-0.354,0.196,-0.051,0.196,-2.176,0.197,17.48,1.19,16.1,15.42,15.3,0.04,27.3,5.58,nan,nan,nan,nan,0,-114.484,-0.164
280.4922,-29.9387,-0.325,0.149,-2.282,0.268,-1.684,0.247,17.93,1.33,16.43,15.72,15.63,0.18,29.06,3.23,nan,nan,nan,nan,0,2.862,1.489
22.0418,-2.2126,0.039,0.123,-0.649,0.217,-3.021,0.13,17.13,1.24,15.56,14.94,14.89,0.05,24.41,2.84,-171.67,6.28,-0.6,0.22,2,-95.923,-3.938
59.0499,13.372,-0.052,0.092,0.423,0.17,-1.22,0.113,16.73,1.78,14.53,13.74,13.55,0.32,35.05,10.29,nan,nan,nan,nan,0,-135.559,0.709
291.1575,-33.3791,0.053,0.038,-2.444,0.063,-1.552,0.062,14.9,1.67,12.79,12.05,11.88,0.11,27.84,1.54,nan,nan,nan,nan,0,-6.644,3.476
287.7446,-31.469,0.089,0.044,-2.692,0.084,-1.399,0.079,15.06,1.91,12.7,11.9,11.71,0.09,28.68,1.24,146.67,0.96,nan,nan,6,-3.544,1.94
292.0384,-30.907,-0.228,0.16,-1.91,0.256,-1.569,0.238,17.92,1.22,16.43,15.58,15.48,0.11,26.14,0.9,nan,nan,nan,nan,0,-7.124,0.939
305.6904,-28.3101,-0.051,0.035,-2.708,0.055,-2.134,0.038,14.95,1.75,12.82,12.03,11.83,0.06,23.64,2.83,nan,nan,nan,nan,0,-18.868,-2.152
285.2872,-31.0438,0.024,0.095,-2.553,0.157,-1.201,0.136,16.96,1.55,15.02,14.34,14.27,0.12,26.94,0.53,nan,nan,nan,nan,0,-1.403,1.833
283.1558,-31.1133,0.066,0.054,-2.982,0.121,-1.349,0.095,15.81,1.47,13.92,13.27,13.15,0.14,25.26,1.71,nan,nan,nan,nan,0,0.386,2.21
281.6643,-28.8641,-0.061,0.054,-2.51,0.097,-1.348,0.089,15.84,1.82,13.55,12.77,12.56,0.18,25.51,0.95,nan,nan,nan,nan,0,2.069,0.237
225.7243,-8.7182,-0.047,0.079,-1.055,0.137,-0.492,0.12,16.46,1.71,14.36,13.58,13.39,0.08,51.05,3.39,nan,nan,nan,nan,0,58.147,1.475
295.6889,-34.0619,-0.049,0.076,-2.493,0.117,-1.548,0.08,16.63,1.6,14.66,13.89,13.8,0.15,24.51,1.58,nan,nan,nan,nan,0,-10.467,3.816
296.9087,-32.1378,0.012,0.085,-2.969,0.121,-1.985,0.086,16.59,1.59,14.59,13.87,13.7,0.2,27.35,2.08,nan,nan,nan,nan,0,-11.362,1.83
284.5718,-30.1586,-0.164,0.128,-2.5,0.161,-1.363,0.14,16.94,1.5,14.77,14.1,14.03,0.14,28.65,0.6,nan,nan,nan,nan,0,-0.651,1.06
283.9158,-30.8513,-0.332,0.227,-2.552,0.267,-1.733,0.23,17.6,1.44,15.65,14.95,14.86,0.17,25.35,0.29,nan,nan,nan,nan,0,-0.21,1.838
22.5106,-28.4554,0.073,0.044,-0.793,0.096,-4.027,0.033,15.48,1.28,13.82,13.23,13.15,0.01,20.68,0.79,nan,nan,nan,nan,0,-82.849,18.936
208.9851,9.9753,-0.04,0.06,-1.221,0.114,-0.516,0.078,16.07,1.86,13.8,13.02,12.72,0.03,44.52,4.7,-19.1,3.32,-0.37,0.13,2,82.011,-6.24
315.9989,-28.2,0.035,0.16,-2.903,0.194,-2.611,0.144,16.58,1.34,14.86,14.27,14.18,0.11,24.1,1.65,nan,nan,nan,nan,0,-27.939,-1.685
283.1052,-29.6902,0.047,0.069,-2.557,0.149,-1.189,0.131,16.31,1.76,14.12,13.36,13.17,0.16,27.65,1.57,nan,nan,nan,nan,0,0.682,0.817
287.0094,-31.6075,-0.06,0.111,-2.855,0.173,-1.257,0.169,17.16,1.4,15.37,14.69,14.58,0.09,27.95,1.22,nan,nan,nan,nan,0,-2.944,2.166
279.0614,-28.8688,0.012,0.06,-2.557,0.127,-1.182,0.11,15.98,1.82,13.61,12.83,12.68,0.23,28.22,1.65,155.96,1.12,nan,nan,6,4.302,0.698
289.2526,-30.4466,0.1,0.09,-2.91,0.155,-1.698,0.153,16.9,1.5,14.98,14.35,14.22,0.11,27.81,0.42,nan,nan,nan,nan,0,-4.691,0.755
282.8806,-30.6491,0.016,0.045,-2.667,0.089,-1.277,0.077,15.74,1.85,13.45,12.72,12.47,0.14,26.96,0.87,nan,nan,nan,nan,0,0.702,1.796
289.1085,-31.6836,0.082,0.074,-2.406,0.104,-1.526,0.091,16.21,1.65,14.16,13.41,13.24,0.11,27.74,1.88,nan,nan,nan,nan,0,-4.725,1.998
51.6678,16.5213,0.025,0.058,0.18,0.117,-1.639,0.096,15.75,1.75,13.62,12.8,12.55,0.14,36.5,6.89,-197.47,0.89,-0.7,0.18,5,-130.749,-5.431
314.0534,-27.8184,-0.018,0.133,-3.032,0.192,-2.831,0.163,17.12,1.3,15.53,14.91,14.83,0.1,24.06,2.19,nan,nan,nan,nan,0,-26.267,-2.236
280.2169,-26.5637,0.018,0.058,-2.792,0.091,-1.347,0.086,15.76,1.92,13.33,12.45,12.26,0.36,26.79,2.76,nan,nan,nan,nan,0,3.777,-1.768
286.5486,-30.9213,-0.046,0.164,-2.906,0.298,-1.069,0.266,17.87,1.31,16.14,15.5,15.38,0.11,28.99,1.45,nan,nan,nan,nan,0,-2.453,1.545
294.4691,-31.2237,0.019,0.039,-2.346,0.068,-1.741,0.065,14.97,2.04,12.5,11.64,11.4,0.14,26.25,1.46,nan,nan,nan,nan,0,-9.227,1.064
18.5681,-16.172,0.003,0.025,-0.702,0.051,-3.142,0.045,13.78,1.78,11.54,10.78,10.57,0.02,22.36,1.78,-100.79,1.29,nan,nan,3,-86.034,6.506
284.0746,-30.7187,-0.056,0.055,-2.677,0.087,-1.509,0.078,15.48,1.95,13.07,12.22,12.02,0.15,29.31,1.04,nan,nan,nan,nan,0,-0.322,1.684
283.325,-28.6021,-0.03,0.043,-2.503,0.077,-1.369,0.066,15.44,1.78,13.25,12.45,12.27,0.18,27.88,0.73,nan,nan,nan,nan,0,0.686,-0.287
283.9535,-30.658,-0.063,0.121,-2.59,0.148,-1.161,0.129,16.62,1.61,14.57,13.83,13.63,0.16,27.26,0.9,141.15,0.09,nan,nan,1,-0.209,1.642
34.2228,12.1206,-0.08,0.132,0.37,0.306,-2.095,0.215,17.87,1.33,16.18,15.44,15.27,0.16,24.0,2.28,nan,nan,nan,nan,0,-113.774,-10.135
284.1152,-30.2606,0.027,0.068,-2.815,0.141,-1.384,0.131,16.49,1.53,14.54,13.91,13.82,0.15,27.86,2.59,nan,nan,nan,nan,0,-0.279,1.227
302.2005,-32.404,0.042,0.117,-2.57,0.172,-1.797,0.12,17.36,1.48,15.56,14.76,14.57,0.22,27.18,0.09,nan,nan,nan,nan,0,-15.845,1.934
283.4017,-30.282,0.067,0.059,-2.686,0.093,-1.293,0.085,15.64,1.58,13.62,12.9,12.76,0.16,26.88,0.91,nan,nan,nan,nan,0,0.325,1.354
282.5651,-30.0019,-0.163,0.097,-2.545,0.133,-1.538,0.112,16.53,1.72,14.35,13.61,13.5,0.17,27.31,2.16,nan,nan,nan,nan,0,1.087,1.208
281.4802,-29.8645,0.005,0.129,-2.852,0.237,-1.252,0.207,17.5,1.49,15.65,14.97,14.74,0.13,26.54,1.95,nan,nan,nan,nan,0,2.036,1.249
294.9041,-30.1149,0.086,0.092,-2.634,0.163,-1.563,0.153,17.02,1.49,15.21,14.44,14.28,0.11,28.05,4.08,nan,nan,nan,nan,0,-9.512,-0.071
215.6697,0.2857,-0.057,0.118,-0.882,0.161,-0.552,0.146,16.33,1.58,14.4,13.6,13.51,0.03,49.74,3.4,nan,nan,nan,nan,0,71.334,-1.272
33.529,-1.4085,-0.163,0.215,0.069,0.292,-2.115,0.25,17.86,1.08,16.75,15.99,15.79,0.03,23.59,4.35,nan,nan,nan,nan,0,-106.251,1.154
22.5752,-2.0999,-0.034,0.046,-0.464,0.079,-2.352,0.058,15.34,1.63,13.31,12.56,12.41,0.04,24.67,3.23,nan,nan,nan,nan,0,-96.443,-3.77
282.895,-31.8546,0.045,0.044,-2.378,0.073,-1.157,0.071,15.13,1.91,12.83,11.91,11.72,0.14,27.59,0.42,nan,nan,nan,nan,0,0.472,2.979
286.6746,-30.8677,-0.06,0.071,-2.813,0.161,-1.357,0.117,14.88,2.43,12.1,11.16,10.91,0.11,27.7,2.17,nan,nan,nan,nan,0,-2.552,1.476
13.3384,-11.9761,-0.025,0.069,-0.318,0.153,-2.568,0.069,14.42,2.75,11.47,10.68,10.37,0.03,22.76,0.97,nan,nan,nan,nan,0,-83.623,0.38
286.8975,-31.5046,-0.307,0.155,-2.418,0.231,-1.637,0.216,17.89,1.21,16.41,15.63,15.34,0.09,27.66,1.24,nan,nan,nan,nan,0,-2.834,2.078
308.8963,-31.9615,0.032,0.037,-2.828,0.053,-1.942,0.035,14.48,1.79,12.29,11.48,11.29,0.06,21.99,2.36,nan,nan,nan,nan,0,-21.521,1.587
262.0181,-20.8184,-0.062,0.166,-2.158,0.333,-0.457,0.263,17.81,2.58,14.62,13.72,13.45,0.98,30.87,4.47,nan,nan,nan,nan,0,21.369,-2.755
39.0406,-0.6842,0.071,0.071,-0.198,0.134,-2.238,0.125,16.43,1.26,14.81,14.21,14.11,0.03,31.15,0.96,nan,nan,nan,nan,0,-111.373,3.323
352.4234,-19.1503,-0.123,0.127,-1.347,0.21,-2.873,0.199,17.16,1.19,15.66,15.09,14.98,0.03,19.14,2.15,nan,nan,nan,nan,0,-62.376,-1.893
281.5925,-28.2065,-0.032,0.064,-2.784,0.141,-1.211,0.127,15.95,1.72,13.74,12.99,12.84,0.23,26.56,2.04,nan,nan,nan,nan,0,2.256,-0.397
282.857,-29.3536,-0.063,0.151,-2.11,0.278,-1.285,0.247,17.73,1.27,16.47,15.59,15.28,0.16,28.22,0.66,nan,nan,nan,nan,0,0.955,0.525
288.4925,-31.8992,0.075,0.152,-2.211,0.254,-1.347,0.221,17.85,1.2,16.32,15.6,15.35,0.11,28.47,1.2,nan,nan,nan,nan,0,-4.234,2.28
318.453,-32.1691,-0.085,0.051,-2.013,0.075,-1.806,0.065,15.35,1.7,13.26,12.49,12.35,0.1,23.52,0.68,nan,nan,nan,nan,0,-29.572,2.508
354.7341,-21.2361,0.011,0.271,-1.456,0.328,-2.411,0.295,17.73,1.11,16.37,15.67,15.6,0.02,17.78,6.85,nan,nan,nan,nan,0,-63.565,0.871
290.0635,-31.6543,-0.022,0.071,-2.809,0.131,-1.85,0.127,16.49,1.51,14.59,13.96,13.79,0.12,25.03,0.44,nan,nan,nan,nan,0,-5.529,1.868
280.9427,-33.0445,0.026,0.066,-2.653,0.103,-0.971,0.096,16.21,1.5,14.31,13.63,13.55,0.09,27.02,0.8,nan,nan,nan,nan,0,1.869,4.458
278.9766,-31.41,0.046,0.061,-2.59,0.092,-1.153,0.08,15.7,1.89,13.37,12.51,12.34,0.14,24.57,0.97,nan,nan,nan,nan,0,3.836,3.197
285.207,-30.3102,-0.225,0.199,-2.463,0.279,-1.164,0.24,17.52,1.29,15.77,15.1,15.04,0.12,27.23,0.22,nan,nan,nan,nan,0,-1.217,1.12
299.4309,-27.6769,-0.024,0.059,-2.589,0.096,-1.728,0.05,15.53,1.66,13.43,12.66,12.49,0.13,27.72,2.47,nan,nan,nan,nan,0,-13.33,-2.731
290.0331,-32.5578,-0.026,0.042,-2.504,0.068,-1.294,0.064,15.37,1.75,13.18,12.4,12.18,0.1,26.62,1.13,nan,nan,nan,nan,0,-5.611,2.769
327.3874,-38.5971,-0.014,0.034,-3.129,0.042,-2.928,0.05,14.22,1.81,12.02,11.18,10.98,0.03,18.86,2.44,nan,nan,nan,nan,0,-35.704,10.066
290.5167,-31.9381,-0.061,0.089,-2.561,0.166,-1.587,0.155,16.7,1.53,14.68,13.98,13.88,0.14,26.1,0.91,nan,nan,nan,nan,0,-5.945,2.105
262.6608,-22.7595,0.069,0.28,-2.427,0.398,-1.03,0.307,18.45,2.64,15.22,14.27,13.93,1.32,30.87,4.47,nan,nan,nan,nan,0,20.156,-1.126
285.0317,-32.0164,0.065,0.059,-2.78,0.104,-1.7,0.099,16.18,1.52,14.22,13.52,13.38,0.13,28.26,2.39,139.69,0.05,-0.34,0.02,1,-1.344,2.828
61.9433,12.7578,0.03,0.076,0.329,0.151,-1.034,0.106,16.27,2.15,13.63,12.66,12.5,0.47,36.28,7.85,nan,nan,nan,nan,0,-137.795,2.532
347.4703,-29.6005,-0.125,0.084,-1.456,0.126,-2.501,0.151,16.42,1.34,14.72,14.15,14.11,0.03,23.78,2.15,nan,nan,nan,nan,0,-54.338,6.172
216.635,-2.8545,-0.005,0.128,-0.924,0.23,-0.779,0.186,17.31,1.61,15.21,14.44,14.37,0.07,52.71,1.85,nan,nan,nan,nan,0,68.911,0.946
288.0613,-31.8506,-0.064,0.102,-2.752,0.201,-1.393,0.151,16.45,1.54,14.56,13.93,13.84,0.09,26.35,3.01,nan,nan,nan,nan,0,-3.864,2.281
219.175,-3.0004,-0.003,0.123,-1.159,0.194,-0.597,0.179,17.29,1.55,15.32,14.52,14.43,0.08,52.68,2.51,nan,nan,nan,nan,0,66.649,-0.211
83.1959,22.6385,-0.894,0.391,-0.31,0.531,-0.923,0.448,18.56,2.07,16.06,15.12,14.97,0.56,49.25,1.44,nan,nan,nan,nan,0,-160.27,1.404
287.0514,-31.2207,-0.01,0.044,-2.644,0.084,-1.176,0.065,14.88,1.84,12.64,11.8,11.58,0.09,25.98,2.19,nan,nan,nan,nan,0,-2.923,1.778
286.2604,-31.1288,-0.199,0.152,-2.526,0.26,-1.161,0.235,17.86,1.27,16.25,15.7,15.63,0.1,27.58,0.36,nan,nan,nan,nan,0,-2.24,1.788
160.271,22.5827,-0.056,0.18,-1.696,0.278,-1.496,0.301,17.65,1.18,16.24,15.54,15.45,0.03,25.0,1.41,nan,nan,nan,nan,0,129.471,2.574
285.2495,-30.8853,0.014,0.066,-2.604,0.111,-1.555,0.097,16.16,1.62,14.08,13.4,13.27,0.14,26.94,0.53,nan,nan,nan,nan,0,-1.345,1.682
286.8458,-31.7179,-0.216,0.17,-2.475,0.22,-1.655,0.204,17.28,1.27,15.71,15.13,15.05,0.09,25.9,0.24,nan,nan,nan,nan,0,-2.822,2.296
276.4401,-30.6339,0.049,0.099,-2.967,0.149,-0.966,0.133,16.34,1.78,13.83,13.07,12.84,0.31,27.67,1.99,nan,nan,nan,nan,0,6.131,2.924
285.6569,-30.6377,0.001,0.153,-2.578,0.213,-1.459,0.2,17.36,1.49,15.43,14.8,14.63,0.14,27.0,1.66,nan,nan,nan,nan,0,-1.652,1.382
281.3468,-33.0079,-0.116,0.167,-2.386,0.27,-1.354,0.245,17.88,1.25,16.27,15.46,15.28,0.11,25.57,1.87,nan,nan,nan,nan,0,1.543,4.356
281.154,-26.1242,-0.019,0.133,-2.73,0.213,-1.495,0.189,17.47,1.59,15.4,14.73,14.6,0.33,25.67,1.41,nan,nan,nan,nan,0,3.04,-2.365
49.8985,4.5438,-0.05,0.064,0.274,0.1,-1.195,0.091,15.47,1.64,13.39,12.69,12.52,0.14,29.42,0.29,nan,nan,nan,nan,0,-123.409,4.199
287.4731,-30.8265,0.035,0.058,-2.51,0.076,-1.259,0.067,15.36,1.64,13.36,12.57,12.46,0.09,26.55,0.05,nan,nan,nan,nan,0,-3.224,1.336
280.697,-30.2506,-0.032,0.048,-2.811,0.08,-1.447,0.068,14.47,2.06,12.01,11.12,10.89,0.14,26.76,2.58,nan,nan,nan,nan,0,2.626,1.76
284.2636,-30.5579,0.044,0.282,-2.609,0.467,-1.534,0.395,18.31,1.31,16.46,15.69,15.36,0.16,27.17,1.68,nan,nan,nan,nan,0,-0.455,1.498
282.5333,-30.3623,-0.029,0.041,-2.431,0.087,-1.259,0.079,15.38,2.12,12.84,11.9,11.71,0.17,26.91,1.05,135.91,0.99,nan,nan,6,1.048,1.568
290.9812,-32.0694,0.018,0.046,-2.744,0.08,-1.414,0.072,15.59,1.8,13.38,12.56,12.39,0.1,28.24,2.04,nan,nan,nan,nan,0,-6.351,2.191
284.6215,-33.7174,-0.051,0.053,-2.453,0.1,-1.751,0.093,15.86,1.53,13.97,13.21,13.11,0.08,27.24,0.23,nan,nan,nan,nan,0,-1.283,4.563
283.5774,-32.6579,0.047,0.063,-3.175,0.125,-1.189,0.105,15.62,1.6,13.59,12.9,12.73,0.11,26.96,0.77,nan,nan,nan,nan,0,-0.239,3.668
277.4488,-28.1019,0.044,0.047,-2.87,0.081,-0.818,0.072,15.14,2.12,12.54,11.71,11.42,0.41,25.7,1.1,nan,nan,nan,nan,0,5.852,0.258
279.9524,-28.2685,-0.114,0.056,-2.465,0.124,-1.105,0.104,15.89,1.74,13.73,12.98,12.82,0.2,27.57,2.07,130.86,1.17,nan,nan,6,3.661,-0.051
281.8182,-28.6942,-0.003,0.057,-2.956,0.118,-1.168,0.095,15.44,1.93,13.05,12.23,12.03,0.19,27.69,1.54,nan,nan,nan,nan,0,1.969,0.044
282.4315,-32.5608,-0.012,0.052,-2.657,0.074,-1.172,0.067,15.0,1.65,12.93,12.21,12.08,0.12,26.16,2.65,nan,nan,nan,nan,0,0.73,3.745
248.509,-16.5568,0.099,0.082,-2.044,0.163,-0.738,0.095,16.24,2.5,13.23,12.19,11.97,0.55,32.49,3.16,nan,nan,nan,nan,0,34.831,-1.852
280.5083,-30.091,-0.049,0.181,-2.731,0.334,-0.924,0.296,17.96,1.28,16.16,15.55,15.42,0.15,28.54,2.67,nan,nan,nan,nan,0,2.818,1.636
282.198,-29.2845,0.095,0.065,-3.086,0.117,-1.199,0.107,16.07,1.45,14.15,13.5,13.38,0.16,27.34,1.2,nan,nan,nan,nan,0,1.532,0.562
204.1837,17.371,-0.104,0.057,-1.588,0.107,-0.603,0.066,16.43,1.46,14.62,13.95,13.77,0.03,44.66,2.36,nan,nan,nan,nan,0,89.869,-10.237
281.7825,-30.4497,0.007,0.055,-2.851,0.084,-1.351,0.07,15.64,1.9,13.28,12.43,12.23,0.19,28.36,0.89,157.42,0.91,nan,nan,6,1.668,1.774
286.5543,-31.9351,0.011,0.041,-2.643,0.071,-1.455,0.063,14.82,1.87,12.53,11.69,11.5,0.1,26.74,0.86,nan,nan,nan,nan,0,-2.609,2.547
284.4034,-29.5543,-0.025,0.093,-2.193,0.141,-1.037,0.124,16.67,1.76,14.51,13.74,13.63,0.18,27.88,1.52,nan,nan,nan,nan,0,-0.406,0.489
245.0297,-10.3609,-0.011,0.111,-1.58,0.235,-0.49,0.146,16.89,1.78,14.64,13.85,13.73,0.25,41.04,4.46,nan,nan,nan,nan,0,40.545,-6.017
283.7845,-26.5555,0.0,0.048,-2.913,0.074,-1.315,0.067,15.19,2.28,12.36,11.41,11.17,0.37,25.86,0.14,nan,nan,nan,nan,0,0.641,-2.374
51.9376,9.3394,0.096,0.142,0.421,0.266,-1.561,0.234,17.64,1.59,15.5,14.84,14.66,0.25,34.53,6.14,nan,nan,nan,nan,0,-127.509,0.986
288.7079,-31.8181,0.032,0.115,-2.898,0.219,-0.881,0.238,17.08,1.35,15.22,14.64,14.57,0.12,28.47,1.37,nan,nan,nan,nan,0,-4.405,2.175
282.3979,-28.7586,-0.038,0.048,-2.604,0.096,-1.336,0.09,15.64,1.85,13.32,12.53,12.3,0.17,28.19,1.44,134.9,nan,nan,nan,4,1.458,0.013
287.7338,-31.866,0.018,0.044,-2.842,0.08,-1.449,0.074,15.65,1.5,13.76,13.05,12.93,0.09,26.75,1.5,155.21,0.94,nan,nan,6,-3.591,2.334
44.9676,8.7117,-0.051,0.112,-0.1,0.186,-1.242,0.164,17.08,1.52,15.09,14.47,14.34,0.24,30.36,3.37,-176.09,4.66,-0.62,0.17,2,-121.2,-1.841
32.6234,7.6189,-0.098,0.117,0.052,0.16,-1.636,0.139,16.87,1.29,15.29,14.66,14.55,0.06,22.78,2.75,-188.09,6.84,-1.45,0.21,2,-110.07,-7.079
287.1975,-31.0944,-0.013,0.05,-3.001,0.09,-1.637,0.075,15.69,1.65,13.64,12.87,12.73,0.1,28.41,3.62,nan,nan,nan,nan,0,-3.028,1.635
281.5536,-30.9974,-0.317,0.161,-3.108,0.299,-1.039,0.284,17.91,1.24,16.38,15.69,15.44,0.13,27.19,1.03,nan,nan,nan,nan,0,1.757,2.349
279.8877,-27.22,-0.058,0.108,-3.11,0.165,-1.428,0.139,16.35,2.07,13.78,12.84,12.71,0.46,27.88,0.63,nan,nan,nan,nan,0,3.931,-1.066
279.0425,-27.846,-0.042,0.05,-2.553,0.088,-1.306,0.072,14.98,2.12,12.32,11.4,11.18,0.31,27.8,1.24,nan,nan,nan,nan,0,4.534,-0.298
281.8101,-28.3068,0.001,0.094,-2.942,0.146,-1.331,0.125,16.75,1.61,14.75,13.95,13.82,0.22,26.3,1.66,nan,nan,nan,nan,0,2.049,-0.335
276.3432,-24.7481,-0.789,0.103,-2.201,0.223,-1.528,0.199,16.52,1.9,13.97,13.25,13.05,0.42,28.43,0.47,nan,nan,nan,nan,0,7.582,-2.781
33.5387,-9.6006,0.083,0.125,-0.335,0.173,-2.205,0.144,17.07,1.2,15.53,14.91,14.8,0.03,26.64,3.89,nan,nan,nan,nan,0,-102.071,8.209
282.459,-29.1657,0.098,0.078,-2.492,0.155,-1.088,0.121,16.26,1.53,14.34,13.66,13.53,0.2,25.69,1.11,nan,nan,nan,nan,0,1.33,0.403
278.1564,-26.0716,0.007,0.089,-2.682,0.154,-1.265,0.139,16.97,1.9,14.65,13.88,13.66,0.49,27.0,2.3,nan,nan,nan,nan,0,5.687,-1.861
286.3164,-32.1145,-0.076,0.077,-2.725,0.131,-1.556,0.116,16.57,1.5,14.66,13.97,13.83,0.1,28.03,0.59,nan,nan,nan,nan,0,-2.436,2.755
286.26,-30.5199,0.013,0.111,-2.422,0.176,-1.304,0.135,16.04,1.42,14.25,13.63,13.51,0.12,26.73,0.59,nan,nan,nan,nan,0,-2.147,1.186
290.8615,-31.0307,-0.076,0.176,-2.478,0.307,-1.995,0.256,17.8,1.2,16.28,15.52,15.39,0.09,27.54,0.82,nan,nan,nan,nan,0,-6.134,1.17
286.4082,-31.8937,-0.052,0.048,-2.721,0.082,-1.453,0.073,15.57,1.61,13.51,12.77,12.64,0.12,26.36,0.93,nan,nan,nan,nan,0,-2.48,2.525
291.4328,-30.1859,-0.276,0.191,-1.909,0.326,-1.564,0.264,17.72,1.15,16.45,15.77,15.66,0.1,24.85,0.28,nan,nan,nan,nan,0,-6.53,0.277
7.9138,-18.1702,0.029,0.073,-0.899,0.116,-2.633,0.082,16.14,1.38,14.44,13.7,13.61,0.02,25.07,1.97,nan,nan,nan,nan,0,-76.096,3.412
223.9347,-10.2196,0.07,0.165,-1.208,0.249,-0.211,0.259,17.23,1.44,15.42,14.7,14.48,0.09,49.31,1.97,nan,nan,nan,nan,0,58.931,3.656
280.2591,-29.7529,0.068,0.091,-2.821,0.137,-1.391,0.122,16.75,1.65,14.72,13.91,13.73,0.16,27.45,1.95,nan,nan,nan,nan,0,3.097,1.348
236.4261,-12.5912,0.048,0.095,-1.159,0.195,-0.871,0.189,16.59,1.65,14.55,13.82,13.63,0.16,46.58,1.31,nan,nan,nan,nan,0,47.069,-0.217
277.1155,-28.5107,0.038,0.207,-2.757,0.322,-0.997,0.278,17.28,1.68,15.08,14.32,14.18,0.36,26.69,1.47,nan,nan,nan,nan,0,6.046,0.722
235.7629,-21.2923,-0.027,0.177,-1.481,0.322,-0.434,0.216,17.79,1.48,15.92,15.16,15.09,0.19,43.01,4.42,nan,nan,nan,nan,0,43.527,7.76
216.4396,-0.677,0.034,0.058,-1.421,0.116,-0.311,0.094,16.05,1.59,14.11,13.4,13.32,0.05,48.48,1.53,49.31,9.31,-1.62,0.16,2,70.182,-0.832
283.8319,-29.4035,0.059,0.054,-2.736,0.072,-1.439,0.064,15.2,2.04,12.71,11.84,11.65,0.19,26.79,2.6,nan,nan,nan,nan,0,0.11,0.425
284.5841,-29.5323,0.088,0.177,-2.796,0.387,-1.349,0.382,17.88,1.36,16.17,15.56,15.49,0.18,28.0,0.62,nan,nan,nan,nan,0,-0.557,0.441
242.9953,-12.8462,-0.039,0.112,-1.116,0.168,-0.56,0.134,16.66,1.9,14.3,13.42,13.24,0.3,38.94,0.27,nan,nan,nan,nan,0,41.246,-2.909
293.0046,-31.0589,0.077,0.073,-2.221,0.145,-1.619,0.121,16.53,1.45,14.77,14.08,13.99,0.12,27.18,1.84,nan,nan,nan,nan,0,-7.963,1.009
261.9901,-24.5,-0.04,0.124,-2.706,0.234,-0.559,0.17,16.2,3.12,12.55,11.5,11.17,1.14,32.97,3.11,nan,nan,nan,nan,0,20.152,0.72
284.9244,-31.1272,-0.035,0.106,-2.64,0.193,-0.982,0.178,17.38,1.47,15.54,14.86,14.7,0.13,26.35,1.04,nan,nan,nan,nan,0,-1.109,1.966
286.6226,-30.8527,0.001,0.079,-2.598,0.233,-1.388,0.162,15.95,1.69,13.87,13.09,12.9,0.11,28.91,3.55,nan,nan,nan,nan,0,-2.505,1.468
214.2479,1.7191,-0.031,0.107,-1.408,0.139,-0.372,0.129,15.76,2.32,13.05,12.18,11.98,0.04,49.74,4.96,nan,nan,nan,nan,0,73.287,-1.786
279.477,-32.1093,0.035,0.057,-2.875,0.084,-1.331,0.067,14.58,2.07,12.05,11.13,10.88,0.12,25.74,1.15,nan,nan,nan,nan,0,3.272,3.792
289.1955,-32.0005,0.022,0.052,-2.642,0.082,-1.302,0.091,14.97,2.34,12.27,11.37,11.13,0.11,28.09,0.79,nan,nan,nan,nan,0,-4.839,2.303
355.8959,-13.5442,-0.156,0.135,-2.102,0.185,-4.041,0.14,16.68,1.09,15.25,14.7,14.64,0.03,18.21,2.42,nan,nan,nan,nan,0,-67.652,-5.743
30.6365,12.8057,0.039,0.047,-0.063,0.075,-1.81,0.06,14.71,1.77,12.57,11.81,11.63,0.08,23.2,2.08,nan,nan,nan,nan,0,-111.079,-12.533
289.0234,-29.9046,-0.053,0.146,-2.774,0.229,-1.382,0.19,17.35,1.29,15.71,14.97,14.75,0.11,27.5,1.68,nan,nan,nan,nan,0,-4.426,0.243
5.6148,-24.1615,0.0,0.034,-1.138,0.052,-2.754,0.039,14.61,1.61,12.65,11.85,11.73,0.01,21.97,1.55,nan,nan,nan,nan,0,-71.44,7.774
286.0311,-29.8418,-0.023,0.091,-2.03,0.143,-1.213,0.129,16.2,1.42,14.3,13.66,13.56,0.13,26.77,0.31,nan,nan,nan,nan,0,-1.848,0.546
5.0844,-18.2765,-0.085,0.135,-1.064,0.199,-2.654,0.165,17.4,1.2,16.03,15.35,15.25,0.04,22.15,5.83,nan,nan,nan,nan,0,-73.647,2.292
129.7058,16.191,-0.043,0.087,-2.198,0.142,-3.163,0.094,16.55,1.1,15.17,14.53,14.44,0.02,17.83,1.94,nan,nan,nan,nan,0,156.933,14.126
285.9011,-31.4879,0.011,0.049,-2.374,0.104,-1.609,0.086,15.71,1.85,13.44,12.59,12.44,0.11,28.91,1.71,nan,nan,nan,nan,0,-1.991,2.189
227.0011,-3.1829,0.022,0.093,-1.127,0.144,-0.63,0.144,16.59,1.72,14.37,13.59,13.47,0.16,52.88,0.56,nan,nan,nan,nan,0,59.785,-3.963
284.3462,-31.6407,0.022,0.065,-3.144,0.128,-1.093,0.11,14.65,3.02,11.12,10.27,9.95,0.15,26.82,2.09,nan,nan,nan,nan,0,-0.707,2.554
278.5828,-30.9444,-0.064,0.078,-2.658,0.129,-1.321,0.107,16.46,1.62,14.45,13.74,13.56,0.17,27.06,1.8,nan,nan,nan,nan,0,4.265,2.815
286.9183,-31.2837,0.026,0.049,-3.02,0.092,-1.515,0.083,15.79,1.51,13.91,13.18,13.1,0.09,26.35,0.55,nan,nan,nan,nan,0,-2.819,1.857
329.2116,-34.2224,-0.0,0.075,-3.089,0.089,-2.921,0.074,13.53,2.42,10.91,9.99,9.75,0.02,21.71,2.37,83.08,0.98,nan,nan,3,-38.097,6.106
220.3783,2.5248,-0.096,0.065,-1.214,0.107,-0.488,0.095,15.69,1.97,13.35,12.53,12.35,0.04,50.94,2.41,28.74,1.18,nan,nan,5,68.404,-5.587
284.6094,-29.6239,-0.04,0.104,-2.608,0.199,-1.452,0.188,17.06,1.55,15.05,14.41,14.24,0.19,28.41,0.79,nan,nan,nan,nan,0,-0.594,0.528
259.5289,-25.4615,0.049,0.305,-1.635,0.435,-0.993,0.304,18.48,2.59,15.45,14.64,14.41,1.05,32.97,1.77,nan,nan,nan,nan,0,21.915,2.392
21.1704,-8.1046,0.048,0.184,-0.524,0.365,-2.504,0.156,17.69,1.24,16.1,15.35,15.27,0.04,26.16,0.71,nan,nan,nan,nan,0,-92.243,0.746
212.5276,-0.008,-0.039,0.082,-0.865,0.139,-0.435,0.119,16.39,1.54,14.46,13.77,13.63,0.04,48.71,2.35,nan,nan,nan,nan,0,73.893,0.575
287.5063,-31.6434,-0.086,0.123,-2.57,0.165,-1.148,0.147,17.03,1.48,15.19,14.52,14.38,0.08,28.18,0.64,nan,nan,nan,nan,0,-3.368,2.141
259.7348,-24.276,0.029,0.142,-1.882,0.241,-0.985,0.164,17.59,2.54,14.44,13.5,13.17,0.93,32.97,1.77,nan,nan,nan,nan,0,22.158,1.217
297.7017,-35.3508,0.037,0.099,-2.623,0.147,-1.419,0.106,17.03,1.46,15.15,14.52,14.38,0.15,26.76,1.26,nan,nan,nan,nan,0,-12.203,5.001
285.295,-32.2486,-0.031,0.046,-2.642,0.09,-1.555,0.09,15.87,1.4,14.12,13.46,13.37,0.11,26.9,0.2,nan,nan,nan,nan,0,-1.602,3.022
288.2707,-29.6607,-0.144,0.101,-2.341,0.154,-1.296,0.132,16.65,1.53,14.71,14.09,14.01,0.15,25.83,2.64,nan,nan,nan,nan,0,-3.746,0.087
283.15,-31.8705,0.095,0.073,-2.681,0.118,-1.349,0.108,16.35,1.66,14.25,13.58,13.35,0.14,26.75,1.14,nan,nan,nan,nan,0,0.256,2.956
287.3536,-32.0859,0.09,0.117,-2.293,0.214,-0.801,0.221,17.04,1.43,15.24,14.54,14.45,0.09,26.76,0.8,nan,nan,nan,nan,0,-3.302,2.597
279.9259,-27.2775,0.092,0.199,-2.55,0.284,-1.242,0.254,17.85,1.72,15.68,14.84,14.59,0.45,27.88,0.63,nan,nan,nan,nan,0,3.886,-1.017
281.293,-30.1197,-0.033,0.208,-2.493,0.351,-1.354,0.317,18.29,1.33,16.48,15.76,15.45,0.14,27.31,0.9,nan,nan,nan,nan,0,2.146,1.531
284.1469,-32.9981,0.008,0.057,-2.864,0.106,-1.137,0.103,15.91,1.52,14.0,13.33,13.19,0.09,26.54,2.12,nan,nan,nan,nan,0,-0.77,3.92
299.7026,-35.1946,-0.094,0.072,-2.77,0.11,-1.599,0.072,16.35,1.58,14.43,13.7,13.5,0.11,26.96,1.11,nan,nan,nan,nan,0,-13.834,4.773
282.9159,-31.9054,-0.116,0.096,-2.927,0.158,-1.27,0.147,16.95,1.36,15.26,14.6,14.39,0.13,27.27,0.52,nan,nan,nan,nan,0,0.446,3.026
303.6742,-37.8604,-0.006,0.037,-2.633,0.057,-1.61,0.044,14.49,1.98,12.13,11.28,11.1,0.07,25.95,4.24,nan,nan,nan,nan,0,-17.089,7.382
283.4252,-32.1406,0.032,0.056,-3.058,0.086,-1.521,0.083,15.66,1.66,13.59,12.78,12.64,0.12,28.37,0.96,169.67,1.16,nan,nan,6,-0.022,3.181
280.441,-26.7388,-0.132,0.103,-2.859,0.166,-1.592,0.149,16.73,1.78,14.48,13.65,13.48,0.33,26.79,1.67,nan,nan,nan,nan,0,3.545,-1.637
288.0779,-32.3446,-0.021,0.051,-2.804,0.085,-1.524,0.078,15.76,1.63,13.66,12.96,12.71,0.1,27.73,0.62,nan,nan,nan,nan,0,-3.946,2.768
219.2277,5.404,-0.041,0.169,-1.017,0.276,-0.339,0.273,17.86,1.21,16.45,15.64,15.53,0.03,47.86,1.45,nan,nan,nan,nan,0,70.871,-7.485
200.3015,16.2155,0.045,0.093,-1.256,0.193,-0.617,0.141,17.19,1.27,15.63,14.98,14.86,0.02,42.66,5.76,nan,nan,nan,nan,0,92.531,-7.368
281.9177,-32.7367,-0.006,0.071,-2.776,0.137,-1.052,0.112,16.19,1.58,14.26,13.46,13.35,0.11,26.85,0.24,nan,nan,nan,nan,0,1.123,3.998
262.0714,-23.3457,-0.314,0.314,-1.997,0.413,-0.328,0.306,18.45,2.74,14.87,13.89,13.49,1.31,30.87,4.47,nan,nan,nan,nan,0,20.471,-0.392
208.9277,2.0629,-0.061,0.107,-1.074,0.136,-0.414,0.104,16.4,1.77,14.22,13.41,13.19,0.04,44.27,1.65,63.78,1.2,-0.57,0.02,5,78.046,0.612
288.3347,-31.8793,0.097,0.149,-2.528,0.298,-1.478,0.259,17.71,1.4,15.97,15.43,15.37,0.11,26.03,2.54,nan,nan,nan,nan,0,-4.098,2.278
15.4415,-21.0354,0.066,0.042,-0.844,0.083,-2.558,0.063,15.71,1.46,13.87,13.19,13.12,0.02,20.23,1.16,nan,nan,nan,nan,0,-81.019,9.291
282.0204,-26.6517,-0.047,0.106,-2.69,0.152,-1.179,0.14,16.89,1.62,14.86,14.12,13.95,0.22,26.51,2.08,nan,nan,nan,nan,0,2.177,-1.996
287.7067,-30.8904,-0.049,0.086,-2.789,0.122,-1.446,0.101,16.23,1.49,14.32,13.62,13.43,0.09,26.2,0.6,nan,nan,nan,nan,0,-3.432,1.371
315.164,-35.86,0.003,0.051,-2.519,0.068,-1.902,0.052,15.43,1.62,13.43,12.66,12.54,0.07,25.6,3.28,nan,nan,nan,nan,0,-26.429,5.859
277.1407,-23.3643,0.016,0.1,-1.722,0.193,-1.514,0.171,17.12,1.71,14.81,14.12,13.96,0.4,28.75,4.59,nan,nan,nan,nan,0,7.191,-4.295
38.5158,14.1781,-0.01,0.034,-0.148,0.069,-1.682,0.06,14.42,2.02,12.08,11.29,11.08,0.13,28.34,2.53,-221.12,3.64,-1.04,0.12,2,-118.488,-9.75
289.4612,-29.1509,-0.015,0.038,-2.492,0.071,-1.296,0.063,15.43,1.87,13.18,12.31,12.11,0.13,28.35,1.37,nan,nan,nan,nan,0,-4.708,-0.553
288.4282,-32.0433,-0.212,0.074,-2.836,0.241,-1.046,0.149,15.88,1.71,13.57,12.78,12.57,0.13,26.09,0.67,nan,nan,nan,nan,0,-4.199,2.43
291.6802,-33.0121,-0.003,0.045,-2.697,0.079,-1.603,0.062,14.46,2.03,12.04,11.22,11.03,0.11,27.5,0.09,nan,nan,nan,nan,0,-7.04,3.064
293.9056,-29.7376,0.091,0.098,-2.645,0.165,-1.784,0.162,17.04,1.49,15.15,14.5,14.38,0.12,28.12,1.78,nan,nan,nan,nan,0,-8.619,-0.377
288.1209,-34.7594,-0.142,0.194,-2.403,0.256,-1.339,0.24,17.85,1.2,16.46,15.57,15.47,0.09,26.01,1.9,nan,nan,nan,nan,0,-4.311,5.156
283.8481,-30.5252,0.013,0.09,-2.272,0.166,-1.594,0.149,16.9,1.5,14.98,14.31,14.19,0.15,26.21,0.58,nan,nan,nan,nan,0,-0.097,1.527
317.3904,-34.436,-0.031,0.103,-3.162,0.13,-2.652,0.115,16.91,1.2,15.33,14.73,14.57,0.08,25.08,3.0,nan,nan,nan,nan,0,-28.405,4.646
280.4843,-29.5453,0.028,0.054,-2.688,0.081,-1.277,0.07,15.42,1.81,13.17,12.43,12.22,0.15,26.14,1.86,nan,nan,nan,nan,0,2.947,1.105
278.4762,-31.3278,0.041,0.042,-2.688,0.085,-1.297,0.078,15.09,1.78,12.92,12.07,11.89,0.19,25.45,0.59,nan,nan,nan,nan,0,4.271,3.209
281.6682,-31.2058,-0.106,0.1,-2.993,0.213,-1.643,0.183,17.11,1.33,15.35,14.74,14.67,0.15,27.88,1.95,nan,nan,nan,nan,0,1.621,2.535
299.3169,-35.1516,-0.112,0.065,-2.498,0.101,-1.567,0.067,16.36,1.48,14.47,13.81,13.63,0.1,26.96,0.36,nan,nan,nan,nan,0,-13.516,4.742
304.1276,-35.0425,-0.015,0.18,-2.208,0.247,-1.927,0.156,17.82,1.24,16.32,15.67,15.56,0.08,24.66,2.6,nan,nan,nan,nan,0,-17.462,4.565
179.1508,15.0264,-0.061,0.075,-2.018,0.075,-0.968,0.067,15.25,1.49,13.34,12.66,12.54,0.04,31.9,6.01,nan,nan,nan,nan,0,110.074,3.095
288.7982,-31.4918,-0.155,0.114,-2.541,0.186,-1.563,0.175,17.43,1.48,15.59,14.95,14.75,0.13,27.33,1.09,nan,nan,nan,nan,0,-4.438,1.842
286.6414,-29.8288,-0.062,0.123,-2.469,0.228,-1.461,0.222,17.2,1.44,15.44,14.66,14.56,0.13,27.39,0.79,nan,nan,nan,nan,0,-2.369,0.453
285.2636,-31.8386,0.066,0.257,-2.853,0.375,-1.303,0.272,17.91,1.41,16.18,15.31,15.13,0.12,27.09,0.51,nan,nan,nan,nan,0,-1.51,2.621
284.1345,-29.1543,-0.434,0.19,-2.849,0.294,-1.446,0.244,17.9,1.46,16.02,15.33,15.14,0.18,28.87,2.02,nan,nan,nan,nan,0,-0.108,0.134
46.5297,7.7742,-0.07,0.167,-0.217,0.291,-1.631,0.237,17.63,1.97,15.11,14.35,14.09,0.53,27.72,3.13,nan,nan,nan,nan,0,-122.078,-0.26
74.7351,24.9118,0.058,0.076,0.243,0.144,-0.926,0.084,16.64,2.57,13.6,12.75,12.45,0.75,47.16,3.18,nan,nan,nan,nan,0,-153.845,-3.479
292.0609,-34.1977,-0.053,0.064,-2.532,0.111,-1.229,0.105,16.4,1.61,14.33,13.67,13.55,0.12,27.01,2.53,nan,nan,nan,nan,0,-7.479,4.211
286.7653,-31.6859,-0.043,0.04,-2.829,0.063,-1.234,0.055,14.37,1.85,12.11,11.33,11.11,0.09,25.9,0.12,nan,nan,nan,nan,0,-2.749,2.274
287.2612,-32.2397,-0.025,0.038,-2.391,0.06,-1.332,0.056,14.63,2.13,12.11,11.25,11.04,0.1,26.2,1.83,175.07,15.62,nan,nan,3,-3.246,2.761
287.5538,-33.3801,0.042,0.068,-2.611,0.096,-1.474,0.085,15.76,1.49,13.87,13.17,13.03,0.09,27.66,0.22,nan,nan,nan,nan,0,-3.653,3.855
283.6092,-31.1058,-0.07,0.19,-2.027,0.304,-1.445,0.278,18.21,1.37,16.45,15.63,15.49,0.14,28.95,1.78,nan,nan,nan,nan,0,0.005,2.134
235.9634,-6.9632,0.007,0.103,-0.954,0.196,-0.544,0.143,17.19,1.61,15.18,14.45,14.3,0.16,48.12,4.17,nan,nan,nan,nan,0,50.116,-4.974
354.4963,-30.8242,0.072,0.125,-2.686,0.154,-4.12,0.158,16.92,1.1,15.52,14.96,14.88,0.01,20.69,2.63,nan,nan,nan,nan,0,-59.551,9.591
291.3025,-30.8768,-0.114,0.044,-2.39,0.071,-1.426,0.059,15.02,1.81,12.79,11.96,11.8,0.08,27.04,2.17,nan,nan,nan,nan,0,-6.493,0.975
298.442,-28.57,0.018,0.104,-2.698,0.163,-1.91,0.1,17.09,1.42,15.3,14.65,14.44,0.14,27.36,2.09,nan,nan,nan,nan,0,-12.495,-1.803
289.2943,-31.004,-0.142,0.07,-2.479,0.122,-1.579,0.114,16.12,1.54,14.27,13.54,13.43,0.11,28.22,0.67,nan,nan,nan,nan,0,-4.797,1.304
295.562,-33.2325,-0.077,0.061,-3.153,0.096,-1.925,0.068,16.16,1.57,14.19,13.47,13.3,0.16,26.46,1.31,nan,nan,nan,nan,0,-10.302,2.996
340.4915,-18.6256,-0.109,0.095,-1.753,0.179,-2.856,0.154,16.81,1.23,15.34,14.65,14.52,0.03,21.18,3.15,nan,nan,nan,nan,0,-51.934,-6.28
295.161,-34.5187,0.05,0.18,-3.1,0.255,-1.833,0.188,17.98,1.36,16.44,15.65,15.55,0.18,27.63,2.05,nan,nan,nan,nan,0,-10.064,4.303
284.3917,-31.6157,0.069,0.064,-2.344,0.113,-1.2,0.105,16.26,1.76,14.08,13.3,13.15,0.15,27.38,1.26,nan,nan,nan,nan,0,-0.741,2.523
285.4284,-30.7284,0.093,0.079,-2.95,0.099,-1.355,0.086,15.11,2.53,12.26,11.31,11.06,0.15,25.91,0.54,145.68,1.97,nan,nan,6,-1.472,1.503
283.9446,-32.0499,0.036,0.242,-2.408,0.424,-0.744,0.343,18.02,1.33,16.22,15.47,15.39,0.16,26.05,0.93,nan,nan,nan,nan,0,-0.44,3.015
288.486,-31.941,-0.078,0.178,-2.255,0.327,-0.97,0.295,17.91,1.18,16.65,15.86,15.71,0.12,28.47,1.2,nan,nan,nan,nan,0,-4.234,2.322
247.2227,-7.0769,-0.173,0.226,-1.709,0.366,-0.139,0.25,17.96,1.72,15.72,15.02,14.84,0.37,43.38,1.53,nan,nan,nan,nan,0,40.004,-9.915
284.3152,-30.9504,-0.002,0.091,-2.78,0.114,-1.428,0.097,15.86,1.91,13.52,12.71,12.46,0.14,27.15,0.66,nan,nan,nan,nan,0,-0.565,1.878
281.14,-30.5205,0.05,0.097,-2.518,0.107,-1.196,0.088,15.2,1.86,12.93,12.08,11.87,0.13,27.92,1.21,nan,nan,nan,nan,0,2.198,1.95
283.6055,-30.0328,0.057,0.203,-2.063,0.415,-1.542,0.348,18.21,1.29,16.15,15.49,15.36,0.16,26.38,1.78,nan,nan,nan,nan,0,0.195,1.078
285.7503,-29.5968,-0.421,0.361,-2.001,0.356,-1.458,0.295,17.83,1.3,15.95,15.35,15.21,0.13,28.38,0.1,nan,nan,nan,nan,0,-1.569,0.342
277.8956,-27.6501,-0.054,0.151,-2.768,0.282,-1.194,0.253,17.44,1.74,15.12,14.31,14.1,0.39,26.05,0.69,nan,nan,nan,nan,0,5.567,-0.27
282.8582,-29.8503,-0.156,0.118,-2.929,0.217,-1.437,0.196,17.3,1.38,15.64,14.95,14.86,0.17,26.46,0.3,nan,nan,nan,nan,0,0.864,1.013
284.511,-30.5188,-0.009,0.048,-2.849,0.085,-1.483,0.073,15.49,1.64,13.42,12.69,12.52,0.14,29.19,3.83,nan,nan,nan,nan,0,-0.659,1.424
284.0924,-30.959,-0.062,0.208,-3.047,0.254,-1.334,0.208,17.43,1.43,15.6,14.96,14.84,0.15,27.15,2.21,nan,nan,nan,nan,0,-0.378,1.919
297.7243,-34.9992,-0.0,0.032,-3.312,0.055,-1.654,0.036,14.6,1.84,12.33,11.49,11.32,0.15,27.05,1.47,nan,nan,nan,nan,0,-12.203,4.649
262.6754,-14.1915,0.087,0.088,-2.66,0.19,-0.766,0.138,16.75,2.04,14.23,13.41,13.2,0.55,28.03,3.44,nan,nan,nan,nan,0,23.021,-9.206
198.654,14.5694,-0.052,0.076,-1.214,0.18,-0.802,0.104,16.89,1.4,15.07,14.4,14.3,0.02,41.37,5.13,-65.38,5.05,-1.05,0.19,2,93.1,-5.152
280.3345,-29.9735,-0.126,0.08,-3.042,0.127,-1.39,0.11,16.07,1.59,14.08,13.36,13.21,0.16,27.59,1.26,nan,nan,nan,nan,0,2.989,1.551
279.4966,-33.4856,-0.036,0.07,-2.658,0.133,-1.356,0.124,16.33,1.6,14.35,13.65,13.46,0.14,26.61,2.11,nan,nan,nan,nan,0,2.968,5.134
282.9824,-29.351,-0.029,0.07,-2.913,0.147,-1.603,0.137,16.39,1.72,14.25,13.41,13.28,0.17,27.56,0.97,nan,nan,nan,nan,0,0.848,0.503
282.7594,-31.9029,0.026,0.2,-2.569,0.319,-1.282,0.31,18.17,1.32,16.5,15.78,15.53,0.13,27.15,0.34,nan,nan,nan,nan,0,0.577,3.048
290.0045,-31.0996,0.002,0.103,-2.493,0.143,-1.311,0.137,16.63,1.45,14.77,14.09,14.01,0.11,27.78,0.95,nan,nan,nan,nan,0,-5.412,1.324
299.7819,-33.3152,-0.182,0.069,-2.848,0.104,-1.883,0.064,16.27,1.56,14.31,13.63,13.49,0.14,27.62,3.08,nan,nan,nan,nan,0,-13.834,2.893
226.2366,-0.7421,0.059,0.074,-0.964,0.129,-0.484,0.127,16.4,1.68,14.29,13.51,13.36,0.06,52.51,2.58,nan,nan,nan,nan,0,61.666,-5.704
284.9911,-32.3688,0.048,0.051,-2.355,0.12,-1.263,0.093,15.52,1.48,13.63,13.0,12.91,0.13,26.42,0.82,nan,nan,nan,nan,0,-1.368,3.182
284.5675,-31.4395,-0.013,0.057,-2.797,0.092,-1.488,0.078,15.5,1.97,13.12,12.25,12.04,0.14,28.26,0.65,nan,nan,nan,nan,0,-0.86,2.324
279.409,-31.602,-0.067,0.052,-2.709,0.078,-1.137,0.068,15.52,1.56,13.61,12.88,12.75,0.12,26.42,0.61,nan,nan,nan,nan,0,3.434,3.308
287.7018,-28.8341,-0.075,0.074,-2.718,0.131,-1.292,0.105,16.31,1.61,14.22,13.53,13.37,0.16,28.64,2.33,nan,nan,nan,nan,0,-3.141,-0.664
282.2934,-32.2734,0.082,0.074,-2.892,0.142,-1.275,0.121,16.53,1.44,14.77,14.07,13.88,0.15,26.56,0.69,nan,nan,nan,nan,0,0.898,3.484
283.2891,-29.3815,0.031,0.085,-2.392,0.149,-0.867,0.128,16.74,1.48,14.83,14.2,14.1,0.17,27.18,0.51,nan,nan,nan,nan,0,0.579,0.485
296.9892,-30.1578,0.054,0.065,-2.959,0.094,-2.042,0.052,15.71,1.67,13.6,12.84,12.71,0.17,28.23,0.98,nan,nan,nan,nan,0,-11.314,-0.151
306.1051,-36.7668,-0.038,0.065,-2.672,0.092,-1.612,0.062,15.54,1.39,13.77,13.14,13.02,0.05,24.46,0.53,nan,nan,nan,nan,0,-19.048,6.31
292.1508,-31.7534,-0.328,0.114,-2.836,0.174,-1.395,0.16,16.95,1.35,15.25,14.62,14.45,0.06,26.64,1.06,nan,nan,nan,nan,0,-7.306,1.771
281.9122,-30.4067,0.006,0.046,-2.776,0.077,-1.286,0.069,15.33,1.9,12.96,12.14,11.91,0.18,25.65,2.5,160.0,0.02,-0.64,0.02,1,1.566,1.711
286.1217,-29.5625,-0.01,0.057,-2.74,0.104,-1.309,0.096,16.18,1.51,14.28,13.62,13.49,0.13,26.86,1.56,nan,nan,nan,nan,0,-1.883,0.258
279.6335,-30.2746,-0.058,0.045,-2.749,0.08,-1.208,0.072,15.13,1.77,12.9,12.13,11.99,0.14,27.38,0.07,nan,nan,nan,nan,0,3.521,1.969
285.1817,-30.5501,0.03,0.075,-2.623,0.115,-1.432,0.099,16.12,1.72,14.01,13.22,13.04,0.12,26.94,0.96,nan,nan,nan,nan,0,-1.234,1.361
282.4431,-28.5333,0.049,0.073,-2.754,0.109,-1.167,0.094,14.89,2.58,11.87,10.95,10.71,0.15,28.32,0.75,147.6,0.01,-0.58,0.02,1,1.46,-0.216
290.8714,-31.0389,-0.086,0.065,-2.279,0.131,-1.587,0.105,15.87,1.5,13.98,13.29,13.18,0.09,27.53,0.81,nan,nan,nan,nan,0,-6.143,1.177
283.7414,-30.4487,-0.078,0.054,-2.671,0.1,-1.534,0.089,15.8,1.63,13.71,12.99,12.8,0.15,27.21,1.31,134.48,nan,nan,nan,4,0.007,1.468
214.9265,-1.4607,-0.015,0.064,-1.181,0.124,-0.611,0.098,16.25,1.63,14.25,13.45,13.31,0.06,49.74,1.22,nan,nan,nan,nan,0,71.089,0.61
294.8716,-28.696,-0.078,0.076,-2.479,0.113,-1.86,0.089,14.6,2.44,11.87,10.96,10.75,0.11,27.9,1.63,nan,nan,nan,nan,0,-9.374,-1.484
284.5718,-31.7852,0.086,0.076,-2.64,0.103,-1.259,0.095,16.1,1.54,13.9,13.2,12.98,0.13,26.51,0.78,nan,nan,nan,nan,0,-0.921,2.664
235.3317,-17.3435,-0.183,0.108,-1.45,0.222,-0.412,0.144,17.01,1.6,15.04,14.16,14.01,0.1,43.03,4.09,nan,nan,nan,nan,0,45.768,4.475
306.2619,-36.9133,-0.091,0.064,-2.767,0.09,-1.723,0.056,15.68,1.42,13.93,13.3,13.19,0.05,24.82,0.67,nan,nan,nan,nan,0,-19.171,6.46
289.1088,-32.3578,0.002,0.165,-2.879,0.286,-1.252,0.263,17.81,1.35,16.09,15.46,15.31,0.1,27.54,0.87,nan,nan,nan,nan,0,-4.812,2.666
291.8934,-34.1211,0.055,0.188,-2.426,0.311,-1.425,0.318,18.1,1.18,16.76,15.71,15.41,0.12,27.01,1.06,nan,nan,nan,nan,0,-7.333,4.149
34.0403,13.4535,-0.192,0.173,0.16,0.279,-1.714,0.244,17.69,1.26,16.05,15.38,15.26,0.12,25.53,3.42,nan,nan,nan,nan,0,-114.32,-11.369
286.3667,-30.7296,0.094,0.107,-2.546,0.141,-1.477,0.116,16.08,1.66,14.01,13.24,13.13,0.11,27.65,2.39,nan,nan,nan,nan,0,-2.269,1.379
283.341,-31.2534,0.032,0.088,-2.591,0.173,-1.508,0.138,16.54,1.63,14.52,13.8,13.56,0.16,26.86,1.02,nan,nan,nan,nan,0,0.205,2.32
289.3597,-31.9373,-0.097,0.108,-2.445,0.17,-1.31,0.162,16.93,1.42,15.15,14.45,14.16,0.11,27.52,1.13,nan,nan,nan,nan,0,-4.969,2.222
283.7637,-31.3171,0.095,0.059,-2.715,0.134,-1.17,0.134,16.0,1.73,13.81,13.02,12.88,0.14,26.68,1.24,nan,nan,nan,nan,0,-0.162,2.32
285.2477,-30.0828,-0.07,0.055,-2.57,0.091,-1.469,0.082,15.9,1.55,13.95,13.24,13.12,0.13,27.33,0.23,nan,nan,nan,nan,0,-1.215,0.89
283.7097,-30.8897,-0.032,0.066,-2.762,0.092,-1.27,0.077,15.67,1.56,13.7,13.06,12.91,0.15,27.68,3.45,nan,nan,nan,nan,0,-0.043,1.907
280.7128,-30.9409,0.073,0.034,-2.7,0.058,-1.448,0.052,14.84,1.88,12.53,11.68,11.52,0.13,26.49,2.14,nan,nan,nan,nan,0,2.476,2.434
226.2079,-5.1558,-0.018,0.053,-0.97,0.093,-0.351,0.081,15.82,1.86,13.57,12.77,12.53,0.08,51.99,3.11,nan,nan,nan,nan,0,59.496,-1.857
288.0792,-32.9903,-0.118,0.189,-2.227,0.296,-1.597,0.271,17.93,1.17,16.56,15.78,15.56,0.09,26.76,0.78,nan,nan,nan,nan,0,-4.035,3.408
282.6327,-29.5988,0.013,0.055,-2.94,0.088,-1.342,0.077,15.15,2.17,12.59,11.7,11.45,0.16,27.79,0.57,nan,nan,nan,nan,0,1.103,0.801
281.1442,-30.7253,-0.221,0.202,-2.384,0.309,-1.088,0.267,17.98,1.28,16.59,15.97,15.85,0.13,27.42,2.14,nan,nan,nan,nan,0,2.155,2.15
281.5457,-30.0642,-0.159,0.224,-2.367,0.322,-1.373,0.289,18.13,1.37,16.37,15.8,15.73,0.15,26.54,2.51,nan,nan,nan,nan,0,1.942,1.434
280.7155,-29.3242,-0.004,0.034,-2.662,0.058,-1.317,0.049,14.45,1.96,12.04,11.22,11.03,0.15,26.83,1.18,nan,nan,nan,nan,0,2.794,0.849
231.6477,-8.6326,-0.184,0.108,-0.864,0.167,-0.647,0.134,16.92,1.63,14.83,14.12,13.9,0.1,48.66,6.92,nan,nan,nan,nan,0,53.083,-1.467
284.9468,-29.3833,0.085,0.043,-2.536,0.083,-1.171,0.069,15.5,1.64,13.47,12.71,12.56,0.15,25.67,0.93,nan,nan,nan,nan,0,-0.845,0.242
287.0711,-31.6227,0.062,0.044,-2.999,0.071,-1.556,0.07,15.15,1.97,12.79,11.9,11.72,0.09,26.92,1.09,152.05,1.02,nan,nan,6,-2.998,2.173
283.355,-30.5678,0.012,0.056,-2.966,0.083,-1.265,0.071,15.3,1.59,13.33,12.58,12.45,0.13,25.44,0.41,nan,nan,nan,nan,0,0.314,1.643
282.0465,-28.9143,0.077,0.205,-2.483,0.371,-0.927,0.311,18.17,1.35,16.39,15.61,15.27,0.18,26.37,1.0,nan,nan,nan,nan,0,1.731,0.223
283.4768,-31.1959,0.099,0.075,-2.693,0.133,-1.4,0.106,16.17,1.75,13.96,13.17,13.05,0.15,27.5,1.6,nan,nan,nan,nan,0,0.101,2.243
298.3499,-34.0945,-0.13,0.096,-2.825,0.124,-1.742,0.091,16.57,1.62,14.52,13.8,13.71,0.16,27.28,2.79,nan,nan,nan,nan,0,-12.674,3.719
311.6874,-31.3743,-0.347,0.102,-1.99,0.143,-1.775,0.113,16.67,1.36,15.0,14.35,14.2,0.07,23.38,1.19,nan,nan,nan,nan,0,-23.927,1.14
279.078,-28.378,0.092,0.09,-2.716,0.194,-1.315,0.178,17.02,1.7,14.91,14.13,13.81,0.24,27.27,1.88,nan,nan,nan,nan,0,4.391,0.215
347.552,-15.9067,0.057,0.055,-2.359,0.102,-3.8,0.082,15.59,1.28,13.97,13.38,13.27,0.03,20.83,2.81,nan,nan,nan,nan,0,-59.241,-6.618
39.0321,0.6896,-0.054,0.043,-0.218,0.076,-2.191,0.074,15.32,1.48,13.44,12.77,12.62,0.03,31.15,2.81,-144.39,0.67,-1.14,0.09,5,-112.061,2.133
36.6714,-7.0017,-0.085,0.117,-0.335,0.14,-2.402,0.139,16.63,1.31,14.99,14.31,14.22,0.03,26.64,3.89,nan,nan,nan,nan,0,-106.102,7.563
283.7606,-29.7597,-0.032,0.06,-2.513,0.117,-1.212,0.104,16.16,1.72,13.98,13.22,13.12,0.17,27.76,0.13,nan,nan,nan,nan,0,0.109,0.786
285.5876,-30.2144,0.024,0.059,-2.814,0.109,-1.354,0.093,16.05,1.51,14.14,13.44,13.27,0.13,27.17,3.09,nan,nan,nan,nan,0,-1.526,0.974
283.108,-28.7278,-0.232,0.128,-2.444,0.169,-1.399,0.146,17.2,1.49,15.36,14.64,14.53,0.18,26.15,0.95,nan,nan,nan,nan,0,0.851,-0.13
282.9849,-33.9126,0.031,0.063,-2.974,0.124,-0.929,0.106,16.2,1.32,14.57,13.91,13.84,0.08,26.93,1.23,nan,nan,nan,nan,0,0.027,4.99
145.9562,21.9052,-0.048,0.053,-2.123,0.076,-2.12,0.064,14.92,1.55,13.0,12.29,12.14,0.03,21.44,0.66,-23.69,5.28,-0.67,0.07,2,142.17,6.537
285.863,-29.9851,0.019,0.045,-2.563,0.087,-1.45,0.079,15.25,2.11,12.7,11.8,11.54,0.13,26.63,0.45,nan,nan,nan,nan,0,-1.726,0.71
282.8242,-30.8136,-0.01,0.06,-2.725,0.13,-1.247,0.111,15.78,1.68,13.67,12.92,12.74,0.15,26.96,0.45,nan,nan,nan,nan,0,0.72,1.966
287.4835,-29.4801,-0.207,0.224,-2.327,0.339,-1.15,0.309,18.03,1.34,16.42,15.5,15.17,0.14,25.94,0.88,nan,nan,nan,nan,0,-3.043,0.002
174.0333,30.764,-0.063,0.049,-1.951,0.062,-1.296,0.058,14.45,1.62,12.44,11.76,11.63,0.02,28.69,1.68,nan,nan,nan,nan,0,120.794,-9.377
290.6217,-34.2093,-0.068,0.052,-2.483,0.081,-1.315,0.071,15.67,1.62,13.6,12.91,12.75,0.11,27.34,3.06,nan,nan,nan,nan,0,-6.294,4.351
252.3941,-27.5354,-0.008,0.055,-1.786,0.118,-0.638,0.054,15.67,2.07,13.13,12.23,12.02,0.26,39.0,4.48,nan,nan,nan,nan,0,27.067,6.715
8.6662,-13.1557,0.058,0.041,-1.278,0.086,-3.115,0.054,15.1,1.34,13.43,12.78,12.65,0.02,23.0,2.1,nan,nan,nan,nan,0,-79.041,-0.712
14.7146,-6.2279,-0.075,0.029,-1.252,0.06,-3.501,0.038,14.61,1.53,12.73,11.98,11.88,0.07,25.09,0.74,nan,nan,nan,nan,0,-87.567,-4.02
283.4244,-31.7979,-0.065,0.113,-2.864,0.198,-1.528,0.177,17.11,1.48,15.23,14.6,14.44,0.16,26.99,2.18,nan,nan,nan,nan,0,0.039,2.843
287.4813,-29.8465,0.07,0.08,-2.63,0.147,-1.321,0.142,16.77,1.38,14.96,14.34,14.19,0.12,27.17,1.31,nan,nan,nan,nan,0,-3.093,0.365
278.962,-29.8909,0.047,0.076,-2.744,0.136,-1.493,0.115,16.46,1.71,14.27,13.5,13.39,0.18,28.42,1.34,nan,nan,nan,nan,0,4.17,1.716
286.5996,-32.0587,-0.005,0.079,-2.615,0.151,-1.549,0.138,16.19,1.46,14.32,13.64,13.53,0.1,26.83,1.19,nan,nan,nan,nan,0,-2.665,2.664
288.8271,-31.8909,-0.067,0.211,-2.298,0.254,-1.457,0.217,17.78,1.37,16.14,15.31,14.9,0.11,28.74,0.41,nan,nan,nan,nan,0,-4.515,2.234
285.6773,-30.4309,0.041,0.053,-2.557,0.085,-1.618,0.076,15.76,1.69,13.53,12.79,12.63,0.14,27.93,1.38,135.25,1.92,nan,nan,6,-1.637,1.175
289.3878,-33.8493,-0.054,0.07,-2.853,0.121,-1.323,0.115,14.76,2.61,11.83,10.88,10.63,0.09,26.41,0.74,nan,nan,nan,nan,0,-5.233,4.116
163.326,16.5415,-0.101,0.228,-1.931,0.332,-1.287,0.288,18.06,1.11,16.79,15.96,15.8,0.03,25.32,0.94,nan,nan,nan,nan,0,124.82,7.402
353.3315,-16.5976,-0.072,0.174,-1.821,0.263,-3.678,0.293,17.48,1.12,16.13,15.46,15.38,0.03,19.14,2.15,nan,nan,nan,nan,0,-64.158,-3.917
290.963,-31.349,0.027,0.047,-2.412,0.09,-1.262,0.089,15.67,1.63,13.63,12.88,12.77,0.08,27.44,1.0,nan,nan,nan,nan,0,-6.256,1.477
250.4379,-15.5964,0.088,0.164,-1.594,0.363,-0.538,0.145,18.0,1.86,15.57,14.8,14.64,0.47,31.95,2.78,nan,nan,nan,nan,0,33.536,-3.49
287.6938,-32.9438,-0.177,0.103,-2.715,0.213,-1.317,0.181,16.97,1.33,15.24,14.62,14.57,0.09,26.37,0.39,nan,nan,nan,nan,0,-3.708,3.406
302.9136,-33.1516,-0.125,0.138,-2.061,0.203,-1.864,0.116,17.16,1.62,15.07,14.37,14.21,0.24,26.85,5.06,nan,nan,nan,nan,0,-16.453,2.676
283.7538,-30.469,0.017,0.036,-2.396,0.065,-1.319,0.054,14.61,1.75,12.37,11.59,11.46,0.15,27.11,1.54,nan,nan,nan,nan,0,-0.007,1.486
161.8978,29.6386,-0.006,0.049,-2.172,0.114,-1.715,0.07,15.47,1.28,13.84,13.23,13.15,0.03,23.82,1.93,-73.32,7.78,-1.64,0.06,2,130.26,-4.588
55.2141,5.5078,-0.036,0.062,0.204,0.125,-1.848,0.101,16.35,1.77,14.14,13.31,13.12,0.28,31.44,5.16,nan,nan,nan,nan,0,-128.534,5.904
292.5266,-34.0479,-0.008,0.041,-2.784,0.065,-1.503,0.062,15.03,1.75,12.88,12.06,11.91,0.13,27.04,2.91,nan,nan,nan,nan,0,-7.849,4.023
281.5796,-30.7054,-0.021,0.083,-2.645,0.126,-1.086,0.108,16.22,1.7,14.06,13.31,13.12,0.16,27.19,0.39,nan,nan,nan,nan,0,1.791,2.058
283.2181,-30.711,-0.06,0.083,-2.531,0.14,-1.178,0.127,16.73,1.54,14.8,14.09,13.98,0.14,25.44,0.64,nan,nan,nan,nan,0,0.405,1.805
278.3687,-29.0347,-0.052,0.104,-2.458,0.218,-1.266,0.212,17.32,1.68,15.21,14.28,14.09,0.29,27.45,0.72,nan,nan,nan,nan,0,4.858,0.99
292.3674,-33.3837,0.026,0.067,-2.552,0.103,-1.461,0.084,14.87,2.28,12.21,11.29,11.06,0.12,25.83,0.57,nan,nan,nan,nan,0,-7.651,3.375
289.7065,-29.4842,-0.08,0.043,-2.609,0.09,-1.938,0.087,15.67,1.61,13.61,12.85,12.72,0.14,26.2,1.55,nan,nan,nan,nan,0,-4.962,-0.249
21.4454,-10.3785,0.054,0.048,-1.121,0.093,-3.827,0.049,15.07,1.35,13.34,12.76,12.66,0.03,25.57,4.58,nan,nan,nan,nan,0,-91.351,2.855
278.6609,-28.8679,0.051,0.046,-2.979,0.082,-1.22,0.068,15.25,2.15,12.65,11.77,11.52,0.27,27.45,0.51,nan,nan,nan,nan,0,4.645,0.772
297.6547,-31.1596,-0.013,0.057,-2.403,0.096,-1.781,0.058,16.02,1.46,14.24,13.6,13.48,0.14,29.17,2.19,nan,nan,nan,nan,0,-11.942,0.817
230.9658,-12.1478,-0.015,0.112,-0.809,0.214,-0.626,0.152,17.07,1.59,15.09,14.36,14.28,0.16,48.53,4.5,nan,nan,nan,nan,0,51.971,1.934
293.0789,-33.1871,-0.023,0.036,-2.821,0.062,-2.088,0.058,14.61,1.94,12.29,11.41,11.22,0.09,26.71,0.55,nan,nan,nan,nan,0,-8.225,3.122
164.1773,13.0404,-0.111,0.148,-1.449,0.236,-0.964,0.184,17.58,1.11,16.15,15.54,15.48,0.02,25.27,1.27,nan,nan,nan,nan,0,122.862,10.434
287.9858,-31.7003,-0.059,0.056,-2.631,0.119,-1.558,0.093,15.94,1.44,14.09,13.41,13.34,0.08,28.68,1.56,nan,nan,nan,nan,0,-3.78,2.141
291.6896,-30.654,-0.011,0.08,-2.819,0.128,-1.437,0.118,16.73,1.34,15.1,14.43,14.31,0.09,27.16,1.76,nan,nan,nan,nan,0,-6.8,0.718
280.7647,-29.2827,-0.017,0.083,-2.763,0.149,-1.532,0.131,16.21,1.73,13.94,13.2,12.94,0.15,26.83,1.18,nan,nan,nan,nan,0,2.76,0.799
293.9462,-32.601,-0.012,0.157,-2.009,0.262,-1.584,0.248,17.95,1.26,16.53,15.79,15.5,0.11,26.77,2.24,nan,nan,nan,nan,0,-8.899,2.473
291.2716,-30.8882,0.071,0.166,-2.656,0.24,-1.699,0.264,17.46,1.33,15.86,15.14,15.08,0.08,27.53,0.73,nan,nan,nan,nan,0,-6.468,0.99
286.4393,-30.9966,-0.265,0.148,-2.377,0.27,-1.581,0.251,17.96,1.34,16.47,15.74,15.67,0.1,28.99,1.45,nan,nan,nan,nan,0,-2.371,1.634
289.6243,-32.9151,-0.119,0.227,-2.422,0.419,-1.909,0.325,17.84,1.32,16.24,15.49,15.44,0.1,27.02,1.3,nan,nan,nan,nan,0,-5.313,3.165
46.5619,10.4873,-0.08,0.044,0.14,0.085,-1.564,0.072,15.25,1.91,12.96,12.06,11.86,0.23,30.36,0.78,nan,nan,nan,nan,0,-123.448,-2.602
289.4315,-35.2056,0.056,0.064,-2.666,0.112,-1.36,0.111,14.77,2.46,11.97,11.07,10.81,0.1,27.36,1.77,nan,nan,nan,nan,0,-5.439,5.458
13.1651,-13.4244,0.009,0.065,-0.733,0.131,-2.411,0.097,16.6,1.31,14.99,14.32,14.23,0.02,22.42,0.51,nan,nan,nan,nan,0,-82.785,1.573
357.2289,-27.5487,0.038,0.032,-1.251,0.054,-2.829,0.046,14.36,1.7,12.31,11.47,11.38,0.02,24.19,1.26,nan,nan,nan,nan,0,-63.099,7.563
288.169,-31.8852,-0.135,0.19,-2.967,0.394,-1.181,0.341,17.83,1.25,16.23,15.5,15.39,0.11,26.03,0.58,nan,nan,nan,nan,0,-3.96,2.303
285.8691,-29.1833,-0.125,0.069,-2.507,0.118,-1.526,0.109,16.11,1.71,13.91,13.16,13.06,0.16,26.36,1.55,nan,nan,nan,nan,0,-1.607,-0.083
283.8347,-30.9873,-0.016,0.06,-2.734,0.093,-1.293,0.083,16.0,1.74,13.83,12.99,12.91,0.15,27.63,2.35,nan,nan,nan,nan,0,-0.165,1.984
277.795,-29.9867,-0.053,0.095,-2.702,0.145,-1.197,0.125,16.74,1.5,14.81,14.16,14.02,0.21,26.68,0.97,nan,nan,nan,nan,0,5.137,2.028
296.9056,-33.2322,0.085,0.227,-2.046,0.306,-1.41,0.235,18.27,1.35,16.78,15.89,15.6,0.19,26.84,0.98,nan,nan,nan,nan,0,-11.425,2.922
149.8325,18.0136,0.048,0.047,-1.904,0.073,-1.848,0.076,15.15,1.39,13.41,12.78,12.62,0.03,21.21,1.23,nan,nan,nan,nan,0,137.745,9.574
283.4179,-30.2877,0.027,0.056,-2.705,0.084,-1.561,0.079,15.36,2.04,12.87,11.99,11.77,0.16,26.88,0.91,146.44,nan,nan,nan,4,0.31,1.358
306.553,-33.015,0.066,0.063,-3.182,0.092,-2.445,0.072,16.15,1.29,14.51,13.91,13.84,0.07,24.02,0.5,nan,nan,nan,nan,0,-19.506,2.568
284.539,-29.6292,0.062,0.055,-2.719,0.103,-1.247,0.106,15.51,1.84,13.27,12.42,12.27,0.19,27.88,0.79,nan,nan,nan,nan,0,-0.535,0.543
283.2506,-32.3696,-0.12,0.072,-2.914,0.114,-1.337,0.092,15.78,1.64,13.68,12.98,12.77,0.13,26.35,0.98,146.1,nan,nan,nan,4,0.083,3.432
287.4445,-32.3422,-0.028,0.034,-2.75,0.063,-1.419,0.066,14.83,1.78,12.55,11.8,11.61,0.1,27.0,1.54,nan,nan,nan,nan,0,-3.415,2.84
261.642,-21.823,0.084,0.168,-2.431,0.326,-1.057,0.242,17.65,2.63,14.43,13.5,13.19,1.17,32.66,2.66,nan,nan,nan,nan,0,21.359,-1.691
290.0495,-30.0161,0.067,0.063,-2.629,0.092,-1.543,0.079,15.83,1.81,13.59,12.79,12.63,0.14,27.67,0.09,nan,nan,nan,nan,0,-5.322,0.243
196.9551,4.2819,-0.048,0.047,-1.223,0.103,-0.624,0.067,15.51,2.09,13.1,12.19,11.96,0.03,42.36,5.06,nan,nan,nan,nan,0,89.53,4.642
79.2782,18.3587,-0.029,0.204,-0.058,0.35,-0.797,0.311,18.16,1.87,15.82,15.09,14.98,0.47,47.49,1.57,nan,nan,nan,nan,0,-155.351,4.168
285.5904,-28.8784,-0.022,0.071,-2.876,0.136,-1.0,0.105,15.91,1.83,13.63,12.82,12.61,0.16,28.53,1.01,nan,nan,nan,nan,0,-1.319,-0.346
278.4861,-30.1671,-0.07,0.227,-2.092,0.321,-0.932,0.268,18.03,1.52,16.29,15.56,15.33,0.21,27.02,1.17,nan,nan,nan,nan,0,4.514,2.073
138.0136,15.6089,0.065,0.029,-2.301,0.047,-2.858,0.037,13.79,1.51,11.89,11.18,11.03,0.04,17.77,3.63,-9.57,0.02,-0.51,0.01,1,148.677,13.965
238.1444,-15.4848,-0.113,0.085,-1.642,0.17,-0.438,0.105,15.48,2.61,12.56,11.62,11.3,0.18,41.39,4.99,nan,nan,nan,nan,0,44.248,1.571
288.8523,-34.0233,0.052,0.17,-2.781,0.317,-1.366,0.303,18.03,1.3,16.45,15.67,15.57,0.08,26.0,1.0,nan,nan,nan,nan,0,-4.813,4.346
290.9267,-29.6536,-0.004,0.061,-2.814,0.121,-1.625,0.115,15.78,1.74,13.67,12.79,12.69,0.11,26.91,1.13,nan,nan,nan,nan,0,-6.036,-0.205
319.8927,-30.3133,0.029,0.074,-2.259,0.097,-2.167,0.085,15.63,1.71,13.48,12.74,12.52,0.1,26.46,4.45,nan,nan,nan,nan,0,-31.045,0.837
283.0252,-30.7985,-0.11,0.104,-2.367,0.204,-0.842,0.186,17.28,1.34,15.57,14.92,14.8,0.15,26.01,2.28,nan,nan,nan,nan,0,0.552,1.92
282.6851,-27.5192,0.072,0.137,-2.818,0.198,-1.513,0.177,17.42,1.53,15.48,14.75,14.65,0.24,28.41,1.46,nan,nan,nan,nan,0,1.435,-1.252
226.7086,-4.6119,-0.135,0.121,-1.098,0.154,-0.309,0.151,16.34,1.95,13.97,13.13,12.94,0.1,52.88,1.31,nan,nan,nan,nan,0,59.332,-2.577
299.5549,-30.0313,-0.142,0.199,-2.154,0.268,-1.793,0.179,17.89,1.23,16.31,15.7,15.59,0.12,25.45,1.29,nan,nan,nan,nan,0,-13.525,-0.383
279.3059,-32.5073,-0.064,0.06,-2.778,0.106,-1.187,0.09,14.8,2.63,11.89,10.96,10.67,0.14,25.85,0.2,nan,nan,nan,nan,0,3.33,4.211
285.2628,-30.0769,-0.023,0.1,-2.745,0.173,-1.275,0.157,17.13,1.47,15.31,14.61,14.41,0.13,27.33,0.23,nan,nan,nan,nan,0,-1.227,0.882
243.4261,-14.3692,0.089,0.1,-0.992,0.19,-0.402,0.145,16.92,1.94,14.54,13.63,13.51,0.3,42.15,5.03,nan,nan,nan,nan,0,40.197,-1.728
280.4061,-29.3096,0.008,0.098,-2.841,0.173,-1.389,0.159,17.3,1.33,15.44,14.77,14.57,0.17,26.73,0.16,nan,nan,nan,nan,0,3.061,0.888
10.8307,-21.7519,-0.14,0.063,-0.946,0.086,-2.53,0.057,15.97,1.45,14.17,13.54,13.41,0.02,20.04,1.18,nan,nan,nan,nan,0,-76.863,7.857
293.3103,-30.9877,0.047,0.065,-2.557,0.094,-1.506,0.082,15.8,1.51,13.92,13.2,13.03,0.12,26.4,1.49,nan,nan,nan,nan,0,-8.218,0.914
290.6819,-30.7571,0.013,0.053,-2.498,0.1,-1.498,0.098,15.79,1.57,13.81,13.16,12.97,0.08,27.72,0.32,nan,nan,nan,nan,0,-5.95,0.916
289.806,-34.8835,-0.045,0.046,-2.557,0.076,-1.442,0.069,15.46,1.54,13.46,12.78,12.64,0.11,26.61,2.79,nan,nan,nan,nan,0,-5.704,5.1
283.3264,-29.8746,-0.096,0.06,-2.807,0.112,-1.399,0.091,15.64,1.95,13.23,12.39,12.19,0.16,25.93,0.67,nan,nan,nan,nan,0,0.46,0.965
40.0601,-0.5582,-0.031,0.055,0.293,0.081,-2.138,0.064,14.51,1.74,12.36,11.57,11.39,0.03,28.08,4.56,nan,nan,nan,nan,0,-112.318,3.73
289.0123,-31.9714,0.007,0.057,-2.566,0.079,-1.563,0.066,15.43,1.88,13.13,12.31,12.12,0.12,28.28,0.81,nan,nan,nan,nan,0,-4.681,2.294
284.7059,-31.7521,-0.007,0.043,-2.66,0.066,-1.306,0.057,15.1,1.9,12.82,11.94,11.72,0.13,25.98,1.45,nan,nan,nan,nan,0,-1.028,2.613
280.8902,-28.5942,0.014,0.064,-2.921,0.116,-1.435,0.107,16.27,1.71,14.11,13.33,13.26,0.15,26.69,0.09,nan,nan,nan,nan,0,2.788,0.103
284.4339,-29.9824,-0.053,0.058,-2.954,0.094,-1.431,0.077,15.54,1.67,13.43,12.68,12.5,0.14,28.48,2.05,nan,nan,nan,nan,0,-0.504,0.907
279.6263,-28.2765,0.018,0.072,-3.02,0.15,-1.201,0.126,16.55,1.68,14.39,13.64,13.53,0.23,28.14,4.3,nan,nan,nan,nan,0,3.94,0.015
292.7514,-30.9373,-0.043,0.193,-2.761,0.356,-1.574,0.292,17.9,1.37,16.25,15.57,15.42,0.13,27.4,1.51,nan,nan,nan,nan,0,-7.736,0.909
279.4596,-30.1913,0.035,0.078,-3.001,0.139,-1.251,0.124,16.64,1.55,14.75,14.05,13.82,0.16,28.27,1.31,nan,nan,nan,nan,0,3.686,1.919
221.6236,-3.6411,-0.21,0.132,-0.858,0.229,-0.371,0.188,17.29,1.42,15.7,14.88,14.66,0.1,49.9,3.44,nan,nan,nan,nan,0,64.214,-0.889
289.7363,-30.1067,0.014,0.12,-2.572,0.173,-1.514,0.159,16.88,1.54,14.95,14.25,14.13,0.14,26.92,1.77,nan,nan,nan,nan,0,-5.063,0.366
281.6677,-32.1797,-0.038,0.051,-2.871,0.081,-1.433,0.075,15.6,1.82,13.35,12.55,12.36,0.14,25.85,1.8,nan,nan,nan,nan,0,1.436,3.491
294.0612,-34.637,-0.029,0.117,-2.311,0.17,-1.503,0.149,16.95,1.4,15.14,14.49,14.34,0.13,27.6,2.47,nan,nan,nan,nan,0,-9.168,4.494
49.4295,8.9757,-0.087,0.082,0.138,0.147,-1.611,0.127,16.66,1.91,14.31,13.49,13.27,0.32,32.57,2.9,-158.14,4.66,-0.5,0.15,2,-125.167,0.103
218.1507,1.5005,0.038,0.106,-1.017,0.197,-0.477,0.151,17.16,1.54,15.26,14.43,14.35,0.04,48.75,1.94,nan,nan,nan,nan,0,69.81,-3.577
283.3909,-31.6551,-0.214,0.281,-2.71,0.374,-1.306,0.321,17.92,1.43,16.28,15.59,15.36,0.16,28.46,0.37,nan,nan,nan,nan,0,0.092,2.708
222.8767,-0.5964,0.093,0.091,-1.096,0.134,-0.306,0.124,16.85,1.65,14.81,14.02,13.88,0.05,50.94,2.94,nan,nan,nan,nan,0,64.66,-4.151
289.6003,-30.1039,-0.055,0.116,-2.725,0.198,-1.603,0.188,17.22,1.39,15.52,14.89,14.82,0.13,28.3,2.04,nan,nan,nan,nan,0,-4.946,0.378
287.0904,-29.3905,-0.048,0.065,-2.504,0.106,-1.329,0.102,16.26,1.71,14.15,13.39,13.33,0.12,26.81,0.26,nan,nan,nan,nan,0,-2.691,-0.038
291.0486,-28.1807,-0.023,0.044,-2.709,0.068,-1.747,0.066,15.04,1.88,12.75,11.92,11.74,0.13,26.37,3.98,nan,nan,nan,nan,0,-5.978,-1.68
286.4309,-30.6912,0.087,0.132,-1.908,0.331,-1.705,0.226,16.55,1.57,14.57,13.88,13.73,0.12,29.36,1.02,nan,nan,nan,nan,0,-2.318,1.333
342.3429,-31.2484,-0.041,0.031,-1.901,0.049,-3.046,0.044,14.04,1.57,12.15,11.45,11.29,0.02,23.62,2.48,nan,nan,nan,nan,0,-49.593,6.237
282.7582,-32.3957,-0.13,0.103,-2.825,0.17,-1.128,0.149,16.89,1.45,15.09,14.35,14.26,0.13,25.49,0.53,nan,nan,nan,nan,0,0.489,3.532
288.1051,-30.8653,-0.039,0.085,-2.869,0.149,-1.394,0.143,16.93,1.45,15.17,14.51,14.27,0.11,27.23,1.56,nan,nan,nan,nan,0,-3.767,1.299
283.924,-28.4256,-0.126,0.199,-2.708,0.302,-1.408,0.28,18.3,1.44,16.66,15.78,15.55,0.2,27.88,1.02,nan,nan,nan,nan,0,0.198,-0.553
70.2686,5.4896,-0.073,0.066,0.206,0.123,-1.525,0.08,16.49,1.52,14.53,13.78,13.68,0.15,39.82,2.39,nan,nan,nan,nan,0,-142.109,12.634
291.9645,-32.1903,-0.13,0.081,-2.246,0.13,-1.395,0.119,16.55,1.49,14.67,13.93,13.83,0.07,27.9,0.24,nan,nan,nan,nan,0,-7.193,2.222
255.4555,-29.4246,-0.167,0.15,-1.889,0.228,-0.241,0.147,17.59,1.52,15.59,15.01,14.92,0.27,29.21,3.28,nan,nan,nan,nan,0,23.828,7.405
294.159,-32.4993,0.098,0.139,-2.151,0.217,-1.214,0.215,17.37,1.41,15.57,14.99,14.89,0.12,26.14,0.94,nan,nan,nan,nan,0,-9.069,2.357
262.5152,-24.1721,0.051,0.161,-1.295,0.195,-0.562,0.152,16.84,3.04,13.01,11.89,11.45,1.47,32.66,2.66,nan,nan,nan,nan,0,19.811,0.25
19.8247,-9.9743,0.045,0.043,-0.958,0.11,-2.851,0.047,15.2,1.37,13.48,12.86,12.77,0.04,20.52,5.54,-104.82,1.32,-1.6,0.09,5,-90.163,1.715
284.0173,-29.8634,0.028,0.133,-2.951,0.231,-1.592,0.199,17.5,1.37,15.99,15.3,15.17,0.15,29.06,2.35,nan,nan,nan,nan,0,-0.128,0.85
284.6518,-29.7171,-0.019,0.088,-2.334,0.141,-1.176,0.131,16.77,1.51,14.91,14.21,14.1,0.19,28.41,1.49,nan,nan,nan,nan,0,-0.646,0.613
299.4709,-29.5826,-0.089,0.041,-2.809,0.059,-2.177,0.036,14.89,1.97,12.53,11.65,11.45,0.1,25.71,0.75,nan,nan,nan,nan,0,-13.436,-0.828
280.5058,-26.4424,0.038,0.105,-2.233,0.183,-0.896,0.172,17.01,1.93,14.59,13.72,13.51,0.43,26.79,1.67,nan,nan,nan,nan,0,3.548,-1.939
286.3275,-28.9154,-0.008,0.057,-2.799,0.087,-1.504,0.084,15.43,2.13,12.85,12.0,11.75,0.18,27.5,0.37,nan,nan,nan,nan,0,-1.962,-0.409
293.8132,-31.2896,-0.256,0.134,-2.377,0.172,-2.051,0.155,17.1,1.44,15.36,14.67,14.51,0.12,27.1,0.51,nan,nan,nan,nan,0,-8.673,1.177
293.0096,-28.7068,0.014,0.11,-2.449,0.233,-1.828,0.157,16.72,1.32,15.13,14.53,14.44,0.1,28.14,2.59,nan,nan,nan,nan,0,-7.747,-1.333
311.7116,-34.6284,-0.037,0.11,-2.585,0.147,-2.07,0.099,16.79,1.31,15.13,14.58,14.51,0.06,24.07,2.83,nan,nan,nan,nan,0,-23.716,4.388
240.6878,-20.5006,-0.033,0.063,-1.973,0.142,-0.574,0.065,15.3,2.54,12.49,11.62,11.36,0.28,40.34,1.21,nan,nan,nan,nan,0,39.796,4.924
282.5284,-28.4604,0.017,0.059,-2.641,0.09,-1.366,0.083,15.8,1.58,13.79,13.12,12.93,0.16,28.32,0.71,151.4,nan,nan,nan,4,1.4,-0.301
210.9137,-1.0472,0.068,0.098,-0.955,0.143,-0.394,0.123,16.13,1.84,13.89,13.04,12.86,0.05,47.12,3.98,nan,nan,nan,nan,0,74.758,2.289
280.4897,-30.461,-0.133,0.058,-2.762,0.11,-1.424,0.098,15.93,1.78,13.75,12.92,12.79,0.13,28.5,2.58,nan,nan,nan,nan,0,2.76,2.002
289.1536,-31.2808,0.08,0.072,-3.001,0.158,-1.382,0.12,16.3,1.57,14.33,13.65,13.49,0.1,27.33,2.45,nan,nan,nan,nan,0,-4.712,1.593
283.4288,-33.0154,-0.015,0.076,-2.382,0.115,-1.3,0.107,15.99,1.52,13.97,13.28,13.08,0.1,25.4,2.73,nan,nan,nan,nan,0,-0.179,4.041
282.6585,-27.2772,-0.049,0.052,-2.505,0.08,-1.367,0.072,15.43,1.71,13.3,12.56,12.42,0.25,28.41,2.2,nan,nan,nan,nan,0,1.502,-1.486
280.1592,-30.5828,0.018,0.045,-2.504,0.072,-1.216,0.062,15.07,1.95,12.7,11.84,11.61,0.14,27.54,0.61,nan,nan,nan,nan,0,3.014,2.178
288.8949,-32.0044,-0.127,0.168,-2.508,0.235,-1.978,0.221,17.82,1.26,16.36,15.78,15.67,0.12,28.47,0.55,nan,nan,nan,nan,0,-4.586,2.339
282.2554,-27.765,-0.074,0.11,-2.717,0.177,-1.293,0.155,17.2,1.55,15.29,14.52,14.39,0.23,27.62,0.16,nan,nan,nan,nan,0,1.764,-0.941
287.7923,-31.2486,-0.038,0.045,-2.555,0.069,-1.465,0.063,15.14,1.98,12.69,11.86,11.64,0.1,27.32,1.78,145.93,1.0,nan,nan,6,-3.554,1.716
279.2952,-30.925,-0.043,0.095,-2.925,0.166,-1.295,0.154,16.95,1.5,15.07,14.38,14.2,0.17,25.09,1.73,nan,nan,nan,nan,0,3.671,2.666
284.1741,-30.0811,0.014,0.044,-2.822,0.08,-1.329,0.073,15.42,1.81,13.15,12.31,12.14,0.14,26.46,2.06,nan,nan,nan,nan,0,-0.299,1.042
285.3456,-31.3785,0.006,0.09,-3.144,0.183,-1.388,0.161,16.52,1.58,14.6,13.79,13.71,0.12,27.68,0.65,nan,nan,nan,nan,0,-1.505,2.156
171.839,7.3944,-0.078,0.283,-1.588,0.543,-0.945,0.61,17.78,1.2,16.21,15.6,15.48,0.09,34.83,3.11,nan,nan,nan,nan,0,113.598,12.967
291.0582,-30.7961,0.021,0.042,-2.78,0.059,-1.654,0.055,15.0,1.94,12.63,11.82,11.63,0.08,27.66,1.09,nan,nan,nan,nan,0,-6.275,0.918
277.3269,-30.2361,-0.271,0.109,-2.649,0.182,-1.48,0.155,16.4,1.78,14.1,13.36,13.08,0.26,26.68,0.65,nan,nan,nan,nan,0,5.477,2.362
285.7311,-26.6197,-0.049,0.074,-2.566,0.13,-1.361,0.122,16.33,1.82,14.05,13.24,13.04,0.24,27.85,2.68,nan,nan,nan,nan,0,-1.088,-2.596
286.1541,-30.4801,-0.022,0.1,-2.706,0.193,-1.316,0.152,16.48,1.64,14.4,13.65,13.46,0.13,26.73,0.36,nan,nan,nan,nan,0,-2.051,1.16
292.4071,-36.3668,-0.034,0.143,-2.825,0.196,-1.815,0.195,17.4,1.44,15.62,14.94,14.85,0.15,30.55,2.57,nan,nan,nan,nan,0,-7.981,6.34
30.1493,9.9665,0.032,0.074,-0.178,0.095,-2.272,0.087,15.81,1.38,13.77,13.18,13.06,0.08,23.06,2.29,nan,nan,nan,nan,0,-109.164,-10.348
283.3688,-30.9366,0.06,0.042,-2.611,0.084,-1.264,0.078,15.32,1.99,12.95,12.07,11.88,0.14,26.64,1.05,nan,nan,nan,nan,0,0.237,2.004
284.8564,-30.6515,-0.033,0.102,-2.849,0.22,-1.052,0.162,16.58,1.47,14.68,13.99,13.92,0.14,29.93,1.74,nan,nan,nan,nan,0,-0.974,1.506
286.0676,-31.4926,-0.068,0.057,-3.097,0.108,-1.542,0.094,16.22,1.58,14.22,13.49,13.4,0.11,26.46,2.87,nan,nan,nan,nan,0,-2.132,2.172
286.252,-29.683,0.082,0.088,-2.492,0.132,-1.223,0.124,16.61,1.52,14.69,13.99,13.76,0.14,27.05,1.46,nan,nan,nan,nan,0,-2.013,0.36
289.2115,-33.5741,0.072,0.031,-2.732,0.057,-1.372,0.056,14.61,2.02,12.16,11.29,11.09,0.09,25.71,0.9,nan,nan,nan,nan,0,-5.052,3.862
279.0932,-28.619,-0.094,0.113,-2.946,0.159,-1.294,0.13,16.66,1.79,14.43,13.68,13.52,0.24,28.53,2.14,nan,nan,nan,nan,0,4.327,0.448
336.1109,-31.5332,0.035,0.072,-2.061,0.09,-2.75,0.1,16.16,1.36,14.46,13.84,13.66,0.01,23.35,5.38,nan,nan,nan,nan,0,-44.403,4.932
299.6151,-34.4277,-0.042,0.175,-3.012,0.241,-1.924,0.152,17.7,1.26,16.24,15.4,15.29,0.11,26.96,3.1,nan,nan,nan,nan,0,-13.734,4.009
277.0026,-26.9373,-0.095,0.074,-2.813,0.104,-1.419,0.086,15.91,2.01,13.35,12.52,12.29,0.34,27.0,0.96,nan,nan,nan,nan,0,6.5,-0.787
258.9008,-24.8048,-0.042,0.216,-2.401,0.327,-0.638,0.217,17.35,2.24,14.18,13.36,13.15,0.75,32.97,1.77,nan,nan,nan,nan,0,22.68,1.98
280.0478,-29.3713,-0.09,0.1,-2.281,0.157,-1.287,0.142,16.5,1.58,14.49,13.77,13.65,0.18,27.15,0.61,nan,nan,nan,nan,0,3.355,1.011
277.7568,-31.338,-0.003,0.049,-2.767,0.083,-1.073,0.073,15.66,1.61,13.67,12.9,12.81,0.18,26.33,1.49,nan,nan,nan,nan,0,4.87,3.353
5.9134,-21.0556,0.015,0.037,-1.242,0.067,-3.379,0.046,15.24,1.42,13.45,12.77,12.64,0.02,22.32,3.64,nan,nan,nan,nan,0,-73.098,5.127
292.5405,-30.9372,-0.048,0.04,-3.083,0.074,-1.611,0.06,14.97,1.79,12.78,11.95,11.8,0.12,27.19,0.7,nan,nan,nan,nan,0,-7.556,0.926
284.6079,-30.98,-0.031,0.059,-3.168,0.098,-1.676,0.088,14.78,2.42,11.6,10.82,10.45,0.14,27.97,1.84,128.21,1.77,nan,nan,6,-0.818,1.865
282.815,-32.2129,0.037,0.088,-2.821,0.151,-0.917,0.131,16.0,1.67,13.93,13.08,12.99,0.13,25.34,0.6,165.9,nan,nan,nan,4,0.474,3.344
289.7466,-32.7957,0.04,0.09,-2.967,0.145,-1.281,0.124,16.4,1.43,14.65,14.0,13.85,0.1,26.97,1.06,nan,nan,nan,nan,0,-5.4,3.034
289.3306,-29.2741,0.082,0.148,-2.924,0.255,-1.851,0.236,17.97,1.23,16.32,15.67,15.52,0.12,28.35,3.02,nan,nan,nan,nan,0,-4.611,-0.417
284.417,-31.6403,0.026,0.042,-2.977,0.077,-1.57,0.068,15.54,1.83,13.29,12.47,12.3,0.15,27.38,1.29,nan,nan,nan,nan,0,-0.767,2.543
280.5985,-31.2331,-0.02,0.212,-2.477,0.253,-1.362,0.229,17.83,1.39,15.6,14.96,14.82,0.19,25.48,0.98,nan,nan,nan,nan,0,2.514,2.74
277.8889,-31.0629,-0.144,0.126,-2.49,0.259,-0.976,0.246,17.73,1.36,15.99,15.22,15.12,0.17,26.33,1.3,nan,nan,nan,nan,0,4.82,3.06
284.0613,-28.6037,0.033,0.055,-2.91,0.096,-1.358,0.084,15.66,2.04,13.23,12.35,12.12,0.18,28.57,2.56,nan,nan,nan,nan,0,0.049,-0.398
289.8508,-33.1964,-0.036,0.097,-2.689,0.166,-1.386,0.159,16.7,1.43,14.96,14.27,14.16,0.09,26.24,2.82,nan,nan,nan,nan,0,-5.536,3.421
255.8364,-26.96,-0.379,0.286,-2.378,0.618,-1.052,0.307,18.52,1.39,16.53,15.67,15.29,0.25,29.21,3.28,nan,nan,nan,nan,0,24.456,4.997
289.8828,-33.3089,0.023,0.056,-2.606,0.097,-1.385,0.091,15.3,1.67,13.24,12.5,12.34,0.09,25.88,1.49,nan,nan,nan,nan,0,-5.576,3.529
284.1723,-32.015,0.033,0.083,-2.811,0.143,-1.031,0.118,16.32,1.6,14.28,13.56,13.36,0.15,25.48,0.07,nan,nan,nan,nan,0,-0.625,2.948
18.6548,-10.8896,0.044,0.06,-0.616,0.115,-2.953,0.089,16.12,1.29,14.5,13.86,13.76,0.03,22.81,3.46,-101.38,1.66,-1.25,0.11,5,-88.711,1.947
280.0436,-28.9118,-0.102,0.144,-2.554,0.261,-1.235,0.273,17.31,1.44,15.43,14.8,14.67,0.19,26.51,1.2,nan,nan,nan,nan,0,3.451,0.562
280.1588,-33.6958,-0.137,0.062,-2.752,0.086,-1.051,0.073,15.54,1.5,13.63,12.92,12.79,0.11,27.37,2.08,nan,nan,nan,nan,0,2.383,5.227
297.3609,-27.5845,-0.04,0.167,-2.46,0.262,-1.186,0.146,17.99,1.28,16.4,15.6,15.23,0.12,27.4,1.29,nan,nan,nan,nan,0,-11.492,-2.738
288.5069,-32.0185,0.061,0.041,-2.616,0.094,-1.432,0.074,15.11,1.61,13.09,12.38,12.26,0.13,26.09,0.89,nan,nan,nan,nan,0,-4.262,2.396
285.3629,-28.9467,0.06,0.03,-2.656,0.053,-1.398,0.047,14.69,1.86,12.38,11.59,11.41,0.15,28.53,1.3,nan,nan,nan,nan,0,-1.133,-0.247
206.9373,4.1951,0.024,0.061,-1.191,0.121,-0.319,0.098,16.28,1.45,14.5,13.79,13.72,0.02,42.74,2.25,nan,nan,nan,nan,0,80.837,-0.226
282.696,-31.1406,-0.069,0.094,-2.67,0.118,-1.329,0.108,15.94,1.73,13.76,13.03,12.85,0.19,25.94,0.66,nan,nan,nan,nan,0,0.769,2.308
286.9517,-29.8145,0.004,0.094,-2.357,0.173,-1.744,0.133,16.2,1.55,14.24,13.5,13.4,0.12,26.15,1.19,nan,nan,nan,nan,0,-2.633,0.399
289.1237,-34.7019,-0.052,0.037,-2.427,0.069,-1.497,0.065,15.28,1.77,13.08,12.29,12.05,0.09,27.16,1.87,163.4,nan,nan,nan,4,-5.124,4.99
282.3817,-29.5348,-0.105,0.148,-2.869,0.191,-1.091,0.177,17.05,1.61,14.94,14.29,14.17,0.16,27.39,0.5,nan,nan,nan,nan,0,1.329,0.778
282.9045,-31.6959,0.018,0.118,-2.328,0.215,-0.885,0.209,17.36,1.46,15.47,14.74,14.67,0.17,26.92,1.68,nan,nan,nan,nan,0,0.493,2.822
278.1009,-30.6331,0.068,0.049,-3.03,0.073,-1.348,0.061,14.93,1.92,12.54,11.69,11.53,0.2,25.65,2.05,nan,nan,nan,nan,0,4.737,2.601
288.387,-32.7125,-0.134,0.112,-2.647,0.146,-1.326,0.128,16.61,1.43,14.76,14.09,13.98,0.11,26.09,1.0,nan,nan,nan,nan,0,-4.254,3.098
298.0076,-34.0259,0.044,0.062,-2.778,0.083,-1.745,0.056,15.27,2.13,12.69,11.81,11.56,0.17,28.38,1.63,nan,nan,nan,nan,0,-12.386,3.665
281.585,-31.4219,-0.246,0.116,-2.497,0.198,-1.171,0.175,17.43,1.46,15.61,14.81,14.6,0.16,25.93,0.81,nan,nan,nan,nan,0,1.65,2.761
291.8334,-33.909,0.05,0.145,-2.366,0.267,-1.381,0.264,17.91,1.29,16.28,15.63,15.49,0.11,26.63,0.45,nan,nan,nan,nan,0,-7.261,3.943
338.8129,-32.7517,0.087,0.043,-2.989,0.069,-3.851,0.067,14.71,1.32,13.03,12.4,12.3,0.01,20.0,2.7,nan,nan,nan,nan,0,-46.261,6.749
283.8744,-29.2037,-0.375,0.2,-1.979,0.306,-1.589,0.28,18.08,1.3,16.69,15.76,15.56,0.17,26.66,2.41,nan,nan,nan,nan,0,0.108,0.221
285.8427,-31.2564,-0.013,0.076,-2.407,0.125,-1.261,0.115,16.41,1.68,14.36,13.58,13.49,0.11,27.26,1.33,nan,nan,nan,nan,0,-1.906,1.969
333.7786,-22.4763,-0.028,0.081,-2.325,0.12,-3.383,0.135,16.34,1.31,14.74,14.07,13.97,0.03,20.52,2.24,nan,nan,nan,nan,0,-44.79,-4.351
67.1626,20.7802,0.076,0.065,0.282,0.135,-1.606,0.1,16.27,2.08,13.67,12.8,12.63,0.44,38.01,6.79,nan,nan,nan,nan,0,-145.784,-2.517
286.6039,-32.445,-0.017,0.112,-2.627,0.183,-1.249,0.17,17.01,1.26,15.34,14.78,14.71,0.1,28.46,0.42,nan,nan,nan,nan,0,-2.726,3.045
281.6438,-32.9604,-0.058,0.062,-2.47,0.116,-1.046,0.104,16.17,1.65,14.1,13.32,13.25,0.11,26.69,0.25,nan,nan,nan,nan,0,1.307,4.262
289.268,-33.8207,0.074,0.218,-2.602,0.477,-1.958,0.376,17.98,1.26,16.5,15.79,15.61,0.1,26.17,0.92,nan,nan,nan,nan,0,-5.13,4.101
281.4468,-30.3918,0.042,0.045,-2.801,0.069,-1.274,0.062,15.06,2.14,12.48,11.55,11.36,0.18,28.66,0.36,116.85,0.01,-0.7,0.02,1,1.964,1.772
16.5761,-5.3057,-0.001,0.045,-1.203,0.078,-3.619,0.049,14.98,1.42,13.19,12.54,12.41,0.03,24.04,3.39,nan,nan,nan,nan,0,-89.639,-3.931
283.9069,-28.7386,-0.071,0.059,-2.451,0.113,-1.303,0.099,15.77,1.71,13.66,12.93,12.79,0.19,28.35,2.24,nan,nan,nan,nan,0,0.159,-0.242
291.8586,-30.1453,0.098,0.091,-2.477,0.156,-1.248,0.141,16.86,1.42,15.07,14.38,14.32,0.13,27.88,0.02,nan,nan,nan,nan,0,-6.892,0.197
37.3566,-4.4767,-0.049,0.039,-0.162,0.093,-2.179,0.07,14.52,1.81,12.33,11.5,11.33,0.03,29.42,1.62,nan,nan,nan,nan,0,-107.989,5.738
324.018,-28.0265,0.027,0.107,-2.067,0.166,-2.195,0.142,16.59,1.23,15.03,14.45,14.31,0.03,24.19,1.6,nan,nan,nan,nan,0,-34.965,-0.846
48.1281,5.5642,-0.38,0.273,-0.253,0.408,-1.928,0.359,18.25,1.36,16.68,15.7,15.16,0.22,29.25,5.22,-174.59,3.68,-0.39,0.02,5,-122.37,2.446
190.6083,1.8396,0.008,0.072,-1.059,0.17,-0.735,0.077,16.43,1.4,14.75,14.05,13.91,0.02,42.56,3.63,nan,nan,nan,nan,0,93.95,9.83
283.3361,-28.7313,0.02,0.077,-2.735,0.133,-1.407,0.123,16.26,1.6,14.24,13.55,13.42,0.18,27.88,0.73,nan,nan,nan,nan,0,0.653,-0.162
287.6308,-32.6098,-0.016,0.047,-2.448,0.076,-1.256,0.067,14.93,1.68,12.78,12.02,11.9,0.09,28.25,0.74,nan,nan,nan,nan,0,-3.608,3.083
290.3931,-29.4691,-0.118,0.185,-2.324,0.364,-1.332,0.32,17.97,1.22,16.45,15.56,15.47,0.11,26.15,1.21,nan,nan,nan,nan,0,-5.553,-0.335
276.2268,-31.8673,0.028,0.219,-2.46,0.358,-1.232,0.332,18.22,1.5,16.28,15.53,15.45,0.27,26.99,1.34,nan,nan,nan,nan,0,6.02,4.166
227.2031,-9.9821,-0.074,0.119,-0.859,0.196,-0.859,0.208,17.05,1.58,15.04,14.24,14.15,0.11,49.24,1.59,nan,nan,nan,nan,0,56.253,1.851
292.0219,-31.9937,0.064,0.165,-2.411,0.268,-1.363,0.254,17.72,1.18,16.45,15.56,15.4,0.06,28.06,1.45,nan,nan,nan,nan,0,-7.221,2.021
295.735,-29.3919,0.013,0.094,-2.979,0.125,-1.951,0.107,16.44,1.49,14.58,13.94,13.79,0.13,26.98,1.33,nan,nan,nan,nan,0,-10.178,-0.845
229.6447,-6.746,-0.032,0.051,-0.995,0.1,-0.565,0.083,16.03,1.83,13.75,12.94,12.78,0.09,46.18,1.8,nan,nan,nan,nan,0,55.735,-2.154
178.5015,19.5892,0.002,0.082,-1.412,0.13,-0.783,0.113,16.5,1.33,14.85,14.14,14.08,0.03,31.94,3.69,nan,nan,nan,nan,0,112.539,-0.795
282.9377,-29.6223,-0.011,0.102,-2.665,0.198,-1.081,0.162,16.67,1.63,14.62,13.89,13.68,0.16,27.57,0.13,nan,nan,nan,nan,0,0.837,0.777
253.7603,-31.9032,0.081,0.28,-2.202,0.449,-0.656,0.266,18.45,1.85,15.98,15.21,15.06,0.46,30.46,5.13,nan,nan,nan,nan,0,24.216,10.255
192.4237,11.7124,0.092,0.109,-1.559,0.201,-0.592,0.116,17.21,1.33,15.49,14.86,14.76,0.04,38.7,3.41,nan,nan,nan,nan,0,97.04,0.277
283.8727,-29.366,-0.325,0.173,-2.853,0.219,-1.712,0.19,17.67,1.35,15.96,14.94,14.59,0.18,26.66,2.41,nan,nan,nan,nan,0,0.081,0.381
294.5219,-30.0919,-0.393,0.185,-1.927,0.313,-1.436,0.327,18.26,1.25,16.75,15.81,15.68,0.12,28.05,2.96,nan,nan,nan,nan,0,-9.181,-0.068
287.154,-32.3949,-0.069,0.094,-2.371,0.161,-1.366,0.14,16.82,1.43,15.01,14.38,14.3,0.1,27.0,1.54,nan,nan,nan,nan,0,-3.179,2.927
286.0229,-33.3696,-0.025,0.064,-2.723,0.109,-1.404,0.094,15.35,1.59,13.33,12.56,12.44,0.09,26.54,0.55,nan,nan,nan,nan,0,-2.384,4.033
288.9524,-31.9948,0.074,0.2,-2.533,0.27,-1.632,0.248,17.97,1.26,16.43,15.71,15.46,0.12,28.28,0.81,nan,nan,nan,nan,0,-4.634,2.323
277.6795,-25.6887,-0.144,0.092,-2.854,0.166,-1.226,0.157,16.9,1.81,14.58,13.79,13.68,0.38,27.06,2.21,nan,nan,nan,nan,0,6.19,-2.14
165.6961,29.1149,-0.008,0.048,-1.894,0.09,-1.751,0.073,16.08,1.3,14.45,13.83,13.77,0.03,24.84,2.97,nan,nan,nan,nan,0,126.95,-5.18
222.3189,3.7597,-0.019,0.141,-1.024,0.154,-0.517,0.198,16.1,1.84,13.83,13.08,12.86,0.04,49.93,8.74,1.19,0.88,nan,nan,5,67.351,-7.633
240.7386,-9.8087,0.056,0.109,-1.332,0.218,-0.516,0.115,17.04,1.66,15.0,14.17,14.03,0.22,45.48,2.92,nan,nan,nan,nan,0,44.592,-4.634
303.7057,-29.6942,0.054,0.047,-2.671,0.079,-1.88,0.055,15.48,1.67,13.41,12.63,12.49,0.08,25.72,0.95,nan,nan,nan,nan,0,-17.118,-0.784
286.6909,-30.425,0.006,0.071,-2.756,0.122,-1.453,0.116,16.51,1.61,14.51,13.8,13.62,0.11,28.59,1.39,nan,nan,nan,nan,0,-2.5,1.036
230.4358,-12.051,-0.209,0.358,-0.781,0.436,-0.519,0.318,18.0,1.51,16.01,15.39,15.31,0.14,48.46,4.4,nan,nan,nan,nan,0,52.471,2.101
314.1347,-23.3484,0.048,0.048,-2.448,0.081,-2.403,0.052,15.21,1.66,13.13,12.38,12.19,0.07,22.79,1.05,nan,nan,nan,nan,0,-26.754,-6.681
285.9797,-32.5435,0.021,0.071,-2.783,0.108,-1.562,0.106,15.88,1.7,13.75,13.05,12.84,0.1,27.77,1.12,122.97,2.36,nan,nan,6,-2.22,3.222
280.8191,-31.4545,-0.05,0.156,-2.553,0.27,-1.278,0.255,17.6,1.42,15.81,15.15,14.96,0.16,26.74,1.05,nan,nan,nan,nan,0,2.285,2.919
292.7362,-29.8902,-0.039,0.117,-2.673,0.216,-1.669,0.209,17.44,1.27,15.81,15.15,15.06,0.13,27.31,2.05,nan,nan,nan,nan,0,-7.622,-0.132
285.1906,-30.8229,0.006,0.076,-2.618,0.142,-1.709,0.122,16.67,1.61,14.64,13.89,13.81,0.15,26.94,0.56,nan,nan,nan,nan,0,-1.285,1.629
282.4156,-33.6343,-0.086,0.09,-2.498,0.139,-1.096,0.129,16.55,1.55,14.61,13.88,13.82,0.1,26.49,1.95,nan,nan,nan,nan,0,0.545,4.803
282.5554,-29.6516,-0.034,0.128,-2.392,0.19,-1.336,0.178,17.4,1.51,15.57,14.88,14.77,0.15,26.96,1.09,nan,nan,nan,nan,0,1.159,0.866
284.3499,-31.4331,-0.15,0.108,-2.707,0.187,-1.415,0.165,17.35,1.4,15.53,14.81,14.6,0.15,27.69,0.65,nan,nan,nan,nan,0,-0.675,2.349
350.5791,-17.5498,-0.122,0.104,-1.286,0.177,-2.56,0.171,16.92,1.26,15.42,14.77,14.65,0.03,22.55,1.49,nan,nan,nan,nan,0,-61.356,-4.035
283.5873,-31.4223,0.012,0.134,-2.673,0.225,-1.181,0.198,17.19,1.45,15.4,14.73,14.53,0.15,28.27,0.81,nan,nan,nan,nan,0,-0.032,2.449
289.584,-30.0695,0.061,0.098,-2.792,0.164,-1.528,0.146,17.09,1.29,15.4,14.76,14.61,0.12,26.92,2.04,nan,nan,nan,nan,0,-4.928,0.345
284.4002,-31.2102,-0.127,0.083,-2.515,0.116,-1.398,0.097,15.77,1.94,13.4,12.54,12.36,0.14,28.99,0.18,nan,nan,nan,nan,0,-0.68,2.122
249.6165,-28.6509,-0.256,0.391,-2.387,0.69,-0.329,0.431,18.69,1.7,16.72,15.75,15.6,0.45,36.68,9.23,nan,nan,nan,nan,0,28.868,8.73
358.3407,-21.5702,0.034,0.056,-1.775,0.095,-3.403,0.069,15.7,1.3,14.06,13.43,13.32,0.02,22.73,0.79,nan,nan,nan,nan,0,-66.502,2.535
284.4213,-30.7585,-0.019,0.047,-2.618,0.09,-1.273,0.08,15.13,1.93,12.73,11.86,11.72,0.14,28.79,2.47,142.7,nan,nan,nan,4,-0.623,1.673
291.0843,-32.3497,-0.1,0.139,-2.698,0.213,-1.466,0.199,17.63,1.22,16.19,15.52,15.31,0.1,26.19,1.83,nan,nan,nan,nan,0,-6.469,2.46
285.2959,-30.4933,0.034,0.079,-2.739,0.108,-1.321,0.094,16.19,1.56,14.25,13.55,13.3,0.11,26.94,0.76,nan,nan,nan,nan,0,-1.322,1.289
285.2281,-31.5664,-0.136,0.081,-2.398,0.129,-1.467,0.127,16.48,1.51,14.53,13.86,13.76,0.12,26.85,1.37,nan,nan,nan,nan,0,-1.437,2.357
283.1035,-31.1043,-0.115,0.101,-3.146,0.176,-1.438,0.149,17.05,1.55,15.18,14.52,14.41,0.15,25.26,1.71,nan,nan,nan,nan,0,0.432,2.209
300.6199,-32.1052,-0.035,0.106,-2.015,0.166,-1.892,0.1,16.75,1.56,14.75,14.05,13.91,0.17,27.44,1.4,nan,nan,nan,nan,0,-14.503,1.662
285.009,-28.8221,-0.083,0.053,-2.847,0.082,-1.384,0.071,15.12,2.0,12.63,11.78,11.59,0.2,27.75,1.12,nan,nan,nan,nan,0,-0.807,-0.32
229.6423,0.2896,0.012,0.071,-1.097,0.126,-0.664,0.107,16.51,1.86,14.21,13.42,13.22,0.06,53.25,1.1,nan,nan,nan,nan,0,59.2,-8.286
281.9014,-30.2106,-0.065,0.131,-2.778,0.208,-1.185,0.18,17.18,1.58,15.11,14.45,14.28,0.19,24.11,0.53,nan,nan,nan,nan,0,1.612,1.52
284.7844,-30.849,-0.039,0.148,-2.707,0.207,-1.262,0.179,17.06,1.44,15.23,14.54,14.35,0.12,27.23,1.08,nan,nan,nan,nan,0,-0.945,1.711
233.0987,-8.8151,0.04,0.097,-1.078,0.174,-0.727,0.132,16.84,1.79,14.64,13.84,13.61,0.14,44.22,3.41,nan,nan,nan,nan,0,51.737,-1.997
278.3614,-29.1625,0.013,0.05,-2.751,0.084,-1.479,0.073,15.7,1.97,13.23,12.33,12.15,0.27,27.69,0.81,nan,nan,nan,nan,0,4.837,1.116
280.3891,-30.2876,-0.114,0.066,-2.999,0.131,-1.113,0.107,16.0,1.86,13.75,12.85,12.7,0.14,29.52,1.33,nan,nan,nan,nan,0,2.88,1.849
226.6095,-3.7412,-0.049,0.101,-1.038,0.178,-0.345,0.141,16.82,1.68,14.73,13.96,13.75,0.17,52.88,1.31,nan,nan,nan,nan,0,59.849,-3.285
285.9774,-32.683,-0.056,0.147,-2.894,0.233,-1.524,0.213,17.76,1.2,16.12,15.47,15.39,0.1,27.77,1.45,nan,nan,nan,nan,0,-2.24,3.36
299.3386,-36.4359,-0.07,0.038,-2.508,0.059,-1.706,0.041,14.81,2.23,12.21,11.32,11.08,0.1,25.41,0.71,132.3,nan,nan,nan,4,-13.583,6.024
299.9597,-29.5677,-0.033,0.034,-3.521,0.052,-2.063,0.036,14.69,1.67,12.64,11.87,11.72,0.1,25.21,1.41,nan,nan,nan,nan,0,-13.86,-0.858
286.6905,-32.8489,0.054,0.06,-2.513,0.09,-0.969,0.079,15.23,1.6,13.23,12.49,12.33,0.09,26.64,1.02,nan,nan,nan,nan,0,-2.859,3.434
290.045,-34.0846,-0.094,0.156,-2.429,0.254,-1.309,0.251,17.84,1.26,16.24,15.46,15.11,0.1,27.34,2.32,nan,nan,nan,nan,0,-5.804,4.283
285.4785,-30.3906,0.036,0.085,-2.407,0.146,-1.137,0.128,16.91,1.57,14.89,14.2,14.02,0.12,27.23,2.39,nan,nan,nan,nan,0,-1.461,1.162
279.4959,-27.9783,0.011,0.089,-2.715,0.156,-1.294,0.135,16.74,1.6,14.63,13.96,13.76,0.28,26.98,2.44,nan,nan,nan,nan,0,4.114,-0.253
296.475,-34.2255,-0.05,0.141,-2.445,0.28,-1.075,0.257,17.93,1.36,16.16,15.42,15.29,0.18,27.55,0.53,nan,nan,nan,nan,0,-11.128,3.936
284.0095,-30.6923,-0.107,0.273,-3.006,0.335,-1.565,0.296,18.23,1.36,16.31,15.74,15.66,0.16,27.76,2.37,nan,nan,nan,nan,0,-0.262,1.668
284.9299,-30.4427,-0.009,0.061,-2.713,0.097,-1.389,0.086,15.73,1.87,13.32,12.52,12.29,0.14,27.18,1.43,nan,nan,nan,nan,0,-1.002,1.29
238.7371,-9.7835,-0.001,0.072,-1.263,0.148,-0.473,0.092,16.38,1.79,14.09,13.33,13.1,0.23,45.8,4.9,nan,nan,nan,nan,0,46.363,-3.756
290.1626,-28.3802,-0.02,0.056,-2.615,0.091,-1.457,0.093,15.8,1.51,13.86,13.18,12.99,0.12,27.61,0.32,nan,nan,nan,nan,0,-5.225,-1.393
232.7311,-26.5332,-0.068,0.086,-1.436,0.155,-0.627,0.11,16.66,1.7,14.51,13.72,13.61,0.19,47.3,6.45,nan,nan,nan,nan,0,43.416,13.687
285.8821,-30.2657,0.081,0.124,-2.708,0.238,-1.285,0.197,16.98,1.41,15.18,14.54,14.4,0.15,27.93,0.55,nan,nan,nan,nan,0,-1.786,0.985
285.5836,-24.9549,0.047,0.09,-3.04,0.148,-1.772,0.127,16.91,1.41,15.12,14.54,14.46,0.2,27.8,0.08,nan,nan,nan,nan,0,-0.695,-4.22
290.058,-32.8788,-0.052,0.099,-3.053,0.185,-1.71,0.191,17.15,1.42,15.31,14.7,14.56,0.1,26.97,1.76,nan,nan,nan,nan,0,-5.67,3.085
283.3874,-28.5341,-0.088,0.06,-2.981,0.117,-1.236,0.096,16.15,1.75,13.97,13.23,13.08,0.19,26.54,1.81,nan,nan,nan,nan,0,0.644,-0.364
286.2138,-31.4508,0.006,0.077,-2.544,0.085,-1.397,0.071,15.55,1.53,13.62,12.92,12.8,0.11,26.12,3.37,nan,nan,nan,nan,0,-2.249,2.112
228.671,-6.2765,-0.142,0.161,-1.412,0.323,-0.736,0.331,17.58,1.34,15.86,15.19,15.1,0.09,47.4,2.36,nan,nan,nan,nan,0,56.81,-2.09
288.1323,-31.0374,0.045,0.086,-2.735,0.127,-1.032,0.124,16.58,1.4,14.71,14.15,14.05,0.1,27.23,0.74,nan,nan,nan,nan,0,-3.814,1.467
291.5213,-30.4405,-0.014,0.034,-2.644,0.058,-1.447,0.051,14.68,1.64,12.66,11.96,11.86,0.08,27.14,3.96,nan,nan,nan,nan,0,-6.633,0.521
291.6049,-33.6209,-0.052,0.181,-2.781,0.288,-1.989,0.305,17.96,1.34,16.31,15.43,15.24,0.12,27.57,1.14,nan,nan,nan,nan,0,-7.042,3.676
322.173,-37.4537,0.082,0.048,-2.134,0.065,-1.903,0.065,14.82,2.11,12.3,11.41,11.19,0.11,19.49,2.37,nan,nan,nan,nan,0,-31.831,8.182
276.7144,-28.6609,-0.074,0.09,-2.545,0.136,-1.225,0.115,16.25,2.07,13.76,12.82,12.65,0.36,26.89,1.19,nan,nan,nan,nan,0,6.355,0.949
284.4647,-30.0056,-0.013,0.081,-2.815,0.115,-1.38,0.1,16.32,1.45,14.44,13.8,13.71,0.14,28.48,2.05,nan,nan,nan,nan,0,-0.534,0.925
297.966,-34.3427,0.035,0.069,-2.431,0.104,-1.694,0.065,16.28,1.62,14.22,13.48,13.33,0.15,27.72,2.14,nan,nan,nan,nan,0,-12.368,3.983
287.8633,-30.5739,-0.011,0.096,-2.679,0.17,-1.553,0.146,16.79,1.56,14.83,14.13,14.04,0.09,26.86,2.55,nan,nan,nan,nan,0,-3.521,1.039
156.4946,24.3696,0.037,0.035,-1.58,0.069,-1.717,0.055,15.04,1.47,13.21,12.54,12.39,0.02,22.18,0.33,-85.49,4.8,-1.07,0.1,2,133.306,1.865
279.8401,-29.0454,0.1,0.087,-2.708,0.145,-1.133,0.123,16.58,1.75,14.3,13.57,13.43,0.22,27.45,2.03,nan,nan,nan,nan,0,3.599,0.729
288.6542,-32.9782,0.014,0.058,-2.685,0.084,-1.264,0.077,15.82,1.68,13.72,12.95,12.78,0.08,27.44,0.75,nan,nan,nan,nan,0,-4.512,3.331
291.3053,-34.3461,-0.006,0.057,-2.541,0.091,-1.271,0.082,15.68,1.75,13.51,12.74,12.58,0.11,27.09,2.25,nan,nan,nan,nan,0,-6.872,4.424
289.3237,-31.7011,0.003,0.039,-2.607,0.074,-1.404,0.074,14.82,2.14,12.3,11.45,11.21,0.11,28.09,1.36,nan,nan,nan,nan,0,-4.909,1.992
285.3778,-30.6649,-0.064,0.085,-2.944,0.125,-1.669,0.114,16.55,1.41,14.76,14.13,14.03,0.14,26.29,1.12,nan,nan,nan,nan,0,-1.419,1.447
226.6787,-18.7073,0.076,0.07,-1.259,0.147,-0.644,0.11,16.67,1.75,14.49,13.67,13.57,0.08,50.31,9.8,nan,nan,nan,nan,0,52.338,9.677
286.9012,-30.2138,-0.031,0.203,-1.993,0.375,-1.69,0.346,18.25,1.31,16.72,15.89,15.67,0.15,27.34,0.83,nan,nan,nan,nan,0,-2.648,0.801
286.3337,-31.1937,-0.032,0.075,-2.573,0.118,-1.219,0.104,16.58,1.5,14.65,13.98,13.82,0.1,27.62,0.41,nan,nan,nan,nan,0,-2.311,1.842
283.8269,-31.1983,-0.091,0.079,-2.663,0.145,-1.461,0.139,16.65,1.44,14.8,14.15,14.05,0.15,27.63,0.39,nan,nan,nan,nan,0,-0.195,2.193
289.2545,-33.5784,0.005,0.061,-2.177,0.121,-1.048,0.124,16.4,1.66,14.33,13.62,13.48,0.09,26.8,1.91,nan,nan,nan,nan,0,-5.088,3.862
287.5631,-33.6164,-0.086,0.096,-2.598,0.119,-1.603,0.11,16.26,1.63,14.23,13.53,13.29,0.11,27.55,0.15,nan,nan,nan,nan,0,-3.694,4.088
294.0626,-28.3387,0.055,0.079,-2.604,0.116,-1.502,0.101,16.26,1.58,14.25,13.58,13.37,0.11,27.39,2.35,nan,nan,nan,nan,0,-8.636,-1.782
294.4123,-32.511,0.071,0.081,-2.574,0.126,-1.379,0.135,16.47,1.42,14.67,14.02,13.86,0.12,26.0,1.55,nan,nan,nan,nan,0,-9.283,2.351
284.7071,-31.1559,-0.113,0.048,-2.533,0.091,-1.141,0.083,14.99,2.48,12.18,11.22,10.96,0.15,25.65,0.83,nan,nan,nan,nan,0,-0.93,2.025
308.9271,-29.8949,-0.023,0.041,-2.721,0.068,-2.561,0.056,15.4,1.46,13.61,12.9,12.76,0.06,24.07,2.75,nan,nan,nan,nan,0,-21.643,-0.476
285.8124,-31.1853,-0.021,0.084,-2.487,0.128,-1.067,0.114,16.32,1.7,14.24,13.47,13.27,0.12,27.15,1.49,nan,nan,nan,nan,0,-1.869,1.902
285.5277,-28.5725,0.021,0.069,-2.422,0.14,-1.332,0.116,16.6,1.62,14.62,13.97,13.81,0.17,27.76,1.14,nan,nan,nan,nan,0,-1.216,-0.64
284.6003,-32.3328,-0.154,0.101,-2.61,0.165,-1.507,0.158,17.08,1.47,15.21,14.47,14.37,0.12,26.29,1.19,nan,nan,nan,nan,0,-1.035,3.2
276.7766,-28.616,0.034,0.105,-2.165,0.168,-1.127,0.145,16.74,1.79,14.52,13.75,13.57,0.37,26.89,1.19,nan,nan,nan,nan,0,6.312,0.893
48.1498,17.8968,-0.054,0.22,0.483,0.446,-1.283,0.355,18.23,1.27,16.87,15.99,15.83,0.11,33.92,4.17,nan,nan,nan,nan,0,-128.478,-8.278
306.9636,-31.9342,-0.03,0.1,-2.933,0.149,-1.917,0.114,17.02,1.31,15.42,14.72,14.66,0.1,23.96,1.26,nan,nan,nan,nan,0,-19.883,1.497
295.6139,-33.8858,0.077,0.052,-2.195,0.085,-1.685,0.053,15.77,1.87,13.49,12.61,12.46,0.17,24.53,1.61,nan,nan,nan,nan,0,-10.392,3.645
334.8662,-29.3056,-0.076,0.051,-1.807,0.094,-2.572,0.077,15.79,1.52,13.92,13.21,13.02,0.02,25.18,0.28,nan,nan,nan,nan,0,-43.966,2.498
282.8327,-31.1363,-0.051,0.098,-2.471,0.135,-1.216,0.123,16.66,1.46,14.76,14.06,13.98,0.2,26.34,0.51,nan,nan,nan,nan,0,0.654,2.282
335.0062,-34.9777,0.062,0.036,-2.244,0.05,-3.102,0.057,13.92,2.23,11.39,10.5,10.3,0.01,20.0,1.88,29.69,2.87,nan,nan,3,-42.573,7.999
287.9317,-29.9818,-0.058,0.172,-2.525,0.3,-1.526,0.316,17.9,1.18,16.73,15.76,15.57,0.12,27.11,1.25,nan,nan,nan,nan,0,-3.498,0.445
303.3908,-34.4431,0.077,0.043,-2.96,0.068,-1.906,0.042,14.87,1.67,12.83,12.07,11.92,0.1,27.5,0.68,nan,nan,nan,nan,0,-16.856,3.965
284.0455,-30.8989,-0.109,0.055,-2.706,0.079,-1.411,0.07,15.14,2.26,12.47,11.58,11.35,0.15,26.76,2.39,132.94,0.01,-0.5,0.02,1,-0.328,1.866
290.1262,-34.348,-0.062,0.063,-2.774,0.107,-1.515,0.093,16.16,1.61,14.06,13.32,13.21,0.11,26.0,1.54,nan,nan,nan,nan,0,-5.902,4.537
211.9763,-0.1321,0.032,0.131,-1.159,0.237,-0.683,0.167,17.17,1.39,15.54,14.86,14.69,0.04,47.12,2.35,nan,nan,nan,nan,0,74.306,0.961
250.0945,-25.073,-0.033,0.074,-1.506,0.142,-0.646,0.091,16.26,2.32,13.46,12.5,12.28,0.62,38.23,3.33,nan,nan,nan,nan,0,29.964,5.295
285.0347,-30.9076,-0.084,0.062,-2.499,0.12,-1.582,0.109,16.46,1.66,14.44,13.61,13.49,0.14,26.59,1.39,144.77,0.05,-0.32,0.02,1,-1.167,1.734
286.073,-30.0893,0.015,0.061,-2.711,0.077,-1.284,0.071,15.45,1.74,13.28,12.52,12.32,0.13,26.94,0.25,nan,nan,nan,nan,0,-1.922,0.785
283.9091,-29.7225,-0.202,0.166,-2.469,0.289,-1.527,0.278,18.02,1.3,16.64,15.66,15.43,0.16,27.76,2.15,nan,nan,nan,nan,0,-0.011,0.727
297.6587,-31.9382,-0.026,0.092,-2.627,0.132,-1.701,0.084,16.82,1.58,14.84,14.13,13.94,0.18,27.7,2.14,nan,nan,nan,nan,0,-11.986,1.595
283.7804,-30.5248,-0.01,0.129,-2.692,0.206,-1.446,0.197,17.16,1.37,15.33,14.74,14.65,0.15,26.49,0.79,nan,nan,nan,nan,0,-0.039,1.537
278.8944,-31.8537,-0.049,0.083,-2.802,0.148,-1.16,0.126,16.77,1.53,14.76,14.16,14.04,0.15,27.44,2.19,nan,nan,nan,nan,0,3.81,3.646
333.749,-27.188,-0.061,0.056,-1.928,0.071,-2.578,0.067,14.68,1.99,12.31,11.45,11.26,0.02,17.95,1.32,nan,nan,nan,nan,0,-43.563,0.198
288.8195,-31.787,0.049,0.041,-2.423,0.06,-1.098,0.058,14.84,1.65,12.76,12.09,11.93,0.12,28.47,0.59,nan,nan,nan,nan,0,-4.495,2.132
283.5707,-32.9439,0.094,0.043,-2.573,0.08,-1.363,0.076,14.68,2.36,12.01,11.14,10.85,0.1,26.44,1.58,157.76,1.06,nan,nan,6,-0.284,3.95
279.6472,-29.3753,0.07,0.077,-2.383,0.132,-1.273,0.118,16.14,1.77,13.87,13.05,12.87,0.19,28.92,1.44,154.9,nan,nan,nan,4,3.696,1.087
285.7751,-32.5493,0.005,0.063,-2.757,0.116,-1.229,0.108,16.35,1.56,14.54,13.71,13.61,0.11,26.8,0.57,nan,nan,nan,nan,0,-2.051,3.255
315.2044,-31.2882,0.051,0.044,-2.319,0.057,-2.376,0.037,14.27,1.72,12.16,11.43,11.26,0.1,26.38,1.19,nan,nan,nan,nan,0,-26.928,1.314
279.5988,-32.2765,0.025,0.066,-2.576,0.124,-1.207,0.104,15.79,1.84,13.5,12.66,12.56,0.14,26.33,0.87,nan,nan,nan,nan,0,3.136,3.934
289.1563,-29.5278,-0.038,0.066,-2.436,0.097,-1.594,0.091,15.83,1.4,14.17,13.46,13.31,0.12,25.98,0.5,nan,nan,nan,nan,0,-4.492,-0.146
262.3745,-23.5267,-0.315,0.304,-1.714,0.51,-0.313,0.363,18.63,2.78,14.93,13.96,13.58,1.36,30.87,4.47,nan,nan,nan,nan,0,20.148,-0.315
287.0476,-29.0266,-0.214,0.172,-2.566,0.21,-1.489,0.185,16.26,1.41,14.38,13.73,13.63,0.14,27.09,1.38,nan,nan,nan,nan,0,-2.602,-0.392
281.504,-28.2747,0.085,0.053,-2.573,0.106,-1.158,0.092,15.93,1.63,13.76,13.0,12.91,0.25,26.56,3.11,nan,nan,nan,nan,0,2.32,-0.315
283.7391,-29.6002,0.034,0.087,-2.368,0.121,-1.329,0.109,16.51,1.63,14.41,13.68,13.52,0.19,26.88,1.31,nan,nan,nan,nan,0,0.155,0.632
295.1935,-33.5598,-0.106,0.062,-2.731,0.107,-1.417,0.096,14.61,2.65,11.6,10.7,10.44,0.16,27.48,1.03,nan,nan,nan,nan,0,-10.019,3.345
180.1545,14.4223,0.097,0.049,-1.559,0.074,-0.932,0.05,15.01,1.67,12.94,12.18,12.04,0.03,31.92,3.66,nan,nan,nan,nan,0,108.938,3.234
283.2087,-29.4682,-0.119,0.102,-2.543,0.202,-1.478,0.182,17.35,1.47,15.57,14.91,14.72,0.17,27.52,1.77,nan,nan,nan,nan,0,0.633,0.583
280.5034,-31.8247,-0.076,0.05,-2.873,0.096,-1.2,0.09,14.67,2.3,11.95,11.03,10.81,0.14,26.02,0.98,nan,nan,nan,nan,0,2.476,3.336
273.3397,-33.4133,0.029,0.051,-2.108,0.089,-0.899,0.077,15.72,1.76,13.5,12.74,12.55,0.26,25.41,4.24,nan,nan,nan,nan,0,8.005,6.262
218.2799,2.9137,-0.001,0.056,-1.0,0.106,-0.653,0.104,15.81,1.8,13.64,12.79,12.6,0.03,49.31,1.13,-33.29,1.21,nan,nan,5,70.417,-4.86
199.1924,11.4967,-0.07,0.05,-1.321,0.109,-0.694,0.072,15.75,1.54,13.91,13.18,13.0,0.02,41.02,1.35,nan,nan,nan,nan,0,91.128,-2.734
286.3252,-30.8523,-0.11,0.086,-2.719,0.178,-1.561,0.177,16.99,1.52,15.06,14.31,14.09,0.1,27.65,2.39,nan,nan,nan,nan,0,-2.253,1.506
188.6112,7.4018,0.048,0.098,-1.053,0.186,-0.933,0.126,16.55,1.44,14.75,14.06,13.94,0.02,38.33,3.47,nan,nan,nan,nan,0,98.352,5.844
291.0709,-30.5202,0.035,0.059,-2.233,0.107,-1.326,0.103,16.17,1.63,14.15,13.39,13.29,0.08,28.17,0.34,nan,nan,nan,nan,0,-6.256,0.643
201.5419,0.587,0.084,0.085,-1.226,0.168,-0.388,0.109,16.76,1.34,15.09,14.44,14.39,0.02,42.9,6.13,39.75,1.57,-1.54,0.0,5,83.699,5.597
177.3612,21.9602,-0.061,0.116,-1.597,0.147,-1.279,0.122,16.3,1.27,14.77,14.12,14.01,0.02,30.65,1.92,nan,nan,nan,nan,0,114.488,-2.516
291.9212,-31.5095,0.018,0.049,-2.9,0.074,-1.435,0.068,15.24,1.76,13.1,12.28,12.12,0.08,26.04,1.0,nan,nan,nan,nan,0,-7.086,1.549
290.1631,-30.2496,0.024,0.167,-3.266,0.23,-1.491,0.204,17.75,1.28,16.32,15.66,15.54,0.12,27.56,1.34,nan,nan,nan,nan,0,-5.447,0.464
286.1777,-33.2151,0.063,0.095,-2.567,0.163,-1.193,0.137,16.59,1.51,14.62,13.97,13.86,0.11,28.08,1.06,nan,nan,nan,nan,0,-2.488,3.86
286.2441,-30.1772,0.044,0.038,-2.752,0.057,-1.29,0.05,14.54,1.97,12.14,11.33,11.14,0.12,26.9,0.11,nan,nan,nan,nan,0,-2.081,0.849
284.6903,-31.4691,0.01,0.078,-2.515,0.104,-1.51,0.096,15.81,1.55,13.83,13.15,12.99,0.16,28.26,0.64,nan,nan,nan,nan,0,-0.968,2.336
282.8633,-27.5467,-0.121,0.091,-2.638,0.137,-1.561,0.124,16.6,1.56,14.54,13.89,13.78,0.23,27.76,0.98,nan,nan,nan,nan,0,1.275,-1.254
279.8689,-28.1261,0.021,0.045,-2.726,0.09,-1.452,0.081,14.87,2.38,11.88,10.93,10.53,0.2,28.96,2.07,147.46,1.96,nan,nan,3,3.762,-0.176
286.3759,-31.7855,-0.094,0.146,-2.626,0.285,-1.573,0.26,17.94,1.24,16.32,15.67,15.54,0.13,26.36,2.05,nan,nan,nan,nan,0,-2.436,2.422
290.5316,-32.3163,0.002,0.076,-2.438,0.161,-1.445,0.133,16.17,1.47,14.36,13.68,13.62,0.11,26.23,1.53,nan,nan,nan,nan,0,-6.001,2.479
295.5555,-33.7246,0.051,0.069,-2.51,0.113,-1.34,0.076,16.72,1.61,14.68,13.96,13.83,0.17,27.16,2.88,nan,nan,nan,nan,0,-10.332,3.488
289.459,-34.605,0.062,0.051,-2.577,0.076,-1.355,0.062,15.03,1.69,12.89,12.16,12.02,0.09,26.07,0.69,132.1,nan,nan,nan,4,-5.386,4.859
285.3033,-31.3413,-0.008,0.047,-2.578,0.114,-1.441,0.095,15.1,1.91,12.78,11.88,11.73,0.12,27.33,0.51,nan,nan,nan,nan,0,-1.464,2.125
338.62,-27.3702,-0.038,0.032,-2.942,0.048,-3.81,0.044,13.71,1.75,11.59,10.75,10.6,0.02,21.28,1.88,9.2,nan,nan,nan,4,-47.679,1.554
284.3995,-29.9994,0.051,0.058,-2.857,0.101,-1.423,0.095,15.18,1.86,12.87,12.04,11.87,0.13,28.48,2.05,nan,nan,nan,nan,0,-0.477,0.928
292.2892,-33.7691,-0.133,0.228,-2.534,0.317,-1.457,0.257,17.94,1.25,16.46,15.55,15.19,0.12,26.41,0.99,nan,nan,nan,nan,0,-7.625,3.765
279.5516,-30.2015,-0.041,0.051,-2.455,0.098,-1.111,0.09,15.86,1.73,13.6,12.82,12.62,0.15,27.38,1.31,nan,nan,nan,nan,0,3.606,1.912
290.787,-32.7218,-0.172,0.182,-2.1,0.317,-1.42,0.308,18.1,1.25,16.6,15.85,15.63,0.1,27.5,0.98,nan,nan,nan,nan,0,-6.262,2.858
244.1977,-13.4744,-0.1,0.084,-1.907,0.167,-0.678,0.126,16.55,1.89,14.25,13.34,13.16,0.3,38.76,2.44,nan,nan,nan,nan,0,39.917,-2.861
277.3063,-30.6437,0.064,0.088,-2.613,0.163,-0.95,0.146,17.0,1.6,14.96,14.26,14.08,0.25,25.05,3.28,nan,nan,nan,nan,0,5.402,2.763
232.7642,-14.6759,-0.058,0.164,-1.499,0.296,-0.468,0.214,17.94,1.52,15.98,15.17,15.04,0.16,45.93,0.7,nan,nan,nan,nan,0,49.216,3.305
278.2126,-29.7627,0.015,0.055,-2.679,0.081,-1.206,0.065,15.17,2.06,12.68,11.76,11.53,0.23,27.69,1.52,nan,nan,nan,nan,0,4.833,1.73
78.9658,26.4171,-0.039,0.336,0.554,0.544,-0.997,0.36,18.68,2.93,14.88,13.68,13.23,1.53,49.25,0.72,nan,nan,nan,nan,0,-157.952,-3.465
298.3194,-32.9841,-0.003,0.04,-3.299,0.062,-2.087,0.042,14.56,2.08,12.05,11.19,10.97,0.14,27.3,3.03,nan,nan,nan,nan,0,-12.596,2.611
285.6166,-30.5107,0.081,0.211,-3.005,0.288,-1.629,0.268,18.08,1.22,16.64,15.73,15.42,0.15,28.84,1.17,nan,nan,nan,nan,0,-1.598,1.262
285.6332,-29.4772,0.001,0.131,-2.335,0.189,-1.61,0.16,17.08,1.4,15.28,14.51,14.39,0.13,27.8,0.08,nan,nan,nan,nan,0,-1.45,0.239
238.5944,-11.8956,-0.116,0.095,-1.117,0.17,-0.346,0.112,15.92,2.73,12.87,11.94,11.64,0.24,45.8,1.49,nan,nan,nan,nan,0,45.515,-1.816
275.9524,-32.5313,0.042,0.067,-2.592,0.112,-0.998,0.096,16.14,1.81,13.91,13.08,12.95,0.24,27.55,0.52,nan,nan,nan,nan,0,6.09,4.866
279.7478,-27.2805,-0.126,0.244,-2.491,0.361,-1.051,0.336,18.46,1.64,16.24,15.53,15.37,0.42,27.89,0.46,nan,nan,nan,nan,0,4.04,-0.981
279.9683,-28.8269,-0.013,0.049,-2.481,0.069,-0.978,0.063,14.88,1.9,12.51,11.71,11.51,0.21,25.89,2.14,nan,nan,nan,nan,0,3.533,0.492
318.1866,-30.429,0.044,0.066,-2.586,0.082,-2.231,0.055,14.91,1.6,12.94,12.2,12.07,0.11,22.98,2.93,nan,nan,nan,nan,0,-29.57,0.754
284.5698,-27.5998,0.039,0.056,-3.057,0.094,-1.742,0.086,15.88,1.76,13.68,12.84,12.71,0.2,26.85,3.42,nan,nan,nan,nan,0,-0.225,-1.463
283.2328,-32.2791,-0.064,0.057,-2.179,0.102,-1.482,0.092,16.03,1.65,13.92,13.2,13.1,0.13,27.01,0.98,120.9,nan,nan,nan,4,0.114,3.346
226.8822,-2.745,0.005,0.085,-1.338,0.146,-0.359,0.176,16.26,1.77,14.05,13.37,13.22,0.11,52.88,0.56,nan,nan,nan,nan,0,60.106,-4.285
286.9706,-30.3981,-0.017,0.078,-2.663,0.113,-1.529,0.098,16.46,1.62,14.51,13.73,13.55,0.13,26.52,0.56,nan,nan,nan,nan,0,-2.735,0.974
283.2494,-28.9197,0.032,0.154,-2.616,0.168,-1.396,0.132,16.3,1.7,14.19,13.39,13.24,0.17,26.31,0.24,nan,nan,nan,nan,0,0.695,0.037
285.7402,-32.3286,0.055,0.06,-2.9,0.088,-1.437,0.07,15.38,1.58,13.22,12.57,12.43,0.11,26.55,0.78,nan,nan,nan,nan,0,-1.987,3.041
294.3465,-34.3586,-0.037,0.072,-2.629,0.111,-1.509,0.103,16.26,1.41,14.45,13.8,13.7,0.13,26.47,0.66,nan,nan,nan,nan,0,-9.38,4.197
291.7541,-34.224,0.068,0.155,-1.875,0.283,-1.371,0.244,17.53,1.4,15.86,15.2,15.1,0.13,27.01,1.06,nan,nan,nan,nan,0,-7.229,4.263
284.8245,-33.322,0.042,0.038,-2.835,0.067,-1.541,0.061,14.88,2.02,12.45,11.57,11.37,0.08,26.53,0.68,141.31,1.11,nan,nan,6,-1.385,4.145
282.5748,-28.673,0.068,0.091,-2.681,0.14,-1.215,0.127,16.59,1.64,14.57,13.88,13.64,0.15,28.62,0.3,nan,nan,nan,nan,0,1.321,-0.1
287.437,-30.7229,0.042,0.059,-2.308,0.081,-1.057,0.073,15.48,1.72,13.34,12.54,12.38,0.09,26.57,0.07,nan,nan,nan,nan,0,-3.179,1.238
238.9193,-14.7283,0.066,0.061,-1.62,0.112,-0.559,0.071,16.14,1.65,14.05,13.34,13.16,0.14,44.79,6.27,nan,nan,nan,nan,0,43.932,0.555
283.5749,-30.9394,-0.085,0.155,-2.612,0.288,-1.523,0.259,17.95,1.28,16.25,15.56,15.49,0.14,27.42,1.16,nan,nan,nan,nan,0,0.063,1.976
285.4087,-29.1904,-0.05,0.113,-2.397,0.126,-1.257,0.109,16.07,1.77,13.87,13.15,12.92,0.19,27.73,2.0,nan,nan,nan,nan,0,-1.211,-0.013
288.7957,-32.2215,-0.043,0.125,-2.172,0.231,-1.355,0.187,16.83,1.42,15.15,14.46,14.39,0.11,26.95,1.88,nan,nan,nan,nan,0,-4.531,2.565
345.3262,-33.7336,0.046,0.032,-3.05,0.062,-3.666,0.058,14.85,1.35,13.14,12.53,12.42,0.02,20.44,1.31,nan,nan,nan,nan,0,-51.161,9.413
233.7028,-4.9144,0.045,0.225,-1.2,0.395,-0.837,0.396,18.12,1.31,16.29,15.54,15.29,0.14,51.63,3.79,nan,nan,nan,nan,0,53.08,-5.709
23.8231,-14.3565,-0.037,0.041,-0.455,0.097,-2.744,0.042,14.9,1.56,12.96,12.23,12.12,0.02,25.33,0.81,nan,nan,nan,nan,0,-91.373,7.461
282.4802,-29.4724,-0.088,0.161,-3.068,0.302,-1.196,0.268,17.87,1.48,16.07,15.31,15.18,0.16,26.98,0.62,nan,nan,nan,nan,0,1.256,0.701
349.9489,-25.2041,-0.155,0.075,-2.203,0.086,-3.638,0.087,15.87,1.33,14.2,13.54,13.46,0.02,19.48,5.63,nan,nan,nan,nan,0,-57.985,2.863
283.0551,-27.3693,0.065,0.202,-2.437,0.293,-1.427,0.264,18.24,1.36,16.93,16.14,15.81,0.21,27.76,1.91,nan,nan,nan,nan,0,1.139,-1.459
283.1008,-27.8279,-0.072,0.078,-2.731,0.128,-1.497,0.116,16.41,1.71,14.31,13.58,13.42,0.26,25.21,1.1,nan,nan,nan,nan,0,1.017,-1.014
285.5958,-33.1251,0.049,0.045,-2.853,0.08,-1.169,0.073,14.94,2.07,12.48,11.59,11.37,0.1,26.7,0.75,123.95,1.23,nan,nan,6,-1.992,3.847
300.946,-33.9212,0.024,0.072,-2.336,0.099,-1.737,0.064,15.98,1.4,14.18,13.59,13.47,0.1,26.25,4.12,nan,nan,nan,nan,0,-14.822,3.47
284.9384,-31.3509,-0.016,0.192,-2.193,0.258,-1.538,0.235,17.99,1.27,16.44,15.49,15.07,0.13,26.35,1.05,nan,nan,nan,nan,0,-1.158,2.185
316.9735,-33.5572,-0.023,0.048,-2.471,0.067,-2.207,0.058,15.1,1.67,13.03,12.26,12.1,0.09,23.52,2.32,nan,nan,nan,nan,0,-28.166,3.732
278.9375,-29.3499,-0.077,0.068,-2.723,0.118,-1.281,0.107,16.43,1.72,14.28,13.53,13.34,0.24,27.51,2.37,158.6,nan,nan,nan,4,4.306,1.191
222.617,8.0887,-0.078,0.166,-1.223,0.238,-0.348,0.308,17.52,1.27,15.96,15.35,15.21,0.02,48.99,1.68,nan,nan,nan,nan,0,69.324,-11.511
281.9185,-27.9074,0.075,0.085,-3.052,0.128,-1.42,0.119,16.51,1.68,14.42,13.6,13.49,0.18,27.19,0.66,nan,nan,nan,nan,0,2.03,-0.745
298.6282,-34.0393,0.096,0.09,-2.279,0.12,-1.765,0.075,16.45,1.59,14.43,13.72,13.62,0.13,27.28,3.68,nan,nan,nan,nan,0,-12.902,3.654
300.9088,-34.8399,-0.023,0.133,-1.976,0.193,-1.657,0.139,17.54,1.38,15.92,15.17,14.86,0.1,26.21,0.81,nan,nan,nan,nan,0,-14.814,4.389
290.1457,-33.0045,-0.054,0.075,-2.483,0.132,-1.53,0.126,16.45,1.37,14.72,14.09,13.9,0.1,26.97,1.34,nan,nan,nan,nan,0,-5.759,3.201
336.2182,-27.6954,0.063,0.059,-2.186,0.114,-3.008,0.096,16.19,1.29,14.55,13.88,13.83,0.02,18.3,1.84,nan,nan,nan,nan,0,-45.543,1.266
7.7723,-14.9394,0.024,0.193,-0.801,0.299,-3.358,0.251,17.95,1.09,16.65,15.94,15.84,0.03,21.29,1.99,nan,nan,nan,nan,0,-77.453,0.476
286.5255,-30.6699,0.09,0.077,-2.839,0.183,-1.403,0.139,16.4,1.41,14.61,13.96,13.86,0.12,28.91,0.94,nan,nan,nan,nan,0,-2.395,1.3
287.209,-32.0323,0.016,0.201,-2.843,0.284,-1.659,0.274,18.05,1.27,16.58,15.92,15.83,0.1,26.76,0.57,nan,nan,nan,nan,0,-3.173,2.562
234.2592,-9.65,-0.091,0.134,-1.204,0.235,-0.581,0.176,17.17,1.64,15.17,14.45,14.19,0.13,45.31,1.79,nan,nan,nan,nan,0,50.331,-1.809
282.6146,-30.7747,-0.004,0.063,-2.84,0.097,-1.408,0.081,14.93,2.46,12.09,11.15,10.88,0.15,26.33,0.57,nan,nan,nan,nan,0,0.904,1.961
284.1969,-31.3752,-0.041,0.165,-3.091,0.288,-1.46,0.282,17.99,1.33,16.35,15.66,15.54,0.16,27.39,0.23,nan,nan,nan,nan,0,-0.537,2.314
292.1308,-34.7473,0.027,0.102,-2.422,0.117,-1.284,0.106,15.92,1.7,13.83,13.11,12.94,0.11,29.63,1.98,nan,nan,nan,nan,0,-7.593,4.752
224.1049,-7.4089,-0.056,0.06,-0.81,0.113,-0.523,0.096,16.32,1.77,14.12,13.31,13.14,0.1,49.31,4.49,nan,nan,nan,nan,0,60.19,1.136
283.1865,-28.6549,0.009,0.122,-2.855,0.186,-0.896,0.181,17.05,1.4,15.28,14.66,14.54,0.18,25.65,2.21,nan,nan,nan,nan,0,0.796,-0.214
280.4681,-28.3927,-0.067,0.107,-2.724,0.195,-1.51,0.17,16.94,1.54,15.1,14.4,14.26,0.18,26.89,0.79,nan,nan,nan,nan,0,3.191,-0.021
299.4249,-33.7838,-0.056,0.05,-2.288,0.077,-1.436,0.054,15.59,1.53,13.68,12.91,12.79,0.12,26.56,3.69,nan,nan,nan,nan,0,-13.553,3.371
284.1776,-29.4347,-0.025,0.06,-2.68,0.101,-1.496,0.094,16.0,1.85,13.72,12.88,12.67,0.17,26.6,2.12,112.3,nan,nan,nan,4,-0.192,0.404
286.4546,-31.5421,-0.1,0.142,-2.726,0.204,-1.548,0.193,17.37,1.44,15.59,14.85,14.71,0.12,27.52,3.03,nan,nan,nan,nan,0,-2.466,2.171
285.1271,-30.3513,0.048,0.126,-2.98,0.175,-1.609,0.156,17.07,1.39,15.29,14.7,14.62,0.13,27.38,1.15,nan,nan,nan,nan,0,-1.156,1.172
57.6533,13.2752,0.024,0.208,0.111,0.307,-1.466,0.234,17.96,1.7,15.81,15.01,14.83,0.34,35.05,10.29,nan,nan,nan,nan,0,-134.308,0.168
285.1882,-29.8077,-0.0,0.046,-2.759,0.108,-1.32,0.083,15.2,1.62,13.21,12.45,12.34,0.16,26.57,2.04,nan,nan,nan,nan,0,-1.12,0.627
283.6164,-31.8028,-0.058,0.053,-2.652,0.071,-1.433,0.063,14.74,1.99,12.32,11.45,11.23,0.16,26.9,0.19,131.6,3.45,nan,nan,6,-0.123,2.82
287.3196,-30.9487,0.01,0.079,-2.85,0.116,-1.54,0.109,16.56,1.44,14.7,14.1,13.98,0.11,26.55,1.59,nan,nan,nan,nan,0,-3.111,1.476
290.488,-31.2831,-0.025,0.076,-2.09,0.133,-1.424,0.133,16.67,1.53,14.65,14.06,13.94,0.09,26.89,0.12,nan,nan,nan,nan,0,-5.845,1.457
283.2987,-27.6688,-0.009,0.051,-2.484,0.08,-1.283,0.069,15.32,2.2,12.65,11.76,11.48,0.23,25.82,2.0,nan,nan,nan,nan,0,0.873,-1.202
321.2889,-22.9083,0.028,0.051,-2.844,0.072,-2.886,0.056,15.48,1.51,13.57,12.9,12.74,0.05,22.13,2.52,nan,nan,nan,nan,0,-33.379,-6.301
227.2684,-6.0353,0.094,0.08,-1.143,0.116,-0.497,0.099,16.12,1.67,14.01,13.27,13.13,0.09,51.01,4.27,nan,nan,nan,nan,0,58.143,-1.615
311.1583,-38.8419,-0.017,0.057,-2.841,0.081,-2.035,0.059,15.51,1.4,13.76,13.05,12.99,0.04,21.21,1.47,nan,nan,nan,nan,0,-22.977,8.56
281.0316,-30.4431,-0.031,0.063,-2.53,0.084,-1.426,0.069,15.21,1.96,12.8,11.9,11.77,0.13,28.84,2.94,152.0,nan,nan,nan,4,2.305,1.892
280.5451,-29.9332,0.024,0.056,-2.631,0.091,-1.412,0.077,15.07,2.14,12.51,11.59,11.35,0.18,29.06,3.23,164.0,nan,nan,nan,4,2.818,1.475
345.6559,-17.9385,-0.026,0.031,-2.228,0.058,-3.817,0.049,14.34,1.48,12.52,11.83,11.72,0.03,19.07,1.38,nan,nan,nan,nan,0,-56.821,-5.343
279.6212,-30.0744,-0.045,0.066,-2.771,0.135,-1.442,0.123,16.46,1.37,14.67,14.03,13.93,0.14,28.05,0.96,nan,nan,nan,nan,0,3.573,1.775
290.237,-34.2811,0.044,0.074,-2.58,0.132,-1.303,0.119,16.58,1.52,14.68,13.87,13.75,0.11,26.0,1.54,nan,nan,nan,nan,0,-5.985,4.46
309.2435,-27.7465,0.028,0.038,-3.106,0.051,-2.565,0.036,13.98,1.78,11.83,11.03,10.87,0.05,23.7,3.68,nan,nan,nan,nan,0,-22.024,-2.609
262.7171,-24.6738,-0.118,0.144,-1.264,0.297,-1.074,0.228,17.56,3.32,13.65,12.43,12.05,1.67,32.66,2.66,nan,nan,nan,nan,0,19.471,0.662
277.3184,-28.288,0.087,0.078,-2.668,0.132,-1.34,0.12,16.39,1.8,14.02,13.22,13.03,0.39,25.7,0.26,nan,nan,nan,nan,0,5.922,0.465
39.0217,-3.4727,-0.21,0.11,-0.064,0.12,-2.137,0.115,16.3,1.32,14.67,14.04,13.96,0.02,29.42,1.16,nan,nan,nan,nan,0,-109.939,5.718
280.3702,-30.4017,-0.036,0.042,-2.69,0.073,-1.365,0.065,15.36,1.85,13.05,12.21,12.1,0.13,28.69,1.24,nan,nan,nan,nan,0,2.873,1.964
231.9401,-7.5269,-0.017,0.083,-1.125,0.148,-0.377,0.12,16.56,1.87,14.24,13.38,13.26,0.1,46.18,3.46,nan,nan,nan,nan,0,53.363,-2.576
266.0164,-17.2411,0.058,0.087,-1.485,0.142,-0.517,0.117,16.3,2.31,13.36,12.53,12.27,0.67,30.35,8.25,nan,nan,nan,nan,0,18.947,-7.366
285.7618,-33.2808,-0.039,0.141,-2.722,0.231,-1.445,0.225,17.74,1.26,16.19,15.59,15.48,0.09,26.54,0.27,nan,nan,nan,nan,0,-2.154,3.979
284.2712,-29.879,-0.209,0.179,-2.136,0.276,-1.092,0.257,17.78,1.31,16.1,15.29,15.17,0.14,26.82,1.68,nan,nan,nan,nan,0,-0.347,0.828
312.1195,-38.0195,0.097,0.047,-2.93,0.069,-2.159,0.049,15.25,1.33,13.58,12.95,12.85,0.05,22.2,1.83,nan,nan,nan,nan,0,-23.795,7.794
289.8837,-33.2967,-0.145,0.076,-2.216,0.125,-1.534,0.125,16.24,1.53,14.29,13.61,13.52,0.09,26.24,1.54,nan,nan,nan,nan,0,-5.575,3.517
290.8739,-33.0859,-0.076,0.044,-2.493,0.067,-1.425,0.059,14.93,2.0,12.5,11.64,11.46,0.1,26.68,2.73,nan,nan,nan,nan,0,-6.375,3.211
280.8847,-29.0857,0.049,0.061,-2.67,0.115,-1.345,0.101,15.64,1.93,13.22,12.38,12.12,0.22,26.79,1.32,126.35,1.12,nan,nan,6,2.696,0.586
287.9008,-31.705,0.017,0.085,-2.465,0.193,-0.94,0.146,16.59,1.54,14.58,13.92,13.78,0.08,26.35,0.91,nan,nan,nan,nan,0,-3.709,2.155
289.9946,-32.1768,-0.047,0.21,-2.354,0.311,-2.056,0.283,17.99,1.34,16.26,15.62,15.55,0.12,26.56,0.52,nan,nan,nan,nan,0,-5.533,2.394
62.0775,12.1337,0.053,0.115,0.134,0.291,-1.134,0.155,16.76,2.02,14.25,13.4,13.26,0.48,39.84,5.28,nan,nan,nan,nan,0,-137.633,3.149
275.9696,-25.241,-0.228,0.064,-2.755,0.129,-1.357,0.107,15.92,2.09,13.18,12.26,12.04,0.44,28.43,0.47,nan,nan,nan,nan,0,7.796,-2.223
290.0809,-31.1122,0.076,0.089,-3.021,0.132,-1.476,0.124,16.81,1.41,15.07,14.34,14.26,0.12,27.78,0.95,nan,nan,nan,nan,0,-5.479,1.328
294.6021,-31.6337,0.02,0.049,-2.844,0.077,-1.986,0.072,15.73,1.71,13.63,12.88,12.73,0.12,25.59,0.42,nan,nan,nan,nan,0,-9.373,1.463
282.908,-30.4297,0.001,0.067,-2.607,0.115,-1.459,0.093,16.11,1.8,13.94,13.12,12.93,0.14,27.16,0.86,nan,nan,nan,nan,0,0.718,1.576
284.9604,-30.761,-0.021,0.09,-2.338,0.183,-0.935,0.173,17.11,1.57,15.22,14.56,14.35,0.14,26.73,1.01,nan,nan,nan,nan,0,-1.08,1.6
284.2558,-31.7086,0.045,0.068,-2.608,0.142,-1.424,0.121,16.42,1.63,14.35,13.62,13.46,0.16,27.24,0.62,nan,nan,nan,nan,0,-0.643,2.634
281.8176,-30.9569,0.094,0.068,-2.714,0.123,-1.231,0.116,16.49,1.7,14.36,13.65,13.52,0.15,27.88,2.04,nan,nan,nan,nan,0,1.543,2.266
281.628,-31.3528,-0.036,0.081,-2.937,0.175,-1.451,0.163,16.55,1.63,14.47,13.79,13.63,0.17,26.47,3.84,nan,nan,nan,nan,0,1.627,2.686
294.4757,-30.5546,-0.111,0.085,-2.482,0.126,-1.739,0.121,16.44,1.57,14.5,13.74,13.68,0.13,25.73,1.68,nan,nan,nan,nan,0,-9.178,0.396
286.0122,-32.118,0.098,0.048,-3.058,0.083,-1.398,0.081,15.38,1.61,13.34,12.63,12.47,0.12,26.99,0.68,nan,nan,nan,nan,0,-2.182,2.798
287.1643,-29.9154,-0.343,0.252,-3.122,0.791,-1.464,0.528,18.08,1.27,16.68,15.77,15.65,0.11,25.63,3.04,nan,nan,nan,nan,0,-2.831,0.473
277.5246,-27.0731,-0.004,0.091,-3.056,0.14,-1.48,0.12,16.75,1.86,14.27,13.48,13.24,0.34,27.0,1.63,nan,nan,nan,nan,0,6.017,-0.76
179.5265,11.2836,0.024,0.096,-1.85,0.132,-1.148,0.095,16.41,1.28,14.83,14.2,14.1,0.02,28.69,5.3,nan,nan,nan,nan,0,108.162,6.337
290.9165,-30.707,-0.009,0.091,-2.387,0.152,-1.486,0.146,16.74,1.51,14.85,14.2,14.01,0.08,27.78,0.91,nan,nan,nan,nan,0,-6.144,0.843
230.5831,-11.0028,-0.126,0.096,-1.277,0.145,-0.34,0.117,16.47,1.81,14.23,13.36,13.19,0.13,52.26,2.11,nan,nan,nan,nan,0,52.854,1.114
286.3718,-29.2448,-0.138,0.054,-2.494,0.12,-1.153,0.1,15.67,1.76,13.61,12.7,12.53,0.14,28.15,1.59,nan,nan,nan,nan,0,-2.05,-0.089
278.8021,-29.5053,0.009,0.064,-2.581,0.111,-1.069,0.096,16.34,1.73,14.05,13.32,13.17,0.25,27.51,0.64,nan,nan,nan,nan,0,4.388,1.368
280.3676,-32.001,0.083,0.131,-2.935,0.254,-0.991,0.218,17.54,1.25,16.03,15.45,15.36,0.13,26.89,1.48,nan,nan,nan,nan,0,2.554,3.531
131.4803,22.0591,0.05,0.073,-1.831,0.12,-2.573,0.071,16.4,1.24,14.88,14.25,14.13,0.03,17.77,2.03,-39.99,4.47,-0.76,0.17,2,155.601,8.165
284.2626,-30.3133,0.038,0.092,-2.83,0.139,-1.182,0.126,16.71,1.5,14.81,14.06,13.9,0.15,27.17,1.69,nan,nan,nan,nan,0,-0.413,1.257
284.0249,-31.0127,0.029,0.081,-2.85,0.108,-1.377,0.088,15.83,1.67,13.72,12.95,12.8,0.15,27.15,2.21,nan,nan,nan,nan,0,-0.33,1.981
282.909,-30.918,-0.025,0.113,-2.466,0.173,-1.394,0.14,16.33,1.66,14.21,13.46,13.37,0.16,26.32,2.05,nan,nan,nan,nan,0,0.629,2.056
297.9447,-32.8886,0.036,0.049,-2.995,0.086,-1.715,0.055,15.95,1.5,14.04,13.36,13.25,0.15,26.57,1.92,nan,nan,nan,nan,0,-12.277,2.531
286.0043,-28.7532,-0.033,0.114,-2.877,0.177,-1.735,0.166,16.92,1.47,15.0,14.41,14.34,0.2,27.5,2.2,nan,nan,nan,nan,0,-1.658,-0.526
290.903,-29.8007,-0.048,0.071,-2.359,0.168,-1.675,0.15,16.26,1.58,14.3,13.56,13.44,0.12,27.01,1.27,nan,nan,nan,nan,0,-6.031,-0.056
288.0437,-29.603,-0.216,0.1,-2.458,0.163,-1.444,0.149,16.95,1.43,15.06,14.42,14.26,0.15,26.53,1.53,nan,nan,nan,nan,0,-3.543,0.056
275.3996,-28.3046,0.062,0.098,-2.718,0.147,-1.14,0.131,16.67,1.91,14.22,13.42,13.14,0.39,25.44,1.18,nan,nan,nan,nan,0,7.562,0.874
294.5813,-30.0198,0.016,0.086,-2.858,0.144,-2.101,0.142,16.79,1.31,15.11,14.47,14.32,0.11,26.92,3.34,nan,nan,nan,nan,0,-9.226,-0.144
278.7092,-28.2067,-0.026,0.069,-2.896,0.096,-1.333,0.079,15.63,2.0,13.18,12.34,12.09,0.27,27.8,2.76,nan,nan,nan,nan,0,4.745,0.117
288.4684,-35.0283,-0.067,0.149,-2.549,0.246,-1.538,0.248,17.57,1.21,15.97,15.17,15.07,0.08,26.29,1.32,nan,nan,nan,nan,0,-4.631,5.384
284.6236,-31.7162,0.075,0.059,-2.6,0.098,-1.466,0.093,15.91,1.44,14.1,13.42,13.3,0.13,26.51,0.78,nan,nan,nan,nan,0,-0.953,2.589
280.0736,-30.3562,-0.031,0.148,-3.016,0.258,-1.28,0.24,18.01,1.24,16.25,15.59,15.45,0.13,26.98,0.81,nan,nan,nan,nan,0,3.133,1.971
282.5977,-29.8378,-0.106,0.045,-2.695,0.07,-1.561,0.064,15.09,1.98,12.66,11.82,11.58,0.16,27.16,1.93,160.52,0.77,nan,nan,6,1.089,1.042
299.3792,-29.351,-0.056,0.048,-2.368,0.079,-1.701,0.055,15.87,1.46,14.05,13.4,13.26,0.11,28.37,2.24,nan,nan,nan,nan,0,-13.348,-1.057
277.0628,-23.7356,0.096,0.052,-2.509,0.077,-0.798,0.066,15.49,2.2,12.73,11.9,11.67,0.51,28.55,0.29,nan,nan,nan,nan,0,7.176,-3.917
283.5344,-28.7926,-0.058,0.208,-2.331,0.352,-1.053,0.317,18.29,1.26,16.52,15.87,15.69,0.17,27.37,1.45,nan,nan,nan,nan,0,0.472,-0.132
280.6069,-30.7084,-0.011,0.053,-2.688,0.098,-1.184,0.088,16.03,1.48,14.07,13.48,13.39,0.14,26.49,2.12,nan,nan,nan,nan,0,2.612,2.224
285.1766,-32.3383,0.081,0.165,-2.707,0.366,-1.605,0.373,17.89,1.27,16.46,15.6,15.36,0.11,26.75,0.13,nan,nan,nan,nan,0,-1.518,3.126
299.7213,-37.2923,-0.012,0.04,-2.556,0.064,-1.363,0.041,14.76,1.69,12.69,11.9,11.79,0.11,25.67,1.91,nan,nan,nan,nan,0,-13.923,6.869
241.6567,-7.3613,-0.099,0.135,-0.839,0.307,-0.53,0.187,17.25,1.62,15.17,14.43,14.35,0.18,46.48,3.41,nan,nan,nan,nan,0,44.891,-7.228
6.1343,-27.2097,-0.082,0.051,-1.808,0.082,-3.803,0.062,15.45,1.25,13.84,13.26,13.16,0.01,19.03,1.38,nan,nan,nan,nan,0,-70.458,10.702
283.6271,-30.773,-0.068,0.088,-2.684,0.145,-1.509,0.128,16.58,1.61,14.57,13.89,13.65,0.15,26.58,1.82,145.7,nan,nan,nan,4,0.048,1.804
284.5021,-31.9788,-0.097,0.085,-2.831,0.154,-1.264,0.134,16.4,1.49,14.43,13.74,13.67,0.14,25.98,2.4,nan,nan,nan,nan,0,-0.895,2.865
43.9296,3.6564,0.021,0.041,-0.151,0.071,-2.223,0.069,15.02,1.95,12.67,11.79,11.59,0.09,26.28,2.39,-160.18,3.22,-0.3,0.11,2,-117.786,2.028
344.1331,-28.1268,-0.026,0.039,-2.152,0.078,-3.217,0.067,15.42,1.3,13.75,13.16,13.04,0.03,20.31,1.42,nan,nan,nan,nan,0,-52.086,3.789
284.9905,-31.3665,-0.274,0.17,-2.112,0.244,-1.099,0.212,17.74,1.3,16.09,15.37,15.29,0.13,26.35,1.05,nan,nan,nan,nan,0,-1.204,2.193
277.8571,-31.5311,-0.078,0.078,-2.463,0.126,-1.132,0.11,16.6,1.58,14.61,13.87,13.75,0.19,25.45,2.8,nan,nan,nan,nan,0,4.743,3.522
29.1267,-4.2261,0.009,0.07,-0.512,0.175,-2.087,0.089,16.05,1.31,14.37,13.73,13.6,0.02,21.34,1.63,nan,nan,nan,nan,0,-101.032,1.355
287.5534,-31.3175,-0.197,0.094,-2.804,0.186,-1.335,0.158,17.09,1.38,15.27,14.6,14.42,0.1,26.75,0.93,nan,nan,nan,nan,0,-3.362,1.813
309.6397,-32.8554,0.059,0.055,-3.12,0.091,-2.416,0.059,15.57,1.47,13.74,13.07,12.88,0.06,20.54,1.35,nan,nan,nan,nan,0,-22.104,2.511
292.0538,-33.5165,0.032,0.073,-2.755,0.114,-1.517,0.108,16.29,1.5,14.37,13.69,13.56,0.11,27.77,2.01,nan,nan,nan,nan,0,-7.404,3.534
287.6612,-28.6997,-0.006,0.094,-3.159,0.16,-1.674,0.148,16.79,1.61,14.76,13.98,13.84,0.17,28.95,0.8,nan,nan,nan,nan,0,-3.087,-0.792
284.4705,-32.9553,-0.034,0.062,-2.474,0.121,-1.505,0.113,16.54,1.56,14.61,13.87,13.72,0.1,25.53,0.72,nan,nan,nan,nan,0,-1.031,3.832
284.7566,-31.2056,0.076,0.083,-2.967,0.137,-0.92,0.132,16.76,1.48,14.91,14.21,14.11,0.14,25.65,0.83,nan,nan,nan,nan,0,-0.98,2.067
246.9737,-15.945,0.049,0.127,-1.801,0.266,-0.366,0.157,17.37,2.46,14.37,13.31,13.08,0.79,36.97,5.45,nan,nan,nan,nan,0,36.427,-1.787
285.6627,-30.0139,-0.129,0.173,-2.05,0.332,-1.076,0.293,18.23,1.22,16.48,15.81,15.6,0.14,27.04,0.2,nan,nan,nan,nan,0,-1.559,0.765
283.4306,-30.4928,-0.129,0.109,-2.629,0.153,-1.309,0.137,17.03,1.56,15.07,14.4,14.22,0.14,27.09,1.69,nan,nan,nan,nan,0,0.263,1.558
275.215,-33.3049,-0.144,0.243,-1.635,0.429,-1.195,0.39,18.05,1.35,16.38,15.63,15.36,0.19,27.42,0.57,nan,nan,nan,nan,0,6.507,5.765
287.9346,-30.6903,0.054,0.079,-2.403,0.143,-1.501,0.129,16.84,1.43,15.02,14.38,14.29,0.1,26.6,2.18,nan,nan,nan,nan,0,-3.598,1.146
298.3395,-35.8692,-0.05,0.043,-2.756,0.071,-1.563,0.05,15.47,1.43,13.67,13.01,12.94,0.1,25.57,1.7,nan,nan,nan,nan,0,-12.749,5.493
283.7987,-30.6775,-0.018,0.089,-2.742,0.137,-1.35,0.119,16.66,1.54,14.68,14.02,13.87,0.16,26.65,1.63,nan,nan,nan,nan,0,-0.081,1.684
284.4421,-31.0854,0.094,0.107,-2.686,0.144,-1.123,0.13,16.46,1.65,14.42,13.63,13.51,0.15,27.97,1.6,nan,nan,nan,nan,0,-0.695,1.993
284.592,-29.5492,0.089,0.186,-2.25,0.355,-1.242,0.326,18.0,1.33,16.38,15.71,15.6,0.18,28.0,0.62,nan,nan,nan,nan,0,-0.567,0.456
289.5994,-32.5972,0.054,0.046,-2.713,0.091,-1.453,0.076,14.99,1.9,12.66,11.68,11.46,0.11,26.77,1.09,nan,nan,nan,nan,0,-5.253,2.852
113.3672,19.5874,0.048,0.042,-1.968,0.078,-3.361,0.062,15.35,1.33,13.66,13.04,12.93,0.04,15.87,2.19,-25.72,5.26,-0.92,0.07,2,172.776,10.443
286.9847,-29.2821,-0.041,0.105,-2.978,0.129,-1.86,0.103,16.33,1.56,14.32,13.67,13.52,0.13,27.75,1.4,nan,nan,nan,nan,0,-2.584,-0.132
289.6584,-32.787,-0.007,0.246,-1.87,0.363,-1.288,0.311,18.05,1.33,16.36,15.68,15.59,0.1,27.02,1.19,nan,nan,nan,nan,0,-5.325,3.034
279.9718,-28.7691,0.026,0.082,-2.784,0.137,-0.886,0.121,16.55,1.58,14.47,13.72,13.53,0.21,25.89,2.14,nan,nan,nan,nan,0,3.542,0.435
27.8876,-3.2224,-0.026,0.069,-0.31,0.156,-2.141,0.103,16.46,1.34,14.82,14.2,14.03,0.03,23.85,4.69,nan,nan,nan,nan,0,-100.472,-0.136
258.4961,-19.453,-0.009,0.132,-2.149,0.196,-0.72,0.122,16.69,1.9,14.3,13.49,13.35,0.4,30.87,4.47,nan,nan,nan,nan,0,24.949,-2.881
305.2535,-31.3732,0.063,0.061,-3.005,0.089,-2.151,0.065,15.98,1.46,14.18,13.53,13.43,0.07,26.69,1.77,nan,nan,nan,nan,0,-18.439,0.905
277.7346,-24.4479,0.052,0.056,-2.051,0.077,-0.748,0.066,15.36,2.16,12.6,11.77,11.54,0.46,28.43,2.03,nan,nan,nan,nan,0,6.417,-3.361
281.7175,-29.2349,0.022,0.102,-2.811,0.155,-1.423,0.139,16.98,1.44,15.22,14.51,14.38,0.16,25.94,1.43,nan,nan,nan,nan,0,1.953,0.592
291.1879,-30.5599,0.009,0.065,-2.403,0.091,-1.655,0.081,15.92,1.65,13.85,13.08,13.0,0.07,28.4,1.29,nan,nan,nan,nan,0,-6.36,0.671
280.2443,-29.4103,0.047,0.071,-2.575,0.134,-1.118,0.13,15.9,1.9,13.53,12.69,12.53,0.17,26.73,0.61,144.2,1.18,nan,nan,6,3.179,1.015
305.1788,-35.5675,-0.08,0.048,-2.516,0.073,-1.739,0.046,14.76,2.17,12.22,11.3,11.09,0.07,25.72,1.03,nan,nan,nan,nan,0,-18.318,5.098
283.9429,-31.5566,0.086,0.063,-2.606,0.119,-1.536,0.094,15.83,1.49,13.94,13.25,13.16,0.13,27.67,0.56,nan,nan,nan,nan,0,-0.354,2.529
286.7809,-29.9687,0.055,0.057,-3.101,0.087,-1.827,0.08,15.88,1.43,14.07,13.45,13.33,0.13,26.96,0.85,nan,nan,nan,nan,0,-2.51,0.574
279.8165,-28.7201,-0.013,0.069,-2.621,0.11,-1.367,0.1,16.36,1.63,14.2,13.44,13.26,0.25,27.45,0.28,nan,nan,nan,nan,0,3.685,0.415
285.4135,-30.9416,0.067,0.105,-2.578,0.175,-1.228,0.152,16.98,1.31,15.32,14.67,14.56,0.14,26.42,1.06,nan,nan,nan,nan,0,-1.493,1.715
236.4421,-5.5137,-0.049,0.152,-0.89,0.296,-0.629,0.214,17.89,1.55,15.88,15.27,15.19,0.18,49.02,1.75,nan,nan,nan,nan,0,50.38,-6.477
296.6481,-31.8985,-0.024,0.094,-2.599,0.12,-1.586,0.079,16.34,1.7,14.23,13.4,13.2,0.18,26.74,2.25,nan,nan,nan,nan,0,-11.127,1.604
307.2878,-40.6921,0.02,0.041,-3.31,0.058,-1.779,0.043,15.31,1.47,13.49,12.76,12.7,0.04,23.73,5.56,nan,nan,nan,nan,0,-19.872,10.259
261.4527,-19.1812,-0.128,0.138,-1.552,0.238,-0.475,0.183,17.51,2.18,14.56,13.71,13.45,0.78,30.8,0.57,nan,nan,nan,nan,0,22.427,-4.115
212.3344,-0.0598,0.018,0.063,-1.267,0.152,-0.434,0.108,16.39,1.63,14.43,13.61,13.41,0.04,48.71,2.35,nan,nan,nan,nan,0,74.034,0.717
243.2152,-15.6015,-0.034,0.064,-1.459,0.132,-0.774,0.091,16.02,2.16,13.45,12.48,12.27,0.24,37.25,4.17,nan,nan,nan,nan,0,39.837,-0.532
293.7538,-32.6013,0.078,0.046,-2.624,0.085,-1.678,0.096,15.27,1.57,13.33,12.64,12.53,0.09,26.77,0.94,nan,nan,nan,nan,0,-8.737,2.488
284.0764,-31.3335,-0.25,0.169,-2.825,0.249,-1.43,0.214,17.62,1.29,15.99,15.39,15.29,0.15,28.32,1.58,nan,nan,nan,nan,0,-0.428,2.29
24.5861,-7.0953,-0.073,0.062,-0.371,0.113,-2.235,0.086,15.94,1.35,14.29,13.59,13.51,0.03,21.27,4.6,nan,nan,nan,nan,0,-95.682,1.558
277.4845,-30.9633,-0.098,0.068,-2.595,0.116,-1.391,0.105,14.46,3.13,11.97,11.09,10.65,0.2,27.61,1.9,nan,nan,nan,nan,0,5.181,3.04
211.1553,-2.7376,-0.027,0.064,-1.296,0.143,-0.511,0.1,16.56,1.72,14.47,13.63,13.39,0.06,51.22,7.12,nan,nan,nan,nan,0,73.69,3.623
185.2862,19.1533,-0.068,0.069,-1.416,0.105,-0.659,0.071,16.14,1.66,14.12,13.32,13.17,0.04,32.26,2.05,-40.45,0.98,-0.19,0.07,5,106.573,-3.162
284.3106,-31.2931,-0.106,0.103,-3.106,0.152,-1.324,0.126,16.45,1.62,14.36,13.65,13.47,0.15,27.21,0.18,nan,nan,nan,nan,0,-0.619,2.216
24.3959,-7.8006,0.078,0.122,-0.48,0.171,-2.265,0.107,16.74,1.33,15.0,14.35,14.23,0.02,24.65,2.23,nan,nan,nan,nan,0,-95.165,2.074
279.2608,-27.4543,-0.133,0.141,-2.793,0.232,-1.391,0.187,16.89,1.73,14.7,13.86,13.7,0.35,27.88,1.11,nan,nan,nan,nan,0,4.427,-0.722
283.7187,-30.0147,-0.102,0.077,-2.782,0.109,-1.186,0.092,15.16,1.83,12.84,12.02,11.82,0.15,27.43,0.61,nan,nan,nan,nan,0,0.101,1.044
213.5616,-2.405,0.064,0.181,-1.106,0.338,-0.562,0.29,17.74,1.37,16.04,15.42,15.32,0.06,50.51,2.14,nan,nan,nan,nan,0,71.786,2.116
356.5865,-20.2377,-0.053,0.088,-1.305,0.114,-2.738,0.137,16.47,1.2,14.95,14.38,14.29,0.02,22.2,2.54,nan,nan,nan,nan,0,-65.552,0.648
290.0773,-31.8225,-0.061,0.153,-2.279,0.279,-1.371,0.263,17.69,1.32,16.01,15.37,15.17,0.11,26.16,1.45,nan,nan,nan,nan,0,-5.561,2.034
282.0332,-30.3229,0.052,0.059,-2.601,0.101,-1.073,0.087,15.71,1.6,13.64,12.96,12.87,0.21,23.97,0.52,nan,nan,nan,nan,0,1.48,1.609
7.1521,-39.0985,-0.02,0.039,-1.776,0.052,-3.947,0.042,15.19,1.32,13.55,12.89,12.8,0.01,16.76,1.59,nan,nan,nan,nan,0,-65.394,21.587
297.3651,-35.409,-0.011,0.167,-2.697,0.225,-1.522,0.147,17.71,1.29,16.02,15.42,15.35,0.16,26.76,1.26,nan,nan,nan,nan,0,-11.931,5.074
287.7881,-34.7945,0.048,0.163,-3.265,0.213,-1.186,0.174,17.43,1.31,16.02,15.19,14.95,0.08,26.73,1.07,nan,nan,nan,nan,0,-4.044,5.228
280.989,-30.7128,-0.007,0.097,-2.614,0.214,-1.254,0.173,16.49,1.63,14.42,13.62,13.48,0.14,27.01,1.54,nan,nan,nan,nan,0,2.288,2.164
288.4763,-33.8409,0.013,0.084,-2.788,0.141,-1.027,0.126,16.57,1.5,14.68,13.95,13.89,0.07,26.16,0.66,nan,nan,nan,nan,0,-4.479,4.206
238.7827,-13.3299,-0.118,0.073,-0.991,0.149,-0.493,0.105,15.79,2.47,12.98,12.07,11.8,0.13,44.58,5.71,nan,nan,nan,nan,0,44.692,-0.627
288.0383,-31.4106,0.002,0.045,-2.491,0.065,-1.212,0.059,14.87,1.78,12.59,11.83,11.64,0.09,27.84,2.38,nan,nan,nan,nan,0,-3.785,1.848
289.4509,-32.229,0.014,0.037,-2.447,0.064,-1.275,0.062,15.14,1.89,12.83,11.99,11.81,0.1,26.6,0.47,nan,nan,nan,nan,0,-5.082,2.502
198.3632,14.0928,-0.201,0.16,-1.045,0.298,-0.446,0.199,17.69,1.19,16.31,15.62,15.55,0.02,37.61,4.55,nan,nan,nan,nan,0,93.111,-4.598
282.8957,-30.3735,0.087,0.116,-2.546,0.169,-0.995,0.151,17.26,1.48,15.41,14.68,14.48,0.14,27.16,0.86,nan,nan,nan,nan,0,0.738,1.522
277.092,-32.8446,0.045,0.143,-2.527,0.173,-1.484,0.159,16.97,1.41,15.24,14.63,14.51,0.19,27.03,0.76,nan,nan,nan,nan,0,5.08,4.948
283.3545,-31.3534,0.097,0.089,-2.638,0.139,-1.437,0.121,16.45,1.72,14.28,13.46,13.33,0.17,26.86,0.68,nan,nan,nan,nan,0,0.176,2.416
288.0314,-30.7134,0.067,0.102,-2.863,0.186,-1.548,0.151,16.84,1.51,14.98,14.24,14.07,0.1,26.6,1.38,nan,nan,nan,nan,0,-3.684,1.158
284.3168,-30.6113,0.027,0.076,-2.701,0.151,-1.245,0.111,15.93,1.84,13.63,12.84,12.61,0.16,29.1,1.93,154.45,0.04,nan,nan,1,-0.509,1.543
288.1407,-34.3002,-0.044,0.147,-3.094,0.215,-1.837,0.187,17.4,1.34,15.75,15.04,14.79,0.09,27.5,2.09,nan,nan,nan,nan,0,-4.265,4.698
287.9516,-34.2036,0.02,0.084,-2.654,0.152,-1.51,0.142,16.74,1.51,14.8,14.12,13.95,0.09,26.73,1.14,nan,nan,nan,nan,0,-4.096,4.624
283.1113,-30.8907,0.036,0.073,-2.58,0.101,-1.292,0.086,15.54,1.93,13.07,12.2,12.0,0.16,25.93,0.96,nan,nan,nan,nan,0,0.463,1.998
286.3669,-30.624,0.016,0.128,-2.602,0.249,-1.311,0.217,16.94,1.5,15.04,14.25,14.09,0.12,28.79,0.93,nan,nan,nan,nan,0,-2.254,1.275
220.6534,-10.3099,-0.055,0.057,-1.063,0.105,-0.757,0.094,16.0,1.76,13.82,13.0,12.89,0.1,51.55,2.08,nan,nan,nan,nan,0,61.685,5.358
287.8241,-34.3945,-0.023,0.096,-2.399,0.187,-1.498,0.157,16.96,1.37,15.27,14.51,14.43,0.08,26.73,3.31,nan,nan,nan,nan,0,-4.018,4.828
282.8862,-29.6183,-0.255,0.119,-2.644,0.188,-1.385,0.166,17.13,1.44,15.11,14.48,14.39,0.17,27.65,0.17,nan,nan,nan,nan,0,0.882,0.781
279.8561,-28.1296,0.005,0.045,-3.074,0.091,-1.222,0.078,15.17,2.28,12.42,11.55,11.29,0.21,28.96,2.07,nan,nan,nan,nan,0,3.772,-0.17
61.1767,27.6429,-0.024,0.055,0.214,0.098,-0.95,0.052,15.82,1.91,13.43,12.67,12.45,0.18,35.23,3.52,-178.47,5.07,-1.36,0.06,2,-143.892,-11.08
145.6104,31.9221,0.001,0.056,-2.095,0.074,-2.427,0.058,15.25,1.41,13.5,12.87,12.69,0.02,20.42,2.44,-87.22,4.22,-0.6,0.16,2,144.393,-3.236
221.9159,-15.1251,0.039,0.068,-1.209,0.111,-0.456,0.089,16.02,2.01,13.58,12.76,12.55,0.09,49.49,3.42,nan,nan,nan,nan,0,58.156,8.885
288.8535,-30.0064,0.042,0.143,-3.087,0.281,-1.876,0.267,17.68,1.18,16.14,15.28,14.88,0.11,28.23,2.15,nan,nan,nan,nan,0,-4.293,0.363
285.0682,-32.9934,-0.207,0.116,-2.666,0.181,-1.529,0.128,16.31,1.49,14.45,13.73,13.64,0.11,25.18,0.26,nan,nan,nan,nan,0,-1.533,3.788
196.4674,3.6079,-0.042,0.099,-1.275,0.222,-0.559,0.143,16.98,1.45,15.14,14.38,14.21,0.02,41.23,1.68,nan,nan,nan,nan,0,89.628,5.468
312.7028,-22.5163,-0.167,0.097,-2.854,0.15,-2.476,0.107,16.75,1.28,15.19,14.55,14.41,0.11,22.38,1.91,nan,nan,nan,nan,0,-25.503,-7.624
283.7744,-31.5458,0.064,0.09,-2.921,0.19,-1.505,0.148,16.54,1.49,14.6,13.91,13.8,0.14,27.68,0.64,nan,nan,nan,nan,0,-0.211,2.543
285.7681,-31.1169,0.008,0.079,-2.653,0.121,-1.254,0.106,16.43,1.54,14.53,13.84,13.64,0.13,28.16,1.28,nan,nan,nan,nan,0,-1.821,1.841
297.0561,-27.833,0.057,0.089,-2.71,0.132,-1.805,0.074,16.76,1.43,15.02,14.25,14.2,0.12,25.87,1.69,nan,nan,nan,nan,0,-11.236,-2.475
39.8152,-2.3558,-0.084,0.048,-0.207,0.103,-2.105,0.089,15.55,1.47,13.7,13.03,12.93,0.03,29.42,3.16,nan,nan,nan,nan,0,-111.194,5.157
283.0751,-30.0902,0.099,0.214,-2.19,0.274,-0.958,0.253,17.93,1.33,16.42,15.8,15.72,0.15,27.25,1.07,nan,nan,nan,nan,0,0.637,1.216
286.3686,-30.0124,-0.018,0.07,-2.711,0.091,-1.336,0.075,15.33,1.81,13.09,12.24,12.07,0.12,26.41,0.71,nan,nan,nan,nan,0,-2.163,0.67
282.5928,-30.42,0.035,0.068,-2.71,0.131,-1.022,0.121,16.39,1.42,14.57,13.91,13.77,0.16,26.91,1.84,nan,nan,nan,nan,0,0.987,1.615
231.0966,-13.6352,-0.172,0.161,-1.248,0.283,-0.301,0.185,17.59,1.53,15.67,14.92,14.74,0.13,48.46,0.85,nan,nan,nan,nan,0,51.138,3.173
165.0115,23.0052,-0.069,0.148,-2.158,0.236,-1.23,0.366,16.34,1.26,14.74,14.18,14.12,0.02,25.32,2.13,nan,nan,nan,nan,0,125.463,0.778
287.0215,-32.0769,0.02,0.058,-2.371,0.099,-1.173,0.096,15.07,2.45,12.28,11.37,11.13,0.1,26.0,0.6,148.84,1.59,nan,nan,6,-3.022,2.629
288.0639,-31.6487,0.031,0.051,-2.637,0.093,-1.358,0.079,15.91,1.61,13.93,13.16,13.03,0.09,26.9,2.81,137.7,nan,nan,nan,4,-3.839,2.08
288.2492,-29.9801,-0.038,0.1,-2.545,0.142,-1.183,0.131,16.82,1.53,14.89,14.19,13.97,0.13,27.01,1.74,nan,nan,nan,nan,0,-3.77,0.406
290.6788,-33.8369,0.095,0.203,-2.293,0.321,-1.267,0.299,18.05,1.3,16.37,15.45,15.24,0.12,27.97,1.5,nan,nan,nan,nan,0,-6.298,3.976
312.1269,-32.5763,-0.287,0.105,-2.196,0.154,-2.093,0.125,16.98,1.37,15.26,14.56,14.5,0.07,22.81,2.54,nan,nan,nan,nan,0,-24.212,2.366
282.9908,-30.6015,0.054,0.07,-2.676,0.13,-1.424,0.115,16.47,1.42,14.6,13.98,13.9,0.14,27.55,2.68,nan,nan,nan,nan,0,0.617,1.732
213.5494,-3.1742,-0.129,0.155,-0.821,0.266,-0.727,0.184,17.81,1.42,15.9,15.22,15.13,0.06,51.95,2.14,nan,nan,nan,nan,0,71.405,2.785
282.9481,-30.2292,0.042,0.069,-2.798,0.091,-1.242,0.081,15.65,2.06,13.22,12.34,12.13,0.16,28.14,0.73,nan,nan,nan,nan,0,0.72,1.372
282.386,-31.4284,-0.065,0.095,-2.717,0.17,-1.249,0.16,16.89,1.6,14.97,14.16,13.95,0.18,25.94,1.28,nan,nan,nan,nan,0,0.977,2.639
289.409,-34.6548,-0.039,0.085,-2.915,0.125,-1.515,0.119,16.45,1.46,14.59,13.97,13.85,0.09,26.07,0.69,125.9,nan,nan,nan,4,-5.351,4.913
228.5529,-2.5886,0.028,0.062,-0.851,0.111,-0.52,0.093,16.05,2.06,13.66,12.77,12.53,0.14,52.88,0.54,nan,nan,nan,nan,0,58.727,-5.245
285.8907,-31.091,-0.03,0.052,-2.518,0.079,-1.402,0.068,14.99,2.07,12.48,11.6,11.37,0.12,27.15,0.79,125.38,0.98,nan,nan,6,-1.921,1.799
284.8409,-29.0196,0.071,0.09,-2.723,0.116,-1.531,0.105,16.23,1.44,14.39,13.75,13.58,0.17,27.38,2.02,nan,nan,nan,nan,0,-0.694,-0.102
329.0874,-21.773,0.036,0.058,-1.927,0.075,-2.545,0.077,14.92,1.5,13.06,12.35,12.2,0.03,22.42,3.47,nan,nan,nan,nan,0,-40.719,-6.066
283.3441,-28.6184,-0.004,0.078,-2.846,0.136,-1.568,0.119,16.55,1.54,14.51,13.87,13.77,0.18,27.88,0.73,nan,nan,nan,nan,0,0.666,-0.274
298.2128,-34.1522,-0.073,0.125,-2.178,0.202,-1.863,0.157,17.65,1.34,16.14,15.36,15.19,0.16,27.28,2.79,nan,nan,nan,nan,0,-12.563,3.782
283.6208,-30.4611,-0.087,0.122,-2.446,0.169,-1.385,0.153,17.12,1.5,15.24,14.49,14.42,0.16,26.98,1.12,nan,nan,nan,nan,0,0.107,1.498
287.0032,-29.3888,-0.119,0.115,-2.703,0.184,-1.347,0.173,17.36,1.38,15.56,14.94,14.85,0.12,26.81,0.58,nan,nan,nan,nan,0,-2.616,-0.028
277.0653,-26.6167,-0.337,0.099,-2.782,0.16,-1.496,0.146,16.57,1.74,14.08,13.3,13.14,0.33,25.9,1.63,nan,nan,nan,nan,0,6.519,-1.112
285.9069,-28.5622,-0.528,0.175,-2.416,0.26,-1.622,0.256,17.94,1.32,16.21,15.62,15.54,0.19,27.8,1.54,nan,nan,nan,nan,0,-1.544,-0.702
168.9016,7.8052,-0.046,0.221,-1.621,0.311,-0.917,0.328,17.77,1.17,16.39,15.7,15.52,0.04,31.64,4.74,nan,nan,nan,nan,0,116.527,13.692
234.9018,-7.0738,-0.024,0.095,-1.123,0.187,-0.658,0.149,16.94,2.25,14.09,13.15,12.89,0.42,48.12,4.17,nan,nan,nan,nan,0,50.995,-4.378
286.2748,-32.543,0.035,0.053,-2.779,0.083,-1.304,0.078,14.81,2.28,12.15,11.25,10.97,0.09,27.77,0.76,nan,nan,nan,nan,0,-2.466,3.184
215.6267,-4.9588,-0.015,0.053,-1.162,0.114,-0.565,0.087,16.0,1.88,13.77,12.92,12.78,0.05,49.58,4.24,66.98,0.02,-1.12,0.02,1,68.71,3.27
279.6857,-30.7725,-0.049,0.113,-2.971,0.198,-1.162,0.18,16.8,1.49,14.65,14.03,13.95,0.17,27.03,2.51,nan,nan,nan,nan,0,3.375,2.447
285.9143,-30.7075,-0.029,0.055,-2.731,0.1,-1.196,0.095,16.05,1.6,14.03,13.31,13.18,0.14,28.05,1.41,nan,nan,nan,nan,0,-1.882,1.417
279.2814,-28.2153,0.064,0.067,-2.893,0.106,-1.358,0.091,15.13,2.88,12.01,11.04,10.69,0.26,27.46,1.74,nan,nan,nan,nan,0,4.25,0.019
290.8579,-33.0795,0.066,0.075,-2.489,0.109,-1.524,0.098,16.21,1.48,14.31,13.71,13.58,0.1,26.68,2.73,nan,nan,nan,nan,0,-6.361,3.206
280.8648,-29.1115,0.018,0.047,-2.837,0.088,-1.481,0.076,15.14,1.75,13.03,12.27,12.1,0.22,26.79,1.32,nan,nan,nan,nan,0,2.708,0.614
240.033,-15.3917,-0.166,0.084,-1.175,0.202,-0.495,0.12,16.59,1.97,14.17,13.28,13.07,0.24,43.3,4.72,nan,nan,nan,nan,0,42.672,0.654
305.5366,-34.0268,0.042,0.063,-2.717,0.12,-1.548,0.072,15.99,1.49,14.07,13.45,13.37,0.07,26.06,4.93,nan,nan,nan,nan,0,-18.636,3.562
281.6841,-30.3229,0.036,0.038,-2.678,0.074,-1.304,0.069,15.44,1.77,13.24,12.39,12.24,0.18,28.61,1.49,139.6,0.03,-0.25,0.01,1,1.776,1.666
171.6863,16.7295,-0.139,0.106,-1.399,0.222,-1.374,0.317,16.31,1.3,14.71,14.13,14.03,0.03,28.61,4.31,-15.54,5.47,-1.37,0.17,2,117.352,4.399
285.6992,-34.0406,0.044,0.213,-1.882,0.28,-0.759,0.259,17.97,1.26,16.51,15.7,15.62,0.11,27.24,1.49,nan,nan,nan,nan,0,-2.221,4.737
289.3072,-31.0223,0.019,0.082,-2.331,0.14,-1.23,0.129,16.36,1.4,14.58,13.93,13.78,0.1,28.22,0.67,nan,nan,nan,nan,0,-4.81,1.32
292.1201,-32.7254,0.051,0.048,-2.775,0.076,-1.311,0.07,15.65,1.64,13.64,12.85,12.71,0.1,27.18,1.26,nan,nan,nan,nan,0,-7.378,2.741
275.66,-28.5072,0.008,0.06,-2.239,0.115,-1.256,0.101,15.62,2.42,12.61,11.64,11.32,0.43,26.09,2.15,nan,nan,nan,nan,0,7.291,1.016
221.2277,-10.1361,-0.156,0.097,-1.249,0.171,-0.768,0.162,17.04,1.46,15.21,14.54,14.32,0.1,50.64,1.34,nan,nan,nan,nan,0,61.283,4.922
245.3885,-16.4892,-0.228,0.19,-0.937,0.289,-0.61,0.208,17.25,1.69,15.2,14.37,14.09,0.31,36.97,4.58,nan,nan,nan,nan,0,37.57,-0.644
279.9959,-29.2067,0.095,0.04,-2.728,0.069,-0.738,0.062,14.66,2.09,12.14,11.34,11.1,0.19,27.32,0.61,nan,nan,nan,nan,0,3.432,0.859
280.7377,-28.8643,0.049,0.041,-2.876,0.085,-1.318,0.072,15.16,1.87,12.79,11.97,11.78,0.16,28.49,3.64,165.79,1.96,nan,nan,6,2.866,0.394
289.5728,-30.4107,-0.049,0.037,-2.212,0.069,-1.166,0.061,15.24,2.04,12.79,11.92,11.72,0.13,28.3,0.43,nan,nan,nan,nan,0,-4.96,0.685
303.7196,-31.3326,0.048,0.063,-2.897,0.097,-2.049,0.069,15.86,1.55,13.91,13.24,13.03,0.11,24.39,3.95,nan,nan,nan,nan,0,-17.129,0.855
280.2356,-28.7776,0.006,0.055,-2.577,0.111,-1.233,0.095,15.36,1.76,13.14,12.35,12.24,0.19,25.61,1.6,nan,nan,nan,nan,0,3.314,0.397
283.7381,-30.5704,-0.018,0.037,-2.743,0.064,-1.417,0.059,14.82,1.77,12.62,11.88,11.75,0.15,26.33,0.29,141.81,nan,nan,nan,4,-0.011,1.588
282.5931,-31.7263,-0.105,0.062,-2.528,0.115,-0.925,0.104,16.47,1.44,14.63,13.98,13.91,0.16,27.32,0.64,nan,nan,nan,nan,0,0.748,2.9
287.0828,-31.687,-0.018,0.063,-2.477,0.109,-1.349,0.097,16.16,1.59,14.15,13.4,13.26,0.09,26.92,1.52,nan,nan,nan,nan,0,-3.017,2.236
283.3008,-30.22,-0.318,0.214,-2.451,0.323,-0.815,0.279,17.98,1.28,15.82,15.22,15.13,0.17,26.88,1.48,nan,nan,nan,nan,0,0.421,1.309
358.5704,-11.5253,-0.048,0.061,-1.128,0.082,-2.501,0.077,15.01,1.5,13.16,12.36,12.3,0.03,21.03,1.47,nan,nan,nan,nan,0,-70.88,-6.512
289.417,-30.116,-0.202,0.128,-2.568,0.275,-1.051,0.236,17.09,1.41,15.43,14.81,14.68,0.11,28.3,1.16,nan,nan,nan,nan,0,-4.79,0.409
337.4149,-28.8691,0.008,0.143,-2.04,0.241,-2.883,0.199,17.41,1.17,16.09,15.36,15.32,0.02,21.28,4.42,nan,nan,nan,nan,0,-46.23,2.686
277.9013,-31.9716,0.036,0.069,-2.514,0.093,-1.122,0.082,15.65,1.78,13.44,12.59,12.41,0.17,27.31,2.18,nan,nan,nan,nan,0,4.609,3.944
285.233,-31.6348,-0.045,0.061,-2.724,0.109,-1.543,0.101,15.87,1.63,13.89,13.08,12.96,0.12,26.24,0.89,nan,nan,nan,nan,0,-1.452,2.424
277.0241,-25.8272,-0.058,0.095,-2.743,0.142,-1.294,0.129,15.87,2.16,13.02,12.15,11.9,0.38,27.06,2.03,nan,nan,nan,nan,0,6.734,-1.873
279.388,-32.6411,0.024,0.056,-2.846,0.102,-1.575,0.091,16.11,1.5,14.17,13.45,13.29,0.12,26.52,1.18,nan,nan,nan,nan,0,3.234,4.328
284.4497,-30.0031,-0.116,0.087,-2.452,0.131,-1.242,0.112,16.56,1.53,14.61,13.95,13.82,0.14,28.48,2.05,nan,nan,nan,nan,0,-0.521,0.925
31.9132,-10.2751,0.068,0.07,-0.287,0.095,-2.324,0.07,15.08,1.5,13.24,12.53,12.41,0.02,25.99,0.59,nan,nan,nan,nan,0,-100.333,7.968
282.5732,-30.2469,-0.093,0.137,-2.312,0.28,-1.141,0.258,17.83,1.29,16.35,15.56,15.25,0.17,26.91,0.6,nan,nan,nan,nan,0,1.035,1.448
231.8021,-8.0636,-0.04,0.151,-1.203,0.255,-0.324,0.209,17.6,1.46,15.82,15.12,15.04,0.1,46.18,3.68,nan,nan,nan,nan,0,53.224,-2.04
260.1489,-27.0048,0.086,0.114,-1.947,0.246,-1.058,0.176,17.44,2.91,13.84,12.88,12.5,1.37,32.97,3.29,nan,nan,nan,nan,0,20.85,3.641
286.5484,-31.6938,-0.047,0.056,-2.54,0.09,-1.343,0.089,15.27,2.19,12.72,11.85,11.58,0.11,27.74,3.6,122.87,2.17,nan,nan,6,-2.568,2.309
135.3405,20.6368,-0.048,0.057,-2.139,0.088,-2.561,0.065,15.83,1.18,14.32,13.78,13.71,0.03,17.77,1.8,nan,nan,nan,nan,0,151.853,9.269
282.8897,-29.3956,0.001,0.068,-2.777,0.147,-1.658,0.114,14.65,2.64,11.75,10.83,10.51,0.16,27.56,1.39,144.07,1.02,nan,nan,6,0.919,0.561
298.3108,-34.6097,-0.012,0.054,-2.468,0.078,-1.648,0.048,15.57,2.32,12.9,11.99,11.72,0.14,27.44,1.39,nan,nan,nan,nan,0,-12.665,4.236
287.394,-30.3652,0.011,0.179,-2.594,0.282,-1.224,0.261,17.92,1.24,16.51,15.54,15.29,0.12,28.08,0.55,nan,nan,nan,nan,0,-3.091,0.889
283.3003,-30.7114,-0.031,0.055,-2.794,0.083,-1.637,0.071,14.94,2.08,12.38,11.52,11.37,0.14,25.44,0.64,146.84,0.01,-0.63,0.02,1,0.335,1.793
284.1065,-30.6134,0.062,0.065,-2.91,0.087,-1.361,0.081,15.59,1.82,13.25,12.45,12.26,0.16,26.66,0.65,143.81,0.03,-0.54,0.02,1,-0.331,1.576
282.4478,-32.0595,0.08,0.067,-2.64,0.119,-1.322,0.1,16.3,1.59,14.3,13.57,13.38,0.14,26.09,0.81,nan,nan,nan,nan,0,0.809,3.25
294.7225,-32.8028,-0.131,0.151,-2.615,0.207,-1.886,0.192,17.27,1.49,15.45,14.73,14.65,0.18,26.02,0.76,nan,nan,nan,nan,0,-9.567,2.621
284.8983,-31.0585,-0.181,0.204,-2.208,0.371,-1.809,0.33,18.14,1.3,16.61,15.84,15.6,0.13,26.49,2.0,nan,nan,nan,nan,0,-1.076,1.902
238.9511,-17.9681,0.033,0.158,-1.113,0.313,-0.529,0.185,17.83,1.52,15.89,15.13,15.03,0.27,45.01,2.71,nan,nan,nan,nan,0,42.417,3.419
282.8621,-29.9158,-0.193,0.088,-2.559,0.172,-1.483,0.155,16.39,1.58,14.4,13.63,13.51,0.17,26.28,0.82,nan,nan,nan,nan,0,0.849,1.077
319.8843,-30.3356,0.014,0.052,-2.911,0.073,-2.927,0.06,14.72,1.68,12.61,11.87,11.71,0.1,26.46,4.45,nan,nan,nan,nan,0,-31.034,0.858
286.7705,-31.1873,0.04,0.044,-2.566,0.076,-1.199,0.071,15.36,1.78,13.11,12.28,12.12,0.1,27.55,1.7,154.92,1.86,nan,nan,6,-2.68,1.78
305.6515,-29.709,-0.461,0.21,-2.318,0.331,-2.319,0.229,18.16,1.18,16.52,15.89,15.81,0.08,23.88,4.91,nan,nan,nan,nan,0,-18.808,-0.754
283.4837,-32.6697,0.065,0.17,-2.932,0.33,-1.534,0.352,17.9,1.16,16.41,15.71,15.57,0.11,26.77,0.49,nan,nan,nan,nan,0,-0.163,3.693
284.8411,-31.7051,0.075,0.043,-2.936,0.067,-1.488,0.056,14.7,2.11,12.2,11.3,11.06,0.12,27.9,0.87,nan,nan,nan,nan,0,-1.134,2.548
284.0883,-28.7003,0.005,0.061,-2.464,0.126,-1.597,0.113,16.01,1.83,13.75,12.97,12.71,0.18,28.88,2.74,nan,nan,nan,nan,0,0.009,-0.307
225.4097,-7.3517,-0.121,0.09,-0.854,0.18,-0.55,0.142,16.79,1.73,14.65,13.9,13.7,0.09,51.05,4.22,nan,nan,nan,nan,0,59.096,0.443
285.4773,-30.7016,0.073,0.068,-2.665,0.087,-1.308,0.075,15.6,1.87,13.3,12.45,12.27,0.15,25.91,0.67,nan,nan,nan,nan,0,-1.509,1.47
289.5804,-30.8686,-0.135,0.082,-2.476,0.122,-1.624,0.122,16.56,1.48,14.64,13.97,13.9,0.11,26.47,0.42,nan,nan,nan,nan,0,-5.023,1.139
283.7756,-30.3652,-0.162,0.076,-2.905,0.145,-1.664,0.131,16.74,1.5,14.78,14.11,13.97,0.15,27.21,1.31,nan,nan,nan,nan,0,-0.008,1.38
283.2443,-29.5904,-0.053,0.06,-2.64,0.119,-1.32,0.103,16.32,1.77,14.12,13.34,13.16,0.17,27.52,1.77,nan,nan,nan,nan,0,0.581,0.698
237.9703,-12.1649,0.084,0.112,-1.409,0.241,-0.69,0.15,17.41,1.65,15.32,14.54,14.42,0.2,44.79,1.49,nan,nan,nan,nan,0,45.932,-1.296
276.7243,-29.058,-0.013,0.133,-2.512,0.191,-0.817,0.175,16.91,1.9,14.62,13.78,13.63,0.38,28.01,1.83,nan,nan,nan,nan,0,6.255,1.333
288.2449,-32.4059,0.04,0.039,-2.539,0.064,-1.268,0.06,15.33,1.66,13.24,12.53,12.33,0.11,27.59,0.41,nan,nan,nan,nan,0,-4.094,2.81
285.7819,-33.1427,0.02,0.035,-2.87,0.074,-1.367,0.066,14.99,2.22,12.37,11.5,11.27,0.08,26.54,1.0,166.97,1.16,nan,nan,6,-2.149,3.84
291.5706,-29.7881,-0.068,0.038,-2.392,0.071,-1.557,0.064,15.04,2.02,12.61,11.74,11.54,0.11,26.53,0.61,nan,nan,nan,nan,0,-6.606,-0.132
286.4367,-32.0135,0.088,0.109,-2.955,0.2,-1.463,0.169,17.06,1.41,15.22,14.57,14.48,0.11,26.83,0.99,nan,nan,nan,nan,0,-2.522,2.64
174.4211,14.298,-0.054,0.067,-1.756,0.094,-1.138,0.082,15.53,1.52,13.63,12.94,12.77,0.03,33.06,1.27,-48.83,0.68,-1.19,0.03,5,113.969,5.622
283.2611,-29.0559,0.014,0.102,-2.428,0.147,-1.347,0.134,16.31,1.61,14.3,13.54,13.45,0.18,26.31,0.32,nan,nan,nan,nan,0,0.661,0.169
283.0842,-30.504,-0.058,0.051,-2.626,0.093,-1.315,0.082,15.91,1.52,13.94,13.32,13.2,0.16,27.53,1.29,nan,nan,nan,nan,0,0.555,1.621
196.2366,2.0362,-0.162,0.071,-1.188,0.125,-0.464,0.071,15.32,1.92,13.05,12.2,12.02,0.02,41.23,7.14,nan,nan,nan,nan,0,89.06,6.952
154.0525,23.1375,-0.141,0.156,-2.226,0.232,-1.558,0.261,17.51,1.05,16.15,15.57,15.51,0.03,22.11,0.43,nan,nan,nan,nan,0,135.135,3.648
350.4236,-20.4946,0.067,0.038,-1.236,0.07,-2.331,0.052,14.99,1.58,13.07,12.31,12.18,0.03,19.07,5.16,nan,nan,nan,nan,0,-60.127,-1.354
6.1006,-19.6589,0.078,0.046,-1.686,0.074,-3.852,0.056,15.32,1.37,13.6,12.94,12.79,0.02,25.37,1.53,nan,nan,nan,nan,0,-73.887,3.959
284.4984,-30.5236,0.054,0.046,-2.729,0.091,-1.785,0.078,15.72,1.66,13.65,12.88,12.72,0.14,29.1,3.27,132.44,nan,nan,nan,4,-0.649,1.431
288.6425,-26.4886,-0.287,0.222,-2.415,0.355,-1.685,0.326,18.0,1.28,16.44,15.69,15.45,0.12,26.59,1.08,nan,nan,nan,nan,0,-3.649,-3.101
234.4521,-14.1324,0.045,0.08,-1.048,0.169,-0.489,0.11,16.13,2.44,13.3,12.38,12.12,0.15,46.58,3.33,nan,nan,nan,nan,0,48.038,2.047
293.5006,-33.2313,-0.023,0.116,-2.488,0.173,-1.61,0.148,17.03,1.46,15.2,14.5,14.38,0.12,27.96,1.96,nan,nan,nan,nan,0,-8.581,3.134
286.6332,-28.886,0.018,0.072,-2.911,0.111,-1.532,0.092,16.23,1.61,14.17,13.36,13.23,0.17,26.97,0.45,nan,nan,nan,nan,0,-2.222,-0.478
282.1828,-29.3817,-0.105,0.179,-2.617,0.26,-1.645,0.239,17.77,1.39,16.01,15.26,15.12,0.15,27.39,0.65,nan,nan,nan,nan,0,1.527,0.66
</file>

<file path="gala/coordinates/__init__.py">
from .sgr import *
from .orphan import *
from .gd1 import *
from .oph import *
from .pal5 import *
from .pal13 import *
from .jhelum import *
from .velocity_frame_transforms import *
from .poincarepolar import *
from .magellanic_stream import *
from .reflex import *
from .greatcircle import *
from .pm_cov_transform import *
</file>

<file path="gala/coordinates/gd1.py">
""" Astropy coordinate class for the Sagittarius coordinate system """

# Third-party
import numpy as np

import astropy.units as u
import astropy.coordinates as coord
from astropy.coordinates import frame_transform_graph

__all__ = ["GD1Koposov10"]


class GD1Koposov10(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit of the GD1 stream,
    as described in Koposov et al. 2010 (see: `<http://arxiv.org/abs/0907.1085>`_).

    For more information about this class, see the Astropy documentation on coordinate
    frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)
    phi1 : angle_like, optional, must be keyword
        The longitude-like angle corresponding to GD-1's orbit.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle corresponding to GD-1's orbit.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.
    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the GD-1 stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        GD-1 stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ],
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Rotation matrix as defined in the Appendix of Koposov et al. (2010)
R = np.array(
    [
        [-0.4776303088, -0.1738432154, 0.8611897727],
        [0.510844589, -0.8524449229, 0.111245042],
        [0.7147776536, 0.4930681392, 0.4959603976],
    ]
)


@frame_transform_graph.transform(coord.StaticMatrixTransform, coord.ICRS, GD1Koposov10)
def icrs_to_gd1():
    """
    Compute the transformation from Galactic spherical to heliocentric GD1 coordinates.
    """
    return R


@frame_transform_graph.transform(coord.StaticMatrixTransform, GD1Koposov10, coord.ICRS)
def gd1_to_icrs():
    """
    Compute the transformation from heliocentric GD1 coordinates to spherical Galactic.
    """
    return icrs_to_gd1().T
</file>

<file path="gala/coordinates/greatcircle.py">
# Built-in
from textwrap import dedent
from warnings import warn

import astropy.coordinates as coord

# Third-party
import astropy.units as u
import numpy as np
from astropy.coordinates.attributes import CoordinateAttribute
from astropy.coordinates.baseframe import base_doc
from astropy.coordinates.transformations import (
    DynamicMatrixTransform,
    FunctionTransform,
)
from astropy.utils.decorators import format_doc

from .helpers import StringValidatedAttribute

__all__ = ["GreatCircleICRSFrame", "make_greatcircle_cls", "pole_from_endpoints"]


def get_xhat(zhat, ra0, tol=1e-10):
    """
    Helper to get the x-hat vector along a great circle defined by the input zhat that
    intersects with the specified longitude (ra0).
    """
    ra0 = 90 * u.deg - ra0

    z1, z2, z3 = zhat

    if np.isclose(z3, 0, atol=tol):  # pole in x-y - can't satisfy ra0
        raise ValueError(
            "Pole is in the x-y plane, so can't satisfy the ra0 requirement"
        )

    denom = (
        z2**2 + z3**2 + 2 * z1 * z2 * np.tan(ra0) + (z1**2 + z3**2) * np.tan(ra0) ** 2
    )
    x1 = -np.tan(ra0) * np.sqrt(z3**2 / denom)
    x2 = x1 / np.tan(ra0)

    if np.isclose(z3, 1, atol=tol):
        x3 = 0.0
    else:
        x3 = (z2 + z1 * np.tan(ra0)) * np.abs(x2) / z3

    return np.array([x1, x2, x3])


def get_origin_from_pole_ra0(pole, ra0, origin_disambiguate=None):
    """
    Figure out the coordinate system origin (i.e. the x-axis, expressed in the old
    coordinate frame). Given just a pole and ra0, there is an ambiguity to the direction
    of the x-axis because the two great circles (defined by pole and ra0) intersect at
    two points. To resolve this ambiguity, you can specify ``origin_disambiguate``,
    which is a coordinate in the old system (ICRS) used to pick the x-axis closest to
    that location. If this is not specified, it uses (RA, Dec)=(0, 0).
    """

    if origin_disambiguate is None:
        origin_disambiguate = coord.SkyCoord(0, 0, unit=u.deg, frame=pole)

    # figure out origin from ra0
    zhat = np.squeeze((pole.cartesian / pole.cartesian.norm()).xyz)
    xhat1 = coord.CartesianRepresentation(get_xhat(zhat, ra0))
    xhat2 = -xhat1

    origin1 = coord.SkyCoord(xhat1, frame=pole, representation_type="unitspherical")
    origin2 = coord.SkyCoord(xhat2, frame=pole, representation_type="unitspherical")

    sep1 = origin_disambiguate.separation(origin1).to_value(u.deg)
    sep2 = origin_disambiguate.separation(origin2).to_value(u.deg)

    # Convention:
    if sep1 <= sep2:
        return origin1
    else:
        return origin2


def pole_from_endpoints(coord1, coord2):
    """Compute the pole from a great circle that connects the two specified
    coordinates.

    This assumes a right-handed rule from coord1 to coord2: the pole is the
    north pole under that assumption.

    Parameters
    ----------
    coord1 : `~astropy.coordinates.SkyCoord`
        Coordinate of one point on a great circle.
    coord2 : `~astropy.coordinates.SkyCoord`
        Coordinate of the other point on a great circle.

    Returns
    -------
    pole : `~astropy.coordinates.SkyCoord`
        The coordinates of the pole.
    """
    cart1 = coord1.cartesian.without_differentials()
    cart2 = coord2.cartesian.without_differentials()
    if isinstance(coord1, coord.SkyCoord):
        frame1 = coord1.frame
    elif isinstance(coord1, coord.BaseCoordinateFrame):
        frame1 = coord1
    else:
        raise TypeError(
            "Input coordinate must be a SkyCoord or coordinate frame instance."
        )

    c1 = cart1 / cart1.norm()

    coord2 = coord2.transform_to(frame1)
    c2 = cart2 / cart2.norm()

    pole = c1.cross(c2)
    pole = pole / pole.norm()
    return frame1.realize_frame(pole)


def sph_midpoint(coord1, coord2):
    """Compute the midpoint between two points on the sphere.

    Parameters
    ----------
    coord1 : `~astropy.coordinates.SkyCoord`
        Coordinate of one point on a great circle.
    coord2 : `~astropy.coordinates.SkyCoord`
        Coordinate of the other point on a great circle.

    Returns
    -------
    midpt : `~astropy.coordinates.SkyCoord`
        The coordinates of the spherical midpoint.
    """
    cart1 = coord1.cartesian.without_differentials()
    cart2 = coord2.cartesian.without_differentials()
    if isinstance(coord1, coord.SkyCoord):
        frame1 = coord1.frame
    elif isinstance(coord1, coord.BaseCoordinateFrame):
        frame1 = coord1
    else:
        raise TypeError(
            "Input coordinate must be a SkyCoord or coordinate frame instance."
        )

    c1 = cart1 / cart1.norm()

    coord2 = coord2.transform_to(frame1)
    c2 = cart2 / cart2.norm()

    midpt = 0.5 * (c1 + c2)
    usph = midpt.represent_as(coord.UnitSphericalRepresentation)

    return frame1.realize_frame(usph)


def ensure_orthogonal(pole, origin, priority="origin", tol=1e-10):
    """
    Makes sure the pole and origin are unit vectors, and are orthogonal. Adjusts either
    the pole or origin to make orthogonal if not.

    Parameters
    ----------
    x : array_like
        Must be a unit vector.
    z : array_like
        Must be a unit vector.

    """

    origin = origin.realize_frame(
        origin.represent_as("unitspherical").without_differentials()
    ).squeeze()
    pole = pole.realize_frame(
        pole.represent_as("unitspherical").without_differentials()
    ).squeeze()

    x = np.squeeze(origin.cartesian.xyz)
    z = np.squeeze(pole.cartesian.xyz)
    if np.abs(np.dot(x, z)) > tol:
        if priority == "origin":
            msg = "Keeping the origin fixed and adjusting the pole to be orthogonal."
            z = z - (z @ x) * x
            pole = pole.realize_frame(
                coord.CartesianRepresentation(z), representation_type="unitspherical"
            )

        else:  # validated by class attribute, so assume "pole"
            msg = "Keeping the pole fixed and adjusting the origin to be orthogonal."
            x = x - (x @ z) * z
            origin = origin.realize_frame(
                coord.CartesianRepresentation(x), representation_type="unitspherical"
            )

        warn(
            f"Input origin and pole are not orthogonal. {msg} Use "
            "warnings.simplefilter('ignore') to ignore this warning.",
            RuntimeWarning,
        )

    return pole, origin


def pole_origin_to_R(pole, origin):
    """
    Compute the Cartesian rotation matrix from the given pole and origin.

    This functiona assumes that ``pole`` and ``origin`` are orthogonal.
    """
    if not pole.is_equivalent_frame(origin):
        raise ValueError("The coordinate frame of the input pole and origin must match")

    xaxis = np.squeeze((origin.cartesian / origin.cartesian.norm()).xyz)
    zaxis = np.squeeze((pole.cartesian / pole.cartesian.norm()).xyz)
    yaxis = np.cross(zaxis, xaxis)

    R = np.stack((xaxis, yaxis, zaxis))
    return R


def greatcircle_to_greatcircle(from_greatcircle_coord, to_greatcircle_frame):
    """Transform between two greatcircle frames."""

    # This transform goes through the parent frames on each side.
    # from_frame -> from_frame.origin -> to_frame.origin -> to_frame
    intermediate_from = from_greatcircle_coord.transform_to(from_greatcircle_coord.pole)
    intermediate_to = intermediate_from.transform_to(to_greatcircle_frame.pole)
    return intermediate_to.transform_to(to_greatcircle_frame)


def reference_to_greatcircle(reference_frame, greatcircle_frame):
    """Convert a reference coordinate to a great circle frame."""
    return greatcircle_frame._R


def greatcircle_to_reference(greatcircle_coord, reference_frame):
    """Convert a great circle frame coordinate to the reference frame"""

    # use the forward transform, but just invert it
    R = reference_to_greatcircle(reference_frame, greatcircle_coord)
    # transpose is the inverse because R is a rotation matrix
    return R.T


def greatcircle_transforms(self_transform=False):
    def set_greatcircle_transforms(cls):
        DynamicMatrixTransform(
            reference_to_greatcircle,
            coord.ICRS,
            cls,
            register_graph=coord.frame_transform_graph,
        )

        DynamicMatrixTransform(
            greatcircle_to_reference,
            cls,
            coord.ICRS,
            register_graph=coord.frame_transform_graph,
        )

        if self_transform:
            FunctionTransform(
                greatcircle_to_greatcircle,
                cls,
                cls,
                register_graph=coord.frame_transform_graph,
            )
        return cls

    return set_greatcircle_transforms


_components = """
    phi1 : `~astropy.units.Quantity`
        Longitude component.
    phi2 : `~astropy.units.Quantity`
        Latitude component.
    distance : `~astropy.units.Quantity`
        Distance.

    pm_phi1_cosphi2 : `~astropy.units.Quantity`
        Proper motion in longitude.
    pm_phi2 : `~astropy.units.Quantity`
        Proper motion in latitude.
    radial_velocity : `~astropy.units.Quantity`
        Line-of-sight or radial velocity.
"""

_footer = """
    Frame attributes
    ----------------
    pole : `~astropy.coordinates.SkyCoord`, `~astropy.coordinates.ICRS`
        The pole of the new coordinate frame, defined in the old frame (ICRS).
    origin : `~astropy.coordinates.SkyCoord`, `~astropy.coordinates.ICRS`
        The x-axis (spherical origin) of the new coordinate frame, defined in the old
        frame (ICRS).
"""


@format_doc(dedent(base_doc), components=_components, footer=_footer)
@greatcircle_transforms(self_transform=True)
class GreatCircleICRSFrame(coord.BaseCoordinateFrame):
    """
    A coordinate frame defined by a pole and origin.

    ``GreatCircleICRSFrame``s always have component names for spherical coordinates of
    ``phi1`` and ``phi2`` (so, proper motion components are ``pm_phi1_cosphi2``, etc.).
    """

    pole = CoordinateAttribute(default=None, frame=coord.ICRS)
    origin = CoordinateAttribute(default=None, frame=coord.ICRS)
    priority = StringValidatedAttribute(
        default="origin", valid_values=["origin", "pole"]
    )

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        if "ra0" in kwargs:
            raise ValueError(
                "Initializing a GreatCircleICRSFrame with a pole and ra0 is no longer "
                "supported because this does not uniquely determine a coordinate frame."
                " To initialize a frame with a pole and ra0 and ignore the ambiguity, "
                "use the .from_pole_ra0() classmethod."
            )

        if "rotation" in kwargs:
            raise ValueError(
                "Initializing a GreatCircleICRSFrame with a `rotation` is no longer "
                "supported."
            )

        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)

        if self.pole is None or self.origin is None:
            raise ValueError("You must specify both a pole and an origin")
        pole, origin = ensure_orthogonal(self.pole, self.origin, priority=self.priority)
        self._pole = pole
        self._origin = origin
        self._R = pole_origin_to_R(self.pole, self.origin)

        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__

    @classmethod
    def from_pole_ra0(cls, pole, ra0, origin_disambiguate=None):
        f"""
        Compute the great circle frame from a pole and RA of longitude=0.

        {get_origin_from_pole_ra0.__doc__}

        Parameters
        ----------
        pole : `~astropy.coordinates.SkyCoord`
            The pole of the new coordinate frame, defined in the old frame (ICRS).
        ra0 : `~astropy.units.Quantity`, `~astropy.coordinates.Angle` (optional)
            Right Ascension of longitude zero.
        origin_disambiguate :  `~astropy.coordinates.SkyCoord` (optional)
            A sky coordinate in the old frame (ICRS) used to disambiguate the coordinate
            system origin. The x-axis closest to this coordinate is chosen as the new
            system origin / x-axis.
        """
        origin = get_origin_from_pole_ra0(
            pole, ra0, origin_disambiguate=origin_disambiguate
        )
        return cls(pole=pole, origin=origin)

    @classmethod
    def from_endpoints(cls, coord1, coord2, origin=None, ra0=None, priority=None):
        """
        Compute the great circle frame from two endpoints of an arc on the unit sphere.

        If you specify an ``origin``, it should be orthogonal to the pole of the great
        circle defined by ``coord1`` and ``coord2``. If it is not orthogonal to the
        pole, by default, the pole will be adjusted along the great circle connecting
        the pole to the input ``origin``. If you would instead like to keep the pole
        fixed and orthogonalize the ``origin``, pass in ``priority='pole'``.

        Parameters
        ----------
        coord1 : `~astropy.coordinates.SkyCoord`
            One endpoint of the great circle arc.
        coord2 : `~astropy.coordinates.SkyCoord`
            The other endpoint of the great circle arc.
        origin : `~astropy.coordinates.SkyCoord` (optional)
            The x-axis (spherical origin) of the new coordinate frame, defined in the
            old frame (ICRS). This defines the (phi1,phi2)=(0,0)º coordinate.
        ra0 : `~astropy.units.Quantity`, `~astropy.coordinates.Angle` (optional)
            Right Ascension of longitude zero. You can only specify one of ``origin`` or
            ``ra0``.
        priority : str (optional)
            Defines the priority of keeping either the pole or origin fixed when they
            are not orthogonal based on the input.
        """

        if ra0 is not None and origin is not None:
            raise ValueError("You can only pass one of `ra0` or `origin`, not both")

        pole = pole_from_endpoints(coord1.squeeze(), coord2.squeeze())

        if ra0 is not None:
            midpt = sph_midpoint(coord1.squeeze(), coord2.squeeze())
            origin = get_origin_from_pole_ra0(pole, ra0, midpt)
        elif ra0 is None and origin is None:
            origin = sph_midpoint(coord1.squeeze(), coord2.squeeze())

        return cls(pole=pole, origin=origin, priority=priority)

    @classmethod
    def from_xyz(cls, xnew=None, ynew=None, znew=None):
        """
        Compute the great circle frame from a specification of the coordinate axes in
        the new system.

        Parameters
        ----------
        xnew : astropy ``Representation`` object
            The x-axis in the new system.
        ynew : astropy ``Representation`` object
            The y-axis in the new system.
        znew : astropy ``Representation`` object
            The z-axis in the new system.
        """
        is_none = [xnew is None, ynew is None, znew is None]
        if np.sum(is_none) > 1:
            raise ValueError("At least 2 axes must be specified.")

        if xnew is not None:
            xnew = xnew.to_cartesian()

        if ynew is not None:
            ynew = ynew.to_cartesian()

        if znew is not None:
            znew = znew.to_cartesian()

        if znew is None:
            znew = xnew.cross(ynew)

        if ynew is None:
            ynew = -xnew.cross(znew)

        if xnew is None:
            xnew = ynew.cross(znew)

        pole = coord.SkyCoord(znew, frame="icrs")
        origin = coord.SkyCoord(xnew, frame="icrs")
        return cls(pole=pole, origin=origin)

    @classmethod
    def from_R(cls, R):
        """
        Compute the great circle frame from a rotation matrix that specifies the
        transformation from ICRS to the new frame.

        Parameters
        ----------
        R : array_like
            The transformation matrix.
        """

        pole = coord.SkyCoord(
            coord.CartesianRepresentation([0.0, 0.0, 1.0]).transform(R.T),
            frame="icrs",
            representation_type="unitspherical",
        )
        origin = coord.SkyCoord(
            coord.CartesianRepresentation([1.0, 0.0, 0.0]).transform(R.T),
            frame="icrs",
            representation_type="unitspherical",
        )

        return cls(pole=pole, origin=origin)


def make_greatcircle_cls(cls_name, docstring_header=None, **kwargs):
    @format_doc(base_doc, components=_components, footer=_footer)
    @greatcircle_transforms(self_transform=False)
    class GCFrame(GreatCircleICRSFrame):
        pole = CoordinateAttribute(default=kwargs.get("pole", None), frame=coord.ICRS)
        origin = CoordinateAttribute(
            default=kwargs.get("origin", None), frame=coord.ICRS
        )

    GCFrame.__name__ = cls_name
    if docstring_header:
        GCFrame.__doc__ = "{0}\n{1}".format(docstring_header, GCFrame.__doc__)

    return GCFrame
</file>

<file path="gala/coordinates/helpers.py">
from astropy.coordinates import Attribute


class StringValidatedAttribute(Attribute):
    """
    Frame attribute for a string that is validated against a provided list of possible
    values for the attribute. See the `~astropy.coordinates.Attribute` API doc for
    further information.

    Parameters
    ----------
    valid_values : iterable of str
        A list or iterable of strings that define the valid values for the attribute
    default : str, None
        Default value for the attribute if not provided
    secondary_attribute : str
        Name of a secondary instance attribute which supplies the value if
        ``default is None`` and no value was supplied during initialization.
    """

    def __init__(self, valid_values, default=None, secondary_attribute=""):
        self.valid_values = list(valid_values)
        try:
            default = self.convert_input(default)[0]
        except ValueError:
            raise ValueError(
                "The specified default value is not in the list of valid values."
            )
        super().__init__(default, secondary_attribute)

    def convert_input(self, value):
        """
        Checks that the input is a valid value.

        Parameters
        ----------
        value : str
            Input value to be validated
        """

        if value is None:
            return None, False

        if value is not None and value not in self.valid_values:
            raise ValueError(
                "The specified attribute value is not in the list of valid values."
            )

        return value, False
</file>

<file path="gala/coordinates/jhelum.py">
# Third-party
import numpy as np

import astropy.units as u
import astropy.coordinates as coord
from astropy.coordinates import frame_transform_graph

__all__ = ["JhelumBonaca19"]


class JhelumBonaca19(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit of the Jhelum
    stream, as described in Bonaca et al. 2019.

    For more information about this class, see the Astropy documentation on coordinate
    frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)
    phi1 : angle_like, optional, must be keyword
        The longitude-like angle aligned with the stream.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle aligned perpendicular to the stream.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the GD-1 stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        GD-1 stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ],
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Rotation matrix as defined in Bonaca+2019
R = np.array(
    [
        [0.6173151074, -0.0093826715, -0.7866600433],
        [-0.0151801852, -0.9998847743, 0.0000135163],
        [-0.7865695266, 0.0119333013, -0.6173864075],
    ]
)


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.ICRS, JhelumBonaca19
)
def icrs_to_jhelum():
    """
    Compute the transformation from Galactic spherical to heliocentric Jhelum
    coordinates.
    """
    return R


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, JhelumBonaca19, coord.ICRS
)
def jhelum_to_icrs():
    """
    Compute the transformation from heliocentric Jhelum coordinates to spherical ICRS.
    """
    return icrs_to_jhelum().T
</file>

<file path="gala/coordinates/magellanic_stream.py">
""" Astropy coordinate class for the Magellanic Stream coordinate system """

from astropy.coordinates.matrix_utilities import rotation_matrix
from astropy.coordinates.baseframe import (
    frame_transform_graph,
    BaseCoordinateFrame,
    RepresentationMapping,
)
from astropy.coordinates.transformations import StaticMatrixTransform
from astropy.coordinates import representation as r
from astropy.coordinates import Galactic

import astropy.units as u

__all__ = ["MagellanicStreamNidever08"]


class MagellanicStreamNidever08(BaseCoordinateFrame):
    """
    A coordinate or frame aligned with the Magellanic Stream,
    as defined by Nidever et al. (2008,
    see: `<http://adsabs.harvard.edu/abs/2008ApJ...679..432N>`_).

    For more information about this class, see the Astropy documentation
    on coordinate frames in :mod:`~astropy.coordinates`.

    Examples
    --------
    Converting the coordinates of the Large Magellanic Cloud:

        >>> from astropy import coordinates as coord
        >>> from astropy import units as u
        >>> from gala.coordinates import MagellanicStreamNidever08

        >>> c = coord.Galactic(l=280.4652*u.deg, b=-32.8884*u.deg)
        >>> ms = c.transform_to(MagellanicStreamNidever08())
        >>> print(ms)
        <MagellanicStreamNidever08 Coordinate: (L, B) in deg
            (-0.13686116, 2.42583948)>
    """

    frame_specific_representation_info = {
        r.SphericalRepresentation: [
            RepresentationMapping("lon", "L"),
            RepresentationMapping("lat", "B"),
        ]
    }

    default_representation = r.SphericalRepresentation
    default_differential = r.SphericalCosLatDifferential

    _ngp = Galactic(l=188.5 * u.deg, b=-7.5 * u.deg)
    _lon0 = Galactic(l=280.47 * u.deg, b=-32.75 * u.deg)

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data, (r.UnitSphericalRepresentation, r.SphericalRepresentation)
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = BaseCoordinateFrame.represent_as.__doc__


@frame_transform_graph.transform(
    StaticMatrixTransform, Galactic, MagellanicStreamNidever08
)
def gal_to_mag():
    mat1 = rotation_matrix(57.275785782128686 * u.deg, "z")
    mat2 = rotation_matrix(90 * u.deg - MagellanicStreamNidever08._ngp.b, "y")
    mat3 = rotation_matrix(MagellanicStreamNidever08._ngp.l, "z")

    return mat1 @ mat2 @ mat3


@frame_transform_graph.transform(
    StaticMatrixTransform, MagellanicStreamNidever08, Galactic
)
def mag_to_gal():
    return gal_to_mag().T
</file>

<file path="gala/coordinates/oph.py">
""" Astropy coordinate class for the Ophiuchus coordinate system """

# Third-party
import numpy as np

import astropy.units as u
import astropy.coordinates as coord
from astropy.coordinates import frame_transform_graph


__all__ = ["OphiuchusPriceWhelan16"]


class OphiuchusPriceWhelan16(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit
    of the Ophiuchus stream, as described in
    Price-Whelan et al. 2016 (see: `<https://arxiv.org/abs/1601.06790>`_).

    For more information about this class, see the Astropy documentation
    on coordinate frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)

    phi1 : angle_like, optional, must be keyword
        The longitude-like angle corresponding to Ophiuchus's orbit.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle corresponding to Ophiuchus's orbit.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the Ophiuchus stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        Ophiuchus stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Rotation matrix
R = np.array(
    [
        [0.84922096554, 0.07001279040, 0.52337554476],
        [-0.27043653641, -0.79364259852, 0.54497294023],
        [0.45352820359, -0.60434231606, -0.65504391727],
    ]
)


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.Galactic, OphiuchusPriceWhelan16
)
def gal_to_oph():
    """Compute the transformation from Galactic spherical to
    heliocentric Ophiuchus coordinates.
    """
    return R


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, OphiuchusPriceWhelan16, coord.Galactic
)
def oph_to_gal():
    """Compute the transformation from heliocentric Ophiuchus coordinates to
    spherical Galactic.
    """
    return gal_to_oph().T
</file>

<file path="gala/coordinates/orphan.py">
""" Astropy coordinate class for the Orphan stream coordinate systems """

import astropy.coordinates as coord
import astropy.units as u
from astropy.coordinates import frame_transform_graph
from astropy.coordinates.matrix_utilities import rotation_matrix
import numpy as np

__all__ = ["OrphanNewberg10", "OrphanKoposov19"]


class OrphanNewberg10(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit
    of the Orphan stream, as described in
    Newberg et al. 2010 (see: `<http://arxiv.org/abs/1001.0576>`_).

    Note: to be consistent with other stream classes, we refer to the longitude
    and latitude as ``phi1`` and ``phi2`` instead of ``Lambda`` and ``Beta``.

    For more information about this class, see the Astropy documentation
    on coordinate frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)

    phi1 : angle_like, optional, must be keyword
        The longitude-like angle corresponding to Orphan's orbit.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle corresponding to Orphan's orbit.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the Orphan stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        Orphan stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Define the Euler angles
phi = 128.79 * u.degree
theta = 54.39 * u.degree
psi = 90.70 * u.degree

# Generate the rotation matrix using the x-convention (see Goldstein)
D = rotation_matrix(phi, "z")
C = rotation_matrix(theta, "x")
B = rotation_matrix(psi, "z")
R = B @ C @ D


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.Galactic, OrphanNewberg10
)
def galactic_to_orp():
    """Compute the transformation from Galactic spherical to
    heliocentric Orphan coordinates.
    """
    return R


# Oph to Galactic coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, OrphanNewberg10, coord.Galactic
)
def orp_to_galactic():
    """Compute the transformation from heliocentric Orphan coordinates to
    spherical Galactic.
    """
    return galactic_to_orp().T


# ------------------------------------------------------------------------------


class OrphanKoposov19(coord.BaseCoordinateFrame):
    """A coordinate frame for the Orphan stream defined by Sergey Koposov.

    Parameters
    ----------
    phi1 : `~astropy.units.Quantity`
        Longitude component.
    phi2 : `~astropy.units.Quantity`
        Latitude component.
    distance : `~astropy.units.Quantity`
        Distance.

    pm_phi1_cosphi2 : `~astropy.units.Quantity`
        Proper motion in longitude.
    pm_phi2 : `~astropy.units.Quantity`
        Proper motion in latitude.
    radial_velocity : `~astropy.units.Quantity`
        Line-of-sight or radial velocity.
    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.ICRS, OrphanKoposov19
)
def icrs_to_orp19():
    """Compute the transformation from ICRS to
    heliocentric Orphan coordinates.
    """
    R = np.array(
        [
            [-0.44761231, -0.08785756, -0.88990128],
            [-0.84246097, 0.37511331, 0.38671632],
            [0.29983786, 0.92280606, -0.2419219],
        ]
    )
    return R


# Oph to Galactic coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, OrphanKoposov19, coord.ICRS
)
def orp19_to_icrs():
    """Compute the transformation from heliocentric Orphan coordinates to
    spherical ICRS.
    """
    return icrs_to_orp19().T
</file>

<file path="gala/coordinates/pal13.py">
""" Astropy coordinate class for the Palomar 5 stream coordinate system """

# Third-party
import numpy as np

import astropy.units as u
import astropy.coordinates as coord
from astropy.coordinates import frame_transform_graph

__all__ = ["Pal13Shipp20"]


class Pal13Shipp20(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit
    of the Pal 13 stream by Shipp et al. (2020).

    For more information about this class, see the Astropy documentation
    on coordinate frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)

    phi1 : angle_like, optional, must be keyword
        The longitude-like angle corresponding to Pal 13's orbit.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle corresponding to Pal 13's orbit.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the Pal 5 stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        Pal 5 stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Rotation matrix defined by trying to align the stream to the equator
R = np.array(
    [
        [0.94906836, -0.22453560, 0.22102719],
        [-0.06325861, 0.55143610, 0.83181523],
        [-0.30865450, -0.80343138, 0.50914675],
    ]
)


@frame_transform_graph.transform(coord.StaticMatrixTransform, coord.ICRS, Pal13Shipp20)
def icrs_to_pal13():
    """Compute the transformation from Galactic spherical to
    heliocentric Pal 13 coordinates.
    """
    return R


@frame_transform_graph.transform(coord.StaticMatrixTransform, Pal13Shipp20, coord.ICRS)
def pal13_to_icrs():
    """Compute the transformation from heliocentric Pal 13 coordinates to
    spherical Galactic.
    """
    return icrs_to_pal13()
</file>

<file path="gala/coordinates/pal5.py">
""" Astropy coordinate class for the Palomar 5 stream coordinate system """

# Third-party
import numpy as np

import astropy.units as u
import astropy.coordinates as coord
from astropy.coordinates import frame_transform_graph

__all__ = ["Pal5PriceWhelan18"]


class Pal5PriceWhelan18(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit
    of the Pal 5 stream by A. Price-Whelan (2018).

    For more information about this class, see the Astropy documentation
    on coordinate frames in :mod:`~astropy.coordinates`.

    Parameters
    ----------
    representation : :class:`~astropy.coordinates.BaseRepresentation` or None
        A representation object or None to have no data (or use the other keywords)

    phi1 : angle_like, optional, must be keyword
        The longitude-like angle corresponding to Pal 5's orbit.
    phi2 : angle_like, optional, must be keyword
        The latitude-like angle corresponding to Pal 5's orbit.
    distance : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_phi1_cosphi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the longitude-like direction corresponding to
        the Pal 5 stream's orbit.
    pm_phi2 : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in the latitude-like direction perpendicular to the
        Pal 5 stream's orbit.
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "phi1"),
            coord.RepresentationMapping("lat", "phi2"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Rotation matrix defined by trying to align the stream to the equator
R = np.array(
    [
        [-0.65019243, -0.75969758, -0.01045969],
        [-0.62969142, 0.54652698, -0.55208422],
        [0.42513354, -0.3523746, -0.83372274],
    ]
)

# Extra rotation to put the cluster center at (0, 0)
R2 = np.array(
    [
        [9.99938314e-01, 1.57847502e-03, -1.09943927e-02],
        [-1.57837962e-03, 9.99998754e-01, 1.73543959e-05],
        [1.09944064e-02, 0.00000000e00, 9.99939560e-01],
    ]
)
R = R2 @ R


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.ICRS, Pal5PriceWhelan18
)
def icrs_to_pal5():
    """Compute the transformation from Galactic spherical to
    heliocentric Pal 5 coordinates.
    """
    return R


@frame_transform_graph.transform(
    coord.StaticMatrixTransform, Pal5PriceWhelan18, coord.ICRS
)
def pal5_to_icrs():
    """Compute the transformation from heliocentric Pal 5 coordinates to
    spherical Galactic.
    """
    return icrs_to_pal5().T
</file>

<file path="gala/coordinates/pm_cov_transform.py">
# Third-party
import astropy.coordinates as coord
import numpy as np

__all__ = ["transform_pm_cov"]


def get_uv_tan(c):
    """Get tangent plane basis vectors on the unit sphere at the given
    spherical coordinates.
    """
    l = c.spherical.lon
    b = c.spherical.lat

    p = np.array([-np.sin(l), np.cos(l), np.zeros_like(l.value)]).T
    q = np.array([-np.cos(l) * np.sin(b), -np.sin(l) * np.sin(b), np.cos(b)]).T

    return np.stack((p, q), axis=-1)


def get_transform_matrix(from_frame, to_frame):
    """Compose sequential matrix transformations (static or dynamic) to get a
    single transformation matrix from a given path through the Astropy
    transformation machinery.

    Parameters
    ----------
    from_frame : `~astropy.coordinates.BaseCoordinateFrame` subclass
        The *class* or instance of the frame you're transforming from.
    to_frame : `~astropy.coordinates.BaseCoordinateFrame` subclass
        The class or instance of the frame you're transforming to.
    """
    if isinstance(from_frame, coord.BaseCoordinateFrame):
        from_frame_cls = from_frame.__class__
    else:
        from_frame_cls = from_frame

    if isinstance(to_frame, coord.BaseCoordinateFrame):
        to_frame_cls = to_frame.__class__
    else:
        to_frame_cls = to_frame

    path, distance = coord.frame_transform_graph.find_shortest_path(
        from_frame_cls, to_frame_cls
    )

    matrices = []
    currsys = from_frame
    for p in path[1:]:  # first element is fromsys so we skip it
        if isinstance(currsys, coord.BaseCoordinateFrame):
            currsys_cls = currsys.__class__
        else:
            currsys_cls = currsys
            currsys = currsys_cls()

        trans = coord.frame_transform_graph._graph[currsys_cls][p]

        if isinstance(to_frame, p):
            p = to_frame

        if isinstance(trans, coord.DynamicMatrixTransform):
            if not isinstance(p, coord.BaseCoordinateFrame):
                p = p()
            M = trans.matrix_func(currsys, p)
        elif isinstance(trans, coord.StaticMatrixTransform):
            M = trans.matrix
        else:
            raise ValueError(
                "Transform path contains a '{0}': cannot "
                "be composed into a single transformation "
                "matrix.".format(trans.__class__.__name__)
            )

        matrices.append(M)
        currsys = p

    M = None
    for Mi in reversed(matrices):
        if M is None:
            M = Mi
        else:
            M = M @ Mi

    return M


def transform_pm_cov(c, cov, to_frame):
    """Transform a proper motion covariance matrix to a new frame.

    Parameters
    ----------
    c : `~astropy.coordinates.SkyCoord`
        The sky coordinates of the sources in the initial coordinate frame.
    cov : array_like
        The covariance matrix of the proper motions. Must have same length as
        the input coordinates.
    to_frame : `~astropy.coordinates.BaseCoordinateFrame` subclass
        The frame to transform to as an Astropy coordinate frame class or
        instance.

    Returns
    -------
    new_cov : array_like
        The transformed covariance matrix.

    """
    if c.isscalar and cov.shape != (2, 2):
        raise ValueError(
            "If input coordinate object is a scalar coordinate, "
            "the proper motion covariance matrix must have shape "
            "(2, 2), not {}".format(cov.shape)
        )

    elif not c.isscalar and len(c) != cov.shape[0]:
        raise ValueError(
            "Input coordinates and covariance matrix must have "
            "the same number of entries ({} vs {}).".format(len(c), cov.shape[0])
        )

    # 3D rotation matrix, to be projected onto the tangent plane
    if hasattr(c, "frame"):
        frame = c.frame
    else:
        frame = c
    R = get_transform_matrix(frame.__class__, to_frame)

    # Get input coordinates in the desired frame:
    c_to = c.transform_to(to_frame)

    # Get tangent plane coordinates:
    uv_in = get_uv_tan(c)
    uv_to = get_uv_tan(c_to)

    if not c.isscalar:
        G = np.einsum("nab, nac->nbc", uv_to, np.einsum("ji, nik->njk", R, uv_in))

        # transform
        cov_to = np.einsum("nba, nac->nbc", G, np.einsum("nij, nkj->nik", cov, G))
    else:
        G = np.einsum("ab, ac->bc", uv_to, np.einsum("ji, ik->jk", R, uv_in))

        # transform
        cov_to = np.einsum("ba, ac->bc", G, np.einsum("ij, kj->ik", cov, G))

    return cov_to
</file>

<file path="gala/coordinates/poincarepolar.py">
# Third-party
import numpy as np

__all__ = ["cartesian_to_poincare_polar"]


def cartesian_to_poincare_polar(w):
    r"""
    Convert an array of 6D Cartesian positions to Poincaré
    symplectic polar coordinates. These are similar to cylindrical
    coordinates.

    Parameters
    ----------
    w : array_like
        Input array of 6D Cartesian phase-space positions. Should have
        shape ``(norbits, 6)``.

    Returns
    -------
    new_w : :class:`~numpy.ndarray`
        Points represented in 6D Poincaré polar coordinates.

    """

    R = np.sqrt(w[..., 0] ** 2 + w[..., 1] ** 2)
    # phi = np.arctan2(w[..., 1], w[..., 0])
    phi = np.arctan2(w[..., 0], w[..., 1])

    vR = (w[..., 0] * w[..., 0 + 3] + w[..., 1] * w[..., 1 + 3]) / R
    vPhi = w[..., 0] * w[..., 1 + 3] - w[..., 1] * w[..., 0 + 3]

    # pg. 437, Papaphillipou & Laskar (1996)
    sqrt_2THETA = np.sqrt(np.abs(2 * vPhi))
    pp_phi = sqrt_2THETA * np.cos(phi)
    pp_phidot = sqrt_2THETA * np.sin(phi)

    z = w[..., 2]
    zdot = w[..., 2 + 3]

    new_w = np.vstack((R.T, pp_phi.T, z.T, vR.T, pp_phidot.T, zdot.T)).T
    return new_w
</file>

<file path="gala/coordinates/reflex.py">
import astropy.coordinates as coord

__all__ = ["reflex_correct"]


def reflex_correct(coords, galactocentric_frame=None):
    """Correct the input Astropy coordinate object for solar reflex motion.

    The input coordinate instance must have distance and radial velocity information.
    So, if the radial velocity is not known, fill the radial velocity values with zeros
    to reflex-correct the proper motions.

    Parameters
    ----------
    coords : `~astropy.coordinates.SkyCoord`
        The Astropy coordinate object with position and velocity information.
    galactocentric_frame : `~astropy.coordinates.Galactocentric` (optional)
        To change properties of the Galactocentric frame, like the height of the
        sun above the midplane, or the velocity of the sun in a Galactocentric
        intertial frame, set arguments of the
        `~astropy.coordinates.Galactocentric` object and pass in to this
        function with your coordinates.

    Returns
    -------
    coords : `~astropy.coordinates.SkyCoord`
        The coordinates in the same frame as input, but with solar motion
        removed.

    """
    c = coord.SkyCoord(coords)

    # If not specified, use the Astropy default Galactocentric frame
    if galactocentric_frame is None:
        galactocentric_frame = coord.Galactocentric()

    v_sun = galactocentric_frame.galcen_v_sun

    observed = c.transform_to(galactocentric_frame)
    rep = observed.cartesian.without_differentials()
    rep = rep.with_differentials(observed.cartesian.differentials["s"] + v_sun)
    fr = galactocentric_frame.realize_frame(rep).transform_to(c.frame)
    return coord.SkyCoord(fr)
</file>

<file path="gala/coordinates/sgr.py">
""" Astropy coordinate class for the Sagittarius coordinate system """

# Third-party
import numpy as np

from astropy.coordinates import frame_transform_graph
import astropy.coordinates as coord
import astropy.units as u
from astropy.coordinates.matrix_utilities import rotation_matrix

__all__ = ["SagittariusLaw10", "SagittariusVasiliev21"]


class SagittariusLaw10(coord.BaseCoordinateFrame):
    """
    A Heliocentric spherical coordinate system defined by the orbit
    of the Sagittarius dwarf galaxy, as described in
    http://adsabs.harvard.edu/abs/2003ApJ...599.1082M
    and further explained in http://www.stsci.edu/~dlaw/Sgr/.

    Parameters
    ----------
    representation : `BaseRepresentation` or None
        A representation object or None to have no data (or use the other
        keywords).

    Lambda : `Angle`, optional, must be keyword
        The longitude-like angle corresponding to Sagittarius' orbit.
    Beta : `Angle`, optional, must be keyword
        The latitude-like angle corresponding to Sagittarius' orbit.
    distance : `Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_Lambda_cosBeta : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion along the stream in ``Lambda`` (including the
        ``cos(Beta)`` factor) for this object (``pm_Beta`` must also be given).
    pm_Beta : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in Declination for this object (``pm_ra_cosdec`` must
        also be given).
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The radial velocity of this object.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "Lambda"),
            coord.RepresentationMapping("lat", "Beta"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Define the Euler angles (from Law & Majewski 2010)
phi = (180 + 3.75) * u.degree
theta = (90 - 13.46) * u.degree
psi = (180 + 14.111534) * u.degree

# Generate the rotation matrix using the x-convention (see Goldstein)
D = rotation_matrix(phi, "z")
C = rotation_matrix(theta, "x")
B = rotation_matrix(psi, "z")
A = np.diag([1.0, 1.0, -1.0])
R = A @ B @ C @ D


# Galactic to Sgr coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.Galactic, SagittariusLaw10
)
def galactic_to_sgr():
    """Compute the transformation from Galactic spherical to
    heliocentric Sagittarius coordinates.
    """
    return R


# Sgr to Galactic coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, SagittariusLaw10, coord.Galactic
)
def sgr_to_galactic():
    """Compute the transformation from heliocentric Sagittarius coordinates to
    spherical Galactic.
    """
    return galactic_to_sgr().T


# -------------------------------------------------------------------------------------


class SagittariusVasiliev21(coord.BaseCoordinateFrame):
    """
    A Heliocentric, right-handed spherical coordinate system defined by the orbit of the
    Sagittarius dwarf galaxy, as described in Vasiliev et al. 2021,
    https://ui.adsabs.harvard.edu/abs/2021MNRAS.501.2279V/abstract

    Parameters
    ----------
    representation : `BaseRepresentation` or None
        A representation object or None to have no data (or use the other
        keywords).

    Lambda : `Angle`, optional, must be keyword
        The longitude-like angle corresponding to Sagittarius' orbit.
    Beta : `Angle`, optional, must be keyword
        The latitude-like angle corresponding to Sagittarius' orbit.
    distance : `Quantity`, optional, must be keyword
        The Distance for this object along the line-of-sight.

    pm_Lambda_cosBeta : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion along the stream in ``Lambda`` (including the
        ``cos(Beta)`` factor) for this object (``pm_Beta`` must also be given).
    pm_Beta : :class:`~astropy.units.Quantity`, optional, must be keyword
        The proper motion in Declination for this object (``pm_ra_cosdec`` must
        also be given).
    radial_velocity : :class:`~astropy.units.Quantity`, optional, must be keyword
        The radial velocity of this object.

    """

    default_representation = coord.SphericalRepresentation
    default_differential = coord.SphericalCosLatDifferential

    frame_specific_representation_info = {
        coord.SphericalRepresentation: [
            coord.RepresentationMapping("lon", "Lambda"),
            coord.RepresentationMapping("lat", "Beta"),
            coord.RepresentationMapping("distance", "distance"),
        ]
    }

    _default_wrap_angle = 180 * u.deg

    def __init__(self, *args, **kwargs):
        wrap = kwargs.pop("wrap_longitude", True)
        super().__init__(*args, **kwargs)
        if wrap and isinstance(
            self._data,
            (coord.UnitSphericalRepresentation, coord.SphericalRepresentation),
        ):
            self._data.lon.wrap_angle = self._default_wrap_angle

    # TODO: remove this. This is a hack required as of astropy v3.1 in order
    # to have the longitude components wrap at the desired angle
    def represent_as(self, base, s="base", in_frame_units=False):
        r = super().represent_as(base, s=s, in_frame_units=in_frame_units)
        if hasattr(r, "lon"):
            r.lon.wrap_angle = self._default_wrap_angle
        return r

    represent_as.__doc__ = coord.BaseCoordinateFrame.represent_as.__doc__


# Galactic to Sgr coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, coord.Galactic, SagittariusVasiliev21
)
def galactic_to_sgr_v21():
    """Compute the transformation from ICRS to Sagittarius coordinates"""
    if not hasattr(SagittariusVasiliev21, "_R"):
        R = np.diag([1.0, -1.0, -1.0]) @ B @ C @ D
        SagittariusVasiliev21._R = R

    return SagittariusVasiliev21._R


# Sgr to Galactic coordinates
@frame_transform_graph.transform(
    coord.StaticMatrixTransform, SagittariusVasiliev21, coord.Galactic
)
def sgr_to_galactic_v21():
    """Compute the inverse transformation from Sagittarius coordinates to ICRS"""
    return galactic_to_sgr_v21().T
</file>

<file path="gala/coordinates/velocity_frame_transforms.py">
""" Miscellaneous astronomical velocity transformations. """

import astropy.coordinates as coord

__all__ = ["vgsr_to_vhel", "vhel_to_vgsr"]


def _get_vproj(c, vsun):
    gal = c.transform_to(coord.Galactic())
    cart_data = gal.data.to_cartesian()
    unit_vector = cart_data / cart_data.norm()
    return coord.CartesianRepresentation(vsun).dot(unit_vector)


def vgsr_to_vhel(coordinate, vgsr, vsun=None):
    """
    Convert a radial velocity in the Galactic standard of rest (GSR) to
    a barycentric radial velocity.

    Parameters
    ----------
    coordinate : :class:`~astropy.coordinates.SkyCoord`
        An Astropy SkyCoord object or anything object that can be passed
        to the SkyCoord initializer.
    vgsr : :class:`~astropy.units.Quantity`
        GSR line-of-sight velocity.
    vsun : :class:`~astropy.units.Quantity`
        Full-space velocity of the sun in a Galactocentric frame. By default,
        uses the value assumed by Astropy in
        `~astropy.coordinates.Galactocentric`.

    Returns
    -------
    vhel : :class:`~astropy.units.Quantity`
        Radial velocity in a barycentric rest frame.

    """

    if vsun is None:
        galcen = coord.Galactocentric()
        vsun = galcen.galcen_v_sun.to_cartesian().xyz

    return vgsr - _get_vproj(coordinate, vsun)


def vhel_to_vgsr(coordinate, vhel, vsun):
    """
    Convert a velocity from a heliocentric radial velocity to
    the Galactic standard of rest (GSR).

    Parameters
    ----------
    coordinate : :class:`~astropy.coordinates.SkyCoord`
        An Astropy SkyCoord object or anything object that can be passed
        to the SkyCoord initializer.
    vhel : :class:`~astropy.units.Quantity`
        Barycentric line-of-sight velocity.
    vsun : :class:`~astropy.units.Quantity`
        Full-space velocity of the sun in a Galactocentric frame. By default,
        uses the value assumed by Astropy in
        `~astropy.coordinates.Galactocentric`.

    Returns
    -------
    vgsr : :class:`~astropy.units.Quantity`
        Radial velocity in a galactocentric rest frame.

    """

    if vsun is None:
        galcen = coord.Galactocentric()
        vsun = galcen.galcen_v_sun.to_cartesian().xyz

    return vhel + _get_vproj(coordinate, vsun)
</file>

<file path="gala/dynamics/actionangle/_genfunc/genfunc_3d.py">
# Solving the series of linear equations for true action
# and generating function Fourier components

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from matplotlib.ticker import MaxNLocator
import time

# in units kpc, km/s and 10^11 M_solar
Grav = 430091.7270069976
Conv = 0.9777922216

from . import toy_potentials as toy
from . import test_potentials as pot
from . import  solver
from . import  visualize_surfaces as vs
from .solver import unroll_angles as ua


def choose_NT(N_max, iffreq=True):
    """ calculates number of time samples required to constrain N_max modes
        --- equation (21) from Sanders & Binney (2014) """
    if(iffreq):
        return max(200, 9*N_max**3/4)
    else:
        return max(100, N_max**3/2)

def check_angle_solution(ang, n_vec, toy_aa, timeseries):
    """ Plots the toy angle solution against the toy angles ---
        Takes true angles and frequencies ang,
        the Fourier vectors n_vec,
        the toy action-angles toy_aa
        and the timeseries """
    f, a=plt.subplots(3, 1)
    for i in range(3):
        a[i].plot(toy_aa.T[i+3],'.')
        size = len(ang[6:])/3
        AA = np.array([np.sum(ang[6+i*size:6+(i+1)*size]*np.sin(np.sum(n_vec*K, axis=1))) for K in toy_aa.T[3:].T])
        a[i].plot((ang[i]+ang[i+3]*timeseries-2.*AA) % (2.*np.pi),'.')
        a[i].set_ylabel(r'$\theta$'+str(i+1))
    a[2].set_xlabel(r'$t$')
    plt.show()

def check_target_angle_solution(ang, n_vec, toy_aa, timeseries):
    """ Plots the angle solution and the toy angles ---
        Takes true angles and frequencies ang,
        the Fourier vectors n_vec,
        the toy action-angles toy_aa
        and the timeseries """
    f, a=plt.subplots(3, 1)
    for i in range(3):
        # a[i].plot(toy_aa.T[i+3],'.')
        size = len(ang[6:])/3
        AA = np.array([np.sum(ang[6+i*size:6+(i+1)*size]*np.sin(np.sum(n_vec*K, axis=1))) for K in toy_aa.T[3:].T])
        a[i].plot(((toy_aa.T[i+3]+2.*AA) % (2.*np.pi))-(ang[i]+timeseries*ang[i+3]) % (2.*np.pi),'.')
        a[i].plot(toy_aa.T[i+3],'.')
        a[i].set_ylabel(r'$\theta$'+str(i+1))
    a[2].set_xlabel(r'$t$')
    plt.show()

def eval_mean_error_functions(act, ang, n_vec, toy_aa, timeseries, withplot=False):
    """ Calculates sqrt(mean(E)) and sqrt(mean(F)) """

    Err = np.zeros(6)
    NT = len(timeseries)
    size = len(ang[6:])/3
    UA = ua(toy_aa.T[3:].T, np.ones(3))
    fig, axis=None, None
    if(withplot):
        fig, axis=plt.subplots(3, 2)
        plt.subplots_adjust(wspace=0.3)
    for K in range(3):
        ErrJ = np.array([(i[K]-act[K]-2.*np.sum(n_vec.T[K]*act[3:]*np.cos(np.dot(n_vec, i[3:]))))**2 for i in toy_aa])
        Err[K] = np.sum(ErrJ)
        ErrT = np.array(((ang[K]+timeseries*ang[K+3]-UA.T[K]-2.*np.array([np.sum(ang[6+K*size:6+(K+1)*size]*np.sin(np.sum(n_vec*i, axis=1))) for i in toy_aa.T[3:].T])))**2)
        Err[K+3] = np.sum(ErrT)
        if(withplot):
            axis[K][0].plot(ErrJ,'.')
            axis[K][0].set_ylabel(r'$E$'+str(K+1))
            axis[K][1].plot(ErrT,'.')
            axis[K][1].set_ylabel(r'$F$'+str(K+1))

    if(withplot):
        for i in range(3):
            axis[i][0].set_xlabel(r'$t$')
            axis[i][1].set_xlabel(r'$t$')
        plt.show()

    EJ = np.sqrt(Err[:3]/NT)
    ET = np.sqrt(Err[3:]/NT)

    return np.array([EJ, ET])

def box_actions(results, times, N_matrix, ifprint):
    """
        Finds actions, angles and frequencies for box orbit.
        Takes a series of phase-space points from an orbit integration at times t and returns
        L = (act, ang, n_vec, toy_aa, pars) -- explained in find_actions() below.
    """
    if(ifprint):
        print("\n=====\nUsing triaxial harmonic toy potential")

    t = time.time()
    # Find best toy parameters
    omega = toy.findbestparams_ho(results)
    if(ifprint):
        print("Best omega "+str(omega)+" found in "+str(time.time()-t)+" seconds")

    # Now find toy actions and angles
    AA = np.array([toy.angact_ho(i, omega) for i in results])
    AA = AA[~np.isnan(AA).any(1)]
    if(len(AA)==0):
        return

    t = time.time()
    act = solver.solver(AA, N_matrix)
    if act==None:
        return

    if(ifprint):
        print("Action solution found for N_max = "+str(N_matrix)+", size "+str(len(act[0]))+" symmetric matrix in "+str(time.time()-t)+" seconds")

    # np.savetxt("GF.Sn_box",np.vstack((act[1].T, act[0][3:])).T)

    ang = solver.angle_solver(AA, times, N_matrix, np.ones(3))
    if(ifprint):
        print("Angle solution found for N_max = "+str(N_matrix)+", size "+str(len(ang))+" symmetric matrix in "+str(time.time()-t)+" seconds")

    # Just some checks
    if(len(ang)>len(AA)):
        print("More unknowns than equations")

    return act[0], ang, act[1], AA, omega


def loop_actions(results, times, N_matrix, ifprint):
    """
        Finds actions, angles and frequencies for loop orbit.
        Takes a series of phase-space points from an orbit integration at times t and returns
        L = (act, ang, n_vec, toy_aa, pars) -- explained in find_actions() below.
        results must be oriented such that circulation is about the z-axis
    """
    if(ifprint):
        print("\n=====\nUsing isochrone toy potential")

    t = time.time()
    # First find the best set of toy parameters
    params = toy.findbestparams_iso(results)
    if(params[0]!=params[0]):
        params = np.array([10., 10.])
    if(ifprint):
        print("Best params "+str(params)+" found in "+str(time.time()-t)+" seconds")

    # Now find the toy angles and actions in this potential
    AA = np.array([toy.angact_iso(i, params) for i in results])
    AA = AA[~np.isnan(AA).any(1)]
    if(len(AA)==0):
        return

    t = time.time()
    act = solver.solver(AA, N_matrix, symNx = 1)
    if act==None:
        return

    if(ifprint):
        print("Action solution found for N_max = "+str(N_matrix)+", size "+str(len(act[0]))+" symmetric matrix in "+str(time.time()-t)+" seconds")

    # Store Sn
    # np.savetxt("GF.Sn_loop",np.vstack((act[1].T, act[0][3:])).T)

    # Find angles
    sign = np.array([1., np.sign(results[0][0]*results[0][4]-results[0][1]*results[0][3]), 1.])
    ang = solver.angle_solver(AA, times, N_matrix, sign, symNx = 1)
    if(ifprint):
        print("Angle solution found for N_max = "+str(N_matrix)+", size "+str(len(ang))+" symmetric matrix in "+str(time.time()-t)+" seconds")

    # Just some checks
    if(len(ang)>len(AA)):
        print("More unknowns than equations")

    return act[0], ang, act[1], AA, params


def angmom(x):
    """ returns angular momentum vector of phase-space point x"""
    return np.array([x[1]*x[5]-x[2]*x[4],x[2]*x[3]-x[0]*x[5],x[0]*x[4]-x[1]*x[3]])


def assess_angmom(X):
    """
        Checks for change of sign in each component of the angular momentum.
        Returns an array with ith entry 1 if no sign change in i component
        and 0 if sign change.
        Box = (0, 0, 0)
        S.A loop = (0, 0, 1)
        L.A loop = (1, 0, 0)
    """
    L=angmom(X[0])
    loop = np.array([1, 1, 1])
    for i in X[1:]:
        L0 = angmom(i)
        if(L0[0]*L[0]<0.):
            loop[0] = 0
        if(L0[1]*L[1]<0.):
            loop[1] = 0
        if(L0[2]*L[2]<0.):
            loop[2] = 0
    return loop


def flip_coords(X, loop):
    """ Align circulation with z-axis """
    if(loop[0]==1):
        return np.array(map(lambda i: np.array([i[2],i[1],i[0],i[5],i[4],i[3]]), X))
    else:
        return X


def find_actions(results, t, N_matrix=8, use_box=False, ifloop=False, ifprint = True):
    """
        Main routine:
        Takes a series of phase-space points from an orbit integration at times t and returns
        L = (act, ang, n_vec, toy_aa, pars) where act is the actions, ang the initial angles and
        frequencies, n_vec the n vectors of the Fourier modes, toy_aa the toy action-angle
        coords, and pars are the toy potential parameters
        N_matrix sets the maximum |n| of the Fourier modes used,
        use_box forces the routine to use the triaxial harmonic oscillator as the toy potential,
        ifloop=True returns orbit classification,
        ifprint=True prints progress messages.
    """

    # Determine orbit class
    loop = assess_angmom(results)
    arethereloops = np.any(loop>0)
    if(arethereloops and not use_box):
        L = loop_actions(flip_coords(results, loop), t, N_matrix, ifprint)
        if(L==None):
            if(ifprint):
                print("Failed to find actions for this orbit")
            return
        # Used for switching J_2 and J_3 for long-axis loop orbits
        # This is so the orbit classes form a continuous plane in action space
        # if(loop[0]):
        #     L[0][1],L[0][2]=L[0][2],L[0][1]
        #     L[1][1],L[1][2]=L[1][2],L[1][1]
        #     L[1][4],L[1][5]=L[1][5],L[1][4]
        #     L[3].T[1],L[3].T[2]=L[3].T[2],L[3].T[1]
    else:
        L = box_actions(results, t, N_matrix, ifprint)
        if(L==None):
            if(ifprint):
                print("Failed to find actions for this orbit")
            return
    if(ifloop):
        return L, loop
    else:
        return L

###################
#  Plotting tests #
###################
from .solver import check_each_direction as ced

def plot_Sn_timesamples(PSP):
    """ Plots Fig. 5 from Sanders & Binney (2014) """
    TT = pot.stackel_triax()
    f, a = plt.subplots(2, 1, figsize=[3.32, 3.6])
    plt.subplots_adjust(hspace=0., top=0.8)

    LowestPeriod = 2.*np.pi/38.86564386
    Times = np.array([2., 4., 8., 12.])
    Sr = np.arange(2, 14, 2)

    # Loop over length of integration window
    for i, P, C in zip(Times,['.','s','D','^'],['k','r','b','g']):
        diffact = np.zeros((len(Sr), 3))
        difffreq = np.zeros((len(Sr), 3))
        MAXGAPS = np.array([])
        # Loop over N_max
        for k, j in enumerate(Sr):
            NT = choose_NT(j)
            timeseries=np.linspace(0., i*LowestPeriod, NT)
            results = odeint(pot.orbit_derivs2, PSP, timeseries, args=(TT,), rtol=1e-13, atol=1e-13)
            act, ang, n_vec, toy_aa, pars = find_actions(results, timeseries, N_matrix=j, ifprint=False, use_box=True)
            # Check all modes
            checks, maxgap = ced(n_vec, ua(toy_aa.T[3:].T, np.ones(3)))
            if len(maxgap)>0:
                maxgap = np.max(maxgap)
            else:
                maxgap = 0
            diffact[k] = act[:3]/TT.action(results[0])
            MAXGAPS = np.append(MAXGAPS, maxgap)
            difffreq[k] = ang[3:6]/TT.freq(results[0])
        size = 15
        if(P=='.'):
            size = 30
        LW = np.array(map(lambda i: 0.5+i*0.5, MAXGAPS))
        a[0].scatter(Sr, np.log10(np.abs(diffact.T[2]-1)), marker=P, s=size, color=C, facecolors="none",lw=LW, label=r'$T =\,$'+str(i)+r'$\,T_F$')
        a[1].scatter(Sr, np.log10(np.abs(difffreq.T[2]-1)), marker=P, s=size, color=C, facecolors="none", lw=LW)
    a[1].get_yticklabels()[-1].set_visible(False)
    a[0].set_xticklabels([])
    a[0].set_xlim(1, 13)
    a[0].set_ylabel(r"$\log_{10}|J_3^\prime/J_{3, \rm true}-1|$")
    leg = a[0].legend(loc='upper center',bbox_to_anchor=(0.5, 1.4), ncol=2, scatterpoints = 1)
    leg.draw_frame(False)
    a[1].set_xlim(1, 13)
    a[1].set_xlabel(r'$N_{\rm max}$')
    a[1].set_ylabel(r"$\log_{10}|\Omega_3^\prime/\Omega_{3,\rm true}-1|$")
    plt.savefig('Sn_T_box.pdf',bbox_inches='tight')


def plot3D_stacktriax(initial, final_t, N_MAT, file_output):
    """ For producing plots from paper """

    # Setup Stackel potential
    TT = pot.stackel_triax()
    times = choose_NT(N_MAT)
    timeseries=np.linspace(0., final_t, times)
    # Integrate orbit
    results = odeint(pot.orbit_derivs2, initial, timeseries, args=(TT,), rtol=1e-13, atol=1e-13)
    # Find actions, angles and frequencies
    (act, ang, n_vec, toy_aa, pars), loop = find_actions(results, timeseries, N_matrix=N_MAT, ifloop=True)

    toy_pot = 0
    if(loop[2]>0.5 or loop[0]>0.5):
        toy_pot = pot.isochrone(par=np.append(pars, 0.))
    else:
        toy_pot = pot.harmonic_oscillator(omega=pars[:3])
    # Integrate initial condition in toy potential
    timeseries_2=np.linspace(0., 2.*final_t, 3500)
    results_toy = odeint(pot.orbit_derivs2, initial, timeseries_2, args=(toy_pot,))

    # and plot
    f, a = plt.subplots(2, 3, figsize=[3.32, 5.5])
    a[0, 0] = plt.subplot2grid((3, 2), (0, 0))
    a[1, 0] = plt.subplot2grid((3, 2), (0, 1))
    a[0, 1] = plt.subplot2grid((3, 2), (1, 0))
    a[1, 1] = plt.subplot2grid((3, 2), (1, 1))
    a[0, 2] = plt.subplot2grid((3, 2), (2, 0), colspan=2)
    plt.subplots_adjust(wspace=0.5, hspace=0.45)

    # xy orbit
    a[0, 0].plot(results.T[0],results.T[1],'k')
    a[0, 0].set_xlabel(r'$x/{\rm kpc}$')
    a[0, 0].set_ylabel(r'$y/{\rm kpc}$')
    a[0, 0].xaxis.set_major_locator(MaxNLocator(5))
    # xz orbit
    a[1, 0].plot(results.T[0],results.T[2],'k')
    a[1, 0].set_xlabel(r'$x/{\rm kpc}$')
    a[1, 0].set_ylabel(r'$z/{\rm kpc}$')
    a[1, 0].xaxis.set_major_locator(MaxNLocator(5))
    # toy orbits
    a[0, 0].plot(results_toy.T[0],results_toy.T[1],'r',alpha=0.2, linewidth=0.3)
    a[1, 0].plot(results_toy.T[0],results_toy.T[2],'r',alpha=0.2, linewidth=0.3)

    # Toy actions
    a[0, 2].plot(Conv*timeseries, toy_aa.T[0],'k:',label='Toy action')
    a[0, 2].plot(Conv*timeseries, toy_aa.T[1],'r:')
    a[0, 2].plot(Conv*timeseries, toy_aa.T[2],'b:')
    # Arrows to show approx. actions
    arrow_end = a[0, 2].get_xlim()[1]
    arrowd = 0.08*(arrow_end-a[0, 2].get_xlim()[0])
    a[0, 2].annotate('',(arrow_end+arrowd, act[0]), (arrow_end, act[0]), arrowprops=dict(arrowstyle='<-',color='k'), annotation_clip=False)
    a[0, 2].annotate('',(arrow_end+arrowd, act[1]), (arrow_end, act[1]), arrowprops=dict(arrowstyle='<-',color='r'), annotation_clip=False)
    a[0, 2].annotate('',(arrow_end+arrowd, act[2]), (arrow_end, act[2]), arrowprops=dict(arrowstyle='<-',color='b'), annotation_clip=False)
    # True actions
    a[0, 2].plot(Conv*timeseries, TT.action(results[0])[0]*np.ones(len(timeseries)),'k',label='True action')
    a[0, 2].plot(Conv*timeseries, TT.action(results[0])[1]*np.ones(len(timeseries)),'k')
    a[0, 2].plot(Conv*timeseries, TT.action(results[0])[2]*np.ones(len(timeseries)),'k')
    a[0, 2].set_xlabel(r'$t/{\rm Gyr}$')
    a[0, 2].set_ylabel(r'$J/{\rm kpc\,km\,s}^{-1}$')
    leg = a[0, 2].legend(loc='upper center',bbox_to_anchor=(0.5, 1.2), ncol=3, numpoints = 1)
    leg.draw_frame(False)

    # Toy angle coverage
    a[0, 1].plot(toy_aa.T[3]/(np.pi), toy_aa.T[4]/(np.pi),'k.',markersize=0.4)
    a[0, 1].set_xlabel(r'$\theta_1/\pi$')
    a[0, 1].set_ylabel(r'$\theta_2/\pi$')
    a[1, 1].plot(toy_aa.T[3]/(np.pi), toy_aa.T[5]/(np.pi),'k.',markersize=0.4)
    a[1, 1].set_xlabel(r'$\theta_1/\pi$')
    a[1, 1].set_ylabel(r'$\theta_3/\pi$')

    plt.savefig(file_output, bbox_inches='tight')
    return act

if __name__=="__main__":
    BoxP = np.array([0.1, 0.1, 0.1, 142., 140., 251.])
    LoopP = np.array([10., 1., 8., 40., 152., 63.])
    ResP = np.array([0.1, 0.1, 0.1, 142., 150., 216.5])
    LongP = np.array([-0.5, 18., 0.5, 25., 20.,-133.1])

    # Short-axis Loop
    LowestPeriodLoop = 2*np.pi/15.30362865
    # Fig 1
    loop = plot3D_stacktriax(LoopP, 8*LowestPeriodLoop, 6,'genfunc_3d_example_LT_Stack_Loop.pdf')
    # Fig 3
    vs.Sn_plots('GF.Sn_loop','loop',loop, 1)

    # Box
    LowestPeriodBox = 2.*np.pi/38.86564386
    # Fig 2
    box = plot3D_stacktriax(BoxP, 8*LowestPeriodBox, 6,'genfunc_3d_example_LT_Stack_Box.pdf')
    # Fig 4
    vs.Sn_plots('GF.Sn_box','box',box, 0)

    # Res
    LowestPeriodRes = 2.*np.pi/42.182
    # Fig 5
    res = plot3D_stacktriax(ResP, 8*LowestPeriodBox, 6,'genfunc_3d_example_LT_Stack_Res.pdf')
    # vs.Sn_plots('GF.Sn_box','box',res, 0)

    # Long-axis loop
    LowestPeriodLong = 2.*np.pi/12.3
</file>

<file path="gala/dynamics/actionangle/_genfunc/solver.py">
#################
#   AA Solvers  #
#################
import numpy as np
from itertools import product
from scipy.linalg import solve


def check_each_direction(n, angs, ifprint=True):
    """ returns a list of the index of elements of n which do not have adequate
    toy angle coverage. The criterion is that we must have at least one sample
    in each Nyquist box when we project the toy angles along the vector n """
    checks = np.array([])
    P = np.array([])
    if(ifprint):
        print("\nChecking modes:\n====")
    for k, i in enumerate(n):
        N_matrix = np.linalg.norm(i)
        X = np.dot(angs, i)
        if(np.abs(np.max(X)-np.min(X))<2.*np.pi):
            if(ifprint):
                print("Need a longer integration window for mode ", i)
            checks=np.append(checks, i)
            P = np.append(P, (2.*np.pi-np.abs(np.max(X)-np.min(X))))
        elif(np.abs(np.max(X)-np.min(X))/len(X)>np.pi):
            if(ifprint):
                print("Need a finer sampling for mode ", i)
            checks=np.append(checks, i)
            P = np.append(P, (2.*np.pi-np.abs(np.max(X)-np.min(X))))
    if(ifprint):
        print("====\n")
    return checks, P

def solver(AA, N_max, symNx = 2, throw_out_modes=False):
    """ Constructs the matrix A and the vector b from a timeseries of toy
    action-angles AA to solve for the vector x = (J_0, J_1, J_2, S...) where
    x contains all Fourier components of the generating function with |n|<N_max """

    # Find all integer component n_vectors which lie within sphere of radius N_max
    # Here we have assumed that the potential is symmetric x->-x, y->-y, z->-z
    # This can be relaxed by changing symN to 1
    # Additionally due to time reversal symmetry S_n = -S_-n so we only consider
    # "half" of the n-vector-space

    angs = unroll_angles(AA.T[3:].T, np.ones(3))

    symNz = 2
    NNx = range(-N_max, N_max+1, symNx)
    NNy = range(-N_max, N_max+1, symNz)
    NNz = range(-N_max, N_max+1, symNz)
    n_vectors = np.array([[i, j, k] for (i, j, k) in product(NNx, NNy, NNz)
                          if(not(i==0 and j==0 and k==0)            # exclude zero vector
                             and (k>0                               # northern hemisphere
                                  or (k==0 and j>0)                 # half of x-y plane
                                  or (k==0 and j==0 and i>0))       # half of x axis
                             and np.sqrt(i*i+j*j+k*k)<=N_max)])     # inside sphere

    xxx = check_each_direction(n_vectors, angs)

    if(throw_out_modes):
        n_vectors = np.delete(n_vectors, check_each_direction(n_vectors, angs), axis=0)

    n = len(n_vectors)+3
    b = np.zeros(shape=(n, ))
    a = np.zeros(shape=(n, n))

    a[:3, :3]=len(AA)*np.identity(3)

    for i in AA:
        a[:3, 3:]+=2.*n_vectors.T[:3]*np.cos(np.dot(n_vectors, i[3:]))
        a[3:, 3:]+=4.*np.dot(n_vectors, n_vectors.T)*np.outer(np.cos(np.dot(n_vectors, i[3:])), np.cos(np.dot(n_vectors, i[3:])))
        b[:3]+=i[:3]
        b[3:]+=2.*np.dot(n_vectors, i[:3])*np.cos(np.dot(n_vectors, i[3:]))

    a[3:, :3]=a[:3, 3:].T

    return np.array(solve(a, b)), n_vectors


def unroll_angles(A, sign):
    """ Unrolls the angles, A, so they increase continuously """
    n = np.array([0, 0, 0])
    P = np.zeros(np.shape(A))
    P[0]=A[0]
    for i in range(1, len(A)):
        n = n+((A[i]-A[i-1]+0.5*sign*np.pi)*sign<0)*np.ones(3)*2.*np.pi
        P[i] = A[i]+sign*n
    return P

import matplotlib.pyplot as plt
from scipy.stats import linregress as lr

def angle_solver(AA, timeseries, N_max, sign, symNx = 2, throw_out_modes=False):
    """ Constructs the matrix A and the vector b from a timeseries of toy
    action-angles AA to solve for the vector x = (theta_0, theta_1, theta_2, omega_1,
    omega_2, omega_3, dSdx..., dSdy..., dSdz...) where x contains all derivatives
    of the Fourier components of the generating function with |n| < N_max """

    # First unroll angles
    angs = unroll_angles(AA.T[3:].T, sign)

    # Same considerations as above
    symNz = 2
    NNx = range(-N_max, N_max+1, symNx)
    NNy = range(-N_max, N_max+1, symNz)
    NNz = range(-N_max, N_max+1, symNz)
    n_vectors = np.array([[i, j, k] for (i, j, k) in product(NNx, NNy, NNz)
                          if(not(i==0 and j==0 and k==0)    # exclude zero vector
                             and (k>0                          # northern hemisphere
                                  or (k==0 and j>0)                 # half of x-y plane
                                  or (k==0 and j==0 and i>0))       # half of x axis
                             and np.sqrt(i*i+j*j+k*k)<=N_max     # inside sphere
                             )])

    if(throw_out_modes):
        n_vectors = np.delete(n_vectors, check_each_direction(n_vectors, angs), axis=0)

    nv = len(n_vectors)
    n = 3*nv+6

    b = np.zeros(shape=(n, ))
    a = np.zeros(shape=(n, n))

    a[:3, :3]=len(AA)*np.identity(3)
    a[:3, 3:6]=np.sum(timeseries)*np.identity(3)
    a[3:6, :3]=a[:3, 3:6]
    a[3:6, 3:6]=np.sum(timeseries*timeseries)*np.identity(3)

    for i, j in zip(angs, timeseries):
        a[6:6+nv, 0]+=-2.*np.sin(np.dot(n_vectors, i))
        a[6:6+nv, 3]+=-2.*j*np.sin(np.dot(n_vectors, i))
        a[6:6+nv, 6:6+nv]+=4.*np.outer(np.sin(np.dot(n_vectors, i)), np.sin(np.dot(n_vectors, i)))

        b[:3]+=i
        b[3:6]+=j*i

        b[6:6+nv]+=-2.*i[0]*np.sin(np.dot(n_vectors, i))
        b[6+nv:6+2*nv]+=-2.*i[1]*np.sin(np.dot(n_vectors, i))
        b[6+2*nv:6+3*nv]+=-2.*i[2]*np.sin(np.dot(n_vectors, i))

    a[6+nv:6+2*nv, 1]=a[6:6+nv, 0]
    a[6+2*nv:6+3*nv, 2]=a[6:6+nv, 0]
    a[6+nv:6+2*nv, 4]=a[6:6+nv, 3]
    a[6+2*nv:6+3*nv, 5]=a[6:6+nv, 3]
    a[6+nv:6+2*nv, 6+nv:6+2*nv]=a[6:6+nv, 6:6+nv]
    a[6+2*nv:6+3*nv, 6+2*nv:6+3*nv]=a[6:6+nv, 6:6+nv]

    a[:6, :]=a[:, :6].T

    return np.array(solve(a, b))
</file>

<file path="gala/dynamics/actionangle/_genfunc/test_potentials.py">
#################
#   Potentials  #
#################
import numpy as np
from scipy.integrate import quad, ode

Grav = 430091.7270069976

class LMPot(object):
    """ Potential used in Law-Majewski 2010 """
    def __init__(self):
        """ Best-fit parameters - units = kpc, km/s and 10^11 M_sol """
        self.M_disk = 1.
        self.a_disk = 6.5
        self.b_disk = 0.26
        self.M_bulge = 0.34
        self.c_bulge = 0.7
        self.vhalo2 = 121.7**2
        phi = 97./180.*np.pi
        q1 = 1.38
        q2 = 1.
        self.C_1 = (np.cos(phi)/q1)**2+(np.sin(phi)/q2)**2
        self.C_2 = (np.cos(phi)/q2)**2+(np.sin(phi)/q1)**2
        self.C_3 = 2.*np.sin(phi)*np.cos(phi)*(1./q1/q1-1./q2/q2)
        self.q_z = 1.36
        self.rhalo2 = 144.
        rot90 = np.array([[0., 1.],[-1., 0.]])
        self.rotmatrix =  np.dot(rot90, np.linalg.svd(np.array([[self.C_1, self.C_3/2.],[self.C_3/2., self.C_2]]))[0])
        self.invrotmatrix = np.linalg.inv(self.rotmatrix)

    def disk_pot(self, x, y, z):
        R = np.sqrt(x*x+y*y)
        return -Grav*self.M_disk/np.sqrt(R*R+(self.a_disk+np.sqrt(z*z+self.b_disk*self.b_disk))**2)

    def disk_force(self, x, y, z):
        R = np.sqrt(x*x+y*y)
        e = self.a_disk+np.sqrt(z*z+self.b_disk*self.b_disk)
        d = -Grav*self.M_disk/np.sqrt(R*R+e**2)**3
        return np.array([x*d, y*d, z*d*e/(e-self.a_disk)])

    def bulge_pot(self, x, y, z):
        r = np.sqrt(x*x+y*y+z*z)
        return -Grav*self.M_bulge/(r+self.c_bulge)

    def bulge_force(self, x, y, z):
        r = np.sqrt(x*x+y*y+z*z)
        if(r==0.):
            return -Grav*self.M_bulge/(r+self.c_bulge)**2
        else:
            return -Grav*self.M_bulge/(r+self.c_bulge)**2/r*np.array([x, y, z])

    def halo_pot(self, x, y, z):
        return self.vhalo2*np.log(self.C_1*x*x+self.C_2*y*y+self.C_3*x*y+(z/self.q_z)**2+self.rhalo2)

    def halo_force(self, x, y, z):
        p = -self.vhalo2/(self.C_1*x*x+self.C_2*y*y+self.C_3*x*y+(z/self.q_z)**2+self.rhalo2)
        return np.array([(2.*x*self.C_1+self.C_3*y)*p, (2.*y*self.C_2+self.C_3*x)*p, 2.*z*p/self.q_z**2])

    def tot_pot(self, x, y, z):
        return self.disk_pot(x, y, z)+self.bulge_pot(x, y, z)+self.halo_pot(x, y, z)

    def H(self, X):
        return 0.5*np.sum(X[3:]**2)+self.tot_pot(*X[:3])

    def tot_force(self, x, y, z):
        return self.disk_force(x, y, z)+self.bulge_force(x, y, z)+self.halo_force(x, y, z)

    def coordrot(self, x, y):
        return np.dot(self.rotmatrix, np.array([x, y]))

    def invcoordrot(self, x, y):
        return np.dot(self.invrotmatrix, np.array([x, y]))


class log_triax(object):
    """ test triaxial logarithmic potential
        Phi(x, y, z) = 0.5 v_c^2 log(Rc^2+x^2+(y/qy)^2+(z/qz)^2) """
    def __init__(self, vc, Rc, qy, qz):
        self.vc2=vc*vc
        self.Rc2=Rc*Rc
        self.qy2=qy*qy
        self.qz2=qz*qz

    def pot(self, x, y, z):
        return self.vc2/2.*np.log(self.Rc2+x*x+y*y/self.qy2+z*z/self.qz2)

    def H(self, X):
        return 0.5*np.sum(X[3:]**2)+self.pot(*X[:3])

    def tot_force(self, x, y, z):
        p = self.Rc2+x*x+y*y/self.qy2+z*z/self.qz2
        return -self.vc2/p*np.array([x, y/self.qy2, z/self.qz2])


class quartic(object):
    """ Quartic potential
        Phi(x, y, z) = 0.25(lam[0] x^4+lam[1] y^4+lam[2] z^4.
    """

    def __init__(self, lam = np.array([1., 0.8, 3.3])):
        self.lambd = lam

    def H(self, x):
        """ Quartic potential Hamiltonian """
        return 0.5*np.sum(x[3:]**2+0.5*self.lambd*x[:3]**4)

    def tot_force(self, x, y, z):
        """ Derivatives of quartic potential for orbit integration """
        return np.array([-self.lambd[0]*x**3,-self.lambd[1]*y**3,-self.lambd[2]*z**3])

    def action(self, x):
        """ Find true action for quartic potential \Phi = \sum_i 0.25*x_i**4 """
        acts = np.ones(3)
        for i in range(3):
            En = 0.5*x[i+3]**2+0.25*self.lambd[i]*x[i]**4
            xlim=(4.*En/self.lambd[i])**0.25
            acts[i]=2.*quad(lambda y:np.sqrt(2.*En-0.5*self.lambd[i]*y**4), 0., xlim)[0]/np.pi
        return acts

    def freq(self, x):
        """ Find true freq. for quartic potential \Phi = 0.25*x**4 """
        freq = np.ones(3)
        for i in range(3):
            En = 0.5*x[i+3]**2+0.25*self.lambd[i]*x[i]**4
            xlim=(4.*En/self.lambd[i])**0.25
            freq[i]=np.pi/quad(lambda y:2./np.sqrt(2.*En-0.5*self.lambd[i]*y**4), 0., xlim)[0]
        return freq

import sys
# sys.path.append("new_struct")
# import triax_py

class stackel_triax(object):
    """ For interface with C code to find actions in triaxial Stackel potential """
    def __init__(self):
        pass

    def H(self, x):
        """ triaxial stackel potential Hamiltonian """
        return triax_py.Stack_Triax_H(x)

    def tot_force(self, x, y, z):
        """ Derivatives of triaxial stackel potential for orbit integration """
        X = np.array([x, y, z])
        return triax_py.Stack_Triax_Forces(X)

    def action(self, x):
        """ Find true action for triaxial stackel potential """
        return triax_py.Stack_Triax_Actions(x)

    def freq(self, x):
        """ Find true action for triaxial stackel potential """
        return triax_py.Stack_Triax_Freqs(x)


class harmonic_oscillator(object):
    """
        Triaxial harmonic oscillator
        Phi(x, y, z) = 0.5*(omega[0]^2 x^2+omega[1]^2 y^2 + omega[2]^2 z^2
    """
    def __init__(self, omega=np.array([1., 1., 1.])):
        self.omega = omega

    def H(self, x):
        """ Hamiltonian """
        return 0.5*np.sum(x[3:]**2+(self.omega*x[:3])**2)

    def tot_force(self, x, y, z):
        """ Derivatives of ho potential for orbit integration """
        return -np.array([self.omega[0]**2*x, self.omega[1]**2*y, self.omega[2]**2*z])


class isochrone(object):
    """
        Isochrone potential
        Phi(r) = -GM/(b+sqrt(b^2+r^2))
    """
    def __init__(self, par = np.array([1./Grav, 4.2, 0.])):
        """ params = {M, b, r0} """
        self.params = par

    def H(self, x):
        """ Hamiltonian """
        r = (np.sqrt(np.sum(x[:3]**2))-self.params[2])**2
        return 0.5*np.sum(x[3:]**2)-Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))

    def pot(self, x):
        r = (np.sqrt(np.sum(x[:3]**2))-self.params[2])**2
        return -Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))

    def tot_force(self, x, y, z):
        """ Derivatives of isochrone potential for orbit integration """
        r = (np.sqrt(x*x+y*y+z*z)-self.params[2])**2
        fac = np.sqrt(r)/(np.sqrt(r)+self.params[2])
        return np.array([x, y, z])*fac*-Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))**2/np.sqrt(self.params[1]**2+r)


def orbit_derivs(t, x, Pot):
    """ Simple interface for derivatives for orbit integration
        t = time
        x = Cartesian coordinates
        Pot is an object which has a function tot_force(x, y, z) which
        calculates the total force at Cartesian x, y, z """
    X=x[0]
    Y=x[1]
    Z=x[2]
    return np.concatenate((x[3:],Pot.tot_force(X, Y, Z)))

def orbit_derivs2(x, t, Pot):
    return orbit_derivs(t, x, Pot)

import warnings

def orbit_integrate(x, tmax, Pot):
    """ Integrates an orbit with initial coordinates x for time tmax in
    potential Pot using Dormund Prince 8 adaptive step size """
    solver = ode(orbit_derivs).set_integrator('dopri5', n_steps=1, rtol=1e-10, atol=1e-10)
    solver.set_initial_value(x, 0.).set_f_params(Pot)
    solver._integrator.iwork[2] = -1
    warnings.filterwarnings("ignore", category=UserWarning)
    t = np.array([0.])
    while solver.t < tmax:
        solver.integrate(tmax)
        x=np.vstack((x, solver.y))
        t=np.append(t, solver.t)
    warnings.resetwarnings()
    return x, t

def leapfrog_integrator(x, tmax, NT, Pot):
    deltat = tmax/NT
    h = deltat/100.
    t = 0.
    counter = 0
    X = np.copy(x)
    results = np.array([x])
    while(t<tmax):
        X[3:] += 0.5*h*Pot.tot_force(X[0],X[1],X[2])
        X[:3] += h*X[3:]
        X[3:] += 0.5*h*Pot.tot_force(X[0],X[1],X[2])
        # if(t==0.1):
        if(counter % 100 == 0):
            results=np.vstack((results, X))
        t+=h
        counter+=1
    return results
</file>

<file path="gala/dynamics/actionangle/_genfunc/toy_potentials.py">
##################
# Toy Potentials #
##################
import numpy as np
from scipy.optimize import leastsq

# in units kpc, km/s and 10^11 M_solar
# Grav = 430091.5694
Grav = 430091.7270069976 # This was a bug in Sanders' code!

# Triaxial harmonic

def H_ho(x, omega):
    """ Simple harmonic oscillator Hamiltonian = 0.5 * omega**2 * x**2"""
    return 0.5*np.sum(x[3:]**2+(omega*x[:3])**2)


def angact_ho(x, omega):
    """ Calculate angle and action variable in sho potential with
    parameter omega """
    action = (x[3:]**2+(omega*x[:3])**2)/(2.*omega)
    angle = np.array([np.arctan(-x[3+i]/omega[i]/x[i]) if x[i]!=0. else -np.sign(x[3+i])*np.pi/2. for i in range(3)])
    for i in range(3):
        if(x[i]<0):
            angle[i]+=np.pi
    return np.concatenate((action, angle % (2.*np.pi)))


def deltaH_ho(omega, xsamples):
    if(np.any(omega<1e-5)):
        return np.nan
    H = 0.5*np.sum(xsamples.T[3:]**2, axis=0)+0.5*np.sum((omega[:3]*xsamples.T[:3].T)**2, axis=1)
    return H-np.mean(H)

def Jac_deltaH_ho(omega, xsamples):
    dHdparams = omega[:3]*xsamples.T[:3].T**2
    return dHdparams-np.mean(dHdparams, axis=0)

def findbestparams_ho(xsamples):
    """ Minimize sum of square differences of H_sho-<H_sho> for timesamples """
    return np.abs(leastsq(deltaH_ho, np.array([10., 10., 10.]), Dfun = Jac_deltaH_ho, args=(xsamples,))[0])[:3]


# Isochrone

def cart2spol(X):
    """ Performs coordinate transformation from cartesian
    to spherical polar coordinates with (r, phi, theta) having
    usual meanings. """
    x, y, z, vx, vy, vz=X
    r=np.sqrt(x*x+y*y+z*z)
    p=np.arctan2(y, x)
    t=np.arccos(z/r)
    vr=(vx*np.cos(p)+vy*np.sin(p))*np.sin(t)+np.cos(t)*vz
    vp=-vx*np.sin(p)+vy*np.cos(p)
    vt=(vx*np.cos(p)+vy*np.sin(p))*np.cos(t)-np.sin(t)*vz
    return np.array([r, p, t, vr, vp, vt])


def H_iso(x, params):
    """ Isochrone Hamiltonian = -GM/(b+sqrt(b**2+(r-r0)**2))"""
    #r = (np.sqrt(np.sum(x[:3]**2))-params[2])**2
    r = np.sum(x[:3]**2)
    return 0.5*np.sum(x[3:]**2)-Grav*params[0]/(params[1]+np.sqrt(params[1]**2+r))


def angact_iso(x, params):
    """ Calculate angle and action variable in isochrone potential with
    parameters params = (M, b) """
    GM = Grav*params[0]
    E = H_iso(x, params)
    r, p, t, vr, vphi, vt=cart2spol(x)
    st=np.sin(t)
    Lz=r*vphi*st
    L=np.sqrt(r*r*vt*vt+Lz*Lz/st/st)
    if(E>0.):  # Unbound
        return (np.nan, np.nan, np.nan, np.nan, np.nan, np.nan)
    Jr=GM/np.sqrt(-2*E)-0.5*(L+np.sqrt(L*L+4*GM*params[1]))
    action = np.array([Jr, Lz, L-abs(Lz)])

    c=GM/(-2*E)-params[1]
    e=np.sqrt(1-L*L*(1+params[1]/c)/GM/c)
    eta=np.arctan2(r*vr/np.sqrt(-2.*E), params[1]+c-np.sqrt(params[1]**2+r*r))
    OmR=np.power(-2*E, 1.5)/GM
    Omp=0.5*OmR*(1+L/np.sqrt(L*L+4*GM*params[1]))
    thetar=eta-e*c*np.sin(eta)/(c+params[1])

    if(abs(vt)>1e-10):
        psi=np.arctan2(np.cos(t),-np.sin(t)*r*vt/L)
    else:
        psi=np.pi/2.
    a=np.sqrt((1+e)/(1-e))
    ap=np.sqrt((1+e+2*params[1]/c)/(1-e+2*params[1]/c))
    F = lambda x, y: np.pi/2.-np.arctan(np.tan(np.pi/2.-0.5*y)/x) if y>np.pi/2. \
        else -np.pi/2.+np.arctan(np.tan(np.pi/2.+0.5*y)/x) if y<-np.pi/2. \
        else np.arctan(x*np.tan(0.5*y))

    thetaz=psi+Omp*thetar/OmR-F(a, eta)-F(ap, eta)/np.sqrt(1+4*GM*params[1]/L/L)

    LR=Lz/L
    sinu = LR/np.sqrt(1.-LR**2)/np.tan(t)
    u = 0
    if(sinu>1.):
        u=np.pi/2.
    elif(sinu<-1.):
        u = -np.pi/2.
    else:
        u = np.arcsin(sinu)
    if(vt>0.):
        u=np.pi-u
    thetap=p-u+np.sign(Lz)*thetaz
    angle = np.array([thetar, thetap, thetaz])
    return np.concatenate((action, angle % (2.*np.pi)))


def deltaH_iso(params, p, r):
    deltaH = p-Grav*params[0]/(params[1]+np.sqrt(params[1]**2+r))
    if(params[0]<0. or params[1]<0. or np.any(deltaH>0.)):
        return np.nan
    return (deltaH-np.mean(deltaH))
    # return JR-np.mean(JR)


def Jac_deltaH_iso(params, p, r):
    H_o = -Grav/(params[1]+np.sqrt(params[1]**2+r))
    H_1 = Grav*params[0]*(1.+params[1]/np.sqrt(params[1]**2+r))/(params[1]+np.sqrt(params[1]**2+r))**2
    return np.array([(H_o-np.mean(H_o)), (H_1-np.mean(H_1))])


def findbestparams_iso(xsamples):
    """ Minimize sum of square differences of H_iso-<H_iso> for timesamples"""
    p = 0.5*np.sum(xsamples.T[3:]**2, axis=0)
    r = np.sum(xsamples.T[:3]**2, axis=0)
    return np.abs(leastsq(deltaH_iso, np.array([10., 10.]), Dfun = None , col_deriv=1, args=(p, r,))[0]) #Jac_deltaH_iso
</file>

<file path="gala/dynamics/actionangle/_genfunc/visualize_surfaces.py">
# For plotting the S_n

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx

def meshgrid2(*arrs):
    arrs = tuple(reversed(arrs))  #edit
    lens = map(len, arrs)
    dim = len(arrs)

    sz = 1
    for s in lens:
        sz*=s

    ans = []
    for i, arr in enumerate(arrs):
        slc = [1]*dim
        slc[i] = lens[i]
        arr2 = np.asarray(arr).reshape(slc)
        for j, sz in enumerate(lens):
            if j!=i:
                arr2 = arr2.repeat(sz, axis=j)
        ans.append(arr2)

    return tuple(ans)

def conv(x, acts):
    return np.log((np.exp(x)-0.1)/acts+0.1)

def Sn_plots(inp, outp, actions, loop):
    Sn = np.genfromtxt(inp)
    loop_acts = actions
    acts = np.sum(loop_acts)
    acts = 1
    dx = 2
    if(loop):
        dx = 1
    x = np.arange(np.min(Sn.T[0])-2, np.max(Sn.T[0])+2, dx)
    y = np.arange(np.min(Sn.T[1])-4, np.max(Sn.T[1])+4, 2)
    z = np.arange(-np.max(Sn.T[2])-2, np.max(Sn.T[2])+4, 2)
    length_x = len(x)
    length_y = len(y)
    length_z = len(z)

    X, Y, Z = meshgrid2(x, y, z)
    S = np.zeros(np.shape(X.T))
    for i in Sn:
        xindex = np.where(np.abs(x-i[0])<1e-5)[0][0]
        yindex = np.where(np.abs(y-i[1])<1e-5)[0][0]
        zindex = np.where(np.abs(z-i[2])<1e-5)[0][0]
        S[xindex][yindex][zindex]=np.log(np.abs(i[3]/acts)+0.1)
        S[length_x-xindex-1][length_y-yindex-1][length_z-zindex-1]=np.log(np.abs(i[3]/acts)+0.1)

    R = np.zeros((length_x, length_z))
    R2 = np.zeros((length_x, length_y))
    for j, i in enumerate(S):
        R[j]=i[length_y/2]

    f, a = plt.subplots(2, 1, figsize=[3.32, 3.6])
    plt.subplots_adjust(right=0.75, wspace=0.4, hspace=0.3)
    conts = map(lambda x: conv(x, acts),[0.15, 0.5, 1., 1.5, 2., 2.5])
    if(loop):
        a[0].set_xlim(-6, 6)
        a[0].set_ylim(-6, 6)
        a[1].set_xlim(-6, 6)
        a[1].set_ylim(-6, 6)
    else:
        a[0].set_xlim(-6, 6)
        a[0].set_ylim(-6, 6)
        a[1].set_xlim(-6, 6)
        a[1].set_ylim(-6, 6)

    a[0].contour(x, y, S.T[length_z/2],levels=conts)
    a[0].set_xlabel(r'$n_1$')
    a[0].set_ylabel(r'$n_2$')
    a[0].set_aspect('equal')
    a[0].text(2, 4, r'$n_3=0$')
    a[0].text(3, 7, outp)

    R = np.zeros((length_x, length_z))
    for j, i in enumerate(S):
        R[j]=i[length_y/2]

    cNorm = colors.Normalize(vmin=np.min(conts), vmax=np.max(conts))
    sM = cmx.ScalarMappable(norm=cNorm)
    sM._A = []
    C = a[1].contour(x, z, R.T, levels=conts)
    # print R.T
    a[1].set_aspect('equal')
    a[1].set_xlabel(r'$n_1$')
    a[1].set_ylabel(r'$n_3$')
    a[1].text(2, 4.5, r'$n_2=0$')
    # a[1].set_xlim(np.min(y), np.max(y))
    cbar_ax = f.add_axes([0.75, 0.15, 0.05, 0.7])
    ccc = f.colorbar(sM, cax=cbar_ax)
    ccc.set_label(r'$\log(|S_n / \rm{kpc}\,\rm{km}\,\rm{s}^{-1}|+0.1)$')
    plt.savefig(outp+"_planes.pdf")
</file>

<file path="gala/dynamics/actionangle/tests/helpers.py">
""" Test helpers """

# Third-party
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np

# Project
# from ..actionangle import classify_orbit
from gala.units import galactic
from gala.potential import HarmonicOscillatorPotential, IsochronePotential
from .._genfunc import genfunc_3d


def sanders_nvecs(N_max, dx, dy, dz):
    from itertools import product
    NNx = range(-N_max, N_max+1, dx)
    NNy = range(-N_max, N_max+1, dy)
    NNz = range(-N_max, N_max+1, dz)
    n_vectors = np.array([[i, j, k] for (i, j, k) in product(NNx, NNy, NNz)
                          if (not (i == 0 and j == 0 and k == 0)        # exclude zero vector
                              and (k > 0                                # northern hemisphere
                                   or (k == 0 and j > 0)                # half of x-y plane
                                   or (k == 0 and j == 0 and i > 0))    # half of x axis
                              and np.sqrt(i*i + j*j + k*k) <= N_max)])  # inside sphere
    return n_vectors


def sanders_act_ang_freq(t, w, circ, N_max=6):
    w2 = w.copy()

    if np.any(circ):
        w2[3:] = (w2[3:]*u.kpc/u.Myr).to(u.km/u.s).value
        (act, ang, n_vec, toy_aa, pars), loop2 = genfunc_3d.find_actions(
            w2.T, t/1000., N_matrix=N_max, ifloop=True)
    else:
        (act, ang, n_vec, toy_aa, pars), loop2 = genfunc_3d.find_actions(
            w2.T, t, N_matrix=N_max, ifloop=True)

    actions = act[:3]
    angles = ang[:3]
    freqs = ang[3:6]

    if np.any(circ):
        toy_potential = IsochronePotential(m=pars[0]*1E11, b=pars[1], units=galactic)
        actions = (actions*u.kpc*u.km/u.s).to(u.kpc**2/u.Myr).value
        freqs = (freqs/u.Gyr).to(1/u.Myr).value
    else:
        toy_potential = HarmonicOscillatorPotential(omega=np.array(pars), units=galactic)

    return actions, angles, freqs, toy_potential


def _crazy_angle_loop(theta1, theta2, ax):
    cnt = 0
    ix1 = 0
    while True:
        cnt += 1

        for ix2 in range(ix1, ix1+1000):
            if ix2 > len(theta1)-1:
                ix2 = len(theta1)-1
                break

            if theta1[ix2] < theta1[ix1] or theta2[ix2] < theta2[ix1]:
                ix2 -= 1
                break

        if theta1[ix2] != theta1[ix1:ix2+1].max() or theta2[ix2] != theta2[ix1:ix2+1].max():
            ix1 = ix2+1
            continue

        if cnt > 100 or ix2 == len(theta1)-1:
            break

        if ix1 == ix2:
            ix1 = ix2+1
            continue

        ax.plot(theta1[ix1:ix2+1], theta2[ix1:ix2+1], alpha=0.5, marker='o', c='k')

        ix1 = ix2+1


def plot_angles(t, angles, freqs, subsample_factor=1000):
    theta = (angles[:, None] + freqs[:, None]*t[np.newaxis])
    subsample = theta.shape[1]//subsample_factor
#    subsample = 1
    theta = (theta[:, ::subsample] / np.pi) % 2.
    print(theta.shape)
    fig, axes = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(10, 5))
    # _crazy_angle_loop(theta[0], theta[1], axes[0])
    # _crazy_angle_loop(theta[0], theta[2], axes[1])
    axes[0].plot(theta[0], theta[1], ls='none')
    axes[0].plot(theta[0], theta[2], ls='none')

    axes[0].set_xlim(0, 2)
    axes[0].set_ylim(0, 2)
    return fig
    # axes[1].scatter(theta[0, ix], theta[2], alpha=0.5, marker='o', c=t)


def isotropic_w0(N=100):
    # positions
    d = np.random.lognormal(mean=np.log(25), sigma=0.5, size=N)
    phi = np.random.uniform(0, 2*np.pi, size=N)
    theta = np.arccos(np.random.uniform(size=N) - 0.5)

    vr = np.random.normal(150., 40., size=N)*u.km/u.s
    vt = np.random.normal(100., 40., size=N)
    vt = np.vstack((vt, np.zeros_like(vt))).T

    # rotate to be random position angle
    pa = np.random.uniform(0, 2*np.pi, size=N)
    M = np.array([[np.cos(pa), -np.sin(pa)], [np.sin(pa), np.cos(pa)]]).T
    vt = np.array([vv.dot(MM) for (vv, MM) in zip(vt, M)])*u.km/u.s
    vphi, vtheta = vt.T

    rep = coord.PhysicsSphericalRepresentation(r=d*u.dimensionless_unscaled,
                                               phi=phi*u.radian,
                                               theta=theta*u.radian)
    x = rep.represent_as(coord.CartesianRepresentation).xyz.T.value

    vr = vr.decompose(galactic).value * u.one
    vphi = vphi.decompose(galactic).value * u.one
    vtheta = vtheta.decompose(galactic).value * u.one

    vsph = coord.PhysicsSphericalDifferential(d_phi=vphi/(d*np.sin(theta)),
                                              d_theta=vtheta/d,
                                              d_r=vr)

    with u.set_enabled_equivalencies(u.dimensionless_angles()):
        v = vsph.represent_as(coord.CartesianDifferential,
                              base=rep).d_xyz.value.T

    return np.hstack((x, v)).T
</file>

<file path="gala/dynamics/actionangle/tests/staeckel_helpers.py">
from collections.abc import Iterable

import astropy.coordinates as coord
import astropy.table as at
import astropy.units as u
import numpy as np

from gala.dynamics import Orbit

from ..actionangle_staeckel import get_staeckel_fudge_delta


__all__ = ["galpy_find_actions_staeckel"]


def galpy_find_actions_staeckel(
    potential, w, mean=True, delta=None, ro=None, vo=None
):
    """
    Compute approximate actions, angles, and frequencies using the Staeckel
    Fudge as implemented in Galpy. If you use this function, please also cite
    Galpy in your work (Bovy 2015).

    Parameters
    ----------
    potential : potential-like
        A Gala potential instances.
    w : `~gala.dynamics.PhaseSpacePosition` or `~gala.dynamics.Orbit`
        Either a set of initial conditions / phase-space positions, or a set of
        orbits computed in the input potential.
    mean : bool (optional)
        If an `~gala.dynamics.Orbit` is passed in, take the mean over actions
        and frequencies.
    delta : numeric, array-like (optional)
        The focal length parameter, ∆, used by the Staeckel fudge. This is
        computed if not provided.
    ro : quantity-like (optional)
    vo : quantity-like (optional)

    Returns
    -------
    aaf : `astropy.table.QTable`
        An Astropy table containing the actions, angles, and frequencies for
        each input phase-space position or orbit.

    """
    from galpy.actionAngle import actionAngleStaeckel

    if delta is None:
        delta = get_staeckel_fudge_delta(potential, w)

    galpy_potential = potential.to_galpy_potential(ro, vo)
    if isinstance(galpy_potential, list):
        ro = galpy_potential[0]._ro * u.kpc
        vo = galpy_potential[0]._vo * u.km / u.s
    else:
        ro = galpy_potential._ro * u.kpc
        vo = galpy_potential._vo * u.km / u.s

    if not isinstance(w, Orbit):
        w = Orbit(w.pos[None], w.vel[None], t=[0.0] * potential.units["time"])

    if w.norbits == 1:
        iter_ = [w]
    else:
        iter_ = w.orbit_gen()

    if isinstance(delta, u.Quantity):
        delta = np.atleast_1d(delta)

    if not isinstance(delta, Iterable):
        delta = [delta] * w.norbits

    if len(delta) != w.norbits:
        raise ValueError(
            "Input delta must have same shape as the inputted number of orbits"
        )

    rows = []
    for w_, delta_ in zip(iter_, delta):
        o = w_.to_galpy_orbit(ro, vo)
        aAS = actionAngleStaeckel(pot=galpy_potential, delta=delta_)

        aaf = aAS.actionsFreqsAngles(o)
        aaf = {
            "actions": np.array(aaf[:3]).T * ro * vo,
            "freqs": np.array(aaf[3:6]).T * vo / ro,
            "angles": coord.Angle(np.array(aaf[6:]).T * u.rad),
        }
        if mean:
            aaf["actions"] = np.nanmean(aaf["actions"], axis=0)
            aaf["freqs"] = np.nanmean(aaf["freqs"], axis=0)
            aaf["angles"] = aaf["angles"][0]
        rows.append(aaf)
    return at.QTable(rows=rows)
</file>

<file path="gala/dynamics/actionangle/tests/test_actionangle_o2gf.py">
""" Test action-angle stuff """

# Standard library
import logging
import warnings

# Third-party
import astropy.units as u
import numpy as np
from gala.logging import logger
from scipy.linalg import solve
import pytest

# Project
from gala.integrate import DOPRI853Integrator
from gala.potential import (
    IsochronePotential,
    HarmonicOscillatorPotential,
    LeeSutoTriaxialNFWPotential,
    Hamiltonian,
)
from gala.units import galactic
from gala.dynamics.actionangle import (
    fit_isochrone,
    fit_harmonic_oscillator,
    fit_toy_potential,
    check_angle_sampling,
    find_actions_o2gf,
    generate_n_vectors,
)
from gala.dynamics.actionangle._genfunc import genfunc_3d, solver
from .helpers import sanders_nvecs, sanders_act_ang_freq, isotropic_w0

logger.setLevel(logging.DEBUG)


def test_generate_n_vectors():
    # test against Sanders' method
    nvecs = generate_n_vectors(N_max=6, dx=2, dy=2, dz=2)
    nvecs_sanders = sanders_nvecs(N_max=6, dx=2, dy=2, dz=2)
    assert np.all(nvecs == nvecs_sanders)

    nvecs = generate_n_vectors(N_max=6, dx=1, dy=1, dz=1)
    nvecs_sanders = sanders_nvecs(N_max=6, dx=1, dy=1, dz=1)
    assert np.all(nvecs == nvecs_sanders)


def test_fit_isochrone():
    # integrate orbit in Isochrone potential, then try to recover it
    true_m = 2.81e11
    true_b = 11.0
    potential = IsochronePotential(m=true_m, b=true_b, units=galactic)
    H = Hamiltonian(potential)
    orbit = H.integrate_orbit([15.0, 0, 0, 0, 0.2, 0], dt=2.0, n_steps=10000)

    fit_potential = fit_isochrone(orbit)
    m, b = (
        fit_potential.parameters["m"].value,
        fit_potential.parameters["b"].value,
    )
    assert np.allclose(m, true_m, rtol=1e-2)
    assert np.allclose(b, true_b, rtol=1e-2)


def test_fit_harmonic_oscillator():
    # integrate orbit in harmonic oscillator potential, then try to recover it
    true_omegas = np.array([0.011, 0.032, 0.045])
    potential = HarmonicOscillatorPotential(omega=true_omegas, units=galactic)
    H = Hamiltonian(potential)
    orbit = H.integrate_orbit([15.0, 1, 2, 0, 0, 0], dt=2.0, n_steps=10000)

    fit_potential = fit_harmonic_oscillator(orbit)
    omegas = fit_potential.parameters["omega"].value
    assert np.allclose(omegas, true_omegas, rtol=1e-2)


def test_fit_toy_potential():
    # integrate orbit in both toy potentials, make sure correct one is chosen
    true_m = 2.81e11
    true_b = 11.0
    true_potential = IsochronePotential(m=true_m, b=true_b, units=galactic)
    H = Hamiltonian(true_potential)
    orbit = H.integrate_orbit([15.0, 0, 0, 0, 0.2, 0], dt=2.0, n_steps=10000)

    potential = fit_toy_potential(orbit)
    for k, v in true_potential.parameters.items():
        assert u.allclose(v, potential.parameters[k], rtol=1e-2)

    # -----------------------------------------------------------------
    true_omegas = np.array([0.011, 0.032, 0.045])
    true_potential = HarmonicOscillatorPotential(
        omega=true_omegas, units=galactic
    )
    H = Hamiltonian(true_potential)
    orbit = H.integrate_orbit([15.0, 1, 2, 0, 0, 0], dt=2.0, n_steps=10000)

    potential = fit_toy_potential(orbit)

    assert u.allclose(
        potential.parameters["omega"],
        true_potential.parameters["omega"],
        rtol=1e-2,
    )


def test_check_angle_sampling():

    # frequencies
    omegas = np.array([0.21, 0.3421, 0.4968])

    # integer vectors
    nvecs = generate_n_vectors(N_max=6)

    # loop over times with known failures:
    #   - first one fails needing longer integration time
    #   - second one fails needing finer sampling
    for i, t in enumerate(
        [np.linspace(0, 50, 500), np.linspace(0, 8000, 8000)]
    ):
        # periods = 2*np.pi/omegas
        # print("Periods:", periods)
        # print("N periods:", t.max() / periods)

        angles = t[np.newaxis] * omegas[:, np.newaxis]
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            checks, failures = check_angle_sampling(nvecs, angles)

        assert np.all(failures == i)


class ActionsBase:

    def test_classify(self):
        # my classify
        orb_type = self.orbit.circulation()

        # compare to Sanders'
        for j in range(self.N):
            sdrs = genfunc_3d.assess_angmom(self.w[..., j].T)
            logger.debug("APW: {}, Sanders: {}".format(orb_type[:, j], sdrs))
            assert np.all(orb_type[:, j] == sdrs)

    def test_actions(self):
        # t = self.t[::10]
        t = self.t

        N_max = 6
        for n in range(self.N):
            print("\n\n")
            print(
                "======================= Orbit {} =======================".format(
                    n
                )
            )
            # w = self.w[:, ::10, n]
            w = self.w[..., n]
            orb = self.orbit[:, n]
            circ = orb.circulation()

            # get values from Sanders' code
            print("Computing actions from genfunc...")
            s_actions, s_angles, s_freqs, toy_potential = sanders_act_ang_freq(
                t, w, circ, N_max=N_max
            )

            print("Computing actions with gala...")
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", UserWarning)
                ret = find_actions_o2gf(
                    orb, N_max=N_max, toy_potential=toy_potential
                )
            actions = ret["actions"]
            angles = ret["angles"]
            freqs = ret["freqs"]

            print("Action ratio: {}".format(actions / s_actions))
            print("Angle ratio: {}".format(angles / s_angles))
            print("Freq ratio: {}".format(freqs / s_freqs))

            assert np.allclose(actions.value, s_actions, rtol=1e-5)
            assert np.allclose(angles.value, s_angles, rtol=1e-5)
            assert np.allclose(freqs.value, s_freqs, rtol=1e-5)

            # logger.debug("Plotting orbit...")
            # fig = plot_orbits(w, marker='.', alpha=0.2, linestyle='none')
            # fig.savefig(str(self.plot_path.join("orbit_{}.png".format(n))))

            # fig = plot_angles(t, angles, freqs)
            # fig.savefig(str(self.plot_path.join("angles_{}.png".format(n))))

            # fig = plot_angles(t, s_angles, s_freqs)
            # fig.savefig(str(self.plot_path.join("angles_sanders_{}.png".format(n))))

            # plt.close('all')

            # print("Plots saved at:", self.plot_path)


class TestActions(ActionsBase):

    @pytest.fixture(autouse=True)
    def setup_method(self, tmpdir):
        self.plot_path = tmpdir.mkdir("normal")

        self.units = galactic
        self.potential = LeeSutoTriaxialNFWPotential(
            v_c=0.2, r_s=20.0, a=1.0, b=0.77, c=0.55, units=galactic
        )
        self.N = 8
        np.random.seed(42)
        w0 = isotropic_w0(N=self.N)
        n_steps = 20000

        # integrate orbits
        H = Hamiltonian(self.potential)
        orbit = H.integrate_orbit(
            w0, dt=2.0, n_steps=n_steps, Integrator=DOPRI853Integrator
        )
        self.orbit = orbit
        self.t = orbit.t.value
        self.w = orbit.w()


def test_compare_action_prepare():

    from gala.dynamics.actionangle.actionangle_o2gf import (
        _action_prepare, _angle_prepare)

    logger.setLevel(logging.ERROR)
    AA = np.random.uniform(0.0, 100.0, size=(1000, 6))
    t = np.linspace(0.0, 100.0, 1000)

    act_san, n_vectors = solver.solver(AA, N_max=6, symNx=2)
    A2, b2, n = _action_prepare(AA.T, N_max=6, dx=2, dy=2, dz=2)
    act_apw = np.array(solve(A2, b2))

    ang_san = solver.angle_solver(AA, t, N_max=6, symNx=2, sign=1)
    A2, b2, n = _angle_prepare(AA.T, t, N_max=6, dx=2, dy=2, dz=2)
    ang_apw = np.array(solve(A2, b2))

    assert np.allclose(act_apw, act_san)
    # assert np.allclose(ang_apw, ang_san)

    # TODO: this could be critical -- why don't our angles agree?


def test_regression_113():
    """Test that fit_isochrone succeeds for a variety of orbits. See issue:
    https://github.com/adrn/gala/issues/113
    """
    from gala.potential import MilkyWayPotential, Hamiltonian
    from gala.dynamics import PhaseSpacePosition

    pot = MilkyWayPotential()

    dt = 0.01
    n_steps = 50000

    rvec = [0.3, 0, 0] * u.kpc
    vinit = pot.circular_velocity(rvec)[0].to(u.km / u.s).value
    vvec = [0, vinit * np.cos(0.01), vinit * np.sin(0.01)] * u.km / u.s
    vvec = 0.999 * vvec

    ics = PhaseSpacePosition(pos=rvec, vel=vvec)
    H = Hamiltonian(pot)
    orbit = H.integrate_orbit(ics, dt=dt, n_steps=n_steps)
    toy_potential = fit_isochrone(orbit)

    assert u.allclose(toy_potential.energy(rvec), pot.energy(rvec), rtol=1e-2)
</file>

<file path="gala/dynamics/actionangle/tests/test_actionangle_staeckel.py">
# Third-party
from astropy.constants import G
import astropy.units as u
import numpy as np
import pytest

# gala
from gala.dynamics import PhaseSpacePosition
from gala.dynamics.actionangle import (
    get_staeckel_fudge_delta,
    find_actions_o2gf
)
from gala.dynamics.actionangle.tests.staeckel_helpers import galpy_find_actions_staeckel
import gala.potential as gp
from gala.units import galactic
from gala.tests.optional_deps import HAS_GALPY


@pytest.mark.skipif(not HAS_GALPY,
                    reason="requires galpy to run this test")
def test_staeckel_fudge_delta():
    import galpy.potential as galpy_pot
    from galpy.actionAngle import estimateDeltaStaeckel

    ro = 8.1 * u.kpc
    vo = 229 * u.km/u.s

    paired_potentials = []

    # Miyamoto-Nagai
    potential = gp.MiyamotoNagaiPotential(
        m=6e10*u.Msun, a=3*u.kpc, b=0.3*u.kpc, units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['a'].to_value(ro)
    b = potential.parameters['b'].to_value(ro)
    galpy_potential = galpy_pot.MiyamotoNagaiPotential(amp=amp, a=a, b=b,
                                                       ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # Hernquist
    potential = gp.HernquistPotential(m=6e10*u.Msun, c=0.3*u.kpc,
                                      units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['c'].to_value(ro)
    galpy_potential = galpy_pot.HernquistPotential(amp=amp, a=a,
                                                   ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # NFW
    potential = gp.NFWPotential(m=6e11*u.Msun, r_s=15.6*u.kpc,
                                units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['r_s'].to_value(ro)
    galpy_potential = galpy_pot.NFWPotential(amp=amp, a=a, ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # TEST:
    # TODO: remove the randomness here
    N = 1024
    rnd = np.random.default_rng(42)
    w = PhaseSpacePosition(
        pos=rnd.uniform(-10, 10, size=(3, N)) * u.kpc,
        vel=rnd.uniform(-100, 100, size=(3, N)) * u.km/u.s
    )

    R = w.cylindrical.rho.to_value(ro)
    z = w.z.to_value(ro)

    for p, galpy_p in paired_potentials:
        galpy_deltas = estimateDeltaStaeckel(galpy_p, R, z,
                                             no_median=True)
        gala_deltas = get_staeckel_fudge_delta(p, w).value
        assert np.allclose(gala_deltas, galpy_deltas, atol=1e-5, rtol=1e-3)


@pytest.mark.skipif(not HAS_GALPY,
                    reason="requires galpy to run this test")
def test_find_actions_staeckel():
    """
    This test function performs some unit test checks of the API
    """
    disk = gp.MiyamotoNagaiPotential(5e10, 3.5, 0.3, units=galactic)
    halo = gp.NFWPotential.from_M200_c(1e12*u.Msun, 15, units=galactic)
    pot = disk + halo

    xyz = (np.zeros((3, 16)) + 1e-5) * u.kpc
    xyz[0] = np.linspace(4, 20, xyz.shape[1]) * u.kpc

    vxyz = np.zeros((3, 16)) * u.km/u.s
    vxyz[0] = 15 * u.km/u.s
    vxyz[1] = pot.circular_velocity(xyz)
    vxyz[2] = 15 * u.km/u.s

    w0_one = PhaseSpacePosition(xyz[:, 0], vxyz[:, 0])
    w0_many = PhaseSpacePosition(xyz, vxyz)
    orbit_one = pot.integrate_orbit(w0_one, dt=1., n_steps=1000)
    orbit_many = pot.integrate_orbit(w0_many, dt=1., n_steps=1000)

    inputs = [
        w0_one,
        w0_many,
        orbit_one,
        orbit_many
    ]
    shapes = [
        (1, 3),
        (xyz.shape[1], 3),
        (1, 3),
        (xyz.shape[1], 3)
    ]
    for w, colshape in zip(inputs, shapes):
        aaf = galpy_find_actions_staeckel(pot, w)

        for colname in ['actions', 'freqs']:
            assert aaf[colname].shape == colshape

    # Check that mean=False returns the right shape
    aaf = galpy_find_actions_staeckel(pot, orbit_one, mean=False)
    for colname in ['actions', 'freqs', 'angles']:
        assert aaf[colname].shape == (1, orbit_one.ntimes, 3)

    aaf = galpy_find_actions_staeckel(pot, orbit_many, mean=False)
    for colname in ['actions', 'freqs', 'angles']:
        assert aaf[colname].shape == (xyz.shape[1], orbit_one.ntimes, 3)


@pytest.mark.skipif(not HAS_GALPY,
                    reason="requires galpy to run this test")
def test_compare_staeckel_o2gf():
    """
    This test function performs some comparisons between actions, angles,
    and frequencies solved from the staeckel fudge and O2GF.
    """
    disk = gp.MiyamotoNagaiPotential(5e10, 3.5, 0.3, units=galactic)
    halo = gp.NFWPotential.from_M200_c(1e12*u.Msun, 15, units=galactic)
    pot = disk + halo

    xyz = (np.zeros((3, 16)) + 1e-5) * u.kpc
    xyz[0] = np.linspace(4, 20, xyz.shape[1]) * u.kpc

    vxyz = np.zeros((3, 16)) * u.km/u.s
    vxyz[0] = 15 * u.km/u.s
    vxyz[1] = pot.circular_velocity(xyz)
    vxyz[2] = 15 * u.km/u.s

    orbits = pot.integrate_orbit(
        PhaseSpacePosition(xyz, vxyz),
        dt=1., n_steps=20_000
    )

    aaf_staeckel = galpy_find_actions_staeckel(pot, orbits)
    aaf_o2gf = find_actions_o2gf(orbits, N_max=10)

    assert u.allclose(aaf_staeckel['actions'], aaf_o2gf['actions'], rtol=1e-3)
    with u.set_enabled_equivalencies(u.dimensionless_angles()):
        assert u.allclose(aaf_staeckel['freqs'], aaf_o2gf['freqs'], rtol=1e-3)
    assert u.allclose(aaf_staeckel['angles'], aaf_o2gf['angles'], rtol=1.5e-2)
</file>

<file path="gala/dynamics/actionangle/tests/test_analyticactionangle.py">
# Third-party
import numpy as np
import astropy.units as u

# Project
from gala.dynamics.actionangle import (
    isochrone_xv_to_aa,
    isochrone_aa_to_xv,
    harmonic_oscillator_xv_to_aa,
)
from gala.logging import logger
from gala.potential import (
    IsochronePotential,
    HarmonicOscillatorPotential,
    Hamiltonian,
)
from gala.units import galactic
from gala.util import assert_angles_allclose
from gala.dynamics.actionangle._genfunc import toy_potentials
from gala.tests.optional_deps import HAS_TWOBODY


class TestIsochrone(object):
    def setup_method(self):
        logger.info("======== Isochrone ========")
        N = 100
        rng = np.random.default_rng(42)
        x = rng.uniform(-10.0, 10.0, size=(3, N))
        v = rng.uniform(-1.0, 1.0, size=(3, N)) / 33.0
        w0 = np.vstack((x, v))

        self.potential = IsochronePotential(units=galactic, m=1.0e11, b=5.0)
        H = Hamiltonian(self.potential)
        self.w = H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        self.w = self.w[::10]

    def test_single(self):
        n = 13  # MAGIC NUMBER to pick one orbit

        # First, check that value of the actions are stable
        actions, angles, freqs = isochrone_xv_to_aa(
            self.w[:, n], self.potential
        )
        for i in range(3):
            assert u.allclose(actions[i, 1:], actions[i, 0], rtol=1e-5)

        for slice_ in [slice(None), 0]:
            actions, angles, freqs = isochrone_xv_to_aa(
                self.w[slice_, n], self.potential
            )

            # Compare to genfunc
            x = self.w.xyz[:, slice_, n]
            v = self.w.v_xyz[:, slice_, n]
            m = self.potential.parameters["m"].value / 1e11
            b = self.potential.parameters["b"].value

            if x.ndim > 1:
                s_w = np.vstack((
                    x.to_value(u.kpc),
                    v.to_value(u.km / u.s)
                ))

                aa = np.array(
                    [
                        toy_potentials.angact_iso(s_w[:, i].T, params=(m, b))
                        for i in range(s_w.shape[1])
                    ]
                )
                s_actions = aa[:, :3] * u.km / u.s * u.kpc
                s_angles = aa[:, 3:] * u.rad

            else:
                s_w = np.concatenate((
                    x.to_value(u.kpc),
                    v.to_value(u.km / u.s)
                ))

                aa = toy_potentials.angact_iso(s_w.T, params=(m, b))
                s_actions = aa[:3] * u.km / u.s * u.kpc
                s_angles = aa[3:] * u.rad

            assert u.allclose(actions, s_actions.T, rtol=1e-8)
            assert_angles_allclose(angles, s_angles.T, rtol=1e-8)

            # Test round-tripping
            if HAS_TWOBODY:
                w_rt = isochrone_aa_to_xv(actions, angles, self.potential)

                assert u.allclose(x, w_rt.xyz, atol=1E-10 * u.kpc)
                assert u.allclose(v, w_rt.v_xyz, atol=1E-10 * u.km/u.s)

    def test_many(self):
        actions, angles, freqs = isochrone_xv_to_aa(
            self.w, self.potential
        )

        # Compare first element of orbit to genfunc, for speed
        x = self.w.xyz
        v = self.w.v_xyz
        m = self.potential.parameters["m"].value / 1e11
        b = self.potential.parameters["b"].value

        s_w = np.vstack((
            x[:, 0].to_value(u.kpc),
            v[:, 0].to_value(u.km / u.s)
        ))

        aa = np.array(
            [
                toy_potentials.angact_iso(s_w[:, i].T, params=(m, b))
                for i in range(s_w.shape[1])
            ]
        )
        s_actions = aa[:, :3] * u.km / u.s * u.kpc
        s_angles = aa[:, 3:] * u.rad

        assert u.allclose(actions[:, 0], s_actions.T, rtol=1e-8)
        assert_angles_allclose(angles[:, 0], s_angles.T, rtol=1e-8)

        # Test round-tripping
        if HAS_TWOBODY:
            # Check round-tripping for full orbits:
            w_rt = isochrone_aa_to_xv(actions, angles, self.potential)

            assert u.allclose(x, w_rt.xyz, atol=1E-10 * u.kpc)
            assert u.allclose(v, w_rt.v_xyz, atol=1E-10 * u.km/u.s)


class TestHarmonicOscillator(object):
    def setup_method(self):
        logger.info("======== Harmonic Oscillator ========")
        self.N = 100
        np.random.seed(42)
        x = np.random.uniform(-10.0, 10.0, size=(3, self.N))
        v = np.random.uniform(-1.0, 1.0, size=(3, self.N)) / 33.0
        w0 = np.vstack((x, v))

        self.potential = HarmonicOscillatorPotential(
            omega=np.array([0.013, 0.02, 0.005]), units=galactic
        )
        H = Hamiltonian(self.potential)
        self.w = H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        self.w = self.w[::10]

    def test(self):
        """
        !!!!! NOTE !!!!!
        For Harmonic Oscillator, Sanders' code works for the units I use...
        """
        for n in range(self.N):
            logger.debug("Orbit {}".format(n))

            actions, angles, freq = harmonic_oscillator_xv_to_aa(
                self.w[:, n], self.potential
            )
            actions = actions.value
            angles = angles.value

            for i in range(3):
                assert np.allclose(actions[i, 1:], actions[i, 0], rtol=1e-5)

            # Compare to genfunc
            x = self.w.xyz.value[..., n]
            v = self.w.v_xyz.value[..., n]
            s_w = np.vstack((x, v))
            omega = self.potential.parameters["omega"].value
            aa = np.array(
                [
                    toy_potentials.angact_ho(s_w[:, i].T, omega=omega)
                    for i in range(s_w.shape[1])
                ]
            )
            s_actions = aa[:, :3]
            s_angles = aa[:, 3:]

            assert np.allclose(actions, s_actions.T, rtol=1e-8)
            assert_angles_allclose(angles, s_angles.T, rtol=1e-8)

            # test roundtrip
            # x2, v2 = harmonic_oscillator_aa_to_xv(actions, angles, self.potential)
            # TODO: transform back??
</file>

<file path="gala/dynamics/actionangle/__init__.py">
from .analyticactionangle import *
from .actionangle_o2gf import *
from .actionangle_staeckel import *
</file>

<file path="gala/dynamics/actionangle/actionangle_o2gf.py">
"""
Utilities for estimating actions and angles for an arbitrary orbit in an
arbitrary potential.
"""

# Standard library
import time
import warnings

# Third-party
from astropy.constants import G
import astropy.table as at
import astropy.units as u
from astropy.utils.decorators import deprecated
import numpy as np
from scipy.linalg import solve
from scipy.optimize import minimize

# Project
from gala.logging import logger
from gala.util import GalaDeprecationWarning

__all__ = ['generate_n_vectors', 'fit_isochrone',
           'fit_harmonic_oscillator', 'fit_toy_potential', 'check_angle_sampling',
           'find_actions_o2gf', 'find_actions']


def generate_n_vectors(N_max, dx=1, dy=1, dz=1, half_lattice=True):
    r"""
    Generate integer vectors, :math:`\boldsymbol{n}`, with
    :math:`|\boldsymbol{n}| < N_{\rm max}`.

    If ``half_lattice=True``, only return half of the three-dimensional
    lattice. If the set N = {(i, j, k)} defines the lattice, we restrict to
    the cases such that ``(k > 0)``, ``(k = 0, j > 0)``, and
    ``(k = 0, j = 0, i > 0)``.

    .. todo::

        Return shape should be (3, N) to be consistent.

    Parameters
    ----------
    N_max : int
        Maximum norm of the integer vector.
    dx : int
        Step size in x direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dy : int
        Step size in y direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dz : int
        Step size in z direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    half_lattice : bool (optional)
        Only return half of the 3D lattice.

    Returns
    -------
    vecs : :class:`numpy.ndarray`
        A 2D array of integers with :math:`|\boldsymbol{n}| < N_{\rm max}`
        with shape (N, 3).

    """
    vecs = np.meshgrid(np.arange(-N_max, N_max+1, dx),
                       np.arange(-N_max, N_max+1, dy),
                       np.arange(-N_max, N_max+1, dz))
    vecs = np.vstack(list(map(np.ravel, vecs))).T
    vecs = vecs[np.linalg.norm(vecs, axis=1) <= N_max]

    if half_lattice:
        ix = ((vecs[:, 2] > 0) |
              ((vecs[:, 2] == 0) &
               (vecs[:, 1] > 0)) |
              ((vecs[:, 2] == 0) &
               (vecs[:, 1] == 0) &
               (vecs[:, 0] > 0)))
        vecs = vecs[ix]

    vecs = np.array(sorted(vecs, key=lambda x: (x[0], x[1], x[2])))
    return vecs


@u.quantity_input(m0=u.Msun, b0=u.kpc)
def fit_isochrone(orbit, m0=None, b0=None, minimize_kwargs=None):
    r"""
    Fit the toy Isochrone potential to the sum of the energy residuals relative
    to the mean energy by minimizing the function

    .. math::

        f(m, b) = \sum_i (\frac{1}{2}v_i^2 + \Phi_{\rm iso}(x_i\,|\,m, b) - <E>)^2

    TODO: This should fail if the Hamiltonian associated with the orbit has
          a frame other than StaticFrame

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
    m0 : numeric (optional)
        Initial guess for mass parameter of fitted Isochrone model.
    b0 : numeric (optional)
        Initial guess for scale length parameter of fitted Isochrone model.
    minimize_kwargs : dict (optional)
        Keyword arguments to pass through to `scipy.optimize.minimize`.

    Returns
    -------
    fit_iso : `gala.potential.IsochronePotential`
        Best-fit Isochrone potential for locally representing true potential.

    """
    from gala.potential import IsochronePotential, LogarithmicPotential

    pot = orbit.potential
    if pot is None:
        raise ValueError(
            "The inputted orbit does not have an associated potential instance "
            "(i.e. orbit.potential is None). You must provide an orbit instance"
            " with a specified potential in order to initialize the toy "
            "potential fitting."
        )

    w = np.squeeze(orbit.w(pot.units))
    if w.ndim > 2:
        raise ValueError("Input orbit object must be a single orbit.")

    if (m0 is not None and b0 is None) or (m0 is None and b0 is not None):
        raise ValueError("If passing in initial guess for one parameter, you "
                         "must also pass in an initial guess for the other "
                         "(m0 and b0).")

    elif m0 is not None and b0 is not None:
        # both initial guesses provided
        m0 = m0.decompose(pot.units).value
        b0 = b0.decompose(pot.units).value

    else:
        # initial guess not specified: some magic to come up with initialization
        r0 = np.mean(orbit.physicsspherical.r)
        Menc0 = pot.mass_enclosed([1, 0, 0] * r0)[0].decompose(pot.units).value
        Phi0 = pot.energy([1, 0, 0] * r0)[0]
        Phi0 = Phi0.decompose(pot.units).value
        r0 = r0.decompose(pot.units).value

        _G = G.decompose(pot.units).value

        # Special case the logarithmic potential:
        if isinstance(pot, LogarithmicPotential):
            def func(pars, r0, M0, Phi0):
                b, const = pars
                a0 = np.sqrt(r0**2 + b**2)
                return (-_G * M0 / r0**3 * a0 * (b + a0) - Phi0 + const) ** 2

            res = minimize(
                func, x0=[r0, 0],
                args=(r0, Menc0, Phi0),
                method='L-BFGS-B',
                bounds=[(0, None), (None, None)]
            )

        else:
            def func(b, r0, M0, Phi0):
                a0 = np.sqrt(r0**2 + b**2)
                return (-_G * M0 / r0**3 * a0 * (b + a0) - Phi0) ** 2

            res = minimize(
                func, x0=[r0],
                args=(r0, Menc0, Phi0),
                method='L-BFGS-B',
                bounds=[(0, None)]
            )

        if not res.success:
            raise RuntimeError(
                "Root finding failed: Unable to find local Isochrone potential "
                "fit for orbit."
            )

        b = res.x[0]
        a0 = np.sqrt(b**2 + r0**2)
        M = Menc0 / r0**3 * a0 * (b + a0)**2

        m0 = M
        b0 = b

    def f(p, w):
        logm, logb = p
        potential = IsochronePotential(m=np.exp(logm), b=np.exp(logb),
                                       units=pot.units)
        H = (potential.energy(w[:3]).decompose(pot.units).value +
             0.5*np.sum(w[3:]**2, axis=0))
        return np.sum(np.squeeze(H - np.mean(H))**2)

    logm0 = np.log(m0)
    logb0 = np.log(b0)

    if minimize_kwargs is None:
        minimize_kwargs = dict()
    minimize_kwargs.setdefault('x0', np.array([logm0, logb0]))
    minimize_kwargs.setdefault('method', 'powell')
    res = minimize(f, args=(w,), **minimize_kwargs)

    if not res.success:
        raise ValueError("Failed to fit toy potential to orbit.")

    return IsochronePotential(*np.exp(res.x), units=pot.units)


def fit_harmonic_oscillator(orbit, omega0=None, minimize_kwargs=None):
    r"""
    Fit the toy harmonic oscillator potential to the sum of the energy
    residuals relative to the mean energy by minimizing the function

    .. math::

        f(\boldsymbol{\omega}) = \sum_i (\frac{1}{2}v_i^2 +
            \Phi_{\rm sho}(x_i\,|\,\boldsymbol{\omega}) - <E>)^2

    TODO: This should fail if the Hamiltonian associated with the orbit has
          a frame other than StaticFrame

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
    omega0 : array_like (optional)
        Initial frequency guess.
    minimize_kwargs : dict (optional)
        Keyword arguments to pass through to `scipy.optimize.minimize`.

    Returns
    -------
    omegas : float
        Best-fit harmonic oscillator frequencies.

    """
    from gala.potential import HarmonicOscillatorPotential

    pot = orbit.potential
    if pot is None:
        raise ValueError(
            "The inputted orbit does not have an associated potential instance "
            "(i.e. orbit.potential is None). You must provide an orbit instance"
            " with a specified potential in order to initialize the toy "
            "potential fitting."
        )

    if omega0 is None:
        # Estimate from orbit:
        P = orbit.cartesian.estimate_period()[0]
        P = u.Quantity([P[k] for k in P.colnames])
        omega0 = (2*np.pi / P).decompose(pot.units).value
    else:
        omega0 = np.atleast_1d(omega0)

    w = np.squeeze(orbit.w(pot.units))
    if w.ndim > 2:
        raise ValueError("Input orbit object must be a single orbit.")

    def f(omega, w):
        potential = HarmonicOscillatorPotential(omega=omega, units=pot.units)
        H = (potential.energy(w[:3]).decompose(pot.units).value +
             0.5*np.sum(w[3:]**2, axis=0))
        return np.sum(np.squeeze(H - np.mean(H))**2)

    if minimize_kwargs is None:
        minimize_kwargs = dict()
    minimize_kwargs['x0'] = omega0
    minimize_kwargs['method'] = minimize_kwargs.get('method', 'powell')
    res = minimize(f, args=(w,), **minimize_kwargs)

    if not res.success:
        raise ValueError("Failed to fit toy potential to orbit.")

    best_omega = np.abs(res.x)
    return HarmonicOscillatorPotential(omega=best_omega, units=pot.units)


def fit_toy_potential(orbit, force_harmonic_oscillator=False, **kwargs):
    """
    Fit a best fitting toy potential to the orbit provided. If the orbit is a
    tube (loop) orbit, use the Isochrone potential. If the orbit is a box
    potential, use the harmonic oscillator potential. An option is available to
    force using the harmonic oscillator (`force_harmonic_oscillator`).

    See the docstrings for ~`gala.dynamics.fit_isochrone()` and
    ~`gala.dynamics.fit_harmonic_oscillator()` for more information.

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
    force_harmonic_oscillator : bool (optional)
        Force using the harmonic oscillator potential as the toy potential.

    Returns
    -------
    potential
        The best-fit potential instance.

    """

    circulation = orbit.circulation()
    if np.any(circulation == 1) and not force_harmonic_oscillator:  # tube orbit
        logger.debug("===== Tube orbit =====")
        logger.debug("Using Isochrone toy potential")

        toy_potential = fit_isochrone(orbit, **kwargs)
        logger.debug(
            f"Best m={toy_potential.parameters['m']}, "
            f"b={toy_potential.parameters['b']}"
        )

    else:  # box orbit
        logger.debug("===== Box orbit =====")
        logger.debug("Using triaxial harmonic oscillator toy potential")

        toy_potential = fit_harmonic_oscillator(orbit, **kwargs)
        logger.debug(f"Best omegas ({toy_potential.parameters['omega']})")

    return toy_potential


def check_angle_sampling(nvecs, angles):
    """
    Returns a list of the index of elements of n which do not have adequate
    toy angle coverage. The criterion is that we must have at least one sample
    in each Nyquist box when we project the toy angles along the vector n.

    Parameters
    ----------
    nvecs : array_like
        Array of integer vectors.
    angles : array_like
        Array of angles.

    Returns
    -------
    failed_nvecs : :class:`numpy.ndarray`
        Array of all integer vectors that failed checks. Has shape (N, 3).
    failures : :class:`numpy.ndarray`
        Array of flags that designate whether this failed needing a longer
        integration window (0) or finer sampling (1).

    """

    failed_nvecs = []
    failures = []
    warn_longer_window = []
    warn_finer_sampling = []
    for i, vec in enumerate(nvecs):
        # N = np.linalg.norm(vec)
        # X = np.dot(angles, vec)
        X = (angles*vec[:, None]).sum(axis=0)
        diff = float(np.abs(X.max() - X.min()))

        if diff < (2.*np.pi):
            failed_nvecs.append(vec.tolist())
            # P.append(2.*np.pi - diff)
            failures.append(0)
            warn_longer_window.append(vec)

        elif (diff/len(X)) > np.pi:
            failed_nvecs.append(vec.tolist())
            # P.append(np.pi - diff/len(X))
            failures.append(1)
            warn_finer_sampling.append(vec)

    if len(warn_longer_window) > 0:
        warn_longer_window = np.array(warn_longer_window)
        warnings.warn(
            f"Need a longer integration window for modes: {warn_longer_window}",
            RuntimeWarning
        )

    if len(warn_finer_sampling) > 0:
        warn_finer_sampling = np.array(warn_finer_sampling)
        warnings.warn(
            f"Need a finer time sampling for modes: {warn_finer_sampling}",
            RuntimeWarning
        )

    return np.array(failed_nvecs), np.array(failures)


def _action_prepare(aa, N_max, dx, dy, dz, sign=1., throw_out_modes=False):
    """
    Given toy actions and angles, `aa`, compute the matrix `A` and
    vector `b` to solve for the vector of "true" actions and generating
    function values, `x` (see Equations 12-14 in Sanders & Binney (2014)).

    .. todo::

        Wrong shape for aa -- should be (6, n) as usual...

    Parameters
    ----------
    aa : array_like
        Shape ``(6, ntimes)`` array of toy actions and angles.
    N_max : int
        Maximum norm of the integer vector.
    dx : int
        Step size in x direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dy : int
        Step size in y direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dz : int
        Step size in z direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    sign : numeric (optional)
        Vector that defines direction of circulation about the axes.
    """

    # unroll the angles so they increase continuously instead of wrap
    angles = np.unwrap(aa[3:])

    # generate integer vectors for fourier modes
    nvecs = generate_n_vectors(N_max, dx, dy, dz)

    # make sure we have enough angle coverage
    modes, P = check_angle_sampling(nvecs, angles)

    # throw out modes?
    # if throw_out_modes:
    #     nvecs = np.delete(nvecs, (modes, P), axis=0)

    n = len(nvecs) + 3
    b = np.zeros(shape=(n, ))
    A = np.zeros(shape=(n, n))

    # top left block matrix: identity matrix summed over timesteps
    A[:3, :3] = aa.shape[1]*np.identity(3)

    actions = aa[:3]
    angles = aa[3:]

    # top right block matrix: transpose of C_nk matrix (Eq. 12)
    C_T = 2.*nvecs.T * np.sum(np.cos(np.dot(nvecs, angles)), axis=-1)
    A[:3, 3:] = C_T
    A[3:, :3] = C_T.T

    # lower right block matrix: C_nk dotted with C_nk^T
    cosv = np.cos(np.dot(nvecs, angles))
    A[3:, 3:] = 4.*np.dot(nvecs, nvecs.T)*np.einsum('it, jt->ij', cosv, cosv)

    # b vector first three is just sum of toy actions
    b[:3] = np.sum(actions, axis=1)

    # rest of the vector is C dotted with actions
    b[3:] = 2*np.sum(np.dot(nvecs, actions)*np.cos(np.dot(nvecs, angles)),
                     axis=1)

    return A, b, nvecs


def _angle_prepare(aa, t, N_max, dx, dy, dz, sign=1.):
    """
    Given toy actions and angles, `aa`, compute the matrix `A` and
    vector `b` to solve for the vector of "true" angles, frequencies, and
    generating function derivatives, `x` (see Appendix of
    Sanders & Binney (2014)).

    .. todo::

        Wrong shape for aa -- should be (6, n) as usual...

    Parameters
    ----------
    aa : array_like
        Shape ``(6, ntimes)`` array of toy actions and angles.
    t : array_like
        Array of times.
    N_max : int
        Maximum norm of the integer vector.
    dx : int
        Step size in x direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dy : int
        Step size in y direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    dz : int
        Step size in z direction. Set to 1 for odd and even terms, set
        to 2 for just even terms.
    sign : numeric (optional)
        Vector that defines direction of circulation about the axes.
    """

    # unroll the angles so they increase continuously instead of wrap
    angles = np.unwrap(aa[3:])

    # generate integer vectors for fourier modes
    nvecs = generate_n_vectors(N_max, dx, dy, dz)

    # make sure we have enough angle coverage
    modes, P = check_angle_sampling(nvecs, angles)

    # TODO: throw out modes?
    # if(throw_out_modes):
    #     n_vectors = np.delete(n_vectors, check_each_direction(n_vectors, angs), axis=0)

    nv = len(nvecs)
    n = 3 + 3 + 3 * nv  # angle(0)'s, freqs, 3 derivatives of Sn

    b = np.zeros(shape=(n,))
    A = np.zeros(shape=(n, n))

    # top left block matrix: identity matrix summed over timesteps
    A[:3, :3] = aa.shape[1]*np.identity(3)

    # identity matrices summed over times
    A[:3, 3:6] = A[3:6, :3] = np.sum(t)*np.identity(3)
    A[3:6, 3:6] = np.sum(t*t)*np.identity(3)

    # S1, 2, 3
    A[6:6+nv, 0] = -2.*np.sum(np.sin(np.dot(nvecs, angles)), axis=1)
    A[6+nv:6+2*nv, 1] = A[6:6+nv, 0]
    A[6+2*nv:6+3*nv, 2] = A[6:6+nv, 0]

    # t*S1, 2, 3
    A[6:6+nv, 3] = -2.*np.sum(t[None, :]*np.sin(np.dot(nvecs, angles)),
                              axis=1)
    A[6+nv:6+2*nv, 4] = A[6:6+nv, 3]
    A[6+2*nv:6+3*nv, 5] = A[6:6+nv, 3]

    # lower right block structure: S dot S^T
    sinv = np.sin(np.dot(nvecs, angles))
    SdotST = np.einsum('it, jt->ij', sinv, sinv)
    A[6:6+nv, 6:6+nv] = A[6+nv:6+2*nv, 6+nv:6+2*nv] = \
        A[6+2*nv:6+3*nv, 6+2*nv:6+3*nv] = 4*SdotST

    # top rectangle
    A[:6, :] = A[:, :6].T

    b[:3] = np.sum(angles.T, axis=0)
    b[3:6] = np.sum(t[:, None]*angles.T, axis=0)
    b[6:6+nv] = -2.*np.sum(angles[0]*np.sin(np.dot(nvecs, angles)), axis=1)
    b[6+nv:6+2*nv] = -2.*np.sum(angles[1]*np.sin(np.dot(nvecs, angles)),
                                axis=1)
    b[6+2*nv:6+3*nv] = -2.*np.sum(angles[2]*np.sin(np.dot(nvecs, angles)),
                                  axis=1)

    return A, b, nvecs


def _single_orbit_find_actions(orbit, N_max, toy_potential=None,
                               force_harmonic_oscillator=False,
                               fit_kwargs=None):
    """
    Find approximate actions and angles for samples of a phase-space orbit,
    `w`, at times `t`. Uses toy potentials with known, analytic action-angle
    transformations to approximate the true coordinates as a Fourier sum.

    This code is adapted from Jason Sanders'
    `genfunc <https://github.com/jlsanders/genfunc>`_

    .. todo::

        Wrong shape for w -- should be (6, n) as usual...

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
    N_max : int
        Maximum integer Fourier mode vector length, |n|.
    toy_potential : Potential (optional)
        Fix the toy potential class.
    force_harmonic_oscillator : bool (optional)
        Force using the harmonic oscillator potential as the toy potential.
    fit_kwargs : dict (optional)
        Passed to ``fit_toy_potential()`` and on to the toy potential fitting
        functions.
    """
    from gala.potential import HarmonicOscillatorPotential, IsochronePotential

    if orbit.norbits > 1:
        raise ValueError("must be a single orbit")

    if fit_kwargs is None:
        fit_kwargs = {}

    if toy_potential is None:
        toy_potential = fit_toy_potential(
            orbit, force_harmonic_oscillator=force_harmonic_oscillator,
            **fit_kwargs)

    else:
        logger.debug(f"Using *fixed* toy potential: {toy_potential.parameters}")

    if isinstance(toy_potential, IsochronePotential):
        orbit_align = orbit.align_circulation_with_z()
        w = orbit_align.w()

        dxyz = (1, 2, 2)
        circ = np.sign(w[0, 0]*w[4, 0]-w[1, 0]*w[3, 0])
        sign = np.array([1., circ, 1.])
        orbit = orbit_align
    elif isinstance(toy_potential, HarmonicOscillatorPotential):
        dxyz = (2, 2, 2)
        sign = 1.
        w = orbit.w()
    else:
        raise ValueError("Invalid toy potential.")

    t = orbit.t.value

    # Now find toy actions and angles
    aaf = toy_potential.action_angle(orbit)

    if aaf[0].ndim > 2:
        aa = np.vstack((aaf[0].value[..., 0], aaf[1].value[..., 0]))
    else:
        aa = np.vstack((aaf[0].value, aaf[1].value))

    if np.any(np.isnan(aa)):
        ix = ~np.any(np.isnan(aa), axis=0)
        aa = aa[:, ix]
        t = t[ix]
        warnings.warn("NaN value in toy actions or angles!")
        if sum(ix) > 1:
            raise ValueError("Too many NaN value in toy actions or angles!")

    t1 = time.time()
    A, b, nvecs = _action_prepare(aa, N_max, dx=dxyz[0], dy=dxyz[1], dz=dxyz[2])
    actions = np.array(solve(A, b))
    logger.debug("Action solution found for N_max={}, size {} symmetric"
                 " matrix in {} seconds"
                 .format(N_max, len(actions), time.time()-t1))

    t1 = time.time()
    A, b, nvecs = _angle_prepare(aa, t, N_max, dx=dxyz[0],
                                 dy=dxyz[1], dz=dxyz[2], sign=sign)
    angles = np.array(solve(A, b))
    logger.debug("Angle solution found for N_max={}, size {} symmetric"
                 " matrix in {} seconds"
                 .format(N_max, len(angles), time.time()-t1))

    # Just some checks
    if len(angles) > len(aa):
        warnings.warn("More unknowns than equations!")

    J = actions[:3]  # * sign
    theta = angles[:3]
    freqs = angles[3:6]  # * sign

    return dict(actions=J * aaf[0].unit,
                angles=theta * aaf[1].unit,
                freqs=freqs * aaf[2].unit,
                Sn=actions[3:],
                dSn_dJ=angles[6:],
                nvecs=nvecs)


def find_actions_o2gf(orbit, N_max, force_harmonic_oscillator=False,
                      toy_potential=None, fit_kwargs=None):
    """
    Find approximate actions and angles for samples of a phase-space orbit.
    Uses toy potentials with known, analytic action-angle transformations to
    approximate the true coordinates as a Fourier sum.

    This code is adapted from Jason Sanders'
    `genfunc <https://github.com/jlsanders/genfunc>`_

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
    N_max : int
        Maximum integer Fourier mode vector length, :math:`|\boldsymbol{n}|`.
    force_harmonic_oscillator : bool (optional)
        Force using the harmonic oscillator potential as the toy potential.
    toy_potential : Potential (optional)
        Fix the toy potential class.

    Returns
    -------
    aaf : `astropy.table.QTable`
        An Astropy table containing the actions, angles, and frequencies for
        each input phase-space position or orbit. The columns also contain the
        value of the generating function and derivatives for each integer
        vector.

    """

    if orbit.norbits == 1:
        result = _single_orbit_find_actions(
            orbit, N_max,
            force_harmonic_oscillator=force_harmonic_oscillator,
            toy_potential=toy_potential,
            fit_kwargs=fit_kwargs
        )
        rows = [result]

    else:
        rows = []
        for n in range(orbit.norbits):
            aaf = _single_orbit_find_actions(
                orbit[:, n], N_max,
                force_harmonic_oscillator=force_harmonic_oscillator,
                toy_potential=toy_potential,
                fit_kwargs=fit_kwargs
            )

            rows.append(aaf)

    return at.QTable(rows=rows)


@deprecated(since="v1.5",
            name="find_actions",
            alternative="find_actions_o2gf",
            warning_type=GalaDeprecationWarning)
def find_actions(*args, **kwargs):
    """
    Deprecated! Use `gala.dynamics.actionangle.find_actions_o2gf` instead.
    """
    return find_actions_o2gf(*args, **kwargs)


# def solve_hessian(relative_actions, relative_freqs):
#     """ Use ordinary least squares to solve for the Hessian, given a
#         set of actions and frequencies relative to the parent orbit.
#     """

# def compute_hessian(t, w, actions_kwargs={}):
#     """ Compute the Hessian (in action-space) of the given orbit

#     """

#     N = dJ.shape[0]

#     Y = np.ravel(dF)
#     A = np.zeros((3*N, 9))
#     A[::3, :3] = dJ
#     A[1::3, 3:6] = dJ
#     A[2::3, 6:9] = dJ

#     # Solve for 'parameters' - the Hessian elements
#     X, res, rank, s = np.linalg.lstsq(A, Y)

#     # Symmetrize
#     D0 = X.reshape(3, 3)
#     D0[0, 1] = D0[1, 0] = (D0[0, 1] + D0[1, 0])/2.
#     D0[0, 2] = D0[2, 0] = (D0[0, 2] + D0[2, 0])/2.
#     D0[1, 2] = D0[2, 1] = (D0[1, 2] + D0[2, 1])/2.

#     print("Residual: " + str(res[0]))

#     return D0, np.linalg.eigh(D0) # symmetric matrix
</file>

<file path="gala/dynamics/actionangle/actionangle_staeckel.py">
import numpy as np
from gala.dynamics import Orbit

__all__ = ['get_staeckel_fudge_delta']


def get_staeckel_fudge_delta(potential, w, median=True):
    """Estimate the focal length parameter, ∆, used by the Staeckel fudge.

    Parameters
    ----------
    potential : `~gala.potential.PotentialBase` subclass
        The potential that the orbits were computed in, or that you would like
        to estimate the best-fitting Staeckel potential for.
    w : `~gala.dynamics.Orbit`, `~gala.dynamics.PhaseSpacePosition`
        The orbit(s) or phase space position(s) to estimate the focal length

    Returns
    -------
    deltas : `~astropy.units.Quantity` [length]
        The focal length values.

    """
    grad = potential.gradient(w).decompose(potential.units).value
    hess = potential.hessian(w).decompose(potential.units).value

    # avoid constructing the full jacobian:
    cyl = w.cylindrical
    R = cyl.rho.decompose(potential.units).value
    z = w.z.decompose(potential.units).value
    cosphi = np.cos(cyl.phi)
    sinphi = np.sin(cyl.phi)
    sin2phi = np.sin(2 * cyl.phi)

    # These expressions transform the Hessian in Cartesian coordinates to the
    # pieces we need in cylindrical coordinates
    # - See: gala-notebooks/Delta-Staeckel.ipnyb
    dPhi_dR = cosphi * grad[0] + sinphi * grad[1]
    dPhi_dz = grad[2]

    d2Phi_dR2 = (cosphi**2 * hess[0, 0] +
                 sinphi**2 * hess[1, 1] +
                 sin2phi * hess[0, 1])
    d2Phi_dz2 = hess[2, 2]
    d2Phi_dRdz = cosphi * hess[0, 2] + sinphi * hess[1, 2]

    # numerator of term in eq. 9 (Sanders 2012), but from Galpy,
    #   which claims there is a sign error in the manuscript??
    num = 3*z * dPhi_dR - 3*R * dPhi_dz + R*z * (d2Phi_dR2 - d2Phi_dz2)
    a2_c2 = z**2 - R**2 + num / d2Phi_dRdz
    a2_c2[np.abs(a2_c2) < 1e-12] = 0.  # MAGIC NUMBER / HACK
    delta = np.sqrt(a2_c2)

    # Median over time if the inputs were orbits
    if (len(delta.shape) > 1 and median) or isinstance(w, Orbit):
        delta = np.nanmedian(delta, axis=0)

    return delta * potential.units['length']
</file>

<file path="gala/dynamics/actionangle/analyticactionangle.py">
"""
Analytic transformations to action-angle coordinates.
"""


# Third-party
import numpy as np
from astropy.constants import G
import astropy.coordinates as coord
import astropy.units as u
from astropy.coordinates.matrix_utilities import rotation_matrix
from astropy.utils.decorators import deprecated

# Gala
import gala.dynamics as gd
from gala.util import GalaDeprecationWarning
from gala.tests.optional_deps import HAS_TWOBODY

__all__ = ['isochrone_xv_to_aa', 'isochrone_aa_to_xv',
           'harmonic_oscillator_xv_to_aa']


def F(x, y):
    z = np.zeros_like(x)

    ix = y > np.pi/2.
    z[ix] = np.pi/2. - np.arctan(np.tan(np.pi/2. - 0.5*y[ix])/x[ix])

    ix = y < -np.pi/2.
    z[ix] = -np.pi/2. + np.arctan(np.tan(np.pi/2. + 0.5*y[ix])/x[ix])

    ix = (y <= np.pi/2) & (y >= -np.pi/2)
    z[ix] = np.arctan(x[ix] * np.tan(0.5*y[ix]))
    return z


def isochrone_xv_to_aa(w, potential):
    """
    Transform the input cartesian position and velocity to action-angle
    coordinates in the Isochrone potential. See Section 3.5.2 in
    Binney & Tremaine (2008), and be aware of the errata entry for
    Eq. 3.225.

    This transformation is analytic and can be used as a "toy potential"
    in the Sanders & Binney (2014) formalism for computing action-angle
    coordinates in any potential.

    Parameters
    ----------
    w : :class:`gala.dynamics.PhaseSpacePosition`, :class:`gala.dynamics.Orbit`
    potential : :class:`gala.potential.IsochronePotential`, dict
        An instance of the potential to use for computing the transformation
        to angle-action coordinates. Or, a dictionary of parameters used to
        define an :class:`gala.potential.IsochronePotential` instance.

    Returns
    -------
    actions : :class:`~astropy.units.Quantity`
        Actions computed from the input positions and velocities.
    angles : :class:`~astropy.units.Quantity`
        Angles computed from the input positions and velocities.
    freqs : :class:`~astropy.units.Quantity`
        Frequencies computed from the input positions and velocities.
    """
    from gala.potential import Hamiltonian, PotentialBase, IsochronePotential

    if not isinstance(potential, PotentialBase):
        potential = IsochronePotential(**potential)

    usys = potential.units
    GM = (G*potential.parameters['m']).decompose(usys).value
    b = potential.parameters['b'].decompose(usys).value
    E = w.energy(Hamiltonian(potential)).decompose(usys).value
    E = np.atleast_1d(E)

    if np.any(E > 0.):
        raise ValueError("Unbound particle. (E = {})".format(E))

    # convert position, velocity to spherical polar coordinates
    w_sph = w.represent_as(coord.PhysicsSphericalRepresentation)
    r, phi, theta = map(
        np.atleast_1d,
        [
            w_sph.r.decompose(usys).value,
            w_sph.phi.radian,
            w_sph.theta.radian
        ]
    )

    ang_unit = u.radian/usys['time']
    vr, phi_dot, theta_dot = map(
        np.atleast_1d,
        [
            w_sph.radial_velocity.decompose(usys).value,
            w_sph.pm_phi.to(ang_unit).value,
            w_sph.pm_theta.to(ang_unit).value
        ]
    )
    vtheta = r * theta_dot

    # ----------------------------
    # Compute the actions
    # ----------------------------

    L_vec = [np.atleast_1d(x)
             for x in w.angular_momentum().decompose(usys).value]
    Lz = L_vec[2]
    L = np.linalg.norm(L_vec, axis=0)

    # Radial action
    Jr = GM / np.sqrt(-2*E) - 0.5*(L + np.sqrt(L*L + 4*GM*b))

    # compute the three action variables
    actions = np.array([Jr, Lz, L - np.abs(Lz)]).reshape((3,) + w.shape)

    # ----------------------------
    # Angles
    # ----------------------------
    c = GM / (-2*E) - b
    e = np.sqrt(1 - L*L*(1 + b/c) / GM / c)

    # Compute theta_r using eta
    tmp1 = r*vr / np.sqrt(-2.*E)
    tmp2 = b + c - np.sqrt(b*b + r*r)
    eta = np.arctan2(tmp1, tmp2)
    thetar = eta - e*c*np.sin(eta) / (c + b)  # same as theta3

    # Compute theta_z
    psi = np.arctan2(np.cos(theta), -np.sin(theta)*r*vtheta/L)
    psi[np.abs(vtheta) <= 1e-10] = np.pi/2.  # blows up for small vtheta

    omega_ratio = 0.5 * (1 + L/np.sqrt(L*L + 4*GM*b))

    a = np.sqrt((1+e) / (1-e))
    ap = np.sqrt((1 + e + 2*b/c) / (1 - e + 2*b/c))

    A = omega_ratio*thetar - F(a, eta) - F(ap, eta)/np.sqrt(1 + 4*GM*b/L/L)
    thetat = psi + A

    LR = Lz/L
    sinu = (LR/np.sqrt(1.-LR*LR)/np.tan(theta))
    uu = np.arcsin(sinu)

    uu[sinu > 1.] = np.pi/2.
    uu[sinu < -1.] = -np.pi/2.
    uu[vtheta > 0.] = np.pi - uu[vtheta > 0.]

    thetap = phi - uu + np.sign(Lz)*thetat
    angles = np.array([thetar, thetap, thetat]).reshape((3,) + w.shape)
    angles = angles % (2*np.pi)

    # ----------------------------
    # Frequencies
    # ----------------------------
    freqs = np.zeros_like(actions)
    omega_r = GM**2 / (Jr + 0.5*(L + np.sqrt(L*L + 4*GM*b)))**3
    freqs[0] = omega_r
    freqs[1] = np.sign(actions[1]) * omega_ratio * omega_r
    freqs[2] = omega_ratio * omega_r

    a_unit = (1 * usys['angular momentum'] / usys['mass']).decompose(usys).unit
    f_unit = (1 * usys['angular speed']).decompose(usys).unit
    return actions * a_unit, angles * u.radian, freqs * f_unit


@deprecated(since="v1.5",
            name="isochrone_to_aa",
            alternative="isochrone_xv_to_aa",
            warning_type=GalaDeprecationWarning)
def isochrone_to_aa(*args, **kwargs):
    """
    Deprecated! Use `gala.dynamics.actionangle.isochrone_xv_to_aa` instead.
    """
    return isochrone_xv_to_aa(*args, **kwargs)


def isochrone_aa_to_xv(actions, angles, potential):
    """
    Transform the input actions and angles to cartesian position and velocity
    coordinates in the Isochrone potential. See Section 3.5.2 in
    Binney & Tremaine (2008), and be aware of the errata entry for
    Eq. 3.225.

    Parameters
    ----------
    actions : :class:`~astropy.units.Quantity`
    angles : :class:`~astropy.units.Quantity`
    potential : :class:`gala.potential.IsochronePotential`, dict
        An instance of the potential to use for computing the transformation
        to angle-action coordinates. Or, a dictionary of parameters used to
        define an :class:`gala.potential.IsochronePotential` instance.

    Returns
    -------
    w : :class:`gala.dynamics.PhaseSpacePosition`
        The computed positions and velocities.
    """
    if not HAS_TWOBODY:
        raise ImportError(
            "Failed to import twobody: Converting from action-angle "
            "coordinates to position and velocity in the isochrone potential "
            "requires a Kepler solver, and thus `twobody` must be installed.")

    import twobody as tb

    Jr, Jphi, Jth = [np.atleast_1d(x) for x in actions]
    thr, thphi, thth = [np.atleast_1d(x) for x in angles]

    GM = (G * potential.parameters['m'])
    b = potential.parameters['b']

    Lz = Jphi
    L = Jth + np.abs(Lz)

    # Eq.3.225 in B&T 2008
    sqrt_L2_4GMb = np.sqrt(L**2 + 4 * GM * b)
    E = -0.5 * (GM / (Jr + 0.5 * (L + sqrt_L2_4GMb)))**2

    # Coordinates orientation crap
    i = np.arccos(Lz / L)
    lon_nodes = coord.Angle(thphi - np.sign(Lz) * thth).wrap_at(2*np.pi*u.rad)
    # TODO: could check that std(i), std(lon_nodes) are small...

    # Auxiliary variables (Eq. 3.240)
    c = GM / (-2*E) - b
    e = np.sqrt(1 - L**2 / (GM * c) * (1 + b/c))

    e_eff = e * c / (c + b)
    eta = tb.eccentric_anomaly_from_mean_anomaly(thr, e_eff)

    s = 2 + c/b * (1 - e * np.cos(eta))
    r = b * np.sqrt((s - 1)**2 - 1)

    Omr = GM**2 / (Jr + 0.5 * (L + sqrt_L2_4GMb))**3
    eta_dot = Omr / (1 - e_eff * np.cos(eta))
    s_dot = e * c / b * np.sin(eta) * eta_dot
    vr = b * (s - 1) * s_dot / np.sqrt((s-1)**2 - 1)
    v_tan = L / r

    sqrt1 = np.sqrt(1 + e) / np.sqrt(1-e)
    sqrt2 = np.sqrt(1 + e + 2*b/c) / np.sqrt(1 - e + 2*b/c)

    with u.set_enabled_equivalencies(u.dimensionless_angles()):
        terms = (
            0.5 * (1 + L / sqrt_L2_4GMb) * thr
            - F(sqrt1, eta)
            - L / sqrt_L2_4GMb * F(sqrt2, eta)
        )
    # psi = angles[2] - terms
    psi = thth - terms - 3*np.pi/2*u.rad  # WT actual F

    xyz_prime = (np.array([
        r.value * np.cos(psi),
        r.value * np.sin(psi),
        np.zeros_like(r.value)]
    ) * r.unit).to(potential.units['length'])

    vx = vr * np.cos(psi) - v_tan * np.sin(psi)
    vy = vr * np.sin(psi) + v_tan * np.cos(psi)
    vxyz_prime = (np.array([
        vx.value,
        vy.to_value(vx.unit),
        np.zeros_like(r.value)
    ]) * vx.unit).to(potential.units['velocity'])

    M1 = rotation_matrix(-i, 'y')
    M2 = rotation_matrix(-lon_nodes, 'z')
    M3 = rotation_matrix(np.pi/2 * u.rad, 'z')  # WT actual F
    M = np.einsum('ij,...jk,...kl->...il', M3, M2, M1)

    xyz = np.einsum('...ij,j...->i...', M, xyz_prime)
    vxyz = np.einsum('...ij,j...->i...', M, vxyz_prime)

    w = gd.PhaseSpacePosition(pos=xyz, vel=vxyz)

    return w.reshape(actions.shape[1:])


def harmonic_oscillator_xv_to_aa(w, potential):
    """
    Transform the input cartesian position and velocity to action-angle
    coordinates for the Harmonic Oscillator potential.

    This transformation is analytic and can be used as a "toy potential"
    in the Sanders & Binney (2014) formalism for computing action-angle
    coordinates in any potential.

    Parameters
    ----------
    w : :class:`gala.dynamics.PhaseSpacePosition`, :class:`gala.dynamics.Orbit`
    potential : Potential

    Returns
    -------
    actions : :class:`~astropy.units.Quantity`
        Actions computed from the input positions and velocities.
    angles : :class:`~astropy.units.Quantity`
        Angles computed from the input positions and velocities.
    freqs : :class:`~astropy.units.Quantity`
        Frequencies computed from the input positions and velocities.
    """

    usys = potential.units
    if usys is not None:
        x = w.xyz.decompose(usys).value
        v = w.v_xyz.decompose(usys).value
    else:
        x = w.xyz.value
        v = w.v_xyz.value
    _new_omega_shape = (3,) + tuple([1]*(len(x.shape)-1))

    # compute actions -- just energy (hamiltonian) over frequency
    if usys is None:
        usys = []

    try:
        omega = potential.parameters['omega'].reshape(_new_omega_shape).decompose(usys).value
    except AttributeError:  # not a Quantity
        omega = potential.parameters['omega'].reshape(_new_omega_shape)

    action = (v**2 + (omega*x)**2) / (2.*omega)

    angle = np.arctan(-v / omega / x)
    angle[x == 0] = -np.sign(v[x == 0])*np.pi/2.
    angle[x < 0] += np.pi

    freq = potential.parameters['omega'].decompose(usys).value

    if usys is not None and usys:
        a_unit = (1*usys['angular momentum']/usys['mass']).decompose(usys).unit
        f_unit = (1*usys['angular speed']).decompose(usys).unit
        return action * a_unit, (angle % (2.*np.pi)) * u.radian, freq * f_unit
    else:
        return action * u.one, (angle % (2.*np.pi)) * u.one, freq * u.one


@deprecated(since="v1.5",
            name="harmonic_oscillator_to_aa",
            alternative="harmonic_oscillator_xv_to_aa",
            warning_type=GalaDeprecationWarning)
def harmonic_oscillator_to_aa(*args, **kwargs):
    """
    Deprecated! Use `gala.dynamics.actionangle.harmonic_oscillator_xv_to_aa`
    instead.
    """
    return harmonic_oscillator_xv_to_aa(*args, **kwargs)


def harmonic_oscillator_to_xv(actions, angles, potential):
    """
    Transform the input action-angle coordinates to cartesian
    position and velocity for the Harmonic Oscillator potential.

    .. note::

        This function is included as a method of the
        :class:`~gala.potential.HarmonicOscillatorPotential`
        and it is recommended to call
        :meth:`~gala.potential.HarmonicOscillatorPotential.phase_space()` instead.

    Parameters
    ----------
    actions : array_like
    angles : array_like
    potential : Potential
    """
    raise NotImplementedError("Implementation not supported until working with "
                              "angle-action variables has a better API.")

    # TODO: bug in below...
    # omega = potential.parameters['omega'].decompose(potential.units).value
    # x = np.sqrt(2*actions/omega[None]) * np.sin(angles)
    # v = np.sqrt(2*actions*omega[None]) * np.cos(angles)

    # return x, v
</file>

<file path="gala/dynamics/lyapunov/__init__.py">
from .dop853_lyapunov import dop853_lyapunov_max, dop853_lyapunov_max_dont_save
</file>

<file path="gala/dynamics/lyapunov/dop853_lyapunov.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" DOP853 integration in Cython. """

# Third-party
import numpy as np
cimport numpy as np
np.import_array()

from libc.stdio cimport printf
from libc.math cimport log

from ...integrate.cyintegrators.dop853 cimport dop853_step
from ...potential.potential.cpotential cimport CPotentialWrapper
from ...potential.frame.cframe cimport CFrameWrapper

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "dopri/dop853.h":
    ctypedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                              CPotential *p, CFrameType *fr, unsigned norbits,
                              unsigned nbody, void *args) nogil
    void Fwrapper (unsigned ndim, double t, double *w, double *f,
                   CPotential *p, CFrameType *fr, unsigned norbits, unsigned nbody)
    double six_norm (double *x)

cpdef dop853_lyapunov_max(hamiltonian, double[::1] w0,
                          double dt, int n_steps, double t0,
                          double d0, int n_steps_per_pullback, int noffset_orbits,
                          double atol=1E-10, double rtol=1E-10, int nmax=0):
    cdef:
        int i, j, k, jiter
        int res
        unsigned ndim = w0.size
        unsigned norbits = noffset_orbits + 1
        unsigned niter = n_steps // n_steps_per_pullback
        double[::1] w = np.empty(norbits*ndim)

        # define full array of times
        double t_end = (<double>n_steps) * dt
        double[::1] t = np.linspace(t0, t_end, n_steps) # TODO: should be n_steps+1
        double dt0 = t[1] - t[0]

        double d1_mag, norm
        double[:, ::1] d1 = np.empty((norbits, ndim))
        double[:, ::1] LEs = np.zeros((niter, noffset_orbits))
        double[:, :, ::1] all_w = np.zeros((n_steps, norbits, ndim))

        # temp stuff
        double[:, ::1] d0_vec = np.random.uniform(size=(noffset_orbits, ndim))

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(hamiltonian.frame.c_instance)).cframe

        void *args

    # store initial conditions
    for i in range(norbits):
        if i == 0:  # store initial conditions for parent orbit
            for k in range(ndim):
                all_w[0, i, k] = w0[k]
                w[i*ndim + k] = all_w[0, i, k]

        else:  # offset orbits
            norm = np.linalg.norm(d0_vec[i-1])
            for k in range(ndim):
                d0_vec[i-1, k] *= d0/norm  # rescale offset vector

                all_w[0, i, k] = w0[k] + d0_vec[i-1, k]
                w[i*ndim + k] = all_w[0, i, k]

    # dummy counter for storing Lyapunov stuff, which only happens every few steps
    jiter = 0
    for j in range(1, n_steps, 1):
        dop853_step(&cp, &cf, <FcnEqDiff> Fwrapper,
                    &w[0], t[j-1], t[j], dt0, ndim,
                    norbits, 0, args, # 0 is for nbody, ignored here
                    atol, rtol, nmax)

        # store position of main orbit
        for i in range(norbits):
            for k in range(ndim):
                all_w[j, i, k] = w[i*ndim + k]

        if (j % n_steps_per_pullback) == 0:
            # get magnitude of deviation vector
            for i in range(1, norbits):
                for k in range(ndim):
                    d1[i, k] = w[i*ndim + k] - w[k]

                d1_mag = six_norm(&d1[i, 0])
                LEs[jiter, i-1] = log(d1_mag / d0)

                # renormalize offset orbits
                for k in range(ndim):
                    w[i*ndim + k] = w[k] + d0 * d1[i, k] / d1_mag

            jiter += 1

    LEs = np.array([np.sum(LEs[:j],axis=0)/t[j*n_steps_per_pullback]
                    for j in range(1, niter)])
    return np.asarray(t), np.asarray(all_w), np.asarray(LEs)

cpdef dop853_lyapunov_max_dont_save(hamiltonian, double[::1] w0,
                                    double dt, int n_steps, double t0,
                                    double d0, int n_steps_per_pullback, int noffset_orbits,
                                    double atol=1E-10, double rtol=1E-10, int nmax=0):
    cdef:
        int i, j, k, jiter
        int res
        unsigned ndim = w0.size
        unsigned norbits = noffset_orbits + 1
        unsigned niter = n_steps // n_steps_per_pullback
        double[::1] w = np.empty(norbits*ndim)

        # define full array of times
        double t_end = (<double>n_steps) * dt
        double[::1] t = np.linspace(t0, t_end, n_steps) # TODO: should be n_steps+1
        double dt0 = t[1]-t[0]

        double d1_mag, norm
        double[:, ::1] d1 = np.empty((norbits, ndim))
        double[:, ::1] LEs = np.zeros((niter, noffset_orbits))

        # temp stuff
        double[:, ::1] d0_vec = np.random.uniform(size=(noffset_orbits, ndim))

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(hamiltonian.frame.c_instance)).cframe

        void *args

    # store initial conditions
    for i in range(norbits):
        if i == 0:  # store initial conditions for parent orbit
            for k in range(ndim):
                w[i*ndim + k] = w0[k]

        else:  # offset orbits
            norm = np.linalg.norm(d0_vec[i-1])
            for k in range(ndim):
                d0_vec[i-1, k] *= d0/norm  # rescale offset vector
                w[i*ndim + k] = w0[k] + d0_vec[i-1, k]

    # dummy counter for storing Lyapunov stuff, which only happens every few steps
    jiter = 0
    for j in range(1, n_steps, 1):
        dop853_step(&cp, &cf, <FcnEqDiff> Fwrapper,
                    &w[0], t[j-1], t[j], dt0, ndim,
                    norbits, 0, args, # 0 is for nbody, ignored here
                    atol, rtol, nmax)

        if (j % n_steps_per_pullback) == 0:
            # get magnitude of deviation vector
            for i in range(1, norbits):
                for k in range(ndim):
                    d1[i, k] = w[i*ndim + k] - w[k]

                d1_mag = six_norm(&d1[i, 0])
                LEs[jiter, i-1] = log(d1_mag / d0)

                # renormalize offset orbits
                for k in range(ndim):
                    w[i*ndim + k] = w[k] + d0 * d1[i, k] / d1_mag

            jiter += 1

    LEs = np.array([np.sum(LEs[:j],axis=0)/t[j*n_steps_per_pullback] for j in range(1, niter)])
    return np.asarray(LEs)
</file>

<file path="gala/dynamics/mockstream/tests/test_coord.py">
"""
Note:
    This is just a way to get pytest to call tests implemented in Cython!
    See _coord.pyx for the actual test functions.
"""

# Project
from .._coord import (_test_sat_rotation_matrix, _test_to_sat_coords_roundtrip,
                      _test_car_to_cyl_roundtrip, _test_cyl_to_car_roundtrip)


def test_sat_rotation_matrix():
    _test_sat_rotation_matrix()


def test_to_sat_coords_roundtrip():
    _test_to_sat_coords_roundtrip()


def test_car_to_cyl_roundtrip():
    _test_car_to_cyl_roundtrip()


def test_cyl_to_car_roundtrip():
    _test_cyl_to_car_roundtrip()
</file>

<file path="gala/dynamics/mockstream/tests/test_df.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Custom
from ....integrate import DOPRI853Integrator
from ....potential import (
    ConstantRotatingFrame,
    Hamiltonian,
    HernquistPotential,
    MilkyWayPotential,
)
from ....units import galactic
from ...core import PhaseSpacePosition

# Project
from ..df import ChenStreamDF, FardalStreamDF, LagrangeCloudStreamDF, StreaklineStreamDF

_DF_CLASSES = [StreaklineStreamDF, FardalStreamDF, LagrangeCloudStreamDF, ChenStreamDF]
_DF_KWARGS = [{}, {"gala_modified": True}, {"v_disp": 1 * u.km / u.s}]
_TEST_POTENTIALS = [
    HernquistPotential(m=1e12, c=5, units=galactic),
    MilkyWayPotential(),
]


@pytest.mark.parametrize("DF, DF_kwargs", zip(_DF_CLASSES, _DF_KWARGS))
@pytest.mark.parametrize("pot", _TEST_POTENTIALS)
def test_init_sample(DF, DF_kwargs, pot):
    H = Hamiltonian(pot)

    orbit = H.integrate_orbit([10.0, 0, 0, 0, 0.2, 0], dt=1.0, n_steps=100)
    n_times = len(orbit.t)

    # Different ways to initialize successfully:
    df = DF(**DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == 2 * n_times

    df = DF(lead=False, **DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == n_times

    df = DF(trail=False, **DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == n_times

    df1 = DF(random_state=np.random.RandomState(42), **DF_kwargs)
    o1 = df1.sample(orbit, 1e4 * u.Msun)
    df2 = DF(random_state=np.random.RandomState(42), **DF_kwargs)
    o2 = df2.sample(orbit, 1e4 * u.Msun)
    assert u.allclose(o1.xyz, o2.xyz)
    assert u.allclose(o1.v_xyz, o2.v_xyz)
    assert len(o1.x) == 2 * n_times


@pytest.mark.parametrize("DF, DF_kwargs", zip(_DF_CLASSES, _DF_KWARGS))
def test_expected_failure(DF, DF_kwargs):

    # Expected failure:
    with pytest.raises(ValueError):
        DF(lead=False, trail=False, **DF_kwargs)


def test_rotating_frame():
    DF = _DF_CLASSES[0]
    H_static = Hamiltonian(_TEST_POTENTIALS[0])

    w0 = PhaseSpacePosition(
        pos=[10.0, 0, 0] * u.kpc, vel=[0, 220, 0.0] * u.km / u.s, frame=H_static.frame
    )
    int_kwargs = dict(w0=w0, dt=1, n_steps=100, Integrator=DOPRI853Integrator)

    orbit_static = H_static.integrate_orbit(**int_kwargs)

    rframe = ConstantRotatingFrame([0, 0, -40] * u.km / u.s / u.kpc, units=galactic)
    H_rotating = Hamiltonian(_TEST_POTENTIALS[0], frame=rframe)
    orbit_rotating = H_rotating.integrate_orbit(**int_kwargs)

    _o = orbit_rotating.to_frame(H_static.frame)
    assert u.allclose(_o.xyz, orbit_static.xyz, atol=1e-13 * u.kpc)
    assert u.allclose(_o.v_xyz, orbit_static.v_xyz, atol=1e-13 * u.km / u.s)

    df_static = DF(trail=False)
    xvt_static = df_static.sample(orbit_static, 1e6 * u.Msun)

    df_rotating = DF(trail=False)
    xvt_rotating = df_rotating.sample(orbit_rotating, 1e6 * u.Msun)
    xvt_rotating_static = xvt_rotating.to_frame(
        H_static.frame, t=xvt_rotating.release_time
    )

    assert u.allclose(xvt_static.xyz, xvt_rotating_static.xyz, atol=1e-9 * u.kpc)
    assert u.allclose(
        xvt_static.v_xyz, xvt_rotating_static.v_xyz, atol=1e-9 * u.kpc / u.Myr
    )
</file>

<file path="gala/dynamics/mockstream/tests/test_mockstream_class.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Custom
from ..core import MockStream


def test_init():

    xyz = np.random.random(size=(3, 100)) * u.kpc
    vxyz = np.random.random(size=(3, 100)) * u.km / u.s
    t1 = np.random.random(size=100) * u.Myr

    lead_trail = np.empty(100, dtype="U1")
    lead_trail[::2] = "t"
    lead_trail[1::2] = "l"

    stream = MockStream(xyz, vxyz)
    stream = MockStream(xyz, vxyz, release_time=t1)
    stream = MockStream(xyz, vxyz, lead_trail=lead_trail)  # noqa

    with pytest.raises(ValueError):
        MockStream(xyz, vxyz, release_time=t1[:-1])

    with pytest.raises(ValueError):
        MockStream(xyz, vxyz, lead_trail=lead_trail[:-1])


def test_one_burst():
    # Regression test: Tests a bug found by Helmer when putting all particles at
    # one timestep
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.dynamics import mockstream as ms
    from gala.units import galactic

    # NFW MW with v_c = 232.8 km/s @ r = 8.2 kpc
    pot = gp.NFWPotential.from_circular_velocity(
        v_c=232.8 * u.km / u.s, r_s=15 * u.kpc, r_ref=8.2 * u.kpc, units=galactic
    )

    H = gp.Hamiltonian(pot)

    prog_w0 = gd.PhaseSpacePosition(
        pos=[10, 0, 0.0] * u.kpc, vel=[0, 10, 0.0] * u.km / u.s
    )

    dt = 1 * u.Myr
    nsteps = 100
    orbit = H.integrate_orbit(prog_w0, dt=dt, n_steps=nsteps)

    r = orbit.spherical.distance

    n_array = np.zeros(orbit.t.size, dtype=int)
    argmin = r[0:150].argmin()
    n_array[argmin] = 1000

    df = ms.FardalStreamDF(gala_modified=True)

    dt = 1 * u.Myr
    prog_mass = 2.5e4 * u.Msun
    prog_pot = gp.PlummerPotential(m=prog_mass, b=4 * u.pc, units=galactic)

    gen = ms.MockStreamGenerator(df, H, progenitor_potential=prog_pot)

    stream, prog = gen.run(
        prog_w0, prog_mass, n_particles=n_array, dt=dt, n_steps=nsteps, progress=False
    )


def test_Fardal_vs_GalaModified():
    """
    Regression test: Check that one can actually use the original Fardal parameter
    values, and that makes a different stream than the Gala-modified values:
    https://github.com/adrn/gala/pull/358
    """
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.dynamics import mockstream as ms
    from gala.units import galactic

    # NFW MW with v_c = 232.8 km/s @ r = 8.2 kpc
    pot = gp.NFWPotential.from_circular_velocity(
        v_c=232.8 * u.km / u.s, r_s=15 * u.kpc, r_ref=8.2 * u.kpc, units=galactic
    )

    H = gp.Hamiltonian(pot)

    prog_w0 = gd.PhaseSpacePosition(
        pos=[10, 0, 0.0] * u.kpc, vel=[0, 300, 20.0] * u.km / u.s
    )

    with pytest.warns(DeprecationWarning, match="Fardal"):
        ms.FardalStreamDF()

    df_false = ms.FardalStreamDF(
        gala_modified=False, random_state=np.random.default_rng(seed=42)
    )
    df_true = ms.FardalStreamDF(
        gala_modified=True, random_state=np.random.default_rng(seed=42)
    )

    gen_false = ms.MockStreamGenerator(df_false, H)
    gen_true = ms.MockStreamGenerator(df_true, H)

    prog_mass = 2.5e4 * u.Msun
    stream_false, _ = gen_false.run(
        prog_w0, prog_mass, dt=1, n_steps=128, progress=False
    )
    stream_true, _ = gen_true.run(prog_w0, prog_mass, dt=1, n_steps=128, progress=False)

    assert not u.allclose(stream_false.xyz, stream_true.xyz)
</file>

<file path="gala/dynamics/mockstream/tests/test_mockstream.py">
import itertools
import os

# Third-party
import astropy.units as u
import numpy as np
import pytest

from gala.tests.optional_deps import HAS_H5PY

from ....dynamics import Orbit, PhaseSpacePosition
from ....potential import (
    ConstantRotatingFrame,
    Hamiltonian,
    HernquistPotential,
    NFWPotential,
)
from ....units import galactic
from ...nbody import DirectNBody
from ..df import FardalStreamDF
from ..mockstream_generator import MockStreamGenerator


def test_init():
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    df = FardalStreamDF(gala_modified=True)

    with pytest.raises(TypeError):
        MockStreamGenerator(df="some df", hamiltonian=H)

    with pytest.raises(TypeError):
        MockStreamGenerator(df=df, hamiltonian=H, progenitor_potential="stuff")

    # Test validating the input nbody
    nbody_w0 = PhaseSpacePosition(
        pos=[25.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    potential2 = NFWPotential.from_circular_velocity(v_c=0.2, r_s=25.0, units=galactic)
    nbody = DirectNBody(
        w0=nbody_w0, external_potential=potential2, particle_potentials=[None]
    )
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    with pytest.raises(ValueError):
        gen._get_nbody(w0, nbody)

    frame2 = ConstantRotatingFrame([0, 0, 25.0] * u.km / u.s / u.kpc, units=galactic)
    nbody = DirectNBody(
        w0=nbody_w0,
        external_potential=potential,
        frame=frame2,
        particle_potentials=[None],
    )
    with pytest.raises(ValueError):
        gen._get_nbody(w0, nbody)

    # we expect success!
    nbody = DirectNBody(
        w0=nbody_w0, external_potential=potential, particle_potentials=[None]
    )
    new_nbody = gen._get_nbody(w0, nbody)  # noqa


def test_run():
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun
    prog_pot = HernquistPotential(mass, 4 * u.pc, units=galactic)

    # The basic run:
    df = FardalStreamDF(gala_modified=True)
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    stream1, _ = gen.run(w0, mass, dt=-1.0, n_steps=100)

    # Expected errors:
    with pytest.raises(TypeError):
        gen.run(w0, mass.value, dt=-1.0, n_steps=100)

    # With self-gravity
    gen = MockStreamGenerator(df=df, hamiltonian=H, progenitor_potential=prog_pot)
    stream2, _ = gen.run(w0, mass, dt=-1.0, n_steps=100)
    assert not u.allclose(stream1.xyz, stream2.xyz)

    # Skipping release steps:
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    stream3, _ = gen.run(w0, mass, dt=-1.0, n_steps=100, release_every=4, n_particles=4)
    assert stream3.shape == ((100 // 4 + 1) * 4 * 2,)

    # Custom n_particles:
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    n_particles = np.random.randint(0, 4, size=101)
    stream3, _ = gen.run(
        w0, mass, dt=-1.0, n_steps=100, release_every=1, n_particles=n_particles
    )
    assert stream3.shape[0] == 2 * n_particles.sum()


@pytest.mark.parametrize("dt", [1, -1])
@pytest.mark.parametrize("save_all", [True, False])
def test_mockstream_nbody_run(dt, save_all):
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun
    df = FardalStreamDF(gala_modified=True)

    # Test passing custom N-body:
    nbody_w0 = PhaseSpacePosition([20, 0, 0] * u.kpc, [0, 100, 0] * u.km / u.s)
    nbody = DirectNBody(
        w0=nbody_w0,
        external_potential=potential,
        particle_potentials=[
            NFWPotential(m=1e8 * u.Msun, r_s=0.2 * u.kpc, units=galactic)
        ],
        save_all=save_all,
    )
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    gen.run(w0, mass, dt=dt, n_steps=100, nbody=nbody)


@pytest.mark.parametrize(
    "dt, nsteps, output_every, release_every, n_particles, trail",
    list(itertools.product([1, -1], [16, 17], [1, 2], [1, 4], [1, 4], [True, False])),
)
@pytest.mark.skipif(not HAS_H5PY, reason="h5py required for this test")
def test_animate(tmpdir, dt, nsteps, output_every, release_every, n_particles, trail):
    import h5py

    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun

    # The basic run:
    df = FardalStreamDF(gala_modified=True, trail=trail)
    gen = MockStreamGenerator(df=df, hamiltonian=H)

    filename = os.path.join(str(tmpdir), "test.hdf5")
    stream, _ = gen.run(
        w0,
        mass,
        dt=dt,
        n_steps=nsteps,
        release_every=release_every,
        n_particles=n_particles,
        output_every=output_every,
        output_filename=filename,
        overwrite=True,
    )

    with h5py.File(filename, mode="r") as f:
        stream_orbits = Orbit.from_hdf5(f["stream"])
        nbody_orbits = Orbit.from_hdf5(f["nbody"])

    noutput_times = 1 + nsteps // output_every
    if nsteps % output_every != 0:
        noutput_times += 1

    tail_n_particles = (1 + int(trail)) * n_particles
    expected_shape = (noutput_times, tail_n_particles * (nsteps // release_every + 1))

    assert stream_orbits.shape == expected_shape
    assert np.isfinite(stream_orbits[:, 0].xyz).all()
    assert np.isfinite(stream_orbits[:, 0].v_xyz).all()

    assert u.allclose(nbody_orbits.t, stream_orbits.t)

    assert np.isfinite(nbody_orbits.xyz).all()
    assert np.isfinite(nbody_orbits.v_xyz).all()
    assert np.isfinite(nbody_orbits.t).all()
</file>

<file path="gala/dynamics/mockstream/__init__.py">
from .core import *
from ._mockstream import mockstream_dop853
from .mockstream_generator import *
from .df import *
</file>

<file path="gala/dynamics/mockstream/_coord.pxd">
# cython: language_level=3

# cdef void cross(double[::1] x, double[::1] y, double[::1] z)
cdef void cross(double *x, double *y, double *z)
cdef double norm(double *x, int n)
cdef void apply_3matrix(double[:, ::1] R, double *x, double *y, int transpose)

cdef void sat_rotation_matrix(double *w, double *R)

cdef void to_sat_coords(double *w, double *R,
                        double *w_prime)

cdef void from_sat_coords(double *w_prime, double *R,
                          double *w)

cdef void car_to_cyl(double *w, double *cyl)
cdef void cyl_to_car(double *cyl, double *w)
</file>

<file path="gala/dynamics/mockstream/_coord.pyx">
# cython: boundscheck=False
# cython: debug=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" Coordinate help for generating mock streams. """

from libc.math cimport M_PI

cdef extern from "math.h":
    double fabs(double x) nogil
    double sqrt(double x) nogil
    double cos(double x) nogil
    double sin(double x) nogil
    double atan2(double y, double x) nogil
    double fmod(double y, double x) nogil


cdef void cross(double *x, double *y, double *z):
    z[0] = x[1]*y[2] - x[2]*y[1]
    z[1] = -x[0]*y[2] + x[2]*y[0]
    z[2] = x[0]*y[1] - x[1]*y[0]


cdef double norm(double *x, int n):
    cdef:
        double val = 0.
        int i

    for i in range(n):
        val += x[i]**2

    return sqrt(val)


cdef void apply_3matrix(double[:, ::1] R, double *x, double *y,
                        int transpose):
    cdef int i
    if transpose == 0:
        for i in range(3):
            y[i] = R[i, 0] * x[0] + R[i, 1] * x[1] + R[i, 2] * x[2]
    else:
        for i in range(3):
            y[i] = R[0, i] * x[0] + R[1, i] * x[1] + R[2, i] * x[2]


cdef void sat_rotation_matrix(double *w, # in
                              double *R): # out
    cdef:
        double x1_norm, x2_norm, x3_norm = 0.
        unsigned int i
        double *x1 = [0., 0., 0.]
        double *x2 = [0., 0., 0.]
        double *x3 = [0., 0., 0.]

    x1[0] = w[0]
    x1[1] = w[1]
    x1[2] = w[2]

    x3[0] = x1[1]*w[2+3] - x1[2]*w[1+3]
    x3[1] = x1[2]*w[0+3] - x1[0]*w[2+3]
    x3[2] = x1[0]*w[1+3] - x1[1]*w[0+3]

    x2[0] = -x1[1]*x3[2] + x1[2]*x3[1]
    x2[1] = -x1[2]*x3[0] + x1[0]*x3[2]
    x2[2] = -x1[0]*x3[1] + x1[1]*x3[0]

    x1_norm = sqrt(x1[0]*x1[0] + x1[1]*x1[1] + x1[2]*x1[2])
    x2_norm = sqrt(x2[0]*x2[0] + x2[1]*x2[1] + x2[2]*x2[2])
    x3_norm = sqrt(x3[0]*x3[0] + x3[1]*x3[1] + x3[2]*x3[2])

    for i in range(3):
        x1[i] /= x1_norm
        x2[i] /= x2_norm
        x3[i] /= x3_norm

    R[0] = x1[0]
    R[1] = x1[1]
    R[2] = x1[2]
    R[3] = x2[0]
    R[4] = x2[1]
    R[5] = x2[2]
    R[6] = x3[0]
    R[7] = x3[1]
    R[8] = x3[2]

cdef void to_sat_coords(double *w, double *R, # in
                        double *w_prime): # out
    # Translate to be centered on progenitor
    cdef int i

    # Project into new basis
    w_prime[0] = w[0]*R[0] + w[1]*R[1] + w[2]*R[2]
    w_prime[1] = w[0]*R[3] + w[1]*R[4] + w[2]*R[5]
    w_prime[2] = w[0]*R[6] + w[1]*R[7] + w[2]*R[8]

    w_prime[3] = w[3]*R[0] + w[4]*R[1] + w[5]*R[2]
    w_prime[4] = w[3]*R[3] + w[4]*R[4] + w[5]*R[5]
    w_prime[5] = w[3]*R[6] + w[4]*R[7] + w[5]*R[8]

cdef void from_sat_coords(double *w_prime, double *R, # in
                          double *w): # out
    cdef int i

    # Project back from sat plane
    w[0] = w_prime[0]*R[0] + w_prime[1]*R[3] + w_prime[2]*R[6]
    w[1] = w_prime[0]*R[1] + w_prime[1]*R[4] + w_prime[2]*R[7]
    w[2] = w_prime[0]*R[2] + w_prime[1]*R[5] + w_prime[2]*R[8]

    w[3] = w_prime[3]*R[0] + w_prime[4]*R[3] + w_prime[5]*R[6]
    w[4] = w_prime[3]*R[1] + w_prime[4]*R[4] + w_prime[5]*R[7]
    w[5] = w_prime[3]*R[2] + w_prime[4]*R[5] + w_prime[5]*R[8]

# ---------------------------------------------------------------------

cdef void car_to_cyl(double *w, # in
                     double *cyl): # out
    cdef:
        double R = sqrt(w[0]*w[0] + w[1]*w[1])
        double phi = atan2(w[1], w[0])
        double vR = (w[0]*w[3] + w[1]*w[4]) / R
        double vphi = (w[0]*w[4] - w[3]*w[1]) / R

    cyl[0] = R
    if phi < 0:
        phi = phi + 2*M_PI
    cyl[1] = phi
    cyl[2] = w[2]

    cyl[3] = vR
    cyl[4] = vphi
    cyl[5] = w[5]

cdef void cyl_to_car(double *cyl, # in
                     double *w): # out
    w[0] = cyl[0] * cos(cyl[1])
    w[1] = cyl[0] * sin(cyl[1])
    w[2] = cyl[2]

    w[3] = cyl[3] * cos(cyl[1]) - cyl[4] * sin(cyl[1])
    w[4] = cyl[3] * sin(cyl[1]) + cyl[4] * cos(cyl[1])
    w[5] = cyl[5]

# ---------------------------------------------------------------------
# Tests
#

cpdef _test_sat_rotation_matrix():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[::1] w = np.zeros(6)
        double[::1] wrot = np.zeros(6)
        double[::1] w2 = np.zeros(6)
        double[:, ::1] R = np.zeros((3, 3))
        unsigned int i, j

    for i in range(n):
        w = np.random.uniform(size=6)
        sat_rotation_matrix(&w[0], &R[0, 0])

        x = np.array(R).dot(np.array(w)[:3])
        assert x[0] > 0
        assert np.allclose(x[1], 0)
        assert np.allclose(x[2], 0)

        v = np.array(R).dot(np.array(w)[3:])
        assert np.allclose(v[2], 0)
        for j in range(3):
            wrot[j] = x[j]
            wrot[j+3] = v[j]

        x2 = np.array(R.T).dot(np.array(wrot)[:3])
        v2 = np.array(R.T).dot(np.array(wrot)[3:])
        for j in range(3):
            w2[j] = x2[j]
            w2[j+3] = v2[j]

        for j in range(6):
            assert np.allclose(w[j], w2[j])

cpdef _test_to_sat_coords_roundtrip():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] w = np.random.uniform(size=(n, 6))
        double[:, ::1] w_sat = np.random.uniform(size=(n, 6))
        double[:, ::1] R = np.zeros((3, 3))

        double[::1] w_prime = np.zeros(6)
        double[::1] w2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        sat_rotation_matrix(&w_sat[i, 0], &R[0, 0])
        to_sat_coords(&w[i, 0], &R[0, 0], &w_prime[0])
        from_sat_coords(&w_prime[0], &R[0, 0], &w2[0])

        for j in range(6):
            assert np.allclose(w[i, j], w2[j])

cpdef _test_car_to_cyl_roundtrip():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] w = np.random.uniform(-10, 10, size=(n, 6))
        double[::1] cyl = np.zeros(6)
        double[::1] w2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        car_to_cyl(&w[i, 0], &cyl[0])
        cyl_to_car(&cyl[0], &w2[0])
        for j in range(6):
            assert np.allclose(w[i, j], w2[j])

cpdef _test_cyl_to_car_roundtrip():
    import numpy as np
    # np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] cyl = np.random.uniform(0, 2*np.pi, size=(n, 6))
        double[::1] w = np.zeros(6)
        double[::1] cyl2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        cyl_to_car(&cyl[i, 0], &w[0])
        car_to_cyl(&w[0], &cyl2[0])
        for j in range(6):
            # assert np.allclose(cyl[i, j], cyl2[j])
            if not np.allclose(cyl[i, j], cyl2[j]):
                print(i, j, cyl[i, j], cyl2[j])

# cdef void car_to_sph(double *xyz, double *sph):
#     # TODO: note this isn't consistent with the velocity transform because of theta
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double phi = atan2(xyz[1], xyz[0])
#         double theta = acos(xyz[2] / d)

#     sph[0] = d
#     sph[1] = phi
#     sph[2] = theta

# cdef void sph_to_car(double *sph, double *xyz):
#     # TODO: note this isn't consistent with the velocity transform because of theta
#     # get out spherical components
#     xyz[0] = sph[0] * cos(sph[1]) * sin(sph[2])
#     xyz[1] = sph[0] * sin(sph[1]) * sin(sph[2])
#     xyz[2] = sph[0] * cos(sph[2])

# cdef void v_car_to_sph(double *xyz, double *vxyz, double *vsph):
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double dxy = sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1])

#         double vr = (xyz[0]*vxyz[0]+xyz[1]*vxyz[1]+xyz[2]*vxyz[2]) / d

#         double mu_lon = (xyz[0]*vxyz[1] - vxyz[0]*xyz[1]) / (dxy*dxy)
#         double vlon = mu_lon * dxy # cos(lat)

#         double mu_lat = (xyz[2]*(xyz[0]*vxyz[0] + xyz[1]*vxyz[1]) - dxy*dxy*vxyz[2]) / (d*d*dxy)
#         double vlat = -mu_lat * d

#     vsph[0] = vr
#     vsph[1] = vlon
#     vsph[2] = vlat

# cdef void v_sph_to_car(double *xyz, double *vsph, double *vxyz):
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double dxy = sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1])

#     vxyz[0] = vsph[0]*xyz[0]/dxy*dxy/d - xyz[1]/dxy*vsph[1] - xyz[0]/dxy*xyz[2]/d*vsph[2]
#     vxyz[1] = vsph[0]*xyz[1]/dxy*dxy/d + xyz[0]/dxy*vsph[1] - xyz[1]/dxy*xyz[2]/d*vsph[2]
#     vxyz[2] = vsph[0]*xyz[2]/d + dxy/d*vsph[2]
</file>

<file path="gala/dynamics/mockstream/core.py">
# Third-party
import astropy.units as u
import numpy as np

# Project
from ...io import quantity_to_hdf5, quantity_from_hdf5
from .. import PhaseSpacePosition

__all__ = ['MockStream']


class MockStream(PhaseSpacePosition):

    @u.quantity_input(release_time=u.Myr)
    def __init__(self, pos, vel=None, frame=None,
                 release_time=None, lead_trail=None):

        super().__init__(pos=pos, vel=vel, frame=frame)

        if release_time is not None:
            release_time = u.Quantity(release_time)
            if len(release_time) != self.pos.shape[0]:
                raise ValueError('shape mismatch: input release time array '
                                 'must have the same shape as the input '
                                 'phase-space data, minus the component '
                                 'dimension. expected {}, got {}'
                                 .format(self.pos.shape[0],
                                         len(release_time)))

        self.release_time = release_time

        if lead_trail is not None:
            lead_trail = np.array(lead_trail)
            if len(lead_trail) != self.pos.shape[0]:
                raise ValueError('shape mismatch: input leading/trailing array '
                                 'must have the same shape as the input '
                                 'phase-space data, minus the component '
                                 'dimension. expected {}, got {}'
                                 .format(self.pos.shape[0],
                                         len(lead_trail)))

        self.lead_trail = lead_trail

    # ------------------------------------------------------------------------
    # Input / output
    #
    def to_hdf5(self, f):
        """
        Serialize this object to an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """

        f = super().to_hdf5(f)

        # if self.potential is not None:
        #     import yaml
        #     from ..potential.potential.io import to_dict
        #     f['potential'] = yaml.dump(to_dict(self.potential)).encode('utf-8')

        if self.release_time:
            quantity_to_hdf5(f, 'release_time', self.release_time)

        if self.lead_trail is not None:
            f['lead_trail'] = self.lead_trail.astype('S1')  # TODO HACK
        return f

    @classmethod
    def from_hdf5(cls, f):
        """
        Load an object from an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """
        # TODO: this is duplicated code from PhaseSpacePosition
        if isinstance(f, str):
            import h5py
            f = h5py.File(f, mode='r')

        obj = PhaseSpacePosition.from_hdf5(f)

        if 'release_time' in f:
            t = quantity_from_hdf5(f['release_time'])
        else:
            t = None

        if 'lead_trail' in f:
            lt = f['lead_trail'][:]
        else:
            lt = None

        return cls(pos=obj.pos, vel=obj.vel,
                   release_time=t, lead_trail=lt,
                   frame=obj.frame)
</file>

<file path="gala/dynamics/mockstream/df.pxd">
# cython: language_level=3

from ...potential.potential.cpotential cimport CPotential

cdef class BaseStreamDF:

    cdef double _lead
    cdef double _trail
    cdef public object random_state

    # TODO: used only in the FardalStreamDF class
    cdef int _gala_modified

    cdef void get_rj_vj_R(self, CPotential *cpotential, double G,
                          double *prog_x, double *prog_v,
                          double prog_m, double t,
                          double *rj, double *vj, double[:, ::1] R)

    cdef void transform_from_sat(self, double[:, ::1] R,
                                 double *x, double *v,
                                 double *prog_x, double *prog_v,
                                 double *out_x, double *out_v)

    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles)

    cpdef sample(self, prog_orbit, prog_mass, hamiltonian=?,
                 release_every=?, n_particles=?)
</file>

<file path="gala/dynamics/mockstream/df.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

# Third-party
from astropy.utils.misc import isiterable
import cython
import astropy.units as u
import numpy as np
cimport numpy as np
from libc.math cimport sqrt, sin, cos, M_PI

# This package
from .. import combine, Orbit
from ..nbody import DirectNBody
from ...potential import Hamiltonian, PotentialBase, StaticFrame
from ...potential.potential.cpotential cimport CPotentialWrapper, CPotential
from ...potential.hamiltonian.chamiltonian import Hamiltonian

from ._coord cimport cross, norm, apply_3matrix
from .core import MockStream

__all__ = ['BaseStreamDF', 'FardalStreamDF', 'StreaklineStreamDF',
           'LagrangeCloudStreamDF', 'ChenStreamDF']

cdef extern from "potential/src/cpotential.h":
    double c_d2_dr2(CPotential *p, double t, double *q, double *epsilon) nogil


@cython.embedsignature(True)
cdef class BaseStreamDF:
    """A base class for representing distribution functions for generating
    stellar streams.

    This class specifies how massless star particles should be sampled in
    order to generate a mock stellar stream.

    Parameters
    ----------
    lead : bool (optional)
        Generate a leading tail. Default: True.
    trail : bool (optional)
        Generate a trailing tail. Default: True.
    random_state : `~numpy.random.RandomState` (optional)
        To control random number generation.

    """
    def __init__(self, lead=True, trail=True, random_state=None):

        self._lead = int(lead)
        self._trail = int(trail)

        if random_state is None:
            random_state = np.random.RandomState()
        self.random_state = random_state

        if not self.lead and not self.trail:
            raise ValueError("You must generate either leading or trailing "
                             "tails (or both!)")

    cdef void get_rj_vj_R(self, CPotential *cpotential, double G,
                          double *prog_x, double *prog_v,
                          double prog_m, double t,
                          double *rj, double *vj, double[:, ::1] R): # outputs
        # NOTE: assuming ndim=3 throughout here
        cdef:
            int i
            double dist = norm(prog_x, 3)
            double L[3]
            double Lmag, Om, d2r

        # angular momentum vector, L, and |L|
        cross(prog_x, prog_v, &L[0])
        Lnorm = norm(&L[0], 3)

        # NOTE: R goes from non-rotating frame to rotating frame!!!
        for i in range(3):
            R[0, i] = prog_x[i] / dist
            R[2, i] = L[i] / Lnorm

        # Now compute jacobi radius and relative velocity at jacobi radius
        # Note: we re-use the L array as the "epsilon" array needed by d2_dr2
        Om = Lnorm / dist**2
        d2r = c_d2_dr2(cpotential, t, prog_x,
                       &L[0])
        rj[0] = (G * prog_m / (Om*Om - d2r)) ** (1/3.)
        vj[0] = Om * rj[0]

        # re-use the epsilon array to compute cross-product
        cross(&R[0, 0], &R[2, 0], &R[1, 0])
        for i in range(3):
            R[1, i] = -R[1, i]

    cdef void transform_from_sat(self, double[:, ::1] R,
                                 double *x, double *v,
                                 double *prog_x, double *prog_v,
                                 double *out_x, double *out_v):
        # from satellite coordinates to global coordinates note: the 1 is
        # because above in get_rj_vj_R(), we compute the transpose of the
        # rotation matrix we actually need
        apply_3matrix(R, x, out_x, 1)
        apply_3matrix(R, v, out_v, 1)

        for n in range(3):
            out_x[n] += prog_x[n]
            out_v[n] += prog_v[n]


    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles):
        pass

    # ------------------------------------------------------------------------
    # Python-only:

    @property
    def lead(self):
        return self._lead

    @property
    def trail(self):
        return self._trail

    cpdef sample(self, prog_orbit, prog_mass, hamiltonian=None,
                 release_every=1, n_particles=1):
        """sample(prog_orbit, prog_mass, hamiltonian=None, release_every=1, n_particles=1)

        Generate stream particle initial conditions and initial times.

        This method is primarily meant to be used within the
        ``MockStreamGenerator``.

        Parameters
        ----------
        prog_orbit : `~gala.dynamics.Orbit`
            The orbit of the progenitor system.
        prog_mass : `~astropy.units.Quantity` [mass]
            The mass of the progenitor system, either a scalar quantity, or as
            an array with the same shape as the number of timesteps in the orbit
            to account for mass evolution.
        hamiltonian : `~gala.potential.Hamiltonian`
            The external potential and reference frame to numerically integrate
            orbits in.
        release_every : int (optional)
            Controls how often to release stream particles from each tail.
            Default: 1, meaning release particles at each timestep.
        n_particles : int, array_like (optional)
            If an integer, this controls the number of particles to release in
            each tail at each release timestep. Alternatively, you can pass in
            an array with the same shape as the number of timesteps to release
            bursts of particles at certain times (e.g., pericenter).

        Returns
        -------
        xyz : `~astropy.units.Quantity` [length]
            The initial positions for stream star particles.
        v_xyz : `~astropy.units.Quantity` [speed]
            The initial velocities for stream star particles.
        t1 : `~astropy.units.Quantity` [time]
            The initial times (i.e. times to start integrating from) for stream
            star particles.
        """

        if prog_orbit.hamiltonian is not None:
            H = prog_orbit.hamiltonian
        elif hamiltonian is not None:
            H = Hamiltonian(hamiltonian)
        else:
            raise ValueError('TODO')

        # TODO: if an orbit with non-static frame passed in, convert to static frame before generating
        static_frame = StaticFrame(H.units)
        frame = H.frame

        # TODO: we could catch this possible error and make it more specific
        prog_orbit_static = prog_orbit.to_frame(static_frame)

        # Coerce the input orbit into C-contiguous numpy arrays in the units of
        # the hamiltonian
        _units = H.units
        prog_x = np.ascontiguousarray(
            prog_orbit_static.xyz.decompose(_units).value.T)
        prog_v = np.ascontiguousarray(
            prog_orbit_static.v_xyz.decompose(_units).value.T)
        prog_t = prog_orbit_static.t.decompose(_units).value
        try:
            prog_m = prog_mass.decompose(_units).value
        except:
            raise TypeError("Input progenitor mass must be a Quantity object "
                            "with a decompose() method, e.g, an astropy "
                            "quantity.")

        if not isiterable(prog_m):
            prog_m = np.ones_like(prog_t) * prog_m

        if isiterable(n_particles):
            n_particles = np.array(n_particles).astype('i4')
            if not len(n_particles) == len(prog_t):
                raise ValueError('If passing in an array n_particles, its '
                                 'shape must match the number of timesteps in '
                                 'the progenitor orbit.')

        else:
            N = int(n_particles)
            n_particles = np.zeros_like(prog_t, dtype='i4')
            n_particles[::release_every] = N

        x, v, t1 = self._sample(H.potential, prog_x, prog_v,
                                prog_t, prog_m,
                                n_particles)

        # First out what particles are leading vs. trailing:
        lt = np.empty(len(t1), dtype='U1')
        i = 0
        for n in n_particles:
            if self._trail:
                lt[i:i+n] = 't'
                i += n

            if self._lead:
                lt[i:i+n] = 'l'
                i += n

        out = Orbit(pos=np.array(x).T * _units['length'],
                    vel=np.array(v).T * _units['length']/_units['time'],
                    t=np.array(t1) * _units['time'],
                    frame=static_frame)

        # Transform back to the input frame
        out = out.to_frame(frame)

        w0 = MockStream(pos=out.pos, vel=out.vel, frame=out.frame,
                        release_time=out.t, lead_trail=lt)

        return w0


@cython.embedsignature(True)
cdef class StreaklineStreamDF(BaseStreamDF):
    """A class for representing the "streakline" distribution function for
    generating stellar streams based on Kuepper et al. 2012
    https://ui.adsabs.harvard.edu/abs/2012MNRAS.420.2700K/abstract

    Parameters
    ----------
    lead : bool (optional)
        Generate a leading tail. Default: True.
    trail : bool (optional)
        Generate a trailing tail. Default: True.
    random_state : `~numpy.random.RandomState` (optional)
        To control random number generation.
    """

    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles):
        cdef:
            int i, j, k, n
            int ntimes = len(prog_t)
            int total_nparticles = (self._lead + self._trail) * np.sum(nparticles)

            double[:, ::1] particle_x = np.zeros((total_nparticles, 3))
            double[:, ::1] particle_v = np.zeros((total_nparticles, 3))
            double[::1] particle_t1 = np.zeros((total_nparticles, ))

            double[::1] tmp_x = np.zeros(3)
            double[::1] tmp_v = np.zeros(3)

            double rj # jacobi radius
            double vj # relative velocity at jacobi radius
            double[:, ::1] R = np.zeros((3, 3)) # rotation to satellite coordinates

            CPotential cpotential = (<CPotentialWrapper>(potential.c_instance)).cpotential
            double G = potential.G

        j = 0
        for i in range(ntimes):
            if prog_m[i] == 0:
                continue

            self.get_rj_vj_R(&cpotential, G,
                             &prog_x[i, 0], &prog_v[i, 0], prog_m[i], prog_t[i],
                             &rj, &vj, R) # outputs

            # Trailing tail
            if self._trail == 1:
                for k in range(nparticles[i]):
                    tmp_x[0] = rj
                    tmp_v[1] = vj
                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

            # Leading tail
            if self._lead == 1:
                for k in range(nparticles[i]):
                    tmp_x[0] = -rj
                    tmp_v[1] = -vj
                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

        return particle_x, particle_v, particle_t1


@cython.embedsignature(True)
cdef class FardalStreamDF(BaseStreamDF):
    """A class for representing the Fardal+2015 distribution function for
    generating stellar streams based on Fardal et al. 2015
    https://ui.adsabs.harvard.edu/abs/2015MNRAS.452..301F/abstract

    Parameters
    ----------
    gala_modified : bool (optional)
        If True, use the modified version of the Fardal method parameters used in Gala. If you would like to use the exact parameters from Fardal+2015, set this to False. Default: True.
    lead : bool (optional)
        Generate a leading tail. Default: True.
    trail : bool (optional)
        Generate a trailing tail. Default: True.
    random_state : `~numpy.random.RandomState` (optional)
        To control random number generation.
    """
    def __init__(
        self, gala_modified=None, lead=True, trail=True, random_state=None
    ):
        super().__init__(lead=lead, trail=trail, random_state=random_state)

        if gala_modified is None:
            from gala.util import GalaDeprecationWarning
            import warnings
            msg = (
                "The parameter values of the FardalStreamDF have been updated (fixed) "
                "to match the parameter values in the final published version of "
                "Fardal+2015. For now, this class uses the Gala modified parameter "
                "values that have been adopted over the last several years in Gala. "
                "In the future, the default behavior of this class will use the "
                "Fardal+2015 parameter values instead, breaking backwards "
                "compatibility for mock stream simulations. To use the Fardal+2015 "
                "parameters now, set gala_modified=False. To continue to use the Gala "
                "modified parameter values, set gala_modified=True."
            )
            warnings.warn(msg, GalaDeprecationWarning)
            gala_modified = True

        self._gala_modified = int(gala_modified)


    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles):
        cdef:
            int i, j, k, n
            int ntimes = len(prog_t)
            int total_nparticles = (self._lead + self._trail) * np.sum(nparticles)

            double[:, ::1] particle_x = np.zeros((total_nparticles, 3))
            double[:, ::1] particle_v = np.zeros((total_nparticles, 3))
            double[::1] particle_t1 = np.zeros((total_nparticles, ))

            double[::1] tmp_x = np.zeros(3)
            double[::1] tmp_v = np.zeros(3)

            double rj # jacobi radius
            double vj # relative velocity at jacobi radius
            double[:, ::1] R = np.zeros((3, 3)) # rotation to satellite coordinates

            # for Fardal method:
            double kx
            double[::1] k_mean = np.zeros(6)
            double[::1] k_disp = np.zeros(6)

            CPotential cpotential = (<CPotentialWrapper>(potential.c_instance)).cpotential
            double G = potential.G

        # TODO: support computing this, which requires knowing the peri/apo and values
        # of Om**2 - d2Phi/dr2 at those points...
        # kvt_fardal = min(0.15 * self.f_t**2 * Racc**(2/3), 0.4)
        kvt_fardal = 0.4

        k_mean[0] = 2. # R
        k_disp[0] = 0.5 if self._gala_modified else 0.4

        k_mean[2] = 0. # z
        k_disp[2] = 0.5

        k_mean[4] = 0.3 # vt
        k_disp[4] = 0.5 if self._gala_modified else kvt_fardal

        k_mean[5] = 0. # vz
        k_disp[5] = 0.5

        j = 0
        for i in range(ntimes):
            if prog_m[i] == 0:
                continue

            self.get_rj_vj_R(&cpotential, G,
                             &prog_x[i, 0], &prog_v[i, 0], prog_m[i], prog_t[i],
                             &rj, &vj, R)  # outputs

            # Trailing tail
            if self._trail == 1:
                for k in range(nparticles[i]):
                    kx = self.random_state.normal(k_mean[0], k_disp[0])
                    tmp_x[0] = kx * rj
                    tmp_x[2] = self.random_state.normal(k_mean[2], k_disp[2]) * rj
                    tmp_v[1] = self.random_state.normal(k_mean[4], k_disp[4]) * vj
                    if self._gala_modified:  # for backwards compatibility
                        tmp_v[1] *= kx
                    tmp_v[2] = self.random_state.normal(k_mean[5], k_disp[5]) * vj
                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

            # Leading tail
            if self._lead == 1:
                for k in range(nparticles[i]):
                    kx = self.random_state.normal(k_mean[0], k_disp[0])
                    tmp_x[0] = kx * -rj
                    tmp_x[2] = self.random_state.normal(k_mean[2], k_disp[2]) * -rj
                    tmp_v[1] = self.random_state.normal(k_mean[4], k_disp[4]) * -vj
                    if self._gala_modified:  # for backwards compatibility
                        tmp_v[1] *= kx
                    tmp_v[2] = self.random_state.normal(k_mean[5], k_disp[5]) * -vj
                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

        return particle_x, particle_v, particle_t1


@cython.embedsignature(True)
cdef class LagrangeCloudStreamDF(BaseStreamDF):
    """A class for representing the Lagrange Cloud Stripping distribution
    function for generating stellar streams. This df is based on Gibbons et al.
    2014 https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3788G/abstract
    but has since been modified by, e.g., Erkal et al. 2019
    https://ui.adsabs.harvard.edu/abs/2019MNRAS.487.2685E/abstract .

    Parameters
    ----------
    v_disp : `~astropy.units.Quantity` [speed]
        The velocity dispersion of the released particles.
    lead : bool (optional)
        Generate a leading tail. Default: True.
    trail : bool (optional)
        Generate a trailing tail. Default: True.
    random_state : `~numpy.random.RandomState` (optional)
        To control random number generation.
    """

    cdef public object v_disp

    @u.quantity_input(v_disp=u.km/u.s)
    def __init__(self, v_disp, lead=True, trail=True, random_state=None):
        super().__init__(lead=lead, trail=trail, random_state=random_state)

        self.v_disp = v_disp

    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles):
        cdef:
            int i, j, k, n
            int ntimes = len(prog_t)
            int total_nparticles = (self._lead + self._trail) * np.sum(nparticles)

            double[:, ::1] particle_x = np.zeros((total_nparticles, 3))
            double[:, ::1] particle_v = np.zeros((total_nparticles, 3))
            double[::1] particle_t1 = np.zeros((total_nparticles, ))

            double[::1] tmp_x = np.zeros(3)
            double[::1] tmp_v = np.zeros(3)

            double rj # jacobi radius
            double vj # relative velocity at jacobi radius
            double[:, ::1] R = np.zeros((3, 3)) # rotation to satellite coordinates

            CPotential cpotential = (<CPotentialWrapper>(potential.c_instance)).cpotential
            double G = potential.G
            double _v_disp = self.v_disp.decompose(potential.units).value

        j = 0
        for i in range(ntimes):
            if prog_m[i] == 0:
                continue

            self.get_rj_vj_R(&cpotential, G,
                             &prog_x[i, 0], &prog_v[i, 0], prog_m[i], prog_t[i],
                             &rj, &vj, R) # outputs

            # Trailing tail
            if self._trail == 1:
                for k in range(nparticles[i]):
                    tmp_x[0] = rj
                    tmp_v[0] = self.random_state.normal(0, _v_disp)
                    tmp_v[1] = self.random_state.normal(0, _v_disp)
                    tmp_v[2] = self.random_state.normal(0, _v_disp)
                    particle_t1[j + k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

            # Leading tail
            if self._lead == 1:
                for k in range(nparticles[i]):
                    tmp_x[0] = -rj
                    tmp_v[0] = self.random_state.normal(0, _v_disp)
                    tmp_v[1] = self.random_state.normal(0, _v_disp)
                    tmp_v[2] = self.random_state.normal(0, _v_disp)
                    particle_t1[j + k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

        return particle_x, particle_v, particle_t1


@cython.embedsignature(True)
cdef class ChenStreamDF(BaseStreamDF):
    """A class for representing the Chen+2024 distribution function for
    generating stellar streams based on Chen et al. 2024
    https://ui.adsabs.harvard.edu/abs/2024arXiv240801496C/abstract

    Parameters
    ----------
    lead : bool (optional)
        Generate a leading tail. Default: True.
    trail : bool (optional)
        Generate a trailing tail. Default: True.
    random_state : `~numpy.random.RandomState` (optional)
        To control random number generation.
    """
    def __init__(
        self, lead=True, trail=True, random_state=None
    ):
        super().__init__(lead=lead, trail=trail, random_state=random_state)


    cpdef _sample(self, potential,
                  double[:, ::1] prog_x, double[:, ::1] prog_v,
                  double[::1] prog_t, double[::1] prog_m, int[::1] nparticles):
        cdef:
            int i, j, k, n
            int ntimes = len(prog_t)
            int total_nparticles = (self._lead + self._trail) * np.sum(nparticles)

            double[:, ::1] particle_x = np.zeros((total_nparticles, 3))
            double[:, ::1] particle_v = np.zeros((total_nparticles, 3))
            double[::1] particle_t1 = np.zeros((total_nparticles, ))

            double[::1] tmp_x = np.zeros(3)
            double[::1] tmp_v = np.zeros(3)

            double rj # jacobi radius
            double vj # relative velocity at jacobi radius
            double[:, ::1] R = np.zeros((3, 3)) # rotation to satellite coordinates

            # for Chen method:
            double Dr
            double Dv
            double[::1] posvel = np.zeros(6)
            double[::1] mean = np.zeros(6)
            double[:, ::1] cov = np.zeros((6, 6))

            CPotential cpotential = (<CPotentialWrapper>(potential.c_instance)).cpotential
            double G = potential.G

        mean[0] = 1.6    # r
        cov[0, 0] = 0.1225

        mean[1] = -30.   # phi
        cov[1, 1] = 529.

        mean[2] = 0.     # theta
        cov[2, 2] = 144.

        mean[3] = 1.     # v
        cov[3, 3] = 0.

        mean[4] = 20.    # alpha
        cov[4, 4] = 400.

        mean[5] = 0.     # beta
        cov[5, 5] = 484.

        cov[0, 4] = -4.9 # covariance between r and alpha
        cov[4, 0] = -4.9

        j = 0
        for i in range(ntimes):
            if prog_m[i] == 0:
                continue

            self.get_rj_vj_R(&cpotential, G,
                             &prog_x[i, 0], &prog_v[i, 0], prog_m[i], prog_t[i],
                             &rj, &vj, R)  # outputs

            # trailing tail
            if self._trail == 1:
                for k in range(nparticles[i]):
                    # calculate the ejection position and velocity
                    posvel = self.random_state.multivariate_normal(mean, cov)

                    Dr = posvel[0] * rj
                    Dv = posvel[3] * sqrt(2*G*prog_m[i]/Dr) # escape velocity

                    # convert degrees to radians
                    posvel[1] = posvel[1] * (M_PI/180)
                    posvel[2] = posvel[2] * (M_PI/180)
                    posvel[4] = posvel[4] * (M_PI/180)
                    posvel[5] = posvel[5] * (M_PI/180)

                    tmp_x[0] = Dr*cos(posvel[2])*cos(posvel[1])
                    tmp_x[1] = Dr*cos(posvel[2])*sin(posvel[1])
                    tmp_x[2] = Dr*sin(posvel[2])

                    tmp_v[0] = Dv*cos(posvel[5])*cos(posvel[4])
                    tmp_v[1] = Dv*cos(posvel[5])*sin(posvel[4])
                    tmp_v[2] = Dv*sin(posvel[5])

                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])

                j += nparticles[i]

            # Leading tail
            if self._lead == 1:
                for k in range(nparticles[i]):
                    # calculate the ejection position and velocity
                    posvel = self.random_state.multivariate_normal(mean, cov)

                    Dr = posvel[0] * rj
                    Dv = posvel[3] * sqrt(2*G*prog_m[i]/Dr) # escape velocity

                    # convert degrees to radians
                    posvel[1] = posvel[1] * (M_PI/180) + M_PI
                    posvel[2] = posvel[2] * (M_PI/180)
                    posvel[4] = posvel[4] * (M_PI/180) + M_PI
                    posvel[5] = posvel[5] * (M_PI/180)

                    tmp_x[0] = Dr*cos(posvel[2])*cos(posvel[1])
                    tmp_x[1] = Dr*cos(posvel[2])*sin(posvel[1])
                    tmp_x[2] = Dr*sin(posvel[2])

                    tmp_v[0] = Dv*cos(posvel[5])*cos(posvel[4])
                    tmp_v[1] = Dv*cos(posvel[5])*sin(posvel[4])
                    tmp_v[2] = Dv*sin(posvel[5])

                    particle_t1[j+k] = prog_t[i]

                    self.transform_from_sat(R,
                                            &tmp_x[0], &tmp_v[0],
                                            &prog_x[i, 0], &prog_v[i, 0],
                                            &particle_x[j+k, 0],
                                            &particle_v[j+k, 0])
                
                j += nparticles[i]

        return particle_x, particle_v, particle_t1
</file>

<file path="gala/dynamics/mockstream/mockstream_generator.py">
# Third-party
import numpy as np

from ...integrate.timespec import parse_time_specification
from ...potential import Hamiltonian, PotentialBase

# This package
from .. import PhaseSpacePosition, combine
from ..nbody import DirectNBody
from ._mockstream import mockstream_dop853, mockstream_dop853_animate
from .core import MockStream

__all__ = ["MockStreamGenerator"]


class MockStreamGenerator:
    def __init__(self, df, hamiltonian, progenitor_potential=None):
        """Generate a mock stellar stream in the specified external potential.

        By default, you must pass in a specification of the stream distribution
        function (``df``), and the external gravitational potential and
        reference frame (via a `~gala.potential.Hamiltonian` object passed in
        through the ``hamiltonian`` argument).

        Also by default, the stream generation does not include the self-gravity
        of the progenitor system: star particles are generated using the ``df``
        object, and released into the external potential specified by the
        ``hamiltonian``. If you would like the star particles to feel the
        gravitational field of the progenitor system, you may pass in a
        potential object to represent the progenitor via the
        ``progenitor_potential`` argument. This can be any valid gala potential
        instance.

        Parameters
        ----------
        df : `~gala.dynamics.BaseStreamDF` subclass instance
            The stream distribution function (DF) object that specifies how to
            generate stream star particle initial conditions.
        hamiltonian : `~gala.potential.Hamiltonian`
            The external potential and reference frame to numerically integrate
            orbits in.
        progenitor_potential : `~gala.potential.PotentialBase` (optional)
            If specified, the self-gravity of the progenitor system is included
            in the force calculation and orbit integration. If not specified,
            self-gravity is not accounted for. Default: ``None``
        """
        from .df import BaseStreamDF

        if not isinstance(df, BaseStreamDF):
            raise TypeError(
                "The input distribution function (DF) instance "
                "must be an instance of a subclass of "
                "BaseStreamDF, not {}.".format(type(df))
            )
        self.df = df

        # Validate the inpute hamiltonian
        self.hamiltonian = Hamiltonian(hamiltonian)

        if progenitor_potential is not None:
            # validate the potential class
            if not isinstance(progenitor_potential, PotentialBase):
                raise TypeError(
                    "If specified, the progenitor_potential must be a gala.potential "
                    "class instance."
                )

            self.self_gravity = True

        else:
            self.self_gravity = False

        self.progenitor_potential = progenitor_potential

    def _get_nbody(self, prog_w0, nbody):
        """
        Internal function that adds the progenitor to the list of nbody objects to
        integrate along with the test particles in the stream.
        """

        kwargs = dict()
        if nbody is not None:
            if nbody.external_potential != self.hamiltonian.potential:
                raise ValueError(
                    "The external potential of the input nbody instance must match the "
                    "potential of the mock stream input hamiltonian! "
                    f"{nbody.external_potential} vs. {self.hamiltonian.potential}"
                )

            if nbody.frame != self.hamiltonian.frame:
                raise ValueError(
                    "The reference frame of the input nbody instance must match the "
                    "frame of the mock stream input hamiltonian! "
                    f"{nbody.frame} vs. {self.hamiltonian.frame}"
                )

            kwargs["w0"] = combine((prog_w0, nbody.w0))
            kwargs["particle_potentials"] = [
                self.progenitor_potential
            ] + nbody.particle_potentials
            kwargs["external_potential"] = self.hamiltonian.potential
            kwargs["frame"] = self.hamiltonian.frame
            kwargs["units"] = self.hamiltonian.units

        else:
            kwargs["w0"] = prog_w0
            kwargs["particle_potentials"] = [self.progenitor_potential]
            kwargs["external_potential"] = self.hamiltonian.potential
            kwargs["frame"] = self.hamiltonian.frame
            kwargs["units"] = self.hamiltonian.units

        return DirectNBody(**kwargs)

    def run(
        self,
        prog_w0,
        prog_mass,
        nbody=None,
        release_every=1,
        n_particles=1,
        output_every=None,
        output_filename=None,
        check_filesize=True,
        overwrite=False,
        progress=False,
        **time_spec,
    ):
        """
        Run the mock stream generator with the specified progenitor initial conditions.

        This method generates the mock stellar stream for the specified progenitor
        system properties. The progenitor orbit is specified by passing in the initial
        or final conditions ``prog_w0`` and by specifying time-stepping information via
        the ``**time_spec`` keyword arguments. If the time-stepping specification
        proceeds forward in time, ``prog_w0`` is interpreted as initial conditions and
        the mock stream is generated forwards from this position. If the time-stepping
        proceeds backwards in time, the progenitor orbit is first numerically integrated
        backwards given the time-stepping information, then the stream is generated
        forward from the past such that ``prog_w0`` becomes the final position of the
        progenitor.

        Note that the stream generation also supports including other massive perturbers
        that can gravitationally influence the stream stars. These other massive bodies
        must be passed in as a `~gala.dynamics.DirectNBody` instance through the
        ``nbody`` argument. The phase-space coordinates of the bodies, ``nbody.w0``, are
        interpreted as initial or final conditions with the same logic as above.

        Parameters
        ----------
        prog_w0 : `~gala.dynamics.PhaseSpacePosition`
            The initial or final phase-space position of the progenitor system (see note
            above).
        prog_mass : `~astropy.units.Quantity` [mass]
            The mass of the progenitor system, passed in to the stream distribution
            function (df) ``.sample()`` method. This quantity sets the scale mass of the
            particle release df, but not the mass of the progenitor potential used to
            compute the self-gravity on the stream particles.
        nbody : `~gala.dynamics.DirectNBody` (optional)
            This allows specifying other massive perturbers (N-bodies) that can
            gravitationally influence the stream star orbits.
        release_every : int (optional)
            Controls how often to release stream particles from each tail. Default: 1,
            meaning release particles at each timestep.
        n_particles : int, array_like (optional)
            If an integer, this controls the number of particles to release in each tail
            at each release timestep. Alternatively, you can pass in an array with the
            same shape as the number of timesteps to release bursts of particles at
            certain times (e.g., pericenter).
        output_every : int (optional)
            Controls whether to output snapshots of the stream particle orbits. This is
            relative to the global time array.
        output_filename : str (optional)
            The path to the HDF5 file to be generated by the snapshotting.
        check_filesize : bool (optional)
            If True (the default value), this controls whether to check the estimated
            size of the  output file, and emits a warning if the file is >8GB in size.
        overwrite : bool (optional)
            Overwrite the output file if it exists.
        progress : bool (optional)
            Print a very basic progress bar while computing the stream.
        **time_spec
            Specification of how long to integrate. Most commonly, this is a timestep
            ``dt`` and number of steps ``n_steps``, or a timestep ``dt``, initial time
            ``t1``, and final time ``t2``. You may also pass in a time array with ``t``.
            See documentation for `~gala.integrate.parse_time_specification` for more
            information.

        Returns
        -------
        stream_w : `~gala.dynamics.PhaseSpacePosition`
        nbody_w : `~gala.dynamics.PhaseSpacePosition`

        """
        units = self.hamiltonian.units
        t = parse_time_specification(units, **time_spec)

        prog_nbody = self._get_nbody(prog_w0, nbody)
        nbody_orbits = prog_nbody.integrate_orbit(t=t)

        # If the time stepping passed in is negative, assume this means that all
        # of the initial conditions are at *end time*, and we first need to
        # integrate them backwards before treating them as initial conditions
        if t[1] < t[0]:
            nbody_orbits = nbody_orbits[::-1]

            # TODO: this could be cleaned up...
            nbody0 = DirectNBody(
                nbody_orbits[0],
                prog_nbody.particle_potentials,
                external_potential=self.hamiltonian.potential,
                frame=self.hamiltonian.frame,
                units=units,
            )

        else:
            nbody0 = prog_nbody

        # Note: assumes that this is an orbit not a psp, i.e. that save_all is True
        prog_orbit = nbody_orbits[:, 0]  # Note: Progenitor must be idx 0!
        orbit_t = prog_orbit.t.decompose(units).value

        # Generate initial conditions from the DF
        stream_w0 = self.df.sample(
            prog_orbit,
            prog_mass,
            hamiltonian=self.hamiltonian,
            release_every=release_every,
            n_particles=n_particles,
        )
        w0 = np.vstack(
            (
                stream_w0.xyz.decompose(units).value,
                stream_w0.v_xyz.decompose(units).value,
            )
        ).T
        w0 = np.ascontiguousarray(w0)

        unq_t1s, nstream = np.unique(
            stream_w0.release_time.decompose(units).value, return_counts=True
        )

        all_nstream = np.zeros(prog_orbit.ntimes, dtype=int)
        for t1, n in zip(unq_t1s, nstream):
            all_nstream[np.isclose(orbit_t, t1)] = n

        if output_every is None:
            raw_nbody, raw_stream = mockstream_dop853(
                nbody0,
                orbit_t[all_nstream != 0],
                w0,
                unq_t1s,
                orbit_t[-1],
                all_nstream[all_nstream != 0].astype("i4"),
                progress=int(progress),
            )
        else:  # store snapshots
            if output_filename is None:
                raise ValueError(
                    "If output_every is specified, you must also pass in a filename to "
                    "store the snapshots in"
                )

            raw_nbody, raw_stream = mockstream_dop853_animate(
                nbody0,
                orbit_t,
                w0,
                all_nstream.astype("i4"),
                output_every=output_every,
                output_filename=output_filename,
                check_filesize=check_filesize,
                overwrite=overwrite,
                progress=int(progress),
            )

        x_unit = units["length"]
        v_unit = units["length"] / units["time"]
        stream_w = MockStream(
            pos=raw_stream[:, :3].T * x_unit,
            vel=raw_stream[:, 3:].T * v_unit,
            release_time=stream_w0.release_time,
            lead_trail=stream_w0.lead_trail,
            frame=self.hamiltonian.frame,
        )
        nbody_w = PhaseSpacePosition(
            pos=raw_nbody[:, :3].T * x_unit,
            vel=raw_nbody[:, 3:].T * v_unit,
            frame=self.hamiltonian.frame,
        )

        return stream_w, nbody_w
</file>

<file path="gala/dynamics/mockstream/mockstream.pyx">
# cython: boundscheck=False
# cython: debug=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" Generate mock streams. """


# Standard library
import warnings
from os import path
import sys

# Third-party
import astropy.units as u
import numpy as np
cimport numpy as np
np.import_array()
from yaml import dump

from libc.math cimport sqrt
from cpython.exc cimport PyErr_CheckSignals

from ...integrate.cyintegrators.dop853 cimport (dop853_step,
                                                dop853_helper_save_all)
from ...potential.potential.cpotential cimport CPotentialWrapper, CPotential
from ...potential.frame.cframe cimport CFrameWrapper, CFrameType
from ...potential.potential.builtin.cybuiltin import NullWrapper

from ...potential import Hamiltonian
from ...potential.frame import StaticFrame
from ...io import quantity_to_hdf5
from ...potential.potential.io import to_dict

from ..nbody.nbody cimport MAX_NBODY
from .df cimport BaseStreamDF

__all__ = ['mockstream_dop853', 'mockstream_dop853_animate']


cdef extern from "dopri/dop853.h":
    ctypedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                              CPotential *p, CFrameType *fr,
                              unsigned norbits, unsigned nbody,
                              void *args) nogil
    void Fwrapper_direct_nbody(unsigned ndim, double t, double *w, double *f,
                               CPotential *p, CFrameType *fr,
                               unsigned norbits, unsigned nbody, void *args) nogil


cpdef mockstream_dop853(nbody, double[::1] time,
                        double[:, ::1] stream_w0, double[::1] stream_t1,
                        double tfinal, int[::1] nstream,
                        double atol=1E-10, double rtol=1E-10, int nmax=0,
                        int progress=0):
    """
    Parameters
    ----------
    nbody : `~gala.dynamics.nbody.DirectNBody`
    time : numpy.ndarray (ntimes, )
    stream_w0 : numpy.ndarray (nstreamparticles, 6)
    stream_t1 : numpy.ndarray (ntimes, )
    nstream : numpy.ndarray (ntimes, )
        The number of stream particles to be integrated from this timestep.
        There should be no zero values.

    Notes
    -----
    In code, ``nbodies`` are the massive bodies included from the ``nbody``
    instance passed in. ``nstreamparticles`` are the stream test particles.
    ``nstream`` is the array containing the number of stream particles released
    at each timestep.

    TODO
    ----
    - `dt0` should be customizable in the Python interface.

    """

    cdef:
        int i, j, k, n  # indexing
        unsigned ndim = 6  # TODO: hard-coded, but really must be 6D

        # For N-body support:
        void *args
        CPotential *c_particle_potentials[MAX_NBODY]

        # Time-stepping parameters:
        int ntimes = time.shape[0]
        double dt0 = 1.

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(nbody.H.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(nbody.H.frame.c_instance)).cframe

        # for the test particles
        CPotentialWrapper null_wrapper = NullWrapper(1., [],
                                                     np.zeros(3), np.eye(3))
        CPotential null_p = null_wrapper.cpotential

        int nbodies = nbody._c_w0.shape[0]  # includes the progenitor
        double [:, ::1] nbody_w0 = nbody._c_w0

        int max_nstream = np.max(nstream)
        int total_nstream = np.sum(nstream)
        double[:, ::1] w_tmp = np.empty((nbodies + max_nstream, ndim))
        double[:, ::1] w_final = np.empty((nbodies + total_nstream, ndim))
        double[:, :, ::1] nbody_w = np.empty((ntimes, nbodies, ndim))

        int prog_out = max(len(time) // 100, 1)

    # set the potential objects of the progenitor (index 0) and any other
    # massive bodies included in the stream generation
    for i in range(nbodies):
        c_particle_potentials[i] = &(<CPotentialWrapper>(nbody.particle_potentials[i].c_instance)).cpotential

    # set null potentials for all of the stream particles
    for i in range(nbodies, nbodies + max_nstream):
        c_particle_potentials[i] = &null_p
    args = <void *>(&c_particle_potentials[0])

    # First have to integrate the nbody orbits so we have their positions at
    # each timestep
    nbody_w = dop853_helper_save_all(&cp, &cf,
                                     <FcnEqDiff> Fwrapper_direct_nbody,
                                     nbody_w0, time,
                                     ndim, nbodies, nbodies, args, ntimes,
                                     atol, rtol, nmax, 0)

    n = 0
    for i in range(ntimes):
        # set initial conditions for progenitor and N-bodies
        for j in range(nbodies):
            for k in range(ndim):
                w_tmp[j, k] = nbody_w[i, j, k]

        for j in range(nstream[i]):
            for k in range(ndim):
                w_tmp[nbodies+j, k] = stream_w0[n+j, k]

        dop853_step(&cp, &cf, <FcnEqDiff> Fwrapper_direct_nbody,
                    &w_tmp[0, 0], stream_t1[i], tfinal, dt0,
                    ndim, nbodies+nstream[i], nbodies, args,
                    atol, rtol, nmax)

        for j in range(nstream[i]):
            for k in range(ndim):
                w_final[nbodies+n+j, k] = w_tmp[nbodies+j, k]

        PyErr_CheckSignals()

        n += nstream[i]

        if progress == 1:
            if i % prog_out == 0:
                sys.stdout.write('\r')
                sys.stdout.write(
                    f"Integrating orbits: {100 * i / ntimes: 3.0f}%")
                sys.stdout.flush()

    if progress == 1:
        sys.stdout.write('\r')
        sys.stdout.write(f"Integrating orbits: {100: 3.0f}%")
        sys.stdout.flush()


    for j in range(nbodies):
        for k in range(ndim):
            w_final[j, k] = w_tmp[j, k]

    return_nbody_w = np.array(w_final)[:nbodies]
    return_stream_w = np.array(w_final)[nbodies:]

    return return_nbody_w, return_stream_w


cpdef mockstream_dop853_animate(nbody, double[::1] t,
                                double[:, ::1] stream_w0, int[::1] nstream,
                                output_every=1, output_filename='',
                                overwrite=False, check_filesize=True,
                                double atol=1E-10, double rtol=1E-10,
                                int nmax=0, int progress=0, double dt0=1.):
    """
    Parameters
    ----------
    nbody : `~gala.dynamics.nbody.DirectNBody`
    t : numpy.ndarray (ntimes, )
    stream_w0 : numpy.ndarray (nstreamparticles, 6)
    nstream : numpy.ndarray (ntimes, )
        The number of stream particles to be integrated from this timestep.
        There should be no zero values.

    Notes
    -----
    In code, ``nbodies`` are the massive bodies included from the ``nbody``
    instance passed in. ``nstreamparticles`` are the stream test particles.
    ``nstream`` is the array containing the number of stream particles released
    at each timestep.

    TODO
    ----
    - `dt0` should be customizable in the Python interface.

    """

    cdef:
        int i, j, k, n # indexing
        unsigned ndim = 6 # TODO: hard-coded, but really must be 6D

        # Time-stepping parameters:
        int ntimes = t.shape[0]

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(nbody.H.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(nbody.H.frame.c_instance)).cframe

        int nbodies = nbody._c_w0.shape[0] # includes the progenitor
        double [:, ::1] nbody_w0 = nbody._c_w0

        int total_nstream = np.sum(nstream)
        double[:, ::1] w = np.empty((nbodies + total_nstream, ndim))

        # For N-body support:
        void *args
        CPotential *c_particle_potentials[MAX_NBODY]

        # Snapshotting:
        int noutput_times = (ntimes-1) // output_every + 1
        double[::1] output_times

        int prog_out = max(len(t) // 100, 1)

    if (ntimes-1) % output_every != 0:
        noutput_times += 1 # +1 for final conditions

    output_times = np.zeros(noutput_times)

    est_filesize = total_nstream * noutput_times * 8 * u.byte
    if est_filesize >= 8 * u.gigabyte and check_filesize:
        warnings.warn("Estimated mockstream output file is expected to be "
                      ">8 GB in size! If you're sure, turn this warning "
                      "off with `check_filesize=False`")

    # create the output file
    if path.exists(output_filename) and overwrite == 0:
        raise IOError("Mockstream output file {} already exists! Use "
                      "overwrite=True to overwrite the file."
                      .format(output_filename))

    # set the potential objects of the progenitor (index 0) and any other
    # massive bodies included in the stream generation
    for i in range(nbodies):
        c_particle_potentials[i] = &(<CPotentialWrapper>(nbody.particle_potentials[i].c_instance)).cpotential
    args = <void *>(&c_particle_potentials[0])

    # Initialize the output file:
    import h5py
    h5f = h5py.File(str(output_filename), 'w')
    stream_g = h5f.create_group('stream')
    nbody_g = h5f.create_group('nbody')

    d = stream_g.create_dataset('pos', dtype='f8',
                                shape=(3, noutput_times, total_nstream),
                                fillvalue=np.nan, compression='gzip',
                                compression_opts=9)
    d.attrs['unit'] = str(nbody.units['length'])

    d = stream_g.create_dataset('vel', dtype='f8',
                                shape=(3, noutput_times, total_nstream),
                                fillvalue=np.nan, compression='gzip',
                                compression_opts=9)
    d.attrs['unit'] = str(nbody.units['length'] / nbody.units['time'])

    d = nbody_g.create_dataset('pos', dtype='f8',
                               shape=(3, noutput_times, nbodies),
                               fillvalue=np.nan, compression='gzip',
                               compression_opts=9)
    d.attrs['unit'] = str(nbody.units['length'])

    d = nbody_g.create_dataset('vel', dtype='f8',
                               shape=(3, noutput_times, nbodies),
                               fillvalue=np.nan, compression='gzip',
                               compression_opts=9)
    d.attrs['unit'] = str(nbody.units['length'] / nbody.units['time'])

    # set initial conditions for progenitor and N-bodies
    for j in range(nbodies):
        for k in range(ndim):
            w[j, k] = nbody_w0[j, k]

    for j in range(total_nstream):
        for k in range(ndim):
            w[nbodies+j, k] = stream_w0[j, k]

    n = nstream[0]
    stream_g['pos'][:, 0, :n] = np.array(w[nbodies:nbodies+n, :]).T[:3]
    stream_g['vel'][:, 0, :n] = np.array(w[nbodies:nbodies+n, :]).T[3:]
    nbody_g['pos'][:, 0, :n] = np.array(w[:nbodies, :]).T[:3]
    nbody_g['vel'][:, 0, :n] = np.array(w[:nbodies, :]).T[3:]
    output_times[0] = t[0]

    j = 1 # output time index
    for i in range(1, ntimes):
        # print(i, j, n,
        #       len(t), len(nstream), len(output_times))

        dop853_step(&cp, &cf, <FcnEqDiff> Fwrapper_direct_nbody,
                    &w[0, 0], t[i-1], t[i], dt0,
                    ndim, nbodies+n, nbodies, args,
                    atol, rtol, nmax)

        PyErr_CheckSignals()

        n += nstream[i]

        if (i % output_every) == 0 or i == ntimes-1:
            output_times[j] = t[i]
            stream_g['pos'][:, j, :n] = np.array(w[nbodies:nbodies+n, :]).T[:3]
            stream_g['vel'][:, j, :n] = np.array(w[nbodies:nbodies+n, :]).T[3:]
            nbody_g['pos'][:, j, :n] = np.array(w[:nbodies, :]).T[:3]
            nbody_g['vel'][:, j, :n] = np.array(w[:nbodies, :]).T[3:]
            j += 1

        if progress == 1:
            if i % prog_out == 0:
                sys.stdout.write('\r')
                sys.stdout.write(
                    f"Integrating orbits: {100 * i / ntimes: 3.0f}%")
                sys.stdout.flush()

    if progress == 1:
        sys.stdout.write('\r')
        sys.stdout.write(f"Integrating orbits: {100: 3.0f}%")
        sys.stdout.flush()

    for g in [stream_g, nbody_g]:
        d = g.create_dataset('time', data=np.array(output_times))
        d.attrs['unit'] = str(nbody.units['time'])

    h5f.close()

    return_nbody_w = np.array(w)[:nbodies]
    return_stream_w = np.array(w)[nbodies:]

    return return_nbody_w, return_stream_w
</file>

<file path="gala/dynamics/nbody/tests/test_nbody.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

from gala.dynamics import PhaseSpacePosition, combine
from gala.integrate import (
    DOPRI853Integrator,
    LeapfrogIntegrator,
    Ruth4Integrator,
)

# Custom
from gala.potential import (
    ConstantRotatingFrame,
    HernquistPotential,
    NFWPotential,
    NullPotential,
    StaticFrame,
)
from gala.units import UnitSystem, galactic

# Project
from ..core import DirectNBody


class TestDirectNBody:
    def setup_method(self):
        self.usys = UnitSystem(
            u.pc, u.Unit(1e-5 * u.Myr), u.Unit(1e6 * u.Msun), u.radian
        )
        pot_particle2 = HernquistPotential(
            m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys
        )
        vcirc = pot_particle2.circular_velocity([1, 0, 0.0] * u.pc).to(u.km / u.s)

        self.particle_potentials = [NullPotential(units=self.usys), pot_particle2]

        w0_2 = PhaseSpacePosition(pos=[10, 0, 0] * u.kpc, vel=[0, 83, 0] * u.km / u.s)
        w0_1 = PhaseSpacePosition(
            pos=w0_2.xyz + [1, 0, 0] * u.pc, vel=w0_2.v_xyz + [0, 1.0, 0] * vcirc
        )
        self.w0 = combine((w0_1, w0_2))

        self.ext_pot = NFWPotential(m=1e11, r_s=10, units=galactic)

    def test_directnbody_init(self):
        # another unit system for testing
        usys2 = UnitSystem(u.pc, u.Unit(1e-3 * u.Myr), u.Unit(1e6 * u.Msun), u.radian)

        particle_potentials_None = [None] + self.particle_potentials[1:]

        # Different VALID ways to initialize
        nbody = DirectNBody(self.w0, particle_potentials=self.particle_potentials)
        nbody = DirectNBody(self.w0, particle_potentials=particle_potentials_None)
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            external_potential=self.ext_pot,
        )
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            external_potential=self.ext_pot,
            units=usys2,
        )
        nbody = DirectNBody(self.w0, particle_potentials=[None, None], units=usys2)
        nbody = DirectNBody(
            self.w0,
            particle_potentials=[None, None],  # noqa
            external_potential=self.ext_pot,
        )

        # Different INVALID ways to initialize
        with pytest.raises(TypeError):
            DirectNBody("sdf", particle_potentials=self.particle_potentials)

        with pytest.raises(ValueError):
            DirectNBody(self.w0, particle_potentials=self.particle_potentials[:1])

        # MAX_NBODY1 = 65536+1
        # w0_max = combine([self.w0[0]]*MAX_NBODY1)
        # with pytest.raises(NotImplementedError):
        #     DirectNBody(w0_max, particle_potentials=[None]*MAX_NBODY1)

        with pytest.raises(ValueError):
            DirectNBody(self.w0, particle_potentials=[None, None])

    @pytest.mark.parametrize(
        "Integrator", [DOPRI853Integrator, Ruth4Integrator, LeapfrogIntegrator]
    )
    def test_directnbody_integrate(self, Integrator):
        # TODO: this is really a unit test, but we should have some functional tests
        # that check that the orbit integration is making sense!

        # First, compare with/without mass with no external potential:
        nbody1 = DirectNBody(self.w0, particle_potentials=[None, None], units=self.usys)
        nbody2 = DirectNBody(
            self.w0, particle_potentials=self.particle_potentials, units=self.usys
        )

        orbits1 = nbody1.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        dx0 = orbits1[:, 0].xyz - orbits2[:, 0].xyz
        dx1 = orbits1[:, 1].xyz - orbits2[:, 1].xyz
        assert u.allclose(np.abs(dx1), 0 * u.pc, atol=1e-13 * u.pc)
        assert np.abs(dx0).max() > 50 * u.pc

        # Now compare with/without mass with external potential:
        nbody1 = DirectNBody(
            self.w0,
            particle_potentials=[None, None],
            units=self.usys,
            external_potential=self.ext_pot,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
        )

        orbits1 = nbody1.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        dx0 = orbits1[:, 0].xyz - orbits2[:, 0].xyz
        dx1 = orbits1[:, 1].xyz - orbits2[:, 1].xyz
        assert u.allclose(np.abs(dx1), 0 * u.pc, atol=1e-13 * u.pc)
        assert np.abs(dx0).max() > 50 * u.pc

    def test_directnbody_acceleration(self):
        pot1 = HernquistPotential(m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys)
        pot2 = HernquistPotential(m=1.6e6 * u.Msun, c=0.33 * u.pc, units=self.usys)

        nbody = DirectNBody(
            self.w0, particle_potentials=[pot1, pot2], external_potential=self.ext_pot
        )

        # Compute the acceleration we expect:
        _pot1 = HernquistPotential(
            m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys, origin=self.w0[0].xyz
        )
        _pot2 = HernquistPotential(
            m=1.6e6 * u.Msun, c=0.33 * u.pc, units=self.usys, origin=self.w0[1].xyz
        )
        exp_acc = np.zeros((3, 2)) * self.usys["acceleration"]
        exp_acc[:, 0] = _pot2.acceleration(self.w0[0])[:, 0]
        exp_acc[:, 1] = _pot1.acceleration(self.w0[1])[:, 0]
        exp_acc += self.ext_pot.acceleration(self.w0)

        acc = nbody.acceleration()
        assert u.allclose(acc, exp_acc)

    @pytest.mark.parametrize(
        "Integrator", [DOPRI853Integrator, Ruth4Integrator, LeapfrogIntegrator]
    )
    def test_directnbody_integrate_dontsaveall(self, Integrator):
        # If we set save_all = False, only return the final positions:
        nbody1 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            save_all=False,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            save_all=True,
        )

        w1 = nbody1.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits = nbody2.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        w2 = orbits[-1]
        assert u.allclose(w1.xyz, w2.xyz)
        assert u.allclose(w1.v_xyz, w2.v_xyz)

    @pytest.mark.parametrize("Integrator", [DOPRI853Integrator])
    def test_directnbody_integrate_rotframe(self, Integrator):
        # Now compare with/without mass with external potential:
        frame = ConstantRotatingFrame(
            Omega=[0, 0, 1] * self.w0[0].v_y / self.w0[0].x, units=self.usys
        )
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            frame=frame,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
        )

        orbits = nbody.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits_static = orbits.to_frame(StaticFrame(self.usys))

        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys["time"], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        assert u.allclose(orbits_static.xyz, orbits_static.xyz)
        assert u.allclose(orbits2.v_xyz, orbits2.v_xyz)

    @pytest.mark.parametrize("Integrator", [DOPRI853Integrator])
    def test_nbody_reorder(self, Integrator):
        N = 16
        rng = np.random.default_rng(seed=42)
        w0 = PhaseSpacePosition(
            pos=rng.normal(0, 5, size=(3, N)) * u.kpc,
            vel=rng.normal(0, 50, size=(3, N)) * u.km / u.s,
        )
        pots = [
            (
                HernquistPotential(1e9 * u.Msun, 1.0 * u.pc, units=galactic)
                if rng.uniform() > 0.5
                else None
            )
            for _ in range(N)
        ]
        sim = DirectNBody(
            w0,
            pots,
            external_potential=HernquistPotential(1e12, 10, units=galactic),
            units=galactic,
        )
        orbits = sim.integrate_orbit(dt=1.0 * u.Myr, t1=0, t2=100 * u.Myr)
        assert np.allclose(orbits.pos[0].xyz, w0.pos.xyz)
</file>

<file path="gala/dynamics/nbody/__init__.py">
from .core import DirectNBody
</file>

<file path="gala/dynamics/nbody/core.py">
# cython: boundscheck=False
# cython: debug=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False

# Third-party
import numpy as np

from ...integrate.cyintegrators.leapfrog import leapfrog_integrate_nbody
from ...integrate.cyintegrators.ruth4 import ruth4_integrate_nbody
from ...integrate.timespec import parse_time_specification
from ...potential import Hamiltonian, NullPotential, StaticFrame
from ...units import UnitSystem
from ...util import atleast_2d
from .. import Orbit, PhaseSpacePosition
from .nbody import direct_nbody_dop853, nbody_acceleration

__all__ = ["DirectNBody"]


class DirectNBody:
    def __init__(
        self,
        w0,
        particle_potentials,
        external_potential=None,
        frame=None,
        units=None,
        save_all=True,
    ):
        """Perform orbit integration using direct N-body forces between
        particles, optionally in an external background potential.

        TODO: could add another option, like in other contexts, for
        "extra_force" to support, e.g., dynamical friction

        Parameters
        ----------
        w0 : `~gala.dynamics.PhaseSpacePosition`
            The particle initial conditions.
        partcle_potentials : list
            List of potential objects to add mass or mass distributions to the
            particles. Use ``None`` to treat particles as test particles.
        external_potential : `~gala.potential.PotentialBase` subclass instance (optional)
            The background or external potential to integrate the particle
            orbits in.
        frame : :class:`~gala.potential.frame.FrameBase` subclass (optional)
            The reference frame to perform integratiosn in.
        units : `~gala.units.UnitSystem` (optional)
            Set of non-reducable units that specify (at minimum) the
            length, mass, time, and angle units.
        save_all : bool (optional)
            Save the full orbits of each particle. If ``False``, only returns
            the final phase-space positions of each particle.

        """
        if not isinstance(w0, PhaseSpacePosition):
            raise TypeError(
                "Initial conditions `w0` must be a "
                "gala.dynamics.PhaseSpacePosition object, "
                "not '{}'".format(w0.__class__.__name__)
            )

        if len(w0.shape) > 0:
            if w0.shape[0] != len(particle_potentials):
                raise ValueError(
                    "The number of initial conditions in `w0` must"
                    " match the number of particle potentials "
                    "passed in with `particle_potentials`."
                )

            # TODO: this is a MAJOR HACK
            if w0.shape[0] > 524288:  # see MAX_NBODY in _nbody.pyx
                raise NotImplementedError(
                    "We currently only support direct "
                    "N-body integration for <= 524288 "
                    "particles."
                )

        # First, figure out how to get units - first place to check is the arg
        if units is None:
            # Next, check the particle potentials
            for pp in particle_potentials:
                if pp is not None:
                    units = pp.units
                    break

        # If units is still none, and external_potential is defined, use that:
        if units is None and external_potential is not None:
            units = external_potential.units

        # Now, if units are still None, raise an error!
        if units is None:
            raise ValueError(
                "Could not determine units from input! You must "
                "either (1) pass in the unit system with `units`,"
                "(2) set the units on one of the "
                "particle_potentials, OR (3) pass in an "
                "`external_potential` with valid units."
            )
        if not isinstance(units, UnitSystem):
            units = UnitSystem(units)

        # Now that we have the unit system, enforce that all potentials are in
        # that system:
        _particle_potentials = []
        for pp in particle_potentials:
            if pp is None:
                pp = NullPotential(units=units)
            else:
                pp = pp.replace_units(units)
            _particle_potentials.append(pp)

        if external_potential is None:
            external_potential = NullPotential(units=units)
        else:
            external_potential = external_potential.replace_units(units)

        if frame is None:
            frame = StaticFrame(units)

        self.units = units
        self.external_potential = external_potential
        self.frame = frame
        self.particle_potentials = _particle_potentials
        self.save_all = save_all

        self.H = Hamiltonian(self.external_potential, frame=self.frame)
        if not self.H.c_enabled:
            raise ValueError(
                "Input potential must be C-enabled: one or more "
                "components in the input external potential are "
                "Python-only."
            )

        self.w0 = w0

    @property
    def w0(self):
        return self._w0

    @w0.setter
    def w0(self, value):
        self._w0 = value
        self._cache_w0()

    def _cache_w0(self):
        # cache the position and velocity / prepare the initial conditions
        self._pos = atleast_2d(self.w0.xyz.decompose(self.units).value, insert_axis=1)
        self._vel = atleast_2d(self.w0.v_xyz.decompose(self.units).value, insert_axis=1)
        self._c_w0 = np.ascontiguousarray(np.vstack((self._pos, self._vel)).T)

    def __repr__(self):
        if self.w0.shape:
            return "<{} bodies={}>".format(self.__class__.__name__, self.w0.shape[0])
        else:
            return "<{} bodies=1>".format(self.__class__.__name__)

    def _nbody_acceleration(self, t=0.0):
        """
        Compute the N-body acceleration at the location of each body
        """
        nbody_acc = nbody_acceleration(self._c_w0, t, self.particle_potentials)
        return nbody_acc.T

    def acceleration(self, t=0.0):
        """
        Compute the acceleration at the location of each N body, including the
        external potential.
        """
        nbody_acc = self._nbody_acceleration(t=t) * self.units["acceleration"]
        ext_acc = self.external_potential.acceleration(self.w0, t=t)
        return nbody_acc + ext_acc

    def integrate_orbit(self, Integrator=None, Integrator_kwargs=dict(), **time_spec):
        """
        Integrate the initial conditions in the combined external potential
        plus N-body forces.

        This integration uses the `~gala.integrate.DOPRI853Integrator`.

        Parameters
        ----------
        **time_spec
            Specification of how long to integrate. See documentation
            for `~gala.integrate.parse_time_specification`.

        Returns
        -------
        orbit : `~gala.dynamics.Orbit`
            The orbits of the particles.

        """
        from gala.integrate import (
            DOPRI853Integrator,
            LeapfrogIntegrator,
            Ruth4Integrator,
        )

        if Integrator is None:
            Integrator = DOPRI853Integrator

        # Prepare the time-stepping array
        t = parse_time_specification(self.units, **time_spec)

        # Reorganize orbits so that massive bodies are first:
        front_idx = []
        front_pp = []
        end_idx = []
        end_pp = []
        for i, pp in enumerate(self.particle_potentials):
            if not isinstance(pp, NullPotential):
                front_idx.append(i)
                front_pp.append(pp)
            else:
                end_idx.append(i)
                end_pp.append(pp)
        idx = np.array(front_idx + end_idx)
        pps = front_pp + end_pp

        reorg_w0 = np.ascontiguousarray(self._c_w0[idx])

        if Integrator == LeapfrogIntegrator:
            _, ws = leapfrog_integrate_nbody(
                self.H, reorg_w0, t, pps, store_all=int(self.save_all)
            )
        elif Integrator == Ruth4Integrator:
            _, ws = ruth4_integrate_nbody(
                self.H, reorg_w0, t, pps, store_all=int(self.save_all)
            )
        elif Integrator == DOPRI853Integrator:
            ws = direct_nbody_dop853(reorg_w0, t, self.H, pps, save_all=self.save_all)
        else:
            raise NotImplementedError(
                "N-body integration is currently not supported with the {Integrator} "
                "integrator class"
            )

        if self.save_all:
            pos = np.rollaxis(np.array(ws[..., :3]), axis=2)  # should this be axis=-1?
            vel = np.rollaxis(np.array(ws[..., 3:]), axis=2)

            orbits = Orbit(
                pos=pos * self.units["length"],
                vel=vel * self.units["length"] / self.units["time"],
                t=t * self.units["time"],
                hamiltonian=self.H,
            )

        else:
            pos = np.array(ws[..., :3]).T
            vel = np.array(ws[..., 3:]).T

            orbits = PhaseSpacePosition(
                pos=pos * self.units["length"],
                vel=vel * self.units["length"] / self.units["time"],
                frame=self.frame,
            )

        # Reorder orbits to original order:
        undo_idx = np.argsort(idx)

        return orbits[..., undo_idx]
</file>

<file path="gala/dynamics/nbody/nbody_helper.h">
#ifndef MAX_NBODY_H
    #define MAX_NBODY_H
    #define MAX_NBODY 524288
#endif
</file>

<file path="gala/dynamics/nbody/nbody.pxd">
# cython: language_level=3

cdef extern from "nbody_helper.h":
    const int MAX_NBODY
</file>

<file path="gala/dynamics/nbody/nbody.pyx">
# cython: boundscheck=False
# cython: debug=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

# Standard library
import warnings

# Third-party
from astropy.constants import G
import astropy.units as u

import numpy as np
cimport numpy as np
np.import_array()

from libc.math cimport sqrt
from cpython.exc cimport PyErr_CheckSignals

from ...potential import Hamiltonian, NullPotential
from ...potential.potential.cpotential cimport (CPotentialWrapper,
                                                MAX_N_COMPONENTS, CPotential)
from ...potential.frame.cframe cimport CFrameWrapper
from ...integrate.cyintegrators.dop853 cimport (dop853_helper,
                                                dop853_helper_save_all)

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    void c_nbody_acceleration(CPotential **pots, double t, double *qp,
                              int norbits, int nbody, int ndim, double *acc)

cdef extern from "dopri/dop853.h":
    ctypedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                              CPotential *p, CFrameType *fr, unsigned norbits,
                              unsigned nbody, void *args) nogil
    void Fwrapper_direct_nbody(unsigned ndim, double t, double *w, double *f,
                               CPotential *p, CFrameType *fr, unsigned norbits,
                               unsigned nbody, void *args)

cpdef direct_nbody_dop853(double [:, ::1] w0, double[::1] t,
                          hamiltonian, list particle_potentials,
                          save_all=True,
                          double atol=1E-10, double rtol=1E-10, int nmax=0):
    """Integrate orbits from initial conditions ``w0`` over the time grid ``t``
    using direct N-body force calculation in the external potential provided via
    the ``hamiltonian`` argument.

    The potential objects for each set of initial conditions must be C-enabled
    (i.e., must be ``CPotentialBase`` subclasses), and the total number of
    potential objects must equal the number of initial conditions.

    By default, this integration procedure stores the full time series of all
    orbits, but this may use a lot of memory. If you just want to store the
    final state of the orbits, pass ``save_all=False``.

    NOTE: This assumes that all massive bodies are organized at the start of w0 and
    particle_potentials, and all test particles are *after* the massive bodies.
    """
    cdef:
        unsigned nparticles = w0.shape[0]
        unsigned nbody = 0
        unsigned ndim = w0.shape[1]
        unsigned ntimes = len(t)

        int i
        void *args
        CPotential *c_particle_potentials[MAX_NBODY]
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(hamiltonian.frame.c_instance)).cframe

    # Some input validation:
    if not isinstance(hamiltonian, Hamiltonian):
        raise TypeError(
            f"Input must be a Hamiltonian object, not {type(hamiltonian)}")

    if not hamiltonian.c_enabled:
        raise TypeError(
            "Input Hamiltonian object does not support C-level access.")

    if len(particle_potentials) != nparticles:
        raise ValueError(
            "The number of particle initial conditions must match the number "
            f"of particle potentials passed in ({nparticles} vs. "
            f"{len(particle_potentials)}).")

    for pot in particle_potentials:
        if not isinstance(pot, NullPotential):
            nbody += 1

    # Extract the CPotential objects from the particle potentials.
    for i in range(nparticles):
        c_particle_potentials[i] = &(<CPotentialWrapper>(particle_potentials[i].c_instance)).cpotential

    # We need a void pointer for any other arguments
    args = <void *>(&c_particle_potentials[0])

    if save_all:
        all_w = dop853_helper_save_all(&cp, &cf,
                                       <FcnEqDiff> Fwrapper_direct_nbody,
                                       w0, t,
                                       ndim, nparticles, nbody, args,
                                       ntimes, atol, rtol, nmax, 0)
    else:
        all_w = dop853_helper(&cp, &cf,
                              <FcnEqDiff> Fwrapper_direct_nbody,
                              w0, t,
                              ndim, nparticles, nbody, args, ntimes,
                              atol, rtol, nmax, 0)
        all_w = np.array(all_w).reshape(nparticles, ndim)

    return all_w


cpdef nbody_acceleration(double [:, ::1] w0, double t,
                         list particle_potentials):
    """
    Computes the N-body acceleration on a set of bodies at phase-space
    positions w0.
    """
    cdef:
        unsigned nparticles = w0.shape[0]
        unsigned ps_ndim = w0.shape[1]
        unsigned ndim = ps_ndim // 2

        int i
        CPotential *c_particle_potentials[MAX_NBODY]

        double[:, ::1] acc = np.zeros((nparticles, ps_ndim))

    # Some input validation:
    if len(particle_potentials) != nparticles:
        raise ValueError(
            "The number of particle initial conditions must match the number "
            f"of particle potentials passed in ({nparticles} vs. "
            f"{len(particle_potentials)}).")

    # Extract the CPotential objects from the particle potentials.
    for i in range(nparticles):
        c_particle_potentials[i] = &(<CPotentialWrapper>(particle_potentials[i].c_instance)).cpotential

    c_nbody_acceleration(&c_particle_potentials[0], t, &w0[0, 0],
                         nparticles, nparticles, ndim, &acc[0, 0])

    # NOTES: Just the acceleration, does not handle frames
    return np.asarray(acc)[:, ndim:]
</file>

<file path="gala/dynamics/tests/test_core.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np
import pytest
from astropy.coordinates import (
    CartesianDifferential,
    CartesianRepresentation,
    Galactic,
    SphericalCosLatDifferential,
    SphericalRepresentation,
)

from gala.tests.optional_deps import HAS_H5PY

from ...potential import Hamiltonian, HernquistPotential
from ...potential.frame import ConstantRotatingFrame, StaticFrame
from ...units import galactic, solarsystem

# Project
from ..core import PhaseSpacePosition


def test_initialize():
    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 8))
        PhaseSpacePosition(pos=x, vel=v)

    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.shape == (10,)

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.km / u.s
    o.data
    assert "s" in o.data.differentials

    # Not 3D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.ndim == 2

    o = PhaseSpacePosition(pos=x, vel=v, frame=StaticFrame(galactic))
    assert o.ndim == 2
    assert o.frame is not None
    assert isinstance(o.frame, StaticFrame)

    x = np.random.random(size=(4, 10))
    v = np.random.random(size=(4, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.ndim == 4

    # back to 3D
    pos = CartesianRepresentation(np.random.random(size=(3, 10)) * u.one)
    vel = CartesianDifferential(np.random.random(size=(3, 10)) * u.one)
    o = PhaseSpacePosition(pos=pos, vel=vel)
    assert hasattr(o, "x")
    assert hasattr(o, "y")
    assert hasattr(o, "z")
    assert hasattr(o, "v_x")
    assert hasattr(o, "v_y")
    assert hasattr(o, "v_z")

    # passing a representation with a differential attached
    pos = CartesianRepresentation(np.random.random(size=(3, 10)) * u.kpc)
    vel = CartesianDifferential(np.random.random(size=(3, 10)) * u.km / u.s)
    o = PhaseSpacePosition(pos.with_differentials({"s": vel}))
    assert hasattr(o, "x")
    assert hasattr(o, "y")
    assert hasattr(o, "z")
    assert hasattr(o, "v_x")
    assert hasattr(o, "v_y")
    assert hasattr(o, "v_z")

    o = o.represent_as(SphericalRepresentation)
    assert hasattr(o, "distance")
    assert hasattr(o, "lat")
    assert hasattr(o, "lon")
    assert hasattr(o, "radial_velocity")
    assert hasattr(o, "pm_lon")
    assert hasattr(o, "pm_lat")

    with pytest.raises(TypeError):
        o = PhaseSpacePosition(pos=x, vel=v, frame="blah blah blah")


def test_from_w():
    w = np.random.random(size=(6, 10))
    o = PhaseSpacePosition.from_w(w, galactic)
    assert o.x.unit == u.kpc
    assert o.v_x.unit == u.kpc / u.Myr
    assert o.shape == (10,)


def test_slice():
    # simple
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5,)

    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5, 8)

    # 3d slice on 3d
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5, :4]
    assert new_o.shape == (5, 4)

    # boolean array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix),)

    # integer array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    ix = np.array([0, 3, 5])
    new_o = o[ix]
    assert new_o.shape == (len(ix),)


def test_reshape():
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o.reshape((10, 1))
    assert new_o.shape == (10, 1)
    assert new_o.x.shape == (10, 1)


def test_represent_as():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o.represent_as(SphericalRepresentation)
    o.spherical
    o.cylindrical
    o.cartesian

    assert new_o.pos.distance.unit == u.one
    assert new_o.vel.d_distance.unit == u.one

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)
    assert sph.pos.distance.unit == u.kpc

    sph2 = o.represent_as("spherical")
    for c in sph.pos.components:
        assert u.allclose(getattr(sph.pos, c), getattr(sph2.pos, c), rtol=1e-12)

    # doesn't work for 2D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.represent_as(SphericalRepresentation)


def test_represent_as_expected_attributes():
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)

    new_o = o.spherical
    assert hasattr(new_o, "distance")
    assert hasattr(new_o, "lat")
    assert hasattr(new_o, "lon")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_lat")
    assert hasattr(new_o, "pm_lon")

    new_o = o.represent_as(SphericalRepresentation, SphericalCosLatDifferential)
    assert hasattr(new_o, "distance")
    assert hasattr(new_o, "lat")
    assert hasattr(new_o, "lon")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_lat")
    assert hasattr(new_o, "pm_lon_coslat")

    new_o = o.physicsspherical
    assert hasattr(new_o, "r")
    assert hasattr(new_o, "phi")
    assert hasattr(new_o, "theta")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_theta")
    assert hasattr(new_o, "pm_phi")

    new_o = o.cylindrical
    assert hasattr(new_o, "rho")
    assert hasattr(new_o, "phi")
    assert hasattr(new_o, "z")
    assert hasattr(new_o, "v_rho")
    assert hasattr(new_o, "pm_phi")
    assert hasattr(new_o, "v_z")

    new_o = new_o.cartesian
    assert hasattr(new_o, "x")
    assert hasattr(new_o, "y")
    assert hasattr(new_o, "z")
    assert hasattr(new_o, "xyz")
    assert hasattr(new_o, "v_x")
    assert hasattr(new_o, "v_y")
    assert hasattr(new_o, "v_z")
    assert hasattr(new_o, "v_xyz")

    # Check that this works with the NDCartesian classes too
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    new_o = PhaseSpacePosition(pos=x, vel=v)

    assert hasattr(new_o, "x1")
    assert hasattr(new_o, "x2")
    assert hasattr(new_o, "xyz")
    assert hasattr(new_o, "v_x1")
    assert hasattr(new_o, "v_x2")
    assert hasattr(new_o, "v_xyz")


def test_to_coord_frame():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)

    with coord.galactocentric_frame_defaults.set("v4.0"):
        with pytest.raises(u.UnitConversionError):
            o.to_coord_frame(Galactic())

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with coord.galactocentric_frame_defaults.set("v4.0"):
        coo = o.to_coord_frame(Galactic())
    assert coo.name == "galactic"

    # doesn't work for 2D
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with coord.galactocentric_frame_defaults.set("v4.0"):
        with pytest.raises(ValueError):
            o.to_coord_frame(Galactic())


def test_w():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 10)

    x = np.random.random(size=3)
    v = np.random.random(size=3)
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 1)

    # simple / unitless, 2D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (4, 10)

    x = np.random.random(size=2)
    v = np.random.random(size=2)
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (4, 1)

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.w()
    w = o.w(units=galactic)
    assert np.allclose(x.value, w[:3])
    assert np.allclose(v.value, (w[3:] * u.kpc / u.Myr).to(u.km / u.s).value)

    # simple / with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w(p.units)
    assert np.allclose(x.value, w[:3])
    assert np.allclose(v.value, (w[3:] * u.kpc / u.Myr).to(u.km / u.s).value)

    w = o.w(units=solarsystem)
    assert np.allclose(x.value, (w[:3] * u.au).to(u.kpc).value)
    assert np.allclose(v.value, (w[3:] * u.au / u.yr).to(u.km / u.s).value)


# ------------------------------------------------------------------------
# Computed dynamical quantities
# ------------------------------------------------------------------------
def test_energy():  # noqa
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    KE = o.kinetic_energy()
    assert KE.unit == (o.v_x.unit) ** 2
    assert KE.shape == o.shape

    # with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    H = Hamiltonian(p)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    PE = o.potential_energy(p)  # noqa
    E = o.energy(H)  # noqa


def test_angular_momentum():
    w = PhaseSpacePosition([1.0, 0.0, 0.0], [0.0, 0.0, 1.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [0.0, -1, 0] * u.one)

    w = PhaseSpacePosition([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [0.0, 0, 1] * u.one)

    w = PhaseSpacePosition([0.0, 1.0, 0.0], [0.0, 0.0, 1.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [1.0, 0, 0] * u.one)

    w = PhaseSpacePosition([1.0, 0, 0] * u.kpc, [0.0, 200.0, 0] * u.pc / u.Myr)
    assert u.allclose(
        np.squeeze(w.angular_momentum()), [0, 0, 0.2] * u.kpc**2 / u.Myr
    )

    # multiple - known
    q = np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0, 1.0, 0.0]]).T
    p = np.array([[0, 0, 1.0], [0, 1.0, 0.0], [0, 0, 1]]).T
    L = PhaseSpacePosition(q, p).angular_momentum()
    true_L = np.array([[0.0, -1, 0], [0.0, 0, 1], [1.0, 0, 0]]).T * u.one
    assert L.shape == (3, 3)
    assert u.allclose(L, true_L)

    # multiple - random
    q = np.random.uniform(size=(3, 128))
    p = np.random.uniform(size=(3, 128))
    L = PhaseSpacePosition(q, p).angular_momentum()
    assert L.shape == (3, 128)


def test_guiding_radius():  # noqa
    rng = np.random.default_rng(42)

    p = HernquistPotential(units=galactic, m=1e11, c=10.0)

    Rs = rng.uniform(4, 10, 128) * u.kpc
    xyz = Rs[None] * np.array([1.0, 0, 0])[:, None]

    vc = p.circular_velocity(xyz)
    vxyz = np.zeros((3, Rs.size)) * u.km / u.s
    vxyz[1] = rng.normal(vc.to_value(u.km / u.s), 15.0) * u.km / u.s

    w0 = PhaseSpacePosition(xyz, vxyz)
    Rgs = w0.guiding_radius(potential=p)
    assert np.all(Rgs > 0) and np.all(Rgs < 25 * u.kpc)


def test_frame_transform():
    static = StaticFrame(galactic)
    rotating = ConstantRotatingFrame(
        Omega=[0.53, 1.241, 0.9394] * u.rad / u.Myr, units=galactic
    )

    x = np.array([[10.0, -0.2, 0.3], [-0.232, 8.1, 0.1934]]).T * u.kpc
    v = np.array([[0.0034, 0.2, 0.0014], [0.0001, 0.002532, -0.2]]).T * u.kpc / u.Myr

    # no frame specified at init
    psp = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        psp.to_frame(rotating)

    psp.to_frame(rotating, current_frame=static, t=0.4 * u.Myr)

    # frame specified at init
    psp = PhaseSpacePosition(pos=x, vel=v, frame=static)
    psp.to_frame(rotating, t=0.4 * u.Myr)


@pytest.mark.parametrize(
    "obj",
    [
        PhaseSpacePosition([1, 2, 3.0] * u.kpc, [1, 2, 3.0] * u.km / u.s),
        PhaseSpacePosition(
            [1, 2, 3.0] * u.kpc, [1, 2, 3.0] * u.km / u.s, StaticFrame(units=galactic)
        ),
        PhaseSpacePosition(
            [1, 2, 3.0] * u.kpc,
            [1, 2, 3.0] * u.km / u.s,
            ConstantRotatingFrame(Omega=[1.0, 0, 0] * u.rad / u.Myr, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_H5PY, reason="h5py required for this test")
def test_io(tmpdir, obj):
    import h5py

    filename = str(tmpdir.join("thing.hdf5"))
    with h5py.File(filename, "w") as f:
        obj.to_hdf5(f)

    obj2 = PhaseSpacePosition.from_hdf5(filename)
    assert u.allclose(obj.xyz, obj2.xyz)
    assert u.allclose(obj.v_xyz, obj2.v_xyz)
    assert obj.frame == obj2.frame
</file>

<file path="gala/dynamics/tests/test_nonlinear.py">
# Third-party
import numpy as np

# Project
from ... import potential as gp
from ...potential import Hamiltonian
from ..nonlinear import lyapunov_max, fast_lyapunov_max, surface_of_section
from ...integrate import DOPRI853Integrator
from ...units import galactic


class TestForcedPendulum(object):
    def setup_method(self):
        def F(t, x, A, omega_d):
            q, p = x
            return np.array([p, -np.sin(q) + A * np.cos(omega_d * t)])

        # initial conditions and parameter choices for chaotic / regular pendulum
        self.regular_w0 = np.array([1.0, 0.0])
        self.regular_par = (0.055, 0.7)
        self.regular_integrator = DOPRI853Integrator(F, func_args=self.regular_par)

        self.chaotic_w0 = np.array([3.0, 0.0])
        self.chaotic_par = (0.07, 0.75)
        self.chaotic_integrator = DOPRI853Integrator(F, func_args=self.chaotic_par)

    def test_lyapunov_max(self, tmpdir):
        n_steps = 20000
        dt = 1.0
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        regular_LEs, regular_orbit = lyapunov_max(
            self.regular_w0,
            self.regular_integrator,
            dt=dt,
            n_steps=n_steps,
            d0=d0,
            n_steps_per_pullback=n_steps_per_pullback,
            noffset_orbits=noffset,
        )

        regular_LEs = np.mean(regular_LEs, axis=1)
        assert regular_LEs[-1] < 1e-3

        chaotic_LEs, chaotic_orbit = lyapunov_max(
            self.chaotic_w0,
            self.chaotic_integrator,
            dt=dt,
            n_steps=n_steps,
            d0=d0,
            n_steps_per_pullback=n_steps_per_pullback,
            noffset_orbits=noffset,
        )
        chaotic_LEs = np.mean(chaotic_LEs, axis=1)
        assert chaotic_LEs[-1] > 1e-2

        # pl.figure()
        # pl.loglog(regular_LEs, marker='')
        # pl.savefig(os.path.join(str(tmpdir),"pend_regular.png"))

        # pl.figure()
        # pl.plot(t, regular_ws[:, 0], marker='')
        # pl.savefig(os.path.join(str(tmpdir),"pend_orbit_regular.png"))

        # pl.figure()
        # pl.loglog(chaotic_LEs, marker='')
        # pl.savefig(os.path.join(str(tmpdir),"pend_chaotic.png"))

        # pl.figure()
        # pl.plot(t, chaotic_ws[:, 0], marker='')
        # pl.savefig(os.path.join(str(tmpdir),"pend_orbit_chaotic.png"))

        # pl.close('all')


# --------------------------------------------------------------------


class HenonHeilesBase(object):
    def potential(self, w, A, B, C, D):
        x, y = w[:2]
        term1 = 0.5 * (A * x**2 + B * y**2)
        term2 = D * x**2 * y - C / 3.0 * y**3
        return term1 + term2

    def acceleration(self, w, A, B, C, D):
        x, y = w[:2]
        ax = -(A * x + 2 * D * x * y)
        ay = -(B * y + D * x * x - C * y * y)
        return np.array([ax, ay])

    def jerk(self, w, A, B, C, D):
        x, y = w[:2]
        dx, dy = w[4:6]

        dax = -(A + 2 * D * y) * dx - 2 * D * x * dy
        day = -2 * D * x * dx - (B - 2 * C * y) * dy

        return np.array([dax, day])

    def F_max(self, t, w, *args):
        x, y, px, py = w
        term1 = np.array([px, py])
        term2 = self.acceleration(w, *args)
        return np.vstack((term1, term2))

    def setup_method(self):
        # parameter choices
        self.par = (1.0, 1.0, 1.0, 1.0)
        self.n_steps = 2000
        self.dt = 2.0

    def test_integrate_orbit(self, tmpdir):
        integrator = DOPRI853Integrator(self.F_max, func_args=self.par)
        orbit = integrator(self.w0, dt=self.dt, n_steps=self.n_steps)

    def test_lyapunov_max(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        integrator = DOPRI853Integrator(self.F_max, func_args=self.par)
        lyap, orbit = lyapunov_max(
            self.w0,
            integrator,
            dt=self.dt,
            n_steps=self.n_steps,
            d0=d0,
            noffset_orbits=noffset,
            n_steps_per_pullback=n_steps_per_pullback,
        )
        lyap = np.mean(lyap, axis=1)

        # pl.clf()
        # pl.loglog(lyap, marker='')
        # pl.savefig(os.path.join(str(tmpdir),"hh_lyap_max_{}.png".format(self.__class__.__name__)))

        # pl.clf()
        # pl.plot(ws[..., 0], ws[..., 1], marker='')
        # pl.savefig(os.path.join(str(tmpdir),"hh_orbit_lyap_max_{}.png".format(self.__class__.__name__)))


# initial conditions from LP-VI documentation:
class TestHenonHeilesStablePeriodic(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.295456, 0.407308431, 0.0])
        self.check = lambda x: x < 1e-3


class TestHenonHeilesStableQuasi1(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.483, 0.27898039, 0.0])
        self.check = lambda x: x < 2e-3


class TestHenonHeilesStableQuasi2(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.46912, 0.291124891, 0.0])
        self.check = lambda x: x < 2e-3


class TestHenonHeilesStableChaos1(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.509, 0.254624859, 0.0])
        self.check = lambda x: x > 2e-3


class TestHenonHeilesStableChaos2(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.56, 0.164113781, 0.112])
        self.check = lambda x: x > 1e-2


# --------------------------------------------------------------------


class TestLogarithmic(object):
    def setup_method(self):

        # set the potential
        potential = gp.LogarithmicPotential(
            v_c=np.sqrt(2), r_h=0.1, q1=1.0, q2=0.9, q3=1.0, units=galactic
        )
        self.hamiltonian = Hamiltonian(potential)

        # see figure 1 from Papaphillipou & Laskar
        x0 = -0.01
        X0 = -0.2
        y0 = 0.0
        E0 = -0.4059
        Y0 = np.squeeze(np.sqrt(E0 - self.hamiltonian.potential.energy([x0, y0, 0.0]).value))
        chaotic_w0 = [x0, y0, 0.0, X0, Y0, 0.0]

        # initial conditions from LP-VI documentation:
        self.w0s = np.array(
            [[0.49, 0.0, 0.0, 1.3156, 0.4788, 0.0], chaotic_w0]  # regular
        )  # chaotic

        self.n_steps = 25000
        self.dt = 0.004

    def test_fast_lyapunov_max(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        for ii, w0 in enumerate(self.w0s):
            print(ii, w0)
            lyap, orbit = fast_lyapunov_max(
                w0,
                self.hamiltonian,
                dt=self.dt,
                n_steps=self.n_steps,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
            )
            lyap = np.mean(lyap, axis=1)

            # also just integrate the orbit to compare dE scaling
            orbit2 = self.hamiltonian.integrate_orbit(
                w0, dt=self.dt, n_steps=self.n_steps, Integrator=DOPRI853Integrator
            )

            # lyapunov exp
            # pl.figure()
            # pl.loglog(lyap, marker='')
            # pl.savefig(os.path.join(str(tmpdir),"log_lyap_max_{}.png".format(ii)))

            # energy conservation
            E = orbit[:, 0].energy().value  # returns 3 orbits
            dE = np.abs(E[1:] - E[0])

            E = orbit2.energy().value
            dE_ww = np.abs(E[1:] - E[0])

            # import matplotlib.pyplot as plt
            # plt.semilogy(dE, marker='')
            # plt.semilogy(dE_ww, marker='')

            # fig, axes = plt.subplots(1, 2, figsize=(10, 5))
            # axes[0].plot(orbit.pos[0, :, 0], orbit.pos[1, :, 0], marker='') # ignore offset orbits
            # axes[1].plot(orbit2.pos[0], orbit2.pos[1], marker='')
            # fig.savefig(os.path.join(str(tmpdir),"log_orbit_lyap_max_{}.png".format(ii)))

            # plt.show()

            assert np.allclose(dE_ww[-100:], dE[-100:], rtol=1e-1)

    def test_compare_fast(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        def F(t, w):
            w_T = np.ascontiguousarray(w.T)
            return self.hamiltonian._gradient(w_T, np.array([t])).T

        integrator = DOPRI853Integrator(F)
        for ii, w0 in enumerate(self.w0s):
            lyap1, orbit1 = fast_lyapunov_max(
                w0,
                self.hamiltonian,
                dt=self.dt,
                n_steps=self.n_steps // 8,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
            )
            lyap1 = np.mean(lyap1, axis=1)

            # check energy conservation
            E = orbit1.energy().value
            dE_fast = np.abs(E[1:] - E[0])
            assert np.all(dE_fast[:, 0] < 1e-10)

            lyap2, orbit2 = lyapunov_max(
                w0.copy(),
                integrator,
                dt=self.dt,
                n_steps=self.n_steps // 8,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
                units=self.hamiltonian.units,
            )
            lyap2 = np.mean(lyap2, axis=1)

            # check energy conservation
            E = orbit2.energy(self.hamiltonian).value
            dE_slow = np.abs(E[1:] - E[0])

            if not np.all(dE_slow[:, 0] < 1e-10):
                import matplotlib.pyplot as plt

                plt.figure()
                plt.plot(orbit2.pos[0, -128:, 0], orbit2.pos[1, -128:, 0], marker=".")
                plt.plot(orbit2.pos[0, -128:, 0], orbit2.pos[2, -128:, 0], marker=".")

                plt.figure()
                plt.semilogy(dE_slow[:, 0], marker=".")

                plt.show()

            assert np.all(dE_slow[:, 0] < 1e-10)

            # plots
            # import matplotlib.pyplot as plt

            # plt.figure()
            # plt.loglog(orbit1.t[1:-10:10], lyap1, marker='')
            # plt.loglog(orbit2.t[1:-10:10], lyap2, marker='')
            # plt.savefig(os.path.join(str(tmpdir),"log_lyap_compare_{}.png".format(ii)))

            # plt.figure()
            # plt.semilogy(dE_fast[:, 0], marker='')
            # plt.semilogy(dE_slow[:, 0], marker='')
            # # plt.savefig(os.path.join(str(tmpdir),"log_dE_{}.png".format(ii)))

            # fig, axes = plt.subplots(1, 2, figsize=(6, 6))
            # axes[0].plot(orbit1.pos[0, :, 0], orbit1.pos[1, :, 0],
            #              marker='.', linestyle='none', alpha=0.1)
            # axes[1].plot(orbit2.pos[0, :, 0], orbit2.pos[1, :, 0],
            #              marker='.', linestyle='none', alpha=0.1)
            # plt.savefig(os.path.join(str(tmpdir),"log_orbit_lyap_max_{}.png".format(ii)))

            # plt.show()
            # plt.close('all')


def test_surface_of_section():
    from ...potential import LogarithmicPotential
    from ...units import galactic

    pot = LogarithmicPotential(v_c=1.0, r_h=1.0, q1=1.0, q2=0.9, q3=0.8, units=galactic)

    w0 = np.array([0.0, 0.8, 0.0, 1.0, 0.0, 0.0])
    orbit = Hamiltonian(pot).integrate_orbit(w0, dt=0.02, n_steps=100_000)
    sos = surface_of_section(orbit, constant_idx=1)
    sos_cyl = surface_of_section(orbit.cylindrical, constant_idx=1)
</file>

<file path="gala/dynamics/tests/test_orbit.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest
import scipy.optimize as so
from astropy.coordinates import (
    Galactic,
    SphericalCosLatDifferential,
    SphericalRepresentation,
)

from gala.tests.optional_deps import HAS_GALPY, HAS_H5PY

from ...integrate import DOPRI853Integrator
from ...potential import (
    Hamiltonian,
    HernquistPotential,
    KeplerPotential,
    LogarithmicPotential,
    NFWPotential,
)
from ...potential.frame import ConstantRotatingFrame, StaticFrame
from ...units import galactic, solarsystem

# Project
from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..util import combine


# Tests below should be cleaned up a bit...
def test_initialize():
    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 8))
        Orbit(pos=x, vel=v)

    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 10))
        t = np.arange(8)
        Orbit(pos=x, vel=v, t=t)

    # TODO: always?
    # x = np.random.random(size=(3, 10))
    # v = np.random.random(size=(3, 10))
    # o = Orbit(pos=x, vel=v)
    # assert o.ndim == 3

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.km / u.s

    # TODO: don't support < 3 dim?
    # x = np.random.random(size=(2, 10))
    # v = np.random.random(size=(2, 10))
    # o = Orbit(pos=x, vel=v)
    # assert o.ndim == 2
    # assert o.hamiltonian is None

    # Check that passing in frame and potential or Hamiltonian works
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    frame = StaticFrame(galactic)
    potential = LogarithmicPotential(
        v_c=1.0, r_h=0.14, q1=1.0, q2=0.9, q3=1.0, units=galactic
    )

    o = Orbit(pos=x, vel=v, frame=frame)
    assert o.hamiltonian is None
    assert o.potential is None

    o = Orbit(pos=x, vel=v, potential=potential)
    assert o.hamiltonian is None
    assert o.frame is None

    o = Orbit(pos=x, vel=v, potential=potential, frame=frame)
    o = Orbit(pos=x, vel=v, hamiltonian=Hamiltonian(potential, frame=frame))
    assert isinstance(o.hamiltonian, Hamiltonian)
    assert isinstance(o.potential, LogarithmicPotential)
    assert isinstance(o.frame, StaticFrame)


def test_from_w():
    w = np.random.random(size=(6, 10))
    o = Orbit.from_w(w, galactic)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.kpc / u.Myr


def test_slice():
    # simple
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5,)

    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.linspace(0, 10, 10)
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5]
    assert new_o.shape == (5,)

    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5]
    assert new_o.shape == (5, 8)
    assert new_o.t.shape == (5,)

    # pick a single orbit
    new_o = o[:, 0]
    assert isinstance(new_o, Orbit)
    assert new_o.shape == (10,)
    assert new_o.t.shape == (10,)

    # pick a single time
    new_o = o[3]
    assert isinstance(new_o, PhaseSpacePosition)
    assert new_o.shape == (8,)

    # REGRESSION TEST: numpy int64 is not an int()
    new_o = o[np.int64(3)]
    assert isinstance(new_o, PhaseSpacePosition)
    assert new_o.shape == (8,)

    # 3d slice on 3d
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5, :4]
    assert new_o.shape == (5, 4)
    assert new_o.t.shape == (5,)

    # boolean array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix),)
    assert new_o.t.shape == (5,)

    # boolean array - 3D
    x = np.random.random(size=(3, 10, 4))
    v = np.random.random(size=(3, 10, 4))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix), x.shape[-1])
    assert new_o.t.shape == (5,)

    # integer array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 3, 5])
    new_o = o[ix]
    assert new_o.shape == (len(ix),)
    assert new_o.t.shape == (len(ix),)


def test_reshape():
    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o.reshape((10, 4, 2))
    assert new_o.shape == (10, 4, 2)
    assert new_o.x.shape == (10, 4, 2)


def test_represent_as():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)

    assert sph.pos.distance.unit == u.one
    assert sph.vel.d_distance.unit == u.one

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)
    assert sph.pos.distance.unit == u.kpc
    assert sph.vel.d_distance.unit == u.km / u.s


def test_represent_as_expected_attributes():
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)

    new_o = o.spherical
    assert hasattr(new_o, "distance")
    assert hasattr(new_o, "lat")
    assert hasattr(new_o, "lon")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_lat")
    assert hasattr(new_o, "pm_lon")
    assert new_o.norbits == o.norbits

    new_o = o.represent_as(SphericalRepresentation, SphericalCosLatDifferential)
    assert hasattr(new_o, "distance")
    assert hasattr(new_o, "lat")
    assert hasattr(new_o, "lon")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_lat")
    assert hasattr(new_o, "pm_lon_coslat")

    new_o = o.physicsspherical
    assert hasattr(new_o, "r")
    assert hasattr(new_o, "phi")
    assert hasattr(new_o, "theta")
    assert hasattr(new_o, "radial_velocity")
    assert hasattr(new_o, "pm_theta")
    assert hasattr(new_o, "pm_phi")
    assert new_o.norbits == o.norbits

    new_o = o.cylindrical
    assert hasattr(new_o, "rho")
    assert hasattr(new_o, "phi")
    assert hasattr(new_o, "z")
    assert hasattr(new_o, "v_rho")
    assert hasattr(new_o, "pm_phi")
    assert hasattr(new_o, "v_z")
    assert new_o.norbits == o.norbits

    new_o = new_o.cartesian
    assert hasattr(new_o, "x")
    assert hasattr(new_o, "y")
    assert hasattr(new_o, "z")
    assert hasattr(new_o, "xyz")
    assert hasattr(new_o, "v_x")
    assert hasattr(new_o, "v_y")
    assert hasattr(new_o, "v_z")
    assert hasattr(new_o, "v_xyz")

    # Check that this works with the NDCartesian classes too
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    new_o = Orbit(pos=x, vel=v)

    assert hasattr(new_o, "x1")
    assert hasattr(new_o, "x2")
    assert hasattr(new_o, "xyz")
    assert hasattr(new_o, "v_x1")
    assert hasattr(new_o, "v_x2")
    assert hasattr(new_o, "v_xyz")


def test_to_coord_frame():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)

    with pytest.raises(u.UnitConversionError):
        o.to_coord_frame(Galactic())

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    coo = o.to_coord_frame(Galactic())
    assert coo.name == "galactic"

    # simple / with units and time
    x = np.random.random(size=(3, 128, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 128, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    coo = o.to_coord_frame(Galactic())
    assert coo.name == "galactic"


def test_w():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 10)

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.w()
    w = o.w(units=galactic)
    assert np.allclose(x.value, w[:3, :])
    assert np.allclose(v.value, (w[3:, :] * u.kpc / u.Myr).to(u.km / u.s).value)

    # simple / with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v, potential=p, frame=StaticFrame(galactic))
    w = o.w()
    assert np.allclose(x.value, w[:3, :])
    assert np.allclose(v.value, (w[3:, :] * u.kpc / u.Myr).to(u.km / u.s).value)

    w = o.w(units=solarsystem)
    assert np.allclose(x.value, (w[:3, :] * u.au).to(u.kpc).value)
    assert np.allclose(v.value, (w[3:, :] * u.au / u.yr).to(u.km / u.s).value)


def test_energy():
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    KE = o.kinetic_energy()
    assert KE.unit == (o.v_x.unit) ** 2
    assert KE.shape == o.pos.shape

    # with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v, potential=p, frame=StaticFrame(galactic))
    o.potential_energy()
    o.energy()


def test_angular_momentum():
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    L = o.angular_momentum()
    assert L.unit == (o.v_x.unit * o.x.unit)
    assert L.shape == ((3,) + o.shape)


def test_eccentricity():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 2 * np.pi, 0.0] * u.au / u.yr
    )
    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)
    e = w.eccentricity()
    assert np.abs(e) < 1e-3


def test_guiding_radius():
    q = [10.0, 0, 0] * u.kpc
    pot = HernquistPotential(m=1e10, c=10.0, units=galactic)
    vc = pot.circular_velocity(q).to_value(u.km / u.s)
    w0 = PhaseSpacePosition(pos=q, vel=[0.0, 1.3, 0.0] * vc)
    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.5, n_steps=1000, Integrator=DOPRI853Integrator)
    w.guiding_radius()

    # Check that orbit in non-axisymmetric potential raises a warning
    pot = NFWPotential(m=1e10, r_s=10.0, b=0.95, units=galactic)
    vc = pot.circular_velocity(q).to_value(u.km / u.s)
    w0 = PhaseSpacePosition(pos=q, vel=[0.0, 1.3, 0.0] * vc)
    ham = Hamiltonian(pot)
    orbit = ham.integrate_orbit(w0, dt=0.5, n_steps=1000, Integrator=DOPRI853Integrator)

    with pytest.warns(RuntimeWarning):
        orbit.guiding_radius()


def test_apocenter_pericenter_period():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 1.5 * np.pi, 0.0] * u.au / u.yr
    )

    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)

    apo = w.apocenter()
    per = w.pericenter()
    zmax = w.zmax()
    assert apo.shape == ()
    assert per.shape == ()
    assert zmax.shape == ()

    assert apo.unit == u.au
    assert per.unit == u.au
    assert zmax.unit == u.au
    assert apo > per

    # see if they're where we expect
    E = np.mean(w.energy()).decompose(pot.units).value
    L = (
        np.mean(np.sqrt(np.sum(w.angular_momentum() ** 2, axis=0)))
        .decompose(pot.units)
        .value
    )

    def func(r):
        val = 2 * (E - pot.energy([r, 0, 0]).value[0]) - L**2 / r**2
        return val

    pred_apo = so.brentq(func, 0.9, 1.0)
    pred_per = so.brentq(func, 0.3, 0.5)

    assert np.allclose(apo.value, pred_apo, rtol=1e-2)
    assert np.allclose(per.value, pred_per, rtol=1e-2)

    # Return all peris, apos
    apos = w.apocenter(func=None)
    pers = w.pericenter(func=None)
    zmax = w.zmax(func=None)
    T = w.estimate_period()  # noqa

    dapo = np.std(apos) / np.mean(apos)
    assert (dapo > 0) and np.allclose(dapo, 0.0, atol=1e-4)

    dper = np.std(pers) / np.mean(pers)
    assert (dper > 0) and np.allclose(dper, 0.0, atol=1e-4)

    # Now try for expected behavior when multiple orbits are integrated:
    w0 = PhaseSpacePosition(
        pos=([[1, 0, 0.0], [1.1, 0, 0]] * u.au).T,
        vel=([[0.0, 1.5 * np.pi, 0.0], [0.0, 1.5 * np.pi, 0.0]] * u.au / u.yr).T,
    )

    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000)

    per = w.pericenter(approximate=True)
    apo = w.apocenter(approximate=True)
    zmax = w.zmax(approximate=True)
    ecc = w.eccentricity(approximate=True)  # noqa


def test_estimate_period():
    ntimes = 16384
    for true_T_R in [1.0, 2.0, 4.123]:
        t = np.linspace(0, 10.0, ntimes)
        R = 0.25 * np.sin(2 * np.pi / true_T_R * t) + 1.0
        phi = (2 * np.pi * t) % (2 * np.pi)

        pos = np.zeros((3, ntimes))
        pos[0] = R * np.cos(phi)
        pos[1] = R * np.sin(phi)
        vel = np.zeros_like(pos)

        orb = Orbit(pos * u.kpc, vel * u.kpc / u.Myr, t=t * u.Gyr)
        T = orb.estimate_period()
        assert "x" in T.colnames and "y" in T.colnames and "z" in T.colnames

        T = orb.cylindrical.estimate_period()
        assert np.allclose(T["rho"].value, true_T_R, rtol=1e-3)
        assert np.allclose(T["phi"].value, 1.0, rtol=1e-3)

    # TODO: remove this in next version
    from gala.util import GalaDeprecationWarning

    with pytest.warns(GalaDeprecationWarning):
        orb.estimate_period(radial=True)


def test_estimate_period_regression():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 1.5 * np.pi, 0.0] * u.au / u.yr
    )
    w0 = combine((w0, w0, w0))

    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)
    T = w.estimate_period()
    print(T)


def make_known_orbits(tmpdir, xs, vxs, potential, names):
    # See Binney & Tremaine (2008) Figure 3.8 and 3.9
    E = -0.337
    y = 0.0

    ws = []
    for x, vx, name in zip(xs, vxs, names):
        vy = np.sqrt(2 * (E - potential.energy([x, y, 0.0]).value))[0]
        w = [x, y, 0.0, vx, vy, 0.0]
        ws.append(w)
    ws = np.array(ws).T

    ham = Hamiltonian(potential)
    orbit = ham.integrate_orbit(ws, dt=0.05, n_steps=10000)

    return orbit


def test_circulation(tmpdir):
    potential = LogarithmicPotential(
        v_c=1.0, r_h=0.14, q1=1.0, q2=0.9, q3=1.0, units=galactic
    )

    # individual
    ws = make_known_orbits(tmpdir, [0.5, 0], [0.0, 1.5], potential, ["loop", "box"])

    w1 = ws[:, 0]
    circ = w1.circulation()
    assert circ.shape == (3,)
    assert circ.sum() == 1

    w2 = ws[:, 1]
    circ = w2.circulation()
    assert circ.shape == (3,)
    assert circ.sum() == 0

    # try also for both, together
    circ = ws.circulation()
    assert circ.shape == (3, 2)
    assert np.allclose(circ.sum(axis=0), [1, 0])


def test_align_circulation():
    t = np.linspace(0, 100, 1024)
    w = np.zeros((6, 1024, 4))

    # loop around x axis
    w[1, :, 0] = np.cos(t)
    w[2, :, 0] = np.sin(t)
    w[4, :, 0] = -np.sin(t)
    w[5, :, 0] = np.cos(t)

    # loop around y axis
    w[0, :, 1] = -np.cos(t)
    w[2, :, 1] = np.sin(t)
    w[3, :, 1] = np.sin(t)
    w[5, :, 1] = np.cos(t)

    # loop around z axis
    w[0, :, 2] = np.cos(t)
    w[1, :, 2] = np.sin(t)
    w[3, :, 2] = -np.sin(t)
    w[4, :, 2] = np.cos(t)

    # box
    w[0, :, 3] = np.cos(t)
    w[1, :, 3] = -np.cos(0.5 * t)
    w[2, :, 3] = np.cos(0.25 * t)
    w[3, :, 3] = -np.sin(t)
    w[4, :, 3] = 0.5 * np.sin(0.5 * t)
    w[5, :, 3] = -0.25 * np.sin(0.25 * t)

    # First, individually
    for i in range(w.shape[2]):
        orb = Orbit.from_w(w[..., i], units=galactic)
        new_orb = orb.align_circulation_with_z()
        circ = new_orb.circulation()

        if i == 3:
            assert np.sum(circ) == 0
        else:
            assert circ[2] == 1.0

    # all together now
    orb = Orbit.from_w(w, units=galactic)
    circ = orb.circulation()
    assert circ.shape == (3, 4)

    new_orb = orb.align_circulation_with_z()
    new_circ = new_orb.circulation()
    assert np.all(new_circ[2, :3] == 1.0)
    assert np.all(new_circ[:, 3] == 0.0)


def test_frame_transform():
    static = StaticFrame(galactic)
    rotating = ConstantRotatingFrame(
        Omega=[0.53, 1.241, 0.9394] * u.rad / u.Myr, units=galactic
    )

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    t = np.linspace(0, 1, 10) * u.Myr

    # no frame specified at init
    o = Orbit(pos=x, vel=v, t=t)
    with pytest.raises(ValueError):
        o.to_frame(rotating)

    o.to_frame(rotating, current_frame=static, t=o.t)
    o.to_frame(rotating, current_frame=static)

    # frame specified at init
    o = Orbit(
        pos=x,
        vel=v,
        t=t,
        frame=static,
        potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
    )
    o.to_frame(rotating)
    o.to_frame(rotating, t=o.t)


_x = ([[1, 2, 3.0], [1, 2, 3.0]] * u.kpc).T
_v = ([[1, 2, 3.0], [1, 2, 3.0]] * u.km / u.s).T


@pytest.mark.parametrize(
    "obj",
    [  # noqa
        Orbit(_x, _v),
        Orbit(_x, _v, t=[5, 99] * u.Myr),
        Orbit(_x, _v, t=[5, 99] * u.Myr, frame=StaticFrame(galactic)),
        Orbit(
            _x,
            _v,
            t=[5, 99] * u.Myr,
            frame=StaticFrame(galactic),
            potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_H5PY, reason="h5py required for this test")
def test_io(tmpdir, obj):
    import h5py

    filename = str(tmpdir.join("thing.hdf5"))
    with h5py.File(filename, "w") as f:
        obj.to_hdf5(f)

    obj2 = Orbit.from_hdf5(filename)
    assert u.allclose(obj.xyz, obj2.xyz)
    assert u.allclose(obj.v_xyz, obj2.v_xyz)
    if obj.t is not None:
        assert u.allclose(obj.t, obj2.t)

    assert obj.frame == obj2.frame
    assert obj.potential == obj2.potential


@pytest.mark.parametrize(
    "obj",
    [
        Orbit(_x, _v),
        Orbit(_x, _v, t=[5, 99] * u.Myr),
        Orbit(_x, _v, t=[5, 99] * u.Myr, frame=StaticFrame(galactic)),
        Orbit(
            _x,
            _v,
            t=[5, 99] * u.Myr,
            frame=StaticFrame(galactic),
            potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_GALPY, reason="requires galpy to run this test")
def test_orbit_to_galpy(obj):
    o1 = obj.to_galpy_orbit()  # noqa
    o2 = obj.to_galpy_orbit(ro=8 * u.kpc)  # noqa
    o3 = obj.to_galpy_orbit(vo=220 * u.km / u.s)  # noqa
    o4 = obj.to_galpy_orbit(ro=8 * u.kpc, vo=220 * u.km / u.s)  # noqa


@pytest.mark.skipif(not HAS_GALPY, reason="requires galpy to run this test")
def test_orbit_from_galpy():
    import galpy.orbit as galpy_o
    import galpy.potential as galpy_p

    mp = galpy_p.MiyamotoNagaiPotential(a=0.5, b=0.0375, amp=1.0, normalize=1.0)
    galpy_orbit = galpy_o.Orbit([1.0, 0.1, 1.1, 0.0, 0.1, 1.0])
    ts = np.linspace(0, 100, 10000)
    galpy_orbit.integrate(ts, mp, method="odeint")
    gala_orbit = Orbit.from_galpy_orbit(galpy_orbit)

    assert len(gala_orbit.t) == len(ts)
</file>

<file path="gala/dynamics/tests/test_plot.py">
""" Test dynamics plotting functions """

import subprocess

import astropy.units as u
import numpy as np
import pytest

from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..plot import plot_projections


def pytest_generate_tests(metafunc):
    if "obj" not in metafunc.fixturenames:
        return

    object_list = []

    norbits = 16
    object_list.append(
        PhaseSpacePosition(pos=np.random.random(size=3), vel=np.random.random(size=3))
    )
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(3, norbits)),
            vel=np.random.random(size=(3, norbits)),
        )
    )
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(3, norbits)) * u.kpc,
            vel=np.random.random(size=(3, norbits)) * u.km / u.s,
        )
    )

    nsteps = 16
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps)),
            vel=np.random.random(size=(3, nsteps)),
            t=np.linspace(0, 1, nsteps),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps, 2)),
            vel=np.random.random(size=(3, nsteps, 2)),
            t=np.linspace(0, 1, nsteps),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps)) * u.kpc,
            vel=np.random.random(size=(3, nsteps)) * u.km / u.s,
            t=np.linspace(0, 1, nsteps) * u.Myr,
        )
    )

    # 2D
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(2, norbits)),
            vel=np.random.random(size=(2, norbits)),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(2, nsteps)),
            vel=np.random.random(size=(2, nsteps)),
            t=np.linspace(0, 1, nsteps),
        )
    )

    test_names = [f"{obj.__class__.__name__}{i}" for i, obj in enumerate(object_list)]

    metafunc.parametrize(["i", "obj"], list(enumerate(object_list)), ids=test_names)


def test_plot_projections(i, obj):
    import matplotlib.pyplot as plt

    # Try executing the method - unfortunately no test of the actual figure
    # drawn!
    obj.plot()

    # Try with just 2D projection, and passing in a bunch of inputs...
    x = obj.xyz.value
    fig, axes = plt.subplots(1, 2)
    fig = plot_projections(
        x[:2],
        autolim=True,
        axes=axes,  # noqa
        subplots_kwargs=dict(sharex=True),
        labels=["x", "y"],
        plot_function=plt.plot,
        marker="o",
        linestyle="--",
        color="r",
    )


def test_animate(tmpdir, i, obj):
    if not isinstance(obj, Orbit):
        pytest.skip()

    try:
        proc = subprocess.run(
            ["ffmpeg -version"], shell=True, check=True, capture_output=True
        )
    except subprocess.CalledProcessError:
        pytest.skip(reason="ffmpeg not installed")

    if proc.returncode > 0:
        pytest.skip(reason="ffmpeg not installed")

    # Try executing the method - unfortunately no test of the actual figure
    # drawn!
    fig, anim = obj.animate(segment_nsteps=3)
    anim.save(tmpdir / f"anim{i}.mp4")

    # test hiding the timestep label
    fig, anim = obj.animate(segment_nsteps=3, show_time=False)
    anim.save(tmpdir / f"anim{i}_no_time.mp4")

    if obj.ndim == 3:
        # Also try cylindrical, and sub-selecting components:
        fig, anim = obj.cylindrical.animate(components=["rho", "z"])
        anim.save(tmpdir / f"anim{i}_cyl.mp4")
</file>

<file path="gala/dynamics/tests/test_representation_nd.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..representation_nd import (NDCartesianRepresentation,
                                 NDCartesianDifferential)


def test_init_repr():

    # Passing in x1, x2
    rep = NDCartesianRepresentation([1., 1.])
    assert rep.xyz.shape == (2,)

    # Passing in x1, x2
    rep = NDCartesianRepresentation(np.random.random(size=(2, 8)))
    assert rep.xyz.shape == (2, 8)
    rep[:1]

    for n in range(1, 6+1):
        print('N: '+str(n))

        xs = np.random.uniform(size=(n, 16)) * u.one
        rep = NDCartesianRepresentation(xs)
        for i in range(1, n+1):
            assert hasattr(rep, 'x'+str(i))

        xs2 = rep.xyz
        assert u.allclose(xs, xs2)

        rep2 = rep[:8]

        assert rep.shape == (16,)
        assert rep2.shape == (8,)


def test_init_diff():

    # Passing in x1, x2
    rep = NDCartesianDifferential([1., 1.])
    assert rep.d_xyz.shape == (2,)
    with pytest.raises(TypeError):
        rep[:1]

    # Passing in x1, x2
    rep = NDCartesianDifferential(np.random.random(size=(2, 8)))
    assert rep.d_xyz.shape == (2, 8)
    rep[:1]

    for n in range(1, 6+1):
        print('N: '+str(n))

        xs = np.random.uniform(size=(n, 16)) * u.one
        rep = NDCartesianDifferential(xs)
        for i in range(1, n+1):
            assert hasattr(rep, 'd_x'+str(i))

        xs2 = rep.d_xyz
        assert u.allclose(xs, xs2)

        rep2 = rep[:8]

        assert rep.shape == (16,)
        assert rep2.shape == (8,)
</file>

<file path="gala/dynamics/tests/test_util.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..util import peak_to_peak_period, estimate_dt_n_steps, combine
from ...potential import Hamiltonian, NFWPotential
from ...potential.frame import StaticFrame
from ...units import galactic


def test_peak_to_peak_period():
    ntimes = 16384

    # trivial test
    for true_T in [1., 2., 4.123]:
        t = np.linspace(0, 10., ntimes)
        f = np.sin(2*np.pi/true_T * t)
        T = peak_to_peak_period(t, f)
        assert np.allclose(T, true_T, atol=1E-3)

    # modulated trivial test
    true_T = 2.
    t = np.linspace(0, 10., ntimes)
    f = np.sin(2*np.pi/true_T * t) + 0.1*np.cos(2*np.pi/(10*true_T) * t)
    T = peak_to_peak_period(t, f)
    assert np.allclose(T, true_T, atol=1E-3)


def test_estimate_dt_n_steps():
    nperiods = 128
    pot = NFWPotential.from_circular_velocity(v_c=1., r_s=10., units=galactic)
    w0 = [10., 0., 0., 0., 0.9, 0.]

    H = Hamiltonian(pot)
    dt, n_steps = estimate_dt_n_steps(w0, H, n_periods=nperiods,
                                      n_steps_per_period=256,
                                      func=np.nanmin)

    orbit = H.integrate_orbit(w0, dt=dt, n_steps=n_steps)
    T = orbit.physicsspherical.estimate_period()['r']
    assert int(np.round((orbit.t.max()/T).decompose().value)) == nperiods


class TestCombine(object):

    def setup_method(self):
        x = np.random.random(size=(3,))
        v = np.random.random(size=(3,))
        p1 = PhaseSpacePosition(pos=x, vel=v)
        p2 = PhaseSpacePosition(pos=x, vel=v, frame=StaticFrame(galactic))
        x = np.random.random(size=(3, 5))
        v = np.random.random(size=(3, 5))
        p3 = PhaseSpacePosition(pos=x, vel=v)
        p4 = PhaseSpacePosition(pos=x*u.kpc, vel=v*u.km/u.s)
        x = np.random.random(size=(2, 5))
        v = np.random.random(size=(2, 5))
        p5 = PhaseSpacePosition(pos=x, vel=v)
        self.psps = [p1, p2, p3, p4, p5]

        x = np.random.random(size=(3, 8))
        v = np.random.random(size=(3, 8))
        o1 = Orbit(pos=x, vel=v)
        o2 = Orbit(pos=x, vel=v, t=np.arange(8))

        pot = NFWPotential.from_circular_velocity(v_c=1., r_s=10.,
                                                  units=galactic)
        o3 = Orbit(pos=x*u.kpc, vel=v*u.km/u.s, t=np.arange(8)*u.Myr,
                   potential=pot, frame=StaticFrame(galactic))

        x = np.random.random(size=(2, 8))
        v = np.random.random(size=(2, 8))
        o4 = Orbit(pos=x, vel=v, t=np.arange(8))
        self.orbs = [o1, o2, o3, o4]

    def test_combine_fail(self):

        with pytest.raises(ValueError):
            combine([])

        with pytest.raises(ValueError):
            combine(self.psps[0])

        with pytest.raises(TypeError):
            combine([self.psps[0], self.orbs[0]])

        with pytest.raises(TypeError):
            combine([5, 5, 5])

        with pytest.raises(ValueError):
            combine(self.psps)

        with pytest.raises(ValueError):
            combine(self.orbs)

    def test_combine_psp(self):

        for psp in self.psps:
            psps = [psp] * 3
            new_psp = combine(psps)
            assert new_psp.ndim == psp.ndim

            if psp.pos.shape:
                shp = psp.pos.shape
            else:
                shp = (1,)

            assert new_psp.pos.shape == (3*shp[0],)
            assert new_psp.frame == psp.frame

    def test_combine_orb(self):

        for orb in self.orbs:
            orbs = [orb] * 4
            new_orb = combine(orbs)
            assert new_orb.ndim == orb.ndim

            shp = orb.shape
            if len(shp) < 2:
                shp = shp + (4,)

            else:
                shp = shp[:-1] + (4*shp[-1],)

            assert new_orb.pos.shape == shp
            assert new_orb.frame == orb.frame
            assert new_orb.potential == orb.potential
</file>

<file path="gala/dynamics/__init__.py">
from .core import PhaseSpacePosition
from .orbit import Orbit
from .actionangle import *
from .nonlinear import *
from .plot import *
from .util import *
from .representation_nd import *
from .nbody import *
from .mockstream import *
</file>

<file path="gala/dynamics/core.py">
# Standard library
import re
from collections import namedtuple

# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np
from astropy.coordinates import representation as r

from ..io import quantity_from_hdf5, quantity_to_hdf5
from ..units import DimensionlessUnitSystem, UnitSystem, _greek_letters
from ..util import atleast_2d

# Project
from . import representation_nd as rep_nd
from .plot import plot_projections

__all__ = ["PhaseSpacePosition"]

_RepresentationMappingBase = namedtuple(
    "RepresentationMapping", ("repr_name", "new_name", "default_unit")
)


class RepresentationMapping(_RepresentationMappingBase):
    """
    This `~collections.namedtuple` is used to override the representation and
    differential class component names in the `PhaseSpacePosition` and `Orbit`
    classes.
    """

    def __new__(cls, repr_name, new_name, default_unit="recommended"):
        # this trick just provides some defaults
        return super().__new__(cls, repr_name, new_name, default_unit)


class RegexRepresentationMapping(RepresentationMapping):
    """
    A representation mapping that uses a regex to map the original attribute
    name to the new attribute name.
    """

    pass


class PhaseSpacePosition:
    representation_mappings = {
        r.CartesianRepresentation: [RepresentationMapping("xyz", "xyz")],
        r.SphericalCosLatDifferential: [
            RepresentationMapping("d_lon_coslat", "pm_lon_coslat", u.mas / u.yr),
            RepresentationMapping("d_lat", "pm_lat", u.mas / u.yr),
            RepresentationMapping("d_distance", "radial_velocity"),
        ],
        r.SphericalDifferential: [
            RepresentationMapping("d_lon", "pm_lon", u.mas / u.yr),
            RepresentationMapping("d_lat", "pm_lat", u.mas / u.yr),
            RepresentationMapping("d_distance", "radial_velocity"),
        ],
        r.PhysicsSphericalDifferential: [
            RepresentationMapping("d_phi", "pm_phi", u.mas / u.yr),
            RepresentationMapping("d_theta", "pm_theta", u.mas / u.yr),
            RepresentationMapping("d_r", "radial_velocity"),
        ],
        r.CartesianDifferential: [
            RepresentationMapping("d_x", "v_x"),
            RepresentationMapping("d_y", "v_y"),
            RepresentationMapping("d_z", "v_z"),
            RepresentationMapping("d_xyz", "v_xyz"),
        ],
        r.CylindricalDifferential: [
            RepresentationMapping("d_rho", "v_rho"),
            RepresentationMapping("d_phi", "pm_phi"),
            RepresentationMapping("d_z", "v_z"),
        ],
        rep_nd.NDCartesianRepresentation: [RepresentationMapping("xyz", "xyz")],
        rep_nd.NDCartesianDifferential: [
            RepresentationMapping("d_xyz", "v_xyz"),
            RegexRepresentationMapping("d_x([0-9])", "v_x{0}"),
        ],
    }
    representation_mappings[
        r.UnitSphericalCosLatDifferential
    ] = representation_mappings[r.SphericalCosLatDifferential]
    representation_mappings[r.UnitSphericalDifferential] = representation_mappings[
        r.SphericalDifferential
    ]

    def __init__(self, pos, vel=None, frame=None):
        """
        Represents phase-space positions, i.e. positions and conjugate momenta
        (velocities).

        The class can be instantiated with Astropy representation objects (e.g.,
        :class:`~astropy.coordinates.CartesianRepresentation`), Astropy
        :class:`~astropy.units.Quantity` objects, or plain Numpy arrays.

        If passing in representation objects, the default representation is
        taken to be the class that is passed in.

        If passing in Quantity or Numpy array instances for both position and
        velocity, they are assumed to be Cartesian. Array inputs are interpreted
        as dimensionless quantities. The input position and velocity objects can
        have an arbitrary number of (broadcastable) dimensions. For Quantity or
        array inputs, the first axis (0) has special meaning:

            - `axis=0` is the coordinate dimension (e.g., x, y, z for Cartesian)

        So if the input position array, `pos`, has shape `pos.shape = (3, 100)`,
        this would represent 100 3D positions (`pos[0]` is `x`, `pos[1]` is `y`,
        etc.). The same is true for velocity.

        Parameters
        ----------
        pos : representation, quantity_like, or array_like
            Positions. If a numpy array (e.g., has no units), this will be
            stored as a dimensionless :class:`~astropy.units.Quantity`. See
            the note above about the assumed meaning of the axes of this object.
        vel : differential, quantity_like, or array_like
            Velocities. If a numpy array (e.g., has no units), this will be
            stored as a dimensionless :class:`~astropy.units.Quantity`. See
            the note above about the assumed meaning of the axes of this object.
        frame : :class:`~gala.potential.FrameBase` (optional)
            The reference frame of the input phase-space positions.

        """

        if isinstance(pos, coord.Galactocentric):
            pos = pos.data

        if not isinstance(pos, coord.BaseRepresentation):
            # assume Cartesian if not specified
            if not hasattr(pos, "unit"):
                pos = pos * u.one

            # 3D coordinates get special treatment
            ndim = pos.shape[0]
            if ndim == 3:
                # TODO: HACK: until this stuff is in astropy core
                if isinstance(pos, coord.BaseRepresentation):
                    kw = [(k, getattr(pos, k)) for k in pos.components]
                    pos = getattr(coord, pos.__class__.__name__)(**kw)

                else:
                    pos = coord.CartesianRepresentation(pos)

            else:
                pos = rep_nd.NDCartesianRepresentation(pos)

        else:
            ndim = 3

        if vel is None:
            if "s" not in pos.differentials:
                raise TypeError(
                    "You must specify velocity data when creating "
                    "a {0} object.".format(self.__class__.__name__)
                )
            else:
                vel = pos.differentials.get("s", None)

        if not isinstance(vel, coord.BaseDifferential):
            # assume representation is same as pos if not specified
            if not hasattr(vel, "unit"):
                vel = vel * u.one

            if ndim == 3:
                name = pos.__class__.get_name()
                Diff = coord.representation.DIFFERENTIAL_CLASSES[name]
                vel = Diff(*vel)
            else:
                Diff = rep_nd.NDCartesianDifferential
                vel = Diff(vel)

        # make sure shape is the same
        if pos.shape != vel.shape:
            raise ValueError(
                "Position and velocity must have the same shape "
                f"{pos.shape} vs. {vel.shape}"
            )

        from ..potential.frame import FrameBase

        if frame is not None and not isinstance(frame, FrameBase):
            raise TypeError(
                "Input reference frame must be a FrameBase " "subclass instance."
            )

        self.pos = pos
        self.vel = vel
        self.frame = frame
        self.ndim = ndim

    def __getitem__(self, slyce):
        return self.__class__(
            pos=self.pos[slyce], vel=self.vel[slyce], frame=self.frame
        )

    def get_components(self, which):
        """
        Get the component name dictionary for the desired object.

        The returned dictionary maps component names on this class to component
        names on the desired object.

        Parameters
        ----------
        which : str
            Can either be ``'pos'`` or ``'vel'`` to get the components for the
            position or velocity object.
        """
        mappings = self.representation_mappings.get(getattr(self, which).__class__, [])

        old_to_new = dict()
        for name in getattr(self, which).components:
            for m in mappings:
                if isinstance(m, RegexRepresentationMapping):
                    pattr = re.match(m.repr_name, name)
                    old_to_new[name] = m.new_name.format(*pattr.groups())

                elif m.repr_name == name:
                    old_to_new[name] = m.new_name

        mapping = dict()
        for name in getattr(self, which).components:
            mapping[old_to_new.get(name, name)] = name

        return mapping

    @property
    def pos_components(self):
        return self.get_components("pos")

    @property
    def vel_components(self):
        return self.get_components("vel")

    def _get_extra_mappings(self, which):
        mappings = self.representation_mappings.get(getattr(self, which).__class__, [])

        extra = dict()
        for m in mappings:
            if m.new_name not in self.get_components(which) and not isinstance(
                m, RegexRepresentationMapping
            ):
                extra[m.new_name] = m.repr_name
        return extra

    def __dir__(self):
        """
        Override the builtin `dir` behavior to include representation and
        differential names.
        """
        dir_values = set(self.pos_components.keys())
        dir_values |= set(self.vel_components.keys())
        dir_values |= set(self._get_extra_mappings("pos").keys())
        dir_values |= set(self._get_extra_mappings("vel").keys())
        dir_values |= set(r.REPRESENTATION_CLASSES.keys())
        dir_values |= set(super().__dir__())
        return sorted(dir_values)

    def __getattr__(self, attr):
        """
        Allow access to attributes on the ``pos`` and ``vel`` representation and
        differential objects.
        """

        # Prevent infinite recursion here.
        if attr.startswith("_"):
            return self.__getattribute__(attr)  # Raise AttributeError.

        # TODO: with >3.5 support, can do:
        # pos_comps = {**self.pos_components,
        #              **self._get_extra_mappings('pos')}
        pos_comps = self.pos_components.copy()
        pos_comps.update(self._get_extra_mappings("pos"))
        if attr in pos_comps:
            val = getattr(self.pos, pos_comps[attr])
            return val

        # TODO: with >3.5 support, can do:
        # pos_comps = {**self.vel_components,
        #              **self._get_extra_mappings('vel')}
        vel_comps = self.vel_components.copy()
        vel_comps.update(self._get_extra_mappings("vel"))
        if attr in vel_comps:
            val = getattr(self.vel, vel_comps[attr])
            return val

        if attr in r.REPRESENTATION_CLASSES:
            return self.represent_as(attr)

        return self.__getattribute__(attr)  # Raise AttributeError.

    @property
    def data(self):
        return self.pos.with_differentials(self.vel)

    # ------------------------------------------------------------------------
    # Convert from Cartesian to other representations
    #
    def represent_as(self, new_pos, new_vel=None):
        """
        Represent the position and velocity of the orbit in an alternate
        coordinate system. Supports any of the Astropy coordinates
        representation classes.

        Parameters
        ----------
        new_pos : :class:`~astropy.coordinates.BaseRepresentation`
            The type of representation to generate. Must be a class (not an
            instance), or the string name of the representation class.
        new_vel : :class:`~astropy.coordinates.BaseDifferential` (optional)
            Class in which any velocities should be represented. Must be a class
            (not an instance), or the string name of the differential class. If
            None, uses the default differential for the new position class.

        Returns
        -------
        new_psp : `gala.dynamics.PhaseSpacePosition`
        """

        if self.ndim != 3:
            raise ValueError("Can only change representation for " "ndim=3 instances.")

        # get the name of the desired representation
        if isinstance(new_pos, str):
            pos_name = new_pos
        else:
            pos_name = new_pos.get_name()

        if isinstance(new_vel, str):
            vel_name = new_vel
        elif new_vel is None:
            vel_name = pos_name
        else:
            vel_name = new_vel.get_name()

        Representation = coord.representation.REPRESENTATION_CLASSES[pos_name]
        Differential = coord.representation.DIFFERENTIAL_CLASSES[vel_name]

        new_pos = self.pos.represent_as(Representation)
        new_vel = self.vel.represent_as(Differential, self.pos)

        return self.__class__(pos=new_pos, vel=new_vel, frame=self.frame)

    def to_frame(self, frame, current_frame=None, **kwargs):
        """
        Transform to a new reference frame.

        Parameters
        ----------
        frame : `~gala.potential.FrameBase`
            The frame to transform to.
        current_frame : `gala.potential.CFrameBase`
            The current frame the phase-space position is in.
        **kwargs
            Any additional arguments are passed through to the individual frame
            transformation functions (see:
            `~gala.potential.frame.builtin.transformations`).

        Returns
        -------
        psp : `gala.dynamics.PhaseSpacePosition`
            The phase-space position in the new reference frame.

        """

        from ..potential.frame.builtin import transformations as frame_trans

        if self.frame is None and current_frame is None:
            raise ValueError(
                f"If no frame was specified when this {self} was "
                "initialized, you must pass the current frame in "
                "via the current_frame argument to transform to a "
                "new frame."
            )

        elif self.frame is not None and current_frame is None:
            current_frame = self.frame

        name1 = current_frame.__class__.__name__.rstrip("Frame").lower()
        name2 = frame.__class__.__name__.rstrip("Frame").lower()
        func_name = f"{name1}_to_{name2}"

        if not hasattr(frame_trans, func_name):
            raise ValueError(
                "Unsupported frame transformation: {} to {}".format(
                    current_frame, frame
                )
            )
        else:
            trans_func = getattr(frame_trans, func_name)

        pos, vel = trans_func(current_frame, frame, self, **kwargs)
        return PhaseSpacePosition(pos=pos, vel=vel, frame=frame)

    def to_coord_frame(self, frame, galactocentric_frame=None, **kwargs):
        """
        Transform the orbit from Galactocentric, cartesian coordinates to
        Heliocentric coordinates in the specified Astropy coordinate frame.

        Parameters
        ----------
        frame : :class:`~astropy.coordinates.BaseCoordinateFrame`
            The frame instance specifying the desired output frame.
            For example, :class:`~astropy.coordinates.ICRS`.
        galactocentric_frame : :class:`~astropy.coordinates.Galactocentric`
            This is the assumed frame that the position and velocity of this
            object are in. The ``Galactocentric`` instand should have parameters
            specifying the position and motion of the sun in the Galactocentric
            frame, but no data.

        Returns
        -------
        c : :class:`~astropy.coordinates.BaseCoordinateFrame`
            An instantiated coordinate frame containing the positions and
            velocities from this object transformed to the specified coordinate
            frame.

        """

        if self.ndim != 3:
            raise ValueError("Can only change representation for " "ndim=3 instances.")

        if galactocentric_frame is None:
            galactocentric_frame = coord.Galactocentric()

        pos_keys = list(self.pos_components.keys())
        vel_keys = list(self.vel_components.keys())
        if (
            getattr(self, pos_keys[0]).unit == u.one
            or getattr(self, vel_keys[0]).unit == u.one
        ):
            raise u.UnitConversionError(
                "Position and velocity must have "
                "dimensioned units to convert to a "
                "coordinate frame."
            )

        # first we need to turn the position into a Galactocentric instance
        gc_c = galactocentric_frame.realize_frame(self.pos.with_differentials(self.vel))
        c = gc_c.transform_to(frame)
        return c

    # Pseudo-backwards compatibility
    def w(self, units=None):
        """
        This returns a single array containing the phase-space positions.

        Parameters
        ----------
        units : `~gala.units.UnitSystem` (optional)
            The unit system to represent the position and velocity in
            before combining into the full array.

        Returns
        -------
        w : `~numpy.ndarray`
            A numpy array of all positions and velocities, without units.
            Will have shape ``(2*ndim, ...)``.

        """
        if self.ndim == 3:
            cart = self.cartesian
        else:
            cart = self

        xyz = cart.xyz
        d_xyz = cart.v_xyz

        x_unit = xyz.unit
        v_unit = d_xyz.unit
        if (units is None or isinstance(units, DimensionlessUnitSystem)) and (
            x_unit == u.one and v_unit == u.one
        ):
            units = DimensionlessUnitSystem()

        elif units is None:
            raise ValueError("A UnitSystem must be provided.")

        x = xyz.decompose(units).value
        if x.ndim < 2:
            x = atleast_2d(x, insert_axis=1)

        v = d_xyz.decompose(units).value
        if v.ndim < 2:
            v = atleast_2d(v, insert_axis=1)

        return np.vstack((x, v))

    @classmethod
    def from_w(cls, w, units=None, **kwargs):
        """
        Create a {name} object from a single array specifying positions
        and velocities. This is mainly for backwards-compatibility and
        it is not recommended for new users.

        Parameters
        ----------
        w : array_like
            The array of phase-space positions.
        units : `~gala.units.UnitSystem` (optional)
            The unit system that the input position+velocity array, ``w``,
            is represented in.
        **kwargs
            Any aditional keyword arguments passed to the class initializer.

        Returns
        -------
        obj : `~gala.dynamics.{name}`

        """.format(
            name=cls.__name__
        )

        w = np.array(w)

        ndim = w.shape[0] // 2
        pos = w[:ndim]
        vel = w[ndim:]

        # TODO: this is bad form - UnitSystem should know what to do with a
        # Dimensionless
        if units is not None and not isinstance(units, DimensionlessUnitSystem):
            units = UnitSystem(units)
            pos = pos * units["length"]
            vel = vel * units["length"] / units["time"]  # from _core_units

        return cls(pos=pos, vel=vel, **kwargs)

    # ------------------------------------------------------------------------
    # Input / output
    #
    def to_hdf5(self, f):
        """
        Serialize this object to an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """

        if isinstance(f, str):
            import h5py

            f = h5py.File(f, mode="r")

        if self.frame is not None:
            frame_group = f.create_group("frame")
            frame_group.attrs["module"] = self.frame.__module__
            frame_group.attrs["class"] = self.frame.__class__.__name__

            units = [str(x).encode("utf8") for x in self.frame.units.to_dict().values()]
            frame_group.create_dataset("units", data=units)

            d = frame_group.create_group("parameters")
            for k, par in self.frame.parameters.items():
                quantity_to_hdf5(d, k, par)

        cart = self.represent_as("cartesian")
        quantity_to_hdf5(f, "pos", cart.xyz)
        quantity_to_hdf5(f, "vel", cart.v_xyz)

        return f

    @classmethod
    def from_hdf5(cls, f):
        """
        Load an object from an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """
        if isinstance(f, str):
            import h5py

            f = h5py.File(f, mode="r")

        pos = quantity_from_hdf5(f["pos"])
        vel = quantity_from_hdf5(f["vel"])

        frame = None
        if "frame" in f:
            g = f["frame"]

            frame_mod = g.attrs["module"]
            frame_cls = g.attrs["class"]
            frame_units = [u.Unit(x.decode("utf-8")) for x in g["units"]]

            if u.dimensionless_unscaled in frame_units:
                units = DimensionlessUnitSystem()
            else:
                units = UnitSystem(*frame_units)

            pars = dict()
            for k in g["parameters"]:
                pars[k] = quantity_from_hdf5(g["parameters/" + k])

            exec("from {0} import {1}".format(frame_mod, frame_cls))
            frame_cls = eval(frame_cls)

            frame = frame_cls(units=units, **pars)

        return cls(pos=pos, vel=vel, frame=frame)

    # ------------------------------------------------------------------------
    # Computed dynamical quantities
    #
    def kinetic_energy(self):
        r"""
        The kinetic energy *per unit mass*:

        .. math::

            E_K = \frac{1}{2} \, |\boldsymbol{v}|^2

        Returns
        -------
        E : :class:`~astropy.units.Quantity`
            The kinetic energy.
        """
        return 0.5 * self.vel.norm() ** 2

    def potential_energy(self, potential):
        r"""
        The potential energy *per unit mass*:

        .. math::

            E_\Phi = \Phi(\boldsymbol{q})

        Parameters
        ----------
        potential : `gala.potential.PotentialBase`
            The potential object to compute the energy from.

        Returns
        -------
        E : :class:`~astropy.units.Quantity`
            The potential energy.
        """
        # TODO: check that potential ndim is consistent with here
        return potential.energy(self)

    def energy(self, hamiltonian):
        r"""
        The total energy *per unit mass* (e.g., kinetic + potential):

        Parameters
        ----------
        hamiltonian : `gala.potential.Hamiltonian`, `gala.potential.PotentialBase` instance
            The Hamiltonian object to evaluate the energy. If a potential is
            passed in, this assumes a static reference frame.

        Returns
        -------
        E : :class:`~astropy.units.Quantity`
            The total energy.
        """
        from gala.potential import Hamiltonian

        hamiltonian = Hamiltonian(hamiltonian)
        return hamiltonian(self)

    def angular_momentum(self):
        r"""
        Compute the angular momentum for the phase-space positions contained
        in this object::

        .. math::

            \boldsymbol{{L}} = \boldsymbol{{q}} \times \boldsymbol{{p}}

        See :ref:`shape-conventions` for more information about the shapes of
        input and output objects.

        Returns
        -------
        L : :class:`~astropy.units.Quantity`
            Array of angular momentum vectors.

        Examples
        --------

            >>> import numpy as np
            >>> import astropy.units as u
            >>> pos = np.array([1., 0, 0]) * u.au
            >>> vel = np.array([0, 2*np.pi, 0]) * u.au/u.yr
            >>> w = PhaseSpacePosition(pos, vel)
            >>> w.angular_momentum() # doctest: +FLOAT_CMP
            <Quantity [0.        ,0.        ,6.28318531] AU2 / yr>
        """
        cart = self.represent_as(coord.CartesianRepresentation)
        return cart.pos.cross(cart.vel).xyz

    def guiding_radius(self, potential, t=0.0, **root_kwargs):
        """
        Compute the guiding-center radius

        Parameters
        ----------
        potential : `gala.potential.PotentialBase` subclass instance
            The potential to compute the guiding radius in.
        t : quantity-like (optional)
            Time.
        **root_kwargs
            Any additional keyword arguments are passed to `~scipy.optimize.root`.

        Returns
        -------
        Rg : :class:`~astropy.units.Quantity`
            Guiding-center radius.
        """

        R0s = np.atleast_1d(
            np.sqrt(self.x**2 + self.y**2).decompose(potential.units).value
        )
        Lzs = np.atleast_1d(self.angular_momentum()[2].decompose(potential.units).value)
        Rgs = _guiding_radius_helper(R0s, Lzs, potential, t, **root_kwargs)

        return Rgs.reshape(self.shape) * potential.units["length"]

    # ------------------------------------------------------------------------
    # Misc. useful methods
    #
    def _plot_prepare(self, components, units):
        """
        Prepare the ``PhaseSpacePosition`` or subclass for passing to a plotting
        routine to plot all projections of the object.
        """

        # components to plot
        if components is None:
            components = self.pos.components
        n_comps = len(components)

        # if units not specified, get units from the components
        if units is not None:
            if isinstance(units, u.UnitBase):
                units = [units] * n_comps  # global unit

            elif len(units) != n_comps:
                raise ValueError(
                    "You must specify a unit for each axis, or a "
                    "single unit for all axes."
                )

        labels = []
        x = []
        for i, name in enumerate(components):
            val = getattr(self, name)

            if units is not None:
                val = val.to(units[i])
                unit = units[i]
            else:
                unit = val.unit

            if val.unit != u.one:
                uu = unit.to_string(format="latex_inline")
                unit_str = " [{}]".format(uu)
            else:
                unit_str = ""

            # Figure out how to fancy display the component name
            if name.startswith("d_"):
                dot = True
                name = name[2:]
            else:
                dot = False

            if name in _greek_letters:
                name = r"\{}".format(name)

            if dot:
                name = r"\dot{{{}}}".format(name)

            labels.append("${}$".format(name) + unit_str)
            x.append(val.value)

        return x, labels

    def plot(self, components=None, units=None, auto_aspect=True, **kwargs):
        """
        Plot the positions in all projections. This is a wrapper around
        `~gala.dynamics.plot_projections` for fast access and quick
        visualization. All extra keyword arguments are passed to that function
        (the docstring for this function is included here for convenience).

        Parameters
        ----------
        components : iterable (optional)
            A list of component names (strings) to plot. By default, this is the
            Cartesian positions ``['x', 'y', 'z']``. To plot Cartesian
            velocities, pass in the velocity component names
            ``['d_x', 'd_y', 'd_z']``.
        units : `~astropy.units.UnitBase`, iterable (optional)
            A single unit or list of units to display the components in.
        auto_aspect : bool (optional)
            Automatically enforce an equal aspect ratio.
        relative_to : bool (optional)
            Plot the values relative to this value or values.
        autolim : bool (optional)
            Automatically set the plot limits to be something sensible.
        axes : array_like (optional)
            Array of matplotlib Axes objects.
        subplots_kwargs : dict (optional)
            Dictionary of kwargs passed to :func:`~matplotlib.pyplot.subplots`.
        labels : iterable (optional)
            List or iterable of axis labels as strings. They should correspond to
            the dimensions of the input orbit.
        plot_function : callable (optional)
            The ``matplotlib`` plot function to use. By default, this is
            :func:`~matplotlib.pyplot.scatter`, but can also be, e.g.,
            :func:`~matplotlib.pyplot.plot`.
        **kwargs
            All other keyword arguments are passed to the ``plot_function``.
            You can pass in any of the usual style kwargs like ``color=...``,
            ``marker=...``, etc.

        Returns
        -------
        fig : `~matplotlib.Figure`

        """

        from gala.tests.optional_deps import HAS_MATPLOTLIB

        if not HAS_MATPLOTLIB:
            raise ImportError("matplotlib is required for visualization.")
        import matplotlib.pyplot as plt

        if components is None:
            components = self.pos.components

        x, labels = self._plot_prepare(components=components, units=units)

        kwargs.setdefault("plot_function", plt.scatter)
        if kwargs["plot_function"] in [plt.plot, plt.scatter]:
            kwargs.setdefault("marker", ".")
            kwargs.setdefault("labels", labels)
            kwargs.setdefault("plot_function", plt.scatter)
            kwargs.setdefault("autolim", False)

        fig = plot_projections(x, **kwargs)

        if (
            self.pos.get_name() == "cartesian"
            and all([not c.startswith("d_") for c in components])
            and auto_aspect
        ):
            for ax in fig.axes:
                ax.set(aspect="equal", adjustable="datalim")

        return fig

    # ------------------------------------------------------------------------
    # Display
    #
    def __repr__(self):
        return "<{} {}, dim={}, shape={}>".format(
            self.__class__.__name__, self.pos.get_name(), self.ndim, self.pos.shape
        )

    def __str__(self):
        return "pos={}\nvel={}".format(self.pos, self.vel)

    # ------------------------------------------------------------------------
    # Shape and size
    #

    @property
    def shape(self):
        """
        This is *not* the shape of the position or velocity arrays. That is
        accessed by doing, e.g., ``obj.x.shape``.
        """
        return self.pos.shape

    def reshape(self, new_shape):
        """
        Reshape the underlying position and velocity arrays.
        """
        return self.__class__(
            pos=self.pos.reshape(new_shape),
            vel=self.vel.reshape(new_shape),
            frame=self.frame,
        )


def _guiding_radius_rootfunc(R, Lz, potential, t):
    dPhi_dR = potential.c_instance.d_dr(
        np.array([[R[0], 0.0, 0.0]]), potential.G, t=np.array([t])
    )
    vc = np.sqrt(R * np.abs(dPhi_dR))
    return Lz - R * vc


def _guiding_radius_helper(R0s, Lzs, potential, t, **root_kwargs):
    from scipy.optimize import root

    root_kwargs.setdefault("options", dict(xtol=1e-5))
    root_kwargs.setdefault("method", "hybr")

    Rgs = np.zeros_like(R0s)
    for i, (R0, Lz) in enumerate(zip(R0s, Lzs)):
        res = root(
            _guiding_radius_rootfunc, R0, args=(np.abs(Lz), potential, t), **root_kwargs
        )
        if res.success:
            Rgs[i] = res.x[0]
        else:
            Rgs[i] = np.nan

    return Rgs
</file>

<file path="gala/dynamics/nonlinear.py">
# Third-party
import astropy.units as u
import numpy as np
from scipy.signal import argrelmin

# Project
from . import PhaseSpacePosition, Orbit

__all__ = ['fast_lyapunov_max', 'lyapunov_max', 'surface_of_section']


def fast_lyapunov_max(w0, hamiltonian, dt, n_steps, d0=1e-5,
                      n_steps_per_pullback=10, noffset_orbits=2, t1=0.,
                      atol=1E-10, rtol=1E-10, nmax=0, return_orbit=True):
    """
    Compute the maximum Lyapunov exponent using a C-implemented estimator
    that uses the DOPRI853 integrator.

    Parameters
    ----------
    w0 : `~gala.dynamics.PhaseSpacePosition`, array_like
        Initial conditions.
    hamiltonian : `~gala.potential.Hamiltonian`
    dt : numeric
        Timestep.
    n_steps : int
        Number of steps to run for.
    d0 : numeric (optional)
        The initial separation.
    n_steps_per_pullback : int (optional)
        Number of steps to run before re-normalizing the offset vectors.
    noffset_orbits : int (optional)
        Number of offset orbits to run.
    t1 : numeric (optional)
        Time of initial conditions. Assumed to be t=0.
    return_orbit : bool (optional)
        Store the full orbit for the parent and all offset orbits.

    Returns
    -------
    LEs : :class:`~astropy.units.Quantity`
        Lyapunov exponents calculated from each offset / deviation orbit.
    orbit : `~gala.dynamics.Orbit` (optional)

    """
    from gala.potential import PotentialBase
    from .lyapunov import dop853_lyapunov_max, dop853_lyapunov_max_dont_save

    # TODO: remove in v1.0
    if isinstance(hamiltonian, PotentialBase):
        from ..potential import Hamiltonian
        hamiltonian = Hamiltonian(hamiltonian)

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian must contain a C-implemented "
                        "potential and frame.")

    if not isinstance(w0, PhaseSpacePosition):
        w0 = np.asarray(w0)
        ndim = w0.shape[0]//2
        w0 = PhaseSpacePosition(pos=w0[:ndim],
                                vel=w0[ndim:])

    _w0 = np.squeeze(w0.w(hamiltonian.units))
    if _w0.ndim > 1:
        raise ValueError("Can only compute fast Lyapunov exponent for a single orbit.")

    if return_orbit:
        t, w, l = dop853_lyapunov_max(hamiltonian, _w0,
                                      dt, n_steps+1, t1,
                                      d0, n_steps_per_pullback, noffset_orbits,
                                      atol, rtol, nmax)
        w = np.rollaxis(w, -1)

        try:
            tunit = hamiltonian.units['time']
        except (TypeError, AttributeError):
            tunit = u.dimensionless_unscaled

        orbit = Orbit.from_w(w=w, units=hamiltonian.units,
                             t=t*tunit, hamiltonian=hamiltonian)
        return l/tunit, orbit

    else:
        l = dop853_lyapunov_max_dont_save(hamiltonian, _w0,
                                          dt, n_steps+1, t1,
                                          d0, n_steps_per_pullback, noffset_orbits,
                                          atol, rtol, nmax)

        try:
            tunit = hamiltonian.units['time']
        except (TypeError, AttributeError):
            tunit = u.dimensionless_unscaled

        return l/tunit


def lyapunov_max(w0, integrator, dt, n_steps, d0=1e-5, n_steps_per_pullback=10,
                 noffset_orbits=8, t1=0., units=None):
    """

    Compute the maximum Lyapunov exponent of an orbit by integrating many
    nearby orbits (``noffset``) separated with isotropically distributed
    directions but the same initial deviation length, ``d0``. This algorithm
    re-normalizes the offset orbits every ``n_steps_per_pullback`` steps.

    Parameters
    ----------
    w0 : `~gala.dynamics.PhaseSpacePosition`, array_like
        Initial conditions.
    integrator : `~gala.integrate.Integrator`
        An instantiated `~gala.integrate.Integrator` object. Must have a run() method.
    dt : numeric
        Timestep.
    n_steps : int
        Number of steps to run for.
    d0 : numeric (optional)
        The initial separation.
    n_steps_per_pullback : int (optional)
        Number of steps to run before re-normalizing the offset vectors.
    noffset_orbits : int (optional)
        Number of offset orbits to run.
    t1 : numeric (optional)
        Time of initial conditions. Assumed to be t=0.
    units : `~gala.units.UnitSystem` (optional)
        If passing in an array (not a `~gala.dynamics.PhaseSpacePosition`),
        you must specify a unit system.

    Returns
    -------
    LEs : :class:`~astropy.units.Quantity`
        Lyapunov exponents calculated from each offset / deviation orbit.
    orbit : `~gala.dynamics.Orbit`
    """

    if units is not None:
        pos_unit = units['length']
        vel_unit = units['length']/units['time']
    else:
        pos_unit = u.dimensionless_unscaled
        vel_unit = u.dimensionless_unscaled

    if not isinstance(w0, PhaseSpacePosition):
        w0 = np.asarray(w0)
        ndim = w0.shape[0]//2
        w0 = PhaseSpacePosition(pos=w0[:ndim]*pos_unit,
                                vel=w0[ndim:]*vel_unit)

    _w0 = w0.w(units)
    ndim = 2*w0.ndim

    # number of iterations
    niter = n_steps // n_steps_per_pullback

    # define offset vectors to start the offset orbits on
    d0_vec = np.random.uniform(size=(ndim, noffset_orbits))
    d0_vec /= np.linalg.norm(d0_vec, axis=0)[np.newaxis]
    d0_vec *= d0

    w_offset = _w0 + d0_vec
    all_w0 = np.hstack((_w0, w_offset))

    # array to store the full, main orbit
    full_w = np.zeros((ndim, n_steps+1, noffset_orbits+1))
    full_w[:, 0] = all_w0
    full_ts = np.zeros((n_steps+1,))
    full_ts[0] = t1

    # arrays to store the Lyapunov exponents and times
    LEs = np.zeros((niter, noffset_orbits))
    ts = np.zeros_like(LEs)
    time = t1
    total_steps_taken = 0
    for i in range(1, niter+1):
        ii = i * n_steps_per_pullback

        orbit = integrator(all_w0, dt=dt, n_steps=n_steps_per_pullback, t1=time)
        tt = orbit.t.value
        ww = orbit.w(units)
        time += dt*n_steps_per_pullback

        main_w = ww[:, -1, 0:1]
        d1 = ww[:, -1, 1:] - main_w
        d1_mag = np.linalg.norm(d1, axis=0)

        LEs[i-1] = np.log(d1_mag/d0)
        ts[i-1] = time

        w_offset = ww[:, -1, 0:1] + d0 * d1 / d1_mag[np.newaxis]
        all_w0 = np.hstack((ww[:, -1, 0:1], w_offset))

        full_w[:, (i-1)*n_steps_per_pullback+1:ii+1] = ww[:, 1:]
        full_ts[(i-1)*n_steps_per_pullback+1:ii+1] = tt[1:]

        total_steps_taken += n_steps_per_pullback

    LEs = np.array([LEs[:ii].sum(axis=0)/ts[ii-1] for ii in range(1, niter)])

    try:
        t_unit = units['time']
    except (TypeError, AttributeError):
        t_unit = u.dimensionless_unscaled

    orbit = Orbit.from_w(w=full_w[:, :total_steps_taken],
                         units=units, t=full_ts[:total_steps_taken]*t_unit)
    return LEs/t_unit, orbit


def surface_of_section(orbit, constant_idx, constant_val=0.):
    """
    Generate and return a surface of section from the given orbit.

    Parameters
    ----------
    orbit : `~gala.dynamics.Orbit`
        The input orbit to generate a surface of section for.
    constant_idx : int
        Integer that represents the coordinate to record crossings in. For
        example, for a 2D Hamiltonian where you want to make a SoS in
        :math:`y-p_y`, you would specify ``constant_idx=0`` (crossing the
        :math:`x` axis), and this will only record crossings for which
        :math:`p_x>0`.

    Returns
    -------
    sos : numpy ndarray

    TODO:
    - Implement interpolation to get the other phase-space coordinates truly
      at the plane, instead of just at the orbital position closest to the
      plane.

    """

    if orbit.norbits > 1:
        raise NotImplementedError("Not yet implemented, sorry!")

    w = ([getattr(orbit, x) for x in orbit.pos_components] +
         [getattr(orbit, v) for v in orbit.vel_components])

    ndim = orbit.ndim

    p_ix = constant_idx + ndim

    # record position on specified plane when orbit crosses
    cross_idx = argrelmin((w[constant_idx] - constant_val) ** 2)[0]
    cross_idx = cross_idx[w[p_ix][cross_idx] > 0.]

    sos_pos = [w[i][cross_idx] for i in range(ndim)]
    sos_pos = orbit.pos.__class__(*sos_pos)

    sos_vel = [w[i][cross_idx] for i in range(ndim, 2*ndim)]
    sos_vel = orbit.vel.__class__(*sos_vel)

    return Orbit(sos_pos, sos_vel)
</file>

<file path="gala/dynamics/orbit.py">
import warnings

# Third-party
import astropy.coordinates as coord
import astropy.table as at
import astropy.units as u
import numpy as np
from scipy.signal import argrelmax

# Project
from gala.logging import logger

from ..io import quantity_from_hdf5, quantity_to_hdf5
from ..units import DimensionlessUnitSystem, UnitSystem, dimensionless
from ..util import atleast_2d
from .core import PhaseSpacePosition
from .plot import plot_projections
from .util import peak_to_peak_period

__all__ = ["Orbit"]


class Orbit(PhaseSpacePosition):
    """
    Represents an orbit: positions and velocities (conjugate momenta) as a
    function of time.

    The class can be instantiated with Astropy representation objects (e.g.,
    :class:`~astropy.coordinates.CartesianRepresentation`), Astropy
    :class:`~astropy.units.Quantity` objects, or plain Numpy arrays.

    If passing in Quantity or Numpy array instances for both position and
    velocity, they are assumed to be Cartesian. Array inputs are interpreted as
    dimensionless quantities. The input position and velocity objects can have
    an arbitrary number of (broadcastable) dimensions. For Quantity or array
    inputs, the first axes have special meaning:

        - ``axis=0`` is the coordinate dimension (e.g., x, y, z)
        - ``axis=1`` is the time dimension

    So if the input position array, ``pos``, has shape ``pos.shape = (3, 100)``,
    this would be a 3D orbit at 100 times (``pos[0]`` is ``x``, ``pos[1]``` is
    ``y``, etc.). For representing multiple orbits, the position array could
    have 3 axes, e.g., it might have shape `pos.shape = (3, 100, 8)`, where this
    is interpreted as a 3D position at 100 times for 8 different orbits. The
    same is true for velocity. The position and velocity arrays must have the
    same shape.

    If a time argument is specified, the position and velocity arrays must have
    the same number of timesteps as the length of the time object::

        len(t) == pos.shape[1]

    Parameters
    ----------
    pos : representation, quantity_like, or array_like
        Positions. If a numpy array (e.g., has no units), this will be
        stored as a dimensionless :class:`~astropy.units.Quantity`. See
        the note above about the assumed meaning of the axes of this object.
    vel : differential, quantity_like, or array_like
        Velocities. If a numpy array (e.g., has no units), this will be
        stored as a dimensionless :class:`~astropy.units.Quantity`. See
        the note above about the assumed meaning of the axes of this object.
    t : array_like, :class:`~astropy.units.Quantity` (optional)
        Array of times. If a numpy array (e.g., has no units), this will be
        stored as a dimensionless :class:`~astropy.units.Quantity`.
    hamiltonian : `~gala.potential.Hamiltonian` (optional)
        The Hamiltonian that the orbit was integrated in.

    """

    def __init__(self, pos, vel, t=None, hamiltonian=None, potential=None, frame=None):
        super().__init__(pos=pos, vel=vel)

        if self.pos.ndim < 1:
            self.pos = self.pos.reshape(1)
            self.vel = self.vel.reshape(1)

        # TODO: check that Hamiltonian ndim is consistent with here

        if t is not None:
            t = np.atleast_1d(t)
            if self.pos.shape[0] != len(t):
                raise ValueError(
                    "Position and velocity must have the same "
                    "length along axis=1 as the length of the "
                    "time array {} vs {}".format(len(t), self.pos.shape[0])
                )

            if not hasattr(t, "unit"):
                t = t * u.one

        self.t = t

        if hamiltonian is not None:
            self.potential = hamiltonian.potential
            self.frame = hamiltonian.frame

        else:
            self.potential = potential
            self.frame = frame

    def __getitem__(self, slice_):
        if isinstance(slice_, np.ndarray) or isinstance(slice_, list):
            slice_ = (slice_,)

        try:
            slice_ = tuple(slice_)
        except TypeError:
            slice_ = (slice_,)

        kw = dict()
        if self.t is not None:
            kw["t"] = self.t[slice_[0]]

        pos = self.pos[slice_]
        vel = self.vel[slice_]

        # if one time is sliced out, return a phasespaceposition
        try:
            int_tslice = int(slice_[0])
        except TypeError:
            int_tslice = None

        if int_tslice is not None:
            return PhaseSpacePosition(pos=pos, vel=vel, frame=self.frame)

        else:
            return self.__class__(
                pos=pos, vel=vel, potential=self.potential, frame=self.frame, **kw
            )

    @property
    def hamiltonian(self):
        if self.potential is None or self.frame is None:
            return None

        try:
            return self._hamiltonian
        except AttributeError:
            from gala.potential import Hamiltonian

            self._hamiltonian = Hamiltonian(potential=self.potential, frame=self.frame)

        return self._hamiltonian

    def w(self, units=None):
        """
        This returns a single array containing the phase-space positions.

        Parameters
        ----------
        units : `~gala.units.UnitSystem` (optional)
            The unit system to represent the position and velocity in
            before combining into the full array.

        Returns
        -------
        w : `~numpy.ndarray`
            A numpy array of all positions and velocities, without units.
            Will have shape ``(2*ndim, ...)``.

        """

        if units is None:
            if self.hamiltonian is None:
                units = dimensionless
            else:
                units = self.hamiltonian.units

        return super().w(units=units)

    # ------------------------------------------------------------------------
    # Convert from Cartesian to other representations
    #
    def represent_as(self, new_pos, new_vel=None):
        """
        Represent the position and velocity of the orbit in an alternate
        coordinate system. Supports any of the Astropy coordinates
        representation classes.

        Parameters
        ----------
        new_pos : :class:`~astropy.coordinates.BaseRepresentation`
            The type of representation to generate. Must be a class (not an
            instance), or the string name of the representation class.
        new_vel : :class:`~astropy.coordinates.BaseDifferential` (optional)
            Class in which any velocities should be represented. Must be a class
            (not an instance), or the string name of the differential class. If
            None, uses the default differential for the new position class.

        Returns
        -------
        new_orbit : `gala.dynamics.Orbit`
        """
        kw = dict()
        if self.t is not None:
            kw["t"] = self.t
        o = super().represent_as(new_pos=new_pos, new_vel=new_vel)
        return self.__class__(pos=o.pos, vel=o.vel, hamiltonian=self.hamiltonian, **kw)

    # ------------------------------------------------------------------------
    # Shape and size
    # ------------------------------------------------------------------------
    @property
    def ntimes(self):
        return self.shape[0]

    @property
    def norbits(self):
        if len(self.shape) < 2:
            return 1
        else:
            return self.shape[1]

    def reshape(self, new_shape):
        """
        Reshape the underlying position and velocity arrays.
        """
        kw = dict()
        if self.t is not None:
            kw["t"] = self.t
        return self.__class__(
            pos=self.pos.reshape(new_shape),
            vel=self.vel.reshape(new_shape),
            hamiltonian=self.hamiltonian,
            **kw,
        )

    # ------------------------------------------------------------------------
    # Input / output
    #
    def to_hdf5(self, f):
        """
        Serialize this object to an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """

        f = super().to_hdf5(f)

        if self.potential is not None:
            import yaml

            from ..potential.potential.io import to_dict

            f["potential"] = yaml.dump(to_dict(self.potential)).encode("utf-8")

        if self.t is not None:
            quantity_to_hdf5(f, "time", self.t)

        return f

    @classmethod
    def from_hdf5(cls, f):
        """
        Load an object from an HDF5 file.

        Requires ``h5py``.

        Parameters
        ----------
        f : str, :class:`h5py.File`
            Either the filename or an open HDF5 file.
        """
        # TODO: this is duplicated code from PhaseSpacePosition
        if isinstance(f, str):
            import h5py

            f = h5py.File(f, mode="r")
            close = True
        else:
            close = False

        pos = quantity_from_hdf5(f["pos"])
        vel = quantity_from_hdf5(f["vel"])

        time = None
        if "time" in f:
            time = quantity_from_hdf5(f["time"])

        frame = None
        if "frame" in f:
            g = f["frame"]

            frame_mod = g.attrs["module"]
            frame_cls = g.attrs["class"]
            frame_units = [u.Unit(x.decode("utf-8")) for x in g["units"]]

            if u.dimensionless_unscaled in frame_units:
                units = DimensionlessUnitSystem()
            else:
                units = UnitSystem(*frame_units)

            pars = dict()
            for k in g["parameters"]:
                pars[k] = quantity_from_hdf5(g["parameters/" + k])

            exec("from {0} import {1}".format(frame_mod, frame_cls))
            frame_cls = eval(frame_cls)

            frame = frame_cls(units=units, **pars)

        potential = None
        if "potential" in f:
            import yaml

            from ..potential.potential.io import from_dict

            _dict = yaml.load(f["potential"][()].decode("utf-8"), Loader=yaml.Loader)
            potential = from_dict(_dict)

        if close:
            f.close()

        return cls(pos=pos, vel=vel, t=time, frame=frame, potential=potential)

    def orbit_gen(self):
        """
        Generator for iterating over each orbit.
        """
        if self.norbits == 1:
            yield self

        else:
            for i in range(self.norbits):
                yield self[:, i]

    # ------------------------------------------------------------------------
    # Computed dynamical quantities
    #

    def potential_energy(self, potential=None):
        r"""
        The potential energy *per unit mass*:

        .. math::

            E_\Phi = \Phi(\boldsymbol{q})

        Returns
        -------
        E : :class:`~astropy.units.Quantity`
            The potential energy.
        """
        if self.hamiltonian is None and potential is None:
            raise ValueError(
                "To compute the potential energy, a potential"
                " object must be provided!"
            )
        if potential is None:
            potential = self.hamiltonian.potential

        return super().potential_energy(potential)

    def energy(self, hamiltonian=None):
        r"""
        The total energy *per unit mass*:

        Parameters
        ----------
        hamiltonian : `gala.potential.Hamiltonian`, `gala.potential.PotentialBase` instance
            The Hamiltonian object to evaluate the energy. If a potential is
            passed in, this assumes a static reference frame.

        Returns
        -------
        E : :class:`~astropy.units.Quantity`
            The total energy.
        """

        if self.hamiltonian is None and hamiltonian is None:
            raise ValueError(
                "To compute the total energy, a hamiltonian" " object must be provided!"
            )

        if hamiltonian is None:
            hamiltonian = self.hamiltonian
        else:
            from gala.potential import Hamiltonian

            hamiltonian = Hamiltonian(hamiltonian)

        return hamiltonian(self)

    def _max_helper(self, arr, approximate=False):
        """
        Helper function for computing extrema (apocenter, pericenter, z_height)
        and times of extrema.

        Parameters
        ----------
        arr : `numpy.ndarray`
        """
        assert self.norbits == 1
        assert self.t[-1] > self.t[0]  # time must increase

        _ix = argrelmax(arr.value, mode="wrap")[0]
        _ix = _ix[(_ix != 0) & (_ix != (len(arr) - 1))]  # remove edges
        t = self.t.value

        approx_arr = arr[_ix]
        approx_t = t[_ix]

        if approximate:
            return approx_arr, approx_t * self.t.unit

        better_times = np.zeros(_ix.shape, dtype=float)
        better_arr = np.zeros(_ix.shape, dtype=float)
        for i, j in enumerate(_ix):
            tvals = t[j - 1 : j + 2]
            rvals = arr[j - 1 : j + 2].value
            coeffs = np.polynomial.polynomial.polyfit(tvals, rvals, 2)
            better_times[i] = (-coeffs[1]) / (2 * coeffs[2])
            better_arr[i] = (
                (coeffs[2] * better_times[i] ** 2)
                + (coeffs[1] * better_times[i])
                + coeffs[0]
            )

        return better_arr * arr.unit, better_times * self.t.unit

    def _max_return_helper(self, vals, times, return_times, reduce):
        if return_times:
            if len(vals) == 1:
                return vals[0], times[0]
            else:
                return vals, times

        elif reduce:
            return u.Quantity(vals).reshape(self.shape[1:])

        else:
            return u.Quantity(vals)

    def pericenter(self, return_times=False, func=np.mean, approximate=False):
        """
        Estimate the pericenter(s) of the orbit by identifying local minima in
        the spherical radius, fitting a parabola around these local minima and
        then solving this parabola to find the pericenter(s).

        By default, this returns the mean of all local minima (pericenters). To
        get, e.g., the minimum pericenter, pass in ``func=np.min``. To get
        all pericenters, pass in ``func=None``.

        Parameters
        ----------
        func : func (optional)
            A function to evaluate on all of the identified pericenter times.
        return_times : bool (optional)
            Also return the pericenter times.
        approximate : bool (optional)
            Compute an approximate pericenter by skipping interpolation.

        Returns
        -------
        peri : float, :class:`~numpy.ndarray`
            Either a single number or an array of pericenters.
        times : :class:`~numpy.ndarray` (optional, see ``return_times``)
            If ``return_times=True``, also returns an array of the pericenter
            times.

        """

        if return_times and func is not None:
            raise ValueError(
                "Cannot return times if reducing pericenters "
                "using an input function. Pass `func=None` if "
                "you want to return all individual pericenters "
                "and times."
            )

        if func is None:
            reduce = False
            func = lambda x: x  # noqa
        else:
            reduce = True

        # time must increase
        if self.t[-1] < self.t[0]:
            self = self[::-1]

        vals = []
        times = []
        for orbit in self.orbit_gen():
            v, t = orbit._max_helper(
                -orbit.physicsspherical.r, approximate=approximate  # pericenter
            )
            vals.append(func(-v))  # negative for pericenter
            times.append(t)

        return self._max_return_helper(vals, times, return_times, reduce)

    def apocenter(self, return_times=False, func=np.mean, approximate=False):
        """
        Estimate the apocenter(s) of the orbit by identifying local maxima in
        the spherical radius, fitting a parabola around these local maxima and
        then solving this parabola to find the apocenter(s).

        By default, this returns the mean of all local maxima (apocenters). To
        get, e.g., the largest apocenter, pass in ``func=np.max``. To get
        all apocenters, pass in ``func=None``.

        Parameters
        ----------
        func : func (optional)
            A function to evaluate on all of the identified apocenter times.
        return_times : bool (optional)
            Also return the apocenter times.
        approximate : bool (optional)
            Compute an approximate apocenter by skipping interpolation.

        Returns
        -------
        apo : float, :class:`~numpy.ndarray`
            Either a single number or an array of apocenters.
        times : :class:`~numpy.ndarray` (optional, see ``return_times``)
            If ``return_times=True``, also returns an array of the apocenter
            times.

        """

        if return_times and func is not None:
            raise ValueError(
                "Cannot return times if reducing apocenters "
                "using an input function. Pass `func=None` if "
                "you want to return all individual apocenters "
                "and times."
            )

        if func is None:
            reduce = False
            func = lambda x: x  # noqa
        else:
            reduce = True

        # time must increase
        if self.t[-1] < self.t[0]:
            self = self[::-1]

        vals = []
        times = []
        for orbit in self.orbit_gen():
            v, t = orbit._max_helper(
                orbit.physicsspherical.r, approximate=approximate  # apocenter
            )
            vals.append(func(v))
            times.append(t)

        return self._max_return_helper(vals, times, return_times, reduce)

    def guiding_radius(self, potential=None, t=0.0, **root_kwargs):
        """
        Compute the guiding-center radius

        Parameters
        ----------
        potential : `gala.potential.PotentialBase` subclass instance (optional)
            The potential to compute the guiding radius in.
        t : quantity-like (optional)
            Time.
        **root_kwargs
            Any additional keyword arguments are passed to `~scipy.optimize.root`.

        Returns
        -------
        Rg : :class:`~astropy.units.Quantity`
            Guiding-center radius.
        """
        from .core import _guiding_radius_helper

        if potential is None:
            potential = self.potential
        if potential is None:
            raise ValueError(
                "You must specify a potential if it is not already defined on the orbit"
            )

        R0s = np.atleast_1d(
            np.mean(self.cylindrical.rho).decompose(potential.units).value
        )
        Lzs = self.angular_momentum()[2].decompose(potential.units).value
        mean_Lzs = np.atleast_1d(np.mean(Lzs, axis=0))
        check = np.abs(np.std(Lzs, axis=0) / mean_Lzs) > 1e-8
        if np.any(check):
            warnings.warn(
                f"{check.sum()} orbits do not have constant Lz (see orbits at indices: "
                f"{list(np.where(check)[0][:10])}, ...). Are you sure you are using an"
                " axisymmetric potential?",
                RuntimeWarning,
            )

        Rgs = _guiding_radius_helper(R0s, mean_Lzs, potential, t=t, **root_kwargs)

        return Rgs.reshape(self.shape[1:]) * potential.units["length"]

    def zmax(self, return_times=False, func=np.mean, approximate=False):
        """
        Estimate the maximum ``z`` height of the orbit by identifying local
        maxima in the absolute value of the ``z`` position, fitting a parabola
        around these local maxima and then solving this parabola to find the
        maximum ``z`` height.

        By default, this returns the mean of all local maxima. To get, e.g., the
        largest ``z`` excursion, pass in ``func=np.max``. To get all ``z``
        maxima, pass in ``func=None``.

        Parameters
        ----------
        func : func (optional)
            A function to evaluate on all of the identified z maximum times.
        return_times : bool (optional)
            Also return the times of maximum.
        approximate : bool (optional)
            Compute approximate values by skipping interpolation.

        Returns
        -------
        zs : float, :class:`~numpy.ndarray`
            Either a single number or an array of maximum z heights.
        times : :class:`~numpy.ndarray` (optional, see ``return_times``)
            If ``return_times=True``, also returns an array of the apocenter
            times.

        """

        if return_times and func is not None:
            raise ValueError(
                "Cannot return times if reducing "
                "using an input function. Pass `func=None` if "
                "you want to return all individual values "
                "and times."
            )

        if func is None:
            reduce = False
            func = lambda x: x  # noqa
        else:
            reduce = True

        # time must increase
        if self.t[-1] < self.t[0]:
            self = self[::-1]

        vals = []
        times = []
        for orbit in self.orbit_gen():
            v, t = orbit._max_helper(
                np.abs(orbit.cylindrical.z), approximate=approximate
            )
            vals.append(func(v))
            times.append(t)

        return self._max_return_helper(vals, times, return_times, reduce)

    def eccentricity(self, **kw):
        r"""
        Returns the eccentricity computed from the mean apocenter and
        mean pericenter.

        .. math::

            e = \frac{r_{\rm apo} - r_{\rm per}}{r_{\rm apo} + r_{\rm per}}

        Parameters
        ----------
        **kw
            Any keyword arguments passed to ``apocenter()`` and
            ``pericenter()``. For example, ``approximate=True``.

        Returns
        -------
        ecc : float
            The orbital eccentricity.

        """
        ra = self.apocenter(**kw)
        rp = self.pericenter(**kw)
        return (ra - rp) / (ra + rp)

    def estimate_period(self, radial=False):
        """
        Estimate the period of the orbit. By default, computes the radial
        period. If ``radial==False``, this returns period estimates for
        each dimension of the orbit.

        Parameters
        ----------
        radial : bool (optional)
            What period to estimate. If ``True``, estimates the radial
            period. If ``False``, estimates period in each dimension, e.g.,
            if the orbit is 3D, along x, y, and z.

        Returns
        -------
        periods : `~astropy.table.QTable`
            The estimated orbital periods for each phase-space component, for
            each orbit.
        """

        if self.t is None:
            raise ValueError(
                "To compute the period, a time array is needed. "
                "Specify a time array when creating this object."
            )

        if radial:
            # TODO: Remove this after deprecation cycle
            import warnings

            from gala.util import GalaDeprecationWarning

            warnings.warn(
                "Passing radial=True in estimate_period() is now deprecated. "
                "This method now returns period estimates for all orbital "
                "components. If you want to get just the radial period, use "
                "orbits.physicsspherical.estimate_period() instead.",
                GalaDeprecationWarning,
            )
            r = self.physicsspherical.r.value
            if self.norbits == 1:
                T = u.Quantity(peak_to_peak_period(self.t, r))
            else:
                T = u.Quantity(
                    [peak_to_peak_period(self.t, r[:, n]) for n in range(r.shape[1])]
                )
            return T

        else:
            periods = {}
            for k in self.pos_components.keys():
                q = getattr(self, k).value
                if self.norbits == 1:
                    T = u.Quantity(peak_to_peak_period(self.t, q))
                else:
                    T = u.Quantity(
                        [
                            peak_to_peak_period(self.t, q[:, n])
                            for n in range(q.shape[1])
                        ]
                    )
                periods[k] = np.atleast_1d(T)
            return at.QTable(periods)

    # ------------------------------------------------------------------------
    # Misc. useful methods
    # ------------------------------------------------------------------------
    def circulation(self):
        """
        Determine which axes the Orbit circulates around by checking
        whether there is a change of sign of the angular momentum
        about an axis. Returns a 2D array with ``ndim`` integers per orbit
        point. If a box orbit, all integers will be 0. A 1 indicates
        circulation about the corresponding axis.

        TODO: clockwise / counterclockwise?

        For example, for a single 3D orbit:

        - Box and boxlet = [0, 0, 0]
        - z-axis (short-axis) tube = [0, 0, 1]
        - x-axis (long-axis) tube = [1, 0, 0]

        Returns
        -------
        circulation : :class:`numpy.ndarray`
            An array that specifies whether there is circulation about any of
            the axes of the input orbit. For a single orbit, will return a
            1D array, but for multiple orbits, the shape will be
            ``(3, norbits)``.

        """
        L = self.angular_momentum()

        # if only 2D, add another empty axis
        if L.ndim == 2:
            single_orbit = True
            L = L[..., None]
        else:
            single_orbit = False

        ndim, ntimes, norbits = L.shape

        # initial angular momentum
        L0 = L[:, 0]

        # see if at any timestep the sign has changed
        circ = np.ones((ndim, norbits))
        for ii in range(ndim):
            cnd = (np.sign(L0[ii]) != np.sign(L[ii, 1:])) | (
                np.abs(L[ii, 1:]).value < 1e-13
            )
            ix = np.atleast_1d(np.any(cnd, axis=0))
            circ[ii, ix] = 0

        circ = circ.astype(int)
        if single_orbit:
            return circ.reshape((ndim,))
        else:
            return circ

    def align_circulation_with_z(self, circulation=None):
        """
        If the input orbit is a tube orbit, this function aligns the circulation
        axis with the z axis and returns a copy.

        Parameters
        ----------
        circulation : array_like (optional)
            Array of bits that specify the axis about which the orbit
            circulates. If not provided, will compute this using
            :meth:`~gala.dynamics.Orbit.circulation`. See that method for more
            information.

        Returns
        -------
        orb : :class:`~gala.dynamics.Orbit`
            A copy of the original orbit object with circulation aligned with
            the z axis.
        """

        if circulation is None:
            circulation = self.circulation()
        circulation = atleast_2d(circulation, insert_axis=1)

        cart = self.cartesian
        pos = cart.xyz
        vel = (
            np.vstack(
                (cart.v_x.value[None], cart.v_y.value[None], cart.v_z.value[None])
            )
            * cart.v_x.unit
        )

        if pos.ndim < 3:
            pos = pos[..., np.newaxis]
            vel = vel[..., np.newaxis]

        if circulation.shape[0] != self.ndim or circulation.shape[1] != pos.shape[2]:
            raise ValueError(
                "Shape of 'circulation' array should match the "
                "shape of the position/velocity (minus the time "
                "axis)."
            )

        new_pos = pos.copy()
        new_vel = vel.copy()
        for n in range(pos.shape[2]):
            if circulation[2, n] == 1 or np.all(circulation[:, n] == 0):
                # already circulating about z or box orbit
                continue

            if sum(circulation[:, n]) > 1:
                logger.warning(
                    "Circulation about multiple axes - are you sure "
                    "the orbit has been integrated for long enough?"
                )

            if circulation[0, n] == 1:
                circ = 0
            elif circulation[1, n] == 1:
                circ = 1
            else:
                raise RuntimeError("Should never get here...")

            new_pos[circ, :, n] = pos[2, :, n]
            new_pos[2, :, n] = pos[circ, :, n]

            new_vel[circ, :, n] = vel[2, :, n]
            new_vel[2, :, n] = vel[circ, :, n]

        return self.__class__(
            pos=new_pos.reshape(cart.xyz.shape),
            vel=new_vel.reshape(cart.xyz.shape),
            t=self.t,
            hamiltonian=self.hamiltonian,
        )

    def plot(self, components=None, units=None, auto_aspect=True, **kwargs):
        """
        Plot the positions in all projections. This is a wrapper around
        `~gala.dynamics.plot_projections` for fast access and quick
        visualization. All extra keyword arguments are passed to that function
        (the docstring for this function is included here for convenience).

        Parameters
        ----------
        components : iterable (optional)
            A list of component names (strings) to plot. By default, this is the
            Cartesian positions ``['x', 'y', 'z']``. To plot Cartesian
            velocities, pass in the velocity component names
            ``['v_x', 'v_y', 'v_z']``. If the representation is different, the
            component names will be different. For example, for a Cylindrical
            representation, the components are ``['rho', 'phi', 'z']`` and
            ``['v_rho', 'pm_phi', 'v_z']``.
        units : `~astropy.units.UnitBase`, iterable (optional)
            A single unit or list of units to display the components in.
        auto_aspect : bool (optional)
            Automatically enforce an equal aspect ratio.
        relative_to : bool (optional)
            Plot the values relative to this value or values.
        autolim : bool (optional)
            Automatically set the plot limits to be something sensible.
        axes : array_like (optional)
            Array of matplotlib Axes objects.
        subplots_kwargs : dict (optional)
            Dictionary of kwargs passed to :func:`~matplotlib.pyplot.subplots`.
        labels : iterable (optional)
            List or iterable of axis labels as strings. They should correspond to
            the dimensions of the input orbit.
        plot_function : callable (optional)
            The ``matplotlib`` plot function to use. By default, this is
            :func:`~matplotlib.pyplot.scatter`, but can also be, e.g.,
            :func:`~matplotlib.pyplot.plot`.
        **kwargs
            All other keyword arguments are passed to the ``plot_function``.
            You can pass in any of the usual style kwargs like ``color=...``,
            ``marker=...``, etc.

        Returns
        -------
        fig : `~matplotlib.Figure`

        """
        from gala.tests.optional_deps import HAS_MATPLOTLIB

        if not HAS_MATPLOTLIB:
            raise ImportError("matplotlib is required for visualization.")
        import matplotlib.pyplot as plt

        if components is None:
            if self.ndim == 1:  # only a 1D orbit, so just plot time series
                components = ["t", self.pos.components[0]]
            else:
                components = self.pos.components

        x, labels = self._plot_prepare(components=components, units=units)

        kwargs.setdefault("plot_function", plt.plot)
        if kwargs["plot_function"] in [plt.plot, plt.scatter]:
            kwargs.setdefault("marker", "")
            kwargs.setdefault("labels", labels)

            if kwargs["plot_function"] == plt.plot:
                kwargs.setdefault("linestyle", "-")

        fig = plot_projections(x, **kwargs)

        if (
            self.pos.get_name() == "cartesian"
            and all([not c.startswith("d_") for c in components])
            and "t" not in components
            and auto_aspect
        ):
            for ax in fig.axes:
                ax.set(aspect="equal", adjustable="datalim")

        return fig

    def plot_3d(
        self,
        components=None,
        units=None,
        auto_aspect=True,
        subplots_kwargs=None,
        **kwargs,
    ):
        """
        Plot the specified 3D components.

        Parameters
        ----------
        components : iterable (optional)
            A list of component names (strings) to plot. By default, this is the
            Cartesian positions ``['x', 'y', 'z']``. To plot Cartesian
            velocities, pass in the velocity component names
            ``['v_x', 'v_y', 'v_z']``. If the representation is different, the
            component names will be different. For example, for a Cylindrical
            representation, the components are ``['rho', 'phi', 'z']`` and
            ``['v_rho', 'pm_phi', 'v_z']``.
        units : `~astropy.units.UnitBase`, iterable (optional)
            A single unit or list of units to display the components in.
        auto_aspect : bool (optional)
            Automatically enforce an equal aspect ratio.
        ax : `matplotlib.axes.Axes`
            The matplotlib Axes object to draw on.
        subplots_kwargs : dict (optional)
            Dictionary of kwargs passed to :func:`~matplotlib.pyplot.subplots`.
        labels : iterable (optional)
            List or iterable of axis labels as strings. They should correspond
            to the dimensions of the input orbit.
        plot_function : str (optional)
            The ``matplotlib`` plot function to use. By default, this is 'plot'
            but can also be, e.g., 'scatter'.
        **kwargs
            All other keyword arguments are passed to the ``plot_function``.
            You can pass in any of the usual style kwargs like ``color=...``,
            ``marker=...``, etc.

        Returns
        -------
        fig : `~matplotlib.Figure`

        """
        from gala.tests.optional_deps import HAS_MATPLOTLIB

        if not HAS_MATPLOTLIB:
            raise ImportError("matplotlib is required for visualization.")
        import matplotlib.pyplot as plt
        from mpl_toolkits import mplot3d  # noqa

        if components is None:
            components = self.pos.components

        if subplots_kwargs is None:
            subplots_kwargs = dict()

        if len(components) != 3:
            raise ValueError(f"The number of components ({len(components)}) must be 3")

        x, labels = self._plot_prepare(components=components, units=units)

        kwargs.setdefault("marker", "")
        kwargs.setdefault("linestyle", kwargs.pop("ls", "-"))
        plot_function_name = kwargs.pop("plot_function", "plot")

        ax = kwargs.pop("ax", None)
        subplots_kwargs.setdefault("constrained_layout", True)
        if ax is None:
            fig, ax = plt.subplots(
                figsize=(6, 6), subplot_kw=dict(projection="3d"), **subplots_kwargs
            )
        else:
            fig = ax.figure

        plot_function = getattr(ax, plot_function_name)
        if x[0].ndim > 1:
            for n in range(x[0].shape[1]):
                plot_function(*[xx[:, n] for xx in x], **kwargs)
        else:
            plot_function(*x, **kwargs)
        ax.set_xlabel(labels[0])
        ax.set_ylabel(labels[1])
        ax.set_zlabel(labels[2])

        if (
            self.pos.get_name() == "cartesian"
            and all([not c.startswith("d_") for c in components])
            and "t" not in components
            and auto_aspect
        ):
            for ax in fig.axes:
                ax.set(aspect="auto", adjustable="datalim")

        return fig, ax

    def animate(
        self,
        components=None,
        units=None,
        stride=1,
        segment_nsteps=10,
        underplot_full_orbit=True,
        show_time=True,
        marker_style=None,
        segment_style=None,
        FuncAnimation_kwargs=None,
        orbit_plot_kwargs=None,
        axes=None,
    ):
        """
        Animate an orbit or collection of orbits.

        Parameters
        ----------
        components : iterable (optional)
            A list of component names (strings) to plot. By default, this is the
            Cartesian positions ``['x', 'y', 'z']``. To plot Cartesian
            velocities, pass in the velocity component names
            ``['v_x', 'v_y', 'v_z']``. If the representation is different, the
            component names will be different. For example, for a Cylindrical
            representation, the components are ``['rho', 'phi', 'z']`` and
            ``['v_rho', 'pm_phi', 'v_z']``.
        units : `~astropy.units.UnitBase`, iterable (optional)
            A single unit or list of units to display the components in.
        stride : int (optional)
            How often to draw a new frame, in terms of orbit timesteps.
        segment_nsteps : int (optional)
            How many timesteps to draw in an orbit segment trailing
            the timestep marker. Set this to 0 or None to disable.
        underplot_full_orbit : bool (optional)
            Controls whether to under-plot the full orbit as a thin line.
        show_time : bool (optional)
            Controls whether to show a label of the current timestep
        marker_style : dict or list of dict (optional)
            Matplotlib style arguments passed to `matplotlib.pyplot.plot`
            that control the plot style of the timestep marker. If a single
            dict is passed then the marker_style is applied to all orbits.
            If a list of dicts is passed then each dict will be applied to
            each orbit.
        segment_style : dict (optional)
            Matplotlib style arguments passed to `matplotlib.pyplot.plot`
            that control the plot style of the orbit segment. If a single
            dict is passed then the segment_style is applied to all orbits.
            If a list of dicts is passed then each dict will be applied to
            each orbit.
        FuncAnimation_kwargs : dict (optional)
            Keyword arguments passed through to
            `matplotlib.animation.FuncAnimation`.
        orbit_plot_kwargs : dict (optional)
            Keyword arguments passed through to `gala.dynamics.Orbit.plot`.
        axes : `matplotlib.axes.Axes` (optional)
            Where to draw the orbit.

        Returns
        -------
        fig : `matplotlib.figure.Figure`
        anim : `matplotlib.animation.FuncAnimation`

        """
        from gala.tests.optional_deps import HAS_MATPLOTLIB

        if not HAS_MATPLOTLIB:
            raise ImportError("matplotlib is required for visualization.")
        from matplotlib.animation import FuncAnimation

        if components is None:
            if self.ndim == 1:  # only a 1D orbit, so just plot time series
                components = ["t", self.pos.components[0]]
            else:
                components = self.pos.components

        # Extract the relevant components, in the given unit system
        xs, _ = self._plot_prepare(components=components, units=units)
        xs = [atleast_2d(xx, insert_axis=1) for xx in xs]

        # Figure out which components to plot on which axes
        data_paired = []
        for i in range(len(xs)):
            for j in range(len(xs)):
                if i >= j:
                    continue  # skip diagonal, upper triangle
                data_paired.append((xs[i], xs[j]))

        if FuncAnimation_kwargs is None:
            FuncAnimation_kwargs = dict()

        if orbit_plot_kwargs is None:
            orbit_plot_kwargs = dict()
        orbit_plot_kwargs.setdefault("zorder", 1)
        orbit_plot_kwargs.setdefault("color", "#aaaaaa")
        orbit_plot_kwargs.setdefault("linewidth", "1")
        orbit_plot_kwargs.setdefault("axes", axes)

        if marker_style is None:
            marker_style = [dict() for _ in range(self.norbits)]

        # if a single dict is passed then copy it into a list
        if isinstance(marker_style, dict):
            marker_style = [marker_style for _ in range(self.norbits)]
        # otherwise ensure the list is the right length
        elif len(marker_style) != self.norbits:
            raise ValueError(
                "Length of `marker_style` list must be equal to the number of orbits"
            )

        for n in range(self.norbits):
            marker_style[n].setdefault("marker", "o")
            marker_style[n].setdefault("linestyle", marker_style[n].pop("ls", "None"))
            marker_style[n].setdefault("markersize", marker_style[n].pop("ms", 4.0))
            marker_style[n].setdefault("color", marker_style[n].pop("c", "tab:red"))
            marker_style[n].setdefault("zorder", 100)

        if segment_style is None:
            segment_style = [dict() for _ in range(self.norbits)]

        # if a single dict is passed then copy it into a list
        if isinstance(segment_style, dict):
            segment_style = [segment_style for _ in range(self.norbits)]
        # otherwise ensure the list is the right length
        elif len(segment_style) != self.norbits:
            raise ValueError(
                "Length of `segment_style` list must be equal to the number of orbits"
            )

        for n in range(self.norbits):
            segment_style[n].setdefault("marker", "None")
            segment_style[n].setdefault("linestyle", segment_style[n].pop("ls", "-"))
            segment_style[n].setdefault("linewidth", segment_style[n].pop("lw", 2.0))
            segment_style[n].setdefault("color", segment_style[n].pop("c", "tab:blue"))
            segment_style[n].setdefault("zorder", 10)
            if segment_nsteps is None or segment_nsteps == 0:  # HACK
                segment_style[n]["alpha"] = 0

        # Use this to get a figure with axes with the right limits
        # Note: Labels are added by .plot()
        if not underplot_full_orbit:
            orbit_plot_kwargs["alpha"] = 0
        fig = self.plot(components=components, units=units, **orbit_plot_kwargs)

        # Set up all of the (data-less) markers and line segments
        markers = []
        segments = []
        for n in range(self.norbits):
            _m = []
            _s = []
            for i in range(len(data_paired)):
                _m.append(fig.axes[i].plot([], [], **marker_style[n])[0])
                _s.append(fig.axes[i].plot([], [], **segment_style[n])[0])
            markers.append(_m)
            segments.append(_s)

        # record the time unit and set up data-less annotates if user wants timestep label
        if show_time:
            time_unit = self.t.unit
            times = [
                fig.axes[i].annotate(
                    "", xy=(0.98, 0.98), xycoords="axes fraction", ha="right", va="top"
                )
                for i in range(len(data_paired))
            ]

        def anim_func(n):
            i = max(0, n - segment_nsteps)

            for k in range(self.norbits):
                for j in range(len(data_paired)):
                    markers[k][j].set_data(
                        data_paired[j][0][n : n + 1, k], data_paired[j][1][n : n + 1, k]
                    )
                    segments[k][j].set_data(
                        data_paired[j][0][i : n + 1, k], data_paired[j][1][i : n + 1, k]
                    )

            if show_time:
                time_value = self.t[n : n + 1].value[0]
                for time in times:
                    time.set_text(f"Time={time_value:1.1f} {time_unit}")

                artists = (
                    *[m for m in markers for x in m],
                    *[s for s in segments for x in s],
                    *times,
                )
            else:
                artists = (
                    *[m for m in markers for x in m],
                    *[s for s in segments for x in s],
                )
            return artists

        anim = FuncAnimation(
            fig,
            anim_func,
            frames=np.arange(0, self.ntimes, stride),
            **FuncAnimation_kwargs,
        )

        return fig, anim

    def to_frame(self, frame, current_frame=None, **kwargs):
        """
        Transform to a different reference frame.

        Parameters
        ----------
        frame : `gala.potential.CFrameBase`
            The frame to transform to.
        current_frame : `gala.potential.CFrameBase` (optional)
            If the Orbit has no associated Hamiltonian, this specifies the
            current frame of the orbit.

        Returns
        -------
        orbit : `gala.dynamics.Orbit`
            The orbit in the new reference frame.

        """

        kw = kwargs.copy()

        # TODO: this short-circuit sux
        if current_frame is None:
            current_frame = self.frame
        if frame == current_frame and not kwargs:
            return self

        # TODO: need a better way to do this!
        from ..potential.frame.builtin import ConstantRotatingFrame

        for fr in [frame, current_frame, self.frame]:
            if isinstance(fr, ConstantRotatingFrame):
                if "t" not in kw:
                    kw["t"] = self.t

        # TODO: this needs a re-write...
        psp = super().to_frame(frame, current_frame, **kw)

        return Orbit(
            pos=psp.pos, vel=psp.vel, t=self.t, frame=frame, potential=self.potential
        )

    # ------------------------------------------------------------------------
    # Compatibility with other packages
    #

    def to_galpy_orbit(self, ro=None, vo=None):
        """Convert this object to a ``galpy.Orbit`` instance.

        Parameters
        ----------
        ro : `astropy.units.Quantity` or `astropy.units.UnitBase`
            "Natural" length unit.
        vo : `astropy.units.Quantity` or `astropy.units.UnitBase`
            "Natural" velocity unit.

        Returns
        -------
        galpy_orbit : `galpy.orbit.Orbit`

        """
        from galpy.orbit import Orbit
        from galpy.util.config import __config__ as galpy_config

        if self.frame is not None:
            from ..potential import StaticFrame

            w = self.to_frame(StaticFrame(self.frame.units))
        else:
            w = self

        if ro is None:
            ro = galpy_config.getfloat("normalization", "ro")
            ro = ro * u.kpc

        if vo is None:
            vo = galpy_config.getfloat("normalization", "vo")
            vo = vo * u.km / u.s

        # PhaseSpacePosition or Orbit:
        cyl = w.cylindrical

        R = cyl.rho.to_value(ro).T
        phi = cyl.phi.to_value(u.rad).T
        z = cyl.z.to_value(ro).T

        vR = cyl.v_rho.to_value(vo).T
        vT = (cyl.rho * cyl.pm_phi).to_value(vo, u.dimensionless_angles()).T
        vz = cyl.v_z.to_value(vo).T

        o = Orbit(np.array([R, vR, vT, z, vz, phi]).T, ro=ro, vo=vo)
        if w.t is not None:
            o.t = w.t.to_value(ro / vo)

        return o

    @classmethod
    def from_galpy_orbit(self, galpy_orbit):
        """Create a Gala ``PhaseSpacePosition`` or ``Orbit`` instance from a
        ``galpy.Orbit`` instance.

        Parameters
        ----------
        galpy_orbit : :class:`galpy.orbit.Orbit`

        Returns
        -------
        orbit : :class:`~gala.dynamics.Orbit`

        """
        ro = galpy_orbit._ro * u.kpc
        vo = galpy_orbit._vo * u.km / u.s
        ts = galpy_orbit.t

        rep = coord.CylindricalRepresentation(
            rho=galpy_orbit.R(ts) * ro,
            phi=galpy_orbit.phi(ts) * u.rad,
            z=galpy_orbit.z(ts) * ro,
        )
        with u.set_enabled_equivalencies(u.dimensionless_angles()):
            dif = coord.CylindricalDifferential(
                d_rho=galpy_orbit.vR(ts) * vo,
                d_phi=galpy_orbit.vT(ts) * vo / rep.rho,
                d_z=galpy_orbit.vz(ts) * vo,
            )

        t = galpy_orbit.t * ro / vo
        return Orbit(rep, dif, t=t)
</file>

<file path="gala/dynamics/plot.py">
# Third-party
import numpy as np

__all__ = ['plot_projections']


def _get_axes(dim, subplots_kwargs=None):
    """
    Parameters
    ----------
    dim : int
        Dimensionality of the orbit.
    subplots_kwargs : dict (optional)
        Dictionary of kwargs passed to :func:`~matplotlib.pyplot.subplots`.
    """
    from gala.tests.optional_deps import HAS_MATPLOTLIB
    if not HAS_MATPLOTLIB:
        raise ImportError('matplotlib is required for visualization.')
    import matplotlib.pyplot as plt

    if subplots_kwargs is None:
        subplots_kwargs = dict()

    if dim > 1:
        n_panels = int(dim * (dim - 1) / 2)
    else:
        n_panels = 1

    subplots_kwargs.setdefault('figsize', (4*n_panels, 4))
    subplots_kwargs.setdefault('constrained_layout', True)

    fig, axes = plt.subplots(1, n_panels, **subplots_kwargs)

    if n_panels == 1:
        axes = [axes]

    else:
        axes = axes.flat

    return axes


def plot_projections(x, relative_to=None, autolim=True, axes=None,
                     subplots_kwargs=None, labels=None, plot_function=None,
                     **kwargs):
    """
    Given N-dimensional quantity, ``x``, make a figure containing 2D projections
    of all combinations of the axes.

    Parameters
    ----------
    x : array_like
        Array of values. ``axis=0`` is assumed to be the dimensionality,
        ``axis=1`` is the time axis. See :ref:`shape-conventions` for more
        information.
    relative_to : bool (optional)
        Plot the values relative to this value or values.
    autolim : bool (optional)
        Automatically set the plot limits to be something sensible.
    axes : array_like (optional)
        Array of matplotlib Axes objects.
    subplots_kwargs : dict (optional)
        Dictionary of kwargs passed to :func:`~matplotlib.pyplot.subplots`.
    labels : iterable (optional)
        List or iterable of axis labels as strings. They should correspond to
        the dimensions of the input orbit.
    plot_function : callable (optional)
        The ``matplotlib`` plot function to use. By default, this is
        :func:`~matplotlib.pyplot.scatter`, but can also be, e.g.,
        :func:`~matplotlib.pyplot.plot`.
    **kwargs
        All other keyword arguments are passed to the ``plot_function``.
        You can pass in any of the usual style kwargs like ``color=...``,
        ``marker=...``, etc.

    Returns
    -------
    fig : `~matplotlib.Figure`

    """

    # don't propagate changes back...
    x = np.array(x, copy=True)
    ndim = x.shape[0]

    # get axes object from arguments
    if axes is None:
        axes = _get_axes(dim=ndim, subplots_kwargs=subplots_kwargs)

    import matplotlib.pyplot as plt  # mpl import already checked above
    if isinstance(axes, plt.Axes):
        axes = [axes]

    # if the quantities are relative
    if relative_to is not None:
        x -= relative_to

    # name of the plotting function
    plot_fn_name = plot_function.__name__

    # automatically determine limits
    if autolim:
        lims = []
        for i in range(ndim):
            max_, min_ = np.max(x[i]), np.min(x[i])
            delta = max_ - min_

            if delta == 0.:
                delta = 1.

            lims.append([min_ - delta*0.02, max_ + delta*0.02])

    k = 0
    for i in range(ndim):
        for j in range(ndim):
            if i >= j:
                continue  # skip diagonal, upper triangle

            plot_func = getattr(axes[k], plot_fn_name)
            plot_func(x[i], x[j], **kwargs)

            if labels is not None:
                axes[k].set_xlabel(labels[i])
                axes[k].set_ylabel(labels[j])

            if autolim:
                # ensure new limits only ever expand current axis limits
                xlims = axes[k].get_xlim()
                ylims = axes[k].get_ylim()
                lims[i] = (min(lims[i][0], xlims[0]),
                           max(lims[i][1], xlims[1]))
                lims[j] = (min(lims[j][0], ylims[0]),
                           max(lims[j][1], ylims[1]))

                axes[k].set_xlim(lims[i])
                axes[k].set_ylim(lims[j])

            k += 1

    return axes[0].figure
</file>

<file path="gala/dynamics/representation_nd.py">
# Standard library
import operator

# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np

from gala._compat_utils import COPY_IF_NEEDED

__all__ = ["NDCartesianRepresentation", "NDCartesianDifferential"]


def _make_getter(component):
    """Make an attribute getter for use in a property.

    Removed from Astropy in v6.3 but still used here.

    Parameters
    ----------
    component : str
        The name of the component that should be accessed.  This assumes the
        actual value is stored in an attribute of that name prefixed by '_'.
    """
    # This has to be done in a function to ensure the reference to component
    # is not lost/redirected.
    component = "_" + component

    def get_component(self):
        return getattr(self, component)

    return get_component


class NDMixin(object):

    def _apply(self, method, *args, **kwargs):
        """Create a new representation with ``method`` applied to the arrays.

        In typical usage, the method is any of the shape-changing methods for
        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those
        picking particular elements (``__getitem__``, ``take``, etc.), which
        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be
        applied to the underlying arrays (e.g., ``x``, ``y``, and ``z`` for
        `~astropy.coordinates.CartesianRepresentation`), with the results used
        to create a new instance.

        Internally, it is also used to apply functions to the components
        (in particular, `~numpy.broadcast_to`).

        Parameters
        ----------
        method : str or callable
            If str, it is the name of a method that is applied to the internal
            ``components``. If callable, the function is applied.
        args : tuple
            Any positional arguments for ``method``.
        kwargs : dict
            Any keyword arguments for ``method``.
        """
        if callable(method):
            apply_method = lambda array: method(array, *args, **kwargs)  # noqa
        else:
            apply_method = operator.methodcaller(method, *args, **kwargs)
        return self.__class__(
            [apply_method(getattr(self, component)) for component in self.components],
            copy=COPY_IF_NEEDED,
        )


class NDCartesianRepresentation(NDMixin, coord.CartesianRepresentation):
    """
    Representation of points in ND cartesian coordinates.

    Parameters
    ----------
    x : `~astropy.units.Quantity` or array
        The Cartesian coordinates of the point(s). If not quantity,
        ``unit`` should be set.
    differentials : dict, `NDCartesianDifferential` (optional)
        Any differential classes that should be associated with this
        representation.
    unit : `~astropy.units.Unit` or str
        If given, the coordinates will be converted to this unit (or taken to
        be in this unit if not given.
    copy : bool, optional
        If `True` (default), arrays will be copied rather than referenced.
    """

    attr_classes = dict()

    def __init__(self, x, differentials=None, unit=None, copy=True):

        if unit is None:
            if not hasattr(x[0], "unit"):
                unit = u.one
            else:
                unit = x[0].unit

        x = u.Quantity(x, unit, copy=copy, subok=True)
        copy = False

        self.attr_classes = dict(
            [("x" + str(i), u.Quantity) for i in range(1, len(x) + 1)]
        )

        super(coord.CartesianRepresentation, self).__init__(
            *x, differentials=differentials, copy=copy
        )

        ptype = None
        for name, _ in self.attr_classes.items():
            if ptype is None:
                ptype = getattr(self, "_" + name).unit.physical_type

            else:
                if getattr(self, "_" + name).unit.physical_type != ptype:
                    raise u.UnitsError(
                        "All components should have matching " "physical types"
                    )

            cls = self.__class__
            if not hasattr(cls, name):
                setattr(
                    cls,
                    name,
                    property(
                        _make_getter(name),
                        doc=(f"The '{name}' component of the points(s)."),
                    ),
                )

    def get_xyz(self, xyz_axis=0):
        """Return a vector array of the x, y, and z coordinates.

        Parameters
        ----------
        xyz_axis : int, optional
            The axis in the final array along which the x, y, z components
            should be stored (default: 0).

        Returns
        -------
        xs : `~astropy.units.Quantity`
            With dimension 3 along ``xyz_axis``.
        """
        # Add new axis in x, y, z so one can concatenate them around it.
        # NOTE: just use np.stack once our minimum numpy version is 1.10.
        result_ndim = self.ndim + 1
        if not -result_ndim <= xyz_axis < result_ndim:
            raise IndexError(
                "xyz_axis {0} out of bounds [-{1}, {1})".format(xyz_axis, result_ndim)
            )
        if xyz_axis < 0:
            xyz_axis += result_ndim

        # Get components to the same units (very fast for identical units)
        # since np.concatenate cannot deal with quantity.
        unit = self._x1.unit

        sh = self.shape
        sh = sh[:xyz_axis] + (1,) + sh[xyz_axis:]
        components = [
            getattr(self, "_" + name).reshape(sh).to(unit).value
            for name in self.attr_classes
        ]
        xs_value = np.concatenate(components, axis=xyz_axis)
        return u.Quantity(xs_value, unit=unit, copy=COPY_IF_NEEDED)

    xyz = property(get_xyz)


class NDCartesianDifferential(NDMixin, coord.CartesianDifferential):
    """Differentials in of points in ND cartesian coordinates.

    Parameters
    ----------
    *d_x : `~astropy.units.Quantity` or array
        The Cartesian coordinates of the differentials. If not quantity,
        ``unit`` should be set.
    unit : `~astropy.units.Unit` or str
        If given, the differentials will be converted to this unit (or taken to
        be in this unit if not given.
    copy : bool, optional
        If `True` (default), arrays will be copied rather than referenced.
    """

    base_representation = NDCartesianRepresentation
    attr_classes = dict()

    def __init__(self, d_x, unit=None, copy=True):

        if unit is None:
            if not hasattr(d_x[0], "unit"):
                unit = u.one
            else:
                unit = d_x[0].unit

        d_x = u.Quantity(d_x, unit, copy=copy, subok=True)
        copy = False

        self.attr_classes = dict(
            [("d_x" + str(i), u.Quantity) for i in range(1, len(d_x) + 1)]
        )

        super(coord.CartesianDifferential, self).__init__(*d_x, copy=copy)

        ptype = None
        for name, _ in self.attr_classes.items():
            if ptype is None:
                ptype = getattr(self, "_" + name).unit.physical_type

            else:
                if getattr(self, "_" + name).unit.physical_type != ptype:
                    raise u.UnitsError(
                        "All components should have matching " "physical types"
                    )

            cls = self.__class__
            if not hasattr(cls, name):
                setattr(
                    cls,
                    name,
                    property(
                        _make_getter(name),
                        doc=("The '{0}' component of the points(s).".format(name)),
                    ),
                )

    def get_d_xyz(self, xyz_axis=0):
        """Return a vector array of the x, y, and z coordinates.

        Parameters
        ----------
        xyz_axis : int, optional
            The axis in the final array along which the x, y, z components
            should be stored (default: 0).

        Returns
        -------
        d_xs : `~astropy.units.Quantity`
            With dimension 3 along ``xyz_axis``.
        """
        # Add new axis in x, y, z so one can concatenate them around it.
        # NOTE: just use np.stack once our minimum numpy version is 1.10.
        result_ndim = self.ndim + 1
        if not -result_ndim <= xyz_axis < result_ndim:
            raise IndexError(
                "xyz_axis {0} out of bounds [-{1}, {1})".format(xyz_axis, result_ndim)
            )
        if xyz_axis < 0:
            xyz_axis += result_ndim

        # Get components to the same units (very fast for identical units)
        # since np.concatenate cannot deal with quantity.
        unit = self._d_x1.unit

        sh = self.shape
        sh = sh[:xyz_axis] + (1,) + sh[xyz_axis:]
        components = [
            getattr(self, "_" + name).reshape(sh).to(unit).value
            for name in self.components
        ]
        xs_value = np.concatenate(components, axis=xyz_axis)
        return u.Quantity(xs_value, unit=unit, copy=COPY_IF_NEEDED)

    d_xyz = property(get_d_xyz)
</file>

<file path="gala/dynamics/setup_package.py">
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/integrate/cyintegrators')
    cfg['include_dirs'].append('gala/potential')
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    cfg['sources'].append('gala/potential/hamiltonian/src/chamiltonian.c')
    cfg['sources'].append('gala/integrate/cyintegrators/dopri/dop853.c')
    cfg['sources'].append('gala/dynamics/lyapunov/dop853_lyapunov.pyx')
    exts.append(Extension('gala.dynamics.lyapunov.dop853_lyapunov', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['sources'].append('gala/dynamics/mockstream/_coord.pyx')
    cfg['extra_compile_args'].append('--std=gnu99')
    exts.append(Extension('gala.dynamics.mockstream._coord', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['sources'].append('gala/dynamics/mockstream/df.pyx')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    cfg['extra_compile_args'].append('--std=gnu99')
    exts.append(Extension('gala.dynamics.mockstream.df', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append('gala/integrate/cyintegrators')
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['include_dirs'].append('gala/dynamics/nbody')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    cfg['sources'].append('gala/potential/hamiltonian/src/chamiltonian.c')
    cfg['sources'].append('gala/dynamics/mockstream/mockstream.pyx')
    cfg['sources'].append('gala/integrate/cyintegrators/dopri/dop853.c')
    cfg['extra_compile_args'].append('--std=gnu99')
    exts.append(Extension('gala.dynamics.mockstream._mockstream', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append('gala/integrate/cyintegrators')
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    cfg['sources'].append('gala/potential/hamiltonian/src/chamiltonian.c')
    cfg['sources'].append('gala/integrate/cyintegrators/dopri/dop853.c')
    cfg['sources'].append('gala/dynamics/nbody/nbody.pyx')
    cfg['extra_compile_args'].append('--std=gnu99')
    exts.append(Extension('gala.dynamics.nbody.nbody', **cfg))

    return exts
</file>

<file path="gala/dynamics/util.py">
""" General dynamics utilities. """

# Third-party
import astropy.units as u
import astropy.coordinates as coord
from astropy.utils.misc import isiterable
import numpy as np
from scipy.signal import argrelmax, argrelmin

# This package
from .core import PhaseSpacePosition
from ..util import atleast_2d

__all__ = ['peak_to_peak_period', 'estimate_dt_n_steps', 'combine']


def peak_to_peak_period(t, f, amplitude_threshold=1E-2):
    """
    Estimate the period of the input time series by measuring the average
    peak-to-peak time.

    Parameters
    ----------
    t : array_like
        Time grid aligned with the input time series.
    f : array_like
        A periodic time series.
    amplitude_threshold : numeric (optional)
        A tolerance parameter. Fails if the mean amplitude of oscillations
        isn't larger than this tolerance.

    Returns
    -------
    period : float
        The mean peak-to-peak period.
    """
    if hasattr(t, 'unit'):
        t_unit = t.unit
        t = t.value
    else:
        t_unit = u.dimensionless_unscaled

    # find peaks
    max_ix = argrelmax(f, mode='wrap')[0]
    max_ix = max_ix[(max_ix != 0) & (max_ix != (len(f)-1))]

    # find troughs
    min_ix = argrelmin(f, mode='wrap')[0]
    min_ix = min_ix[(min_ix != 0) & (min_ix != (len(f)-1))]

    # neglect minor oscillations
    if abs(np.mean(f[max_ix]) - np.mean(f[min_ix])) < amplitude_threshold:
        return np.nan * t_unit

    # compute mean peak-to-peak
    if len(max_ix) > 0:
        T_max = np.mean(t[max_ix[1:]] - t[max_ix[:-1]])
    else:
        T_max = np.nan

    # now compute mean trough-to-trough
    if len(min_ix) > 0:
        T_min = np.mean(t[min_ix[1:]] - t[min_ix[:-1]])
    else:
        T_min = np.nan

    # then take the mean of these two
    return np.mean([T_max, T_min]) * t_unit


def _autodetermine_initial_dt(w0, H, dE_threshold=1E-9,
                              **integrate_kwargs):
    if w0.shape and w0.shape[0] > 1:
        raise ValueError("Only one set of initial conditions may be passed "
                         "in at a time.")

    if dE_threshold is None:
        return 1.

    dts = np.logspace(-3, 1, 8)[::-1]
    _base_n_steps = 1000

    for dt in dts:
        n_steps = int(round(_base_n_steps / dt))
        orbit = H.integrate_orbit(w0, dt=dt, n_steps=n_steps,
                                  **integrate_kwargs)
        E = orbit.energy()
        dE = np.abs((E[-1] - E[0]) / E[0]).value

        if dE < dE_threshold:
            break

    return dt


def estimate_dt_n_steps(w0, hamiltonian, n_periods, n_steps_per_period,
                        dE_threshold=1E-9, func=np.nanmax,
                        **integrate_kwargs):
    """
    Estimate the timestep and number of steps to integrate an orbit for
    given its initial conditions and a potential object.

    Parameters
    ----------
    w0 : `~gala.dynamics.PhaseSpacePosition`, array_like
        Initial conditions.
    potential : :class:`~gala.potential.PotentialBase`
        The potential to integrate the orbit in.
    n_periods : int
        Number of (max) orbital periods to integrate for.
    n_steps_per_period : int
        Number of steps to take per (max) orbital period.
    dE_threshold : numeric (optional)
        Maximum fractional energy difference -- used to determine initial
        timestep. Set to ``None`` to ignore this.
    func : callable (optional)
        Determines which period to use. By default, this takes the maximum
        period using :func:`~numpy.nanmax`. Other options could be
        :func:`~numpy.nanmin`, :func:`~numpy.nanmean`, :func:`~numpy.nanmedian`.

    Returns
    -------
    dt : float
        The timestep.
    n_steps : int
        The number of timesteps to integrate for.

    """
    if not isinstance(w0, PhaseSpacePosition):
        w0 = np.asarray(w0)
        w0 = PhaseSpacePosition.from_w(w0, units=hamiltonian.units)

    from ..potential import Hamiltonian
    hamiltonian = Hamiltonian(hamiltonian)

    # integrate orbit
    dt = _autodetermine_initial_dt(w0, hamiltonian, dE_threshold=dE_threshold,
                                   **integrate_kwargs)
    n_steps = int(round(10000 / dt))
    orbit = hamiltonian.integrate_orbit(w0, dt=dt, n_steps=n_steps,
                                        **integrate_kwargs)

    # if loop, align circulation with Z and take R period
    circ = orbit.circulation()
    if np.any(circ):
        orbit = orbit.align_circulation_with_z(circulation=circ)
        cyl = orbit.represent_as(coord.CylindricalRepresentation)

        # convert to cylindrical coordinates
        R = cyl.rho.value
        phi = cyl.phi.value
        z = cyl.z.value

        T = np.array([peak_to_peak_period(orbit.t, f).value
                      for f in [R, phi, z]])*orbit.t.unit

    else:
        T = np.array([peak_to_peak_period(orbit.t, f).value
                      for f in orbit.pos])*orbit.t.unit

    # timestep from number of steps per period
    T = func(T)

    if np.isnan(T):
        raise RuntimeError("Failed to find period.")

    T = T.decompose(hamiltonian.units).value
    dt = T / float(n_steps_per_period)
    n_steps = int(round(n_periods * T / dt))

    if dt == 0. or dt < 1E-13:
        raise ValueError("Timestep is zero or very small!")

    return dt, n_steps


def combine(objs):
    """Combine the specified `~gala.dynamics.PhaseSpacePosition` or
    `~gala.dynamics.Orbit` objects.

    Parameters
    ----------
    objs : iterable
        An iterable of either `~gala.dynamics.PhaseSpacePosition` or
        `~gala.dynamics.Orbit` objects.
    """
    from .orbit import Orbit

    # have to special-case this because they are iterable
    if isinstance(objs, PhaseSpacePosition) or isinstance(objs, Orbit):
        raise ValueError("You must pass a non-empty iterable to combine.")

    elif not isiterable(objs) or len(objs) < 1:
        raise ValueError("You must pass a non-empty iterable to combine.")

    elif len(objs) == 1:  # short circuit
        return objs[0]

    # We only support these two types to combine:
    if objs[0].__class__ not in [PhaseSpacePosition, Orbit]:
        raise TypeError("Objects must be either PhaseSpacePosition or Orbit "
                        "instances.")

    # Validate objects:
    # - check type
    # - check dimensionality
    # - check frame, potential
    # - Right now, we only support Cartesian
    for obj in objs:
        # Check to see if they are all the same type of object:
        if obj.__class__ != objs[0].__class__:
            raise TypeError("All objects must have the same type.")

        # Make sure they have same dimensionality
        if obj.ndim != objs[0].ndim:
            raise ValueError("All objects must have the same ndim.")

        # Check that all objects have the same reference frame
        if obj.frame != objs[0].frame:
            raise ValueError("All objects must have the same frame.")

        # Check that (for orbits) they all have the same potential
        if hasattr(obj, 'potential') and obj.potential != objs[0].potential:
            raise ValueError("All objects must have the same potential.")

        # For orbits, time arrays must be the same
        if (hasattr(obj, 't') and obj.t is not None and objs[0].t is not None
                and not u.allclose(obj.t, objs[0].t,
                                   atol=1E-13*objs[0].t.unit)):
            raise ValueError("All orbits must have the same time array.")

        if 'cartesian' not in obj.pos.get_name():
            raise NotImplementedError("Currently, combine only works for "
                                      "Cartesian-represented objects.")

    # Now we prepare the positions, velocities:
    if objs[0].__class__ == PhaseSpacePosition:
        pos = []
        vel = []

        for i, obj in enumerate(objs):
            if i == 0:
                pos_unit = obj.pos.xyz.unit
                vel_unit = obj.vel.d_xyz.unit

            pos.append(atleast_2d(obj.pos.xyz.to(pos_unit).value,
                                  insert_axis=1))
            vel.append(atleast_2d(obj.vel.d_xyz.to(vel_unit).value,
                                  insert_axis=1))

        pos = np.concatenate(pos, axis=1) * pos_unit
        vel = np.concatenate(vel, axis=1) * vel_unit

        return PhaseSpacePosition(pos=pos, vel=vel, frame=objs[0].frame)

    elif objs[0].__class__ == Orbit:
        pos = []
        vel = []

        for i, obj in enumerate(objs):
            if i == 0:
                pos_unit = obj.pos.xyz.unit
                vel_unit = obj.vel.d_xyz.unit

            p = obj.pos.xyz.to(pos_unit).value
            v = obj.vel.d_xyz.to(vel_unit).value

            if p.ndim < 3:
                p = p.reshape(p.shape + (1,))
                v = v.reshape(v.shape + (1,))

            pos.append(p)
            vel.append(v)

        pos = np.concatenate(pos, axis=2) * pos_unit
        vel = np.concatenate(vel, axis=2) * vel_unit

        return Orbit(pos=pos, vel=vel,
                     t=objs[0].t, frame=objs[0].frame,
                     potential=objs[0].potential)

    else:
        raise RuntimeError("should never get here...")
</file>

<file path="gala/integrate/cyintegrators/dopri/dop853.c">
#include <math.h>
#include <stdio.h>
// #include <malloc.h>
#include <stdlib.h>
#include <limits.h>
#include <memory.h>
#include "dop853.h"


static long      nfcn, nstep, naccpt, nrejct;
static double    hout, xold, xout;
static unsigned  nrds, *indir;
static double    *yy1, *k1, *k2, *k3, *k4, *k5, *k6, *k7, *k8, *k9, *k10;
static double    *rcont1, *rcont2, *rcont3, *rcont4;
static double    *rcont5, *rcont6, *rcont7, *rcont8;


long nfcnRead (void)
{
  return nfcn;

} /* nfcnRead */


long nstepRead (void)
{
  return nstep;

} /* stepRead */


long naccptRead (void)
{
  return naccpt;

} /* naccptRead */


long nrejctRead (void)
{
  return nrejct;

} /* nrejct */


double hRead (void)
{
  return hout;

} /* hRead */


double xRead (void)
{
  return xout;

} /* xRead */


static double sign (double a, double b)
{
  return (b < 0.0)? -fabs(a) : fabs(a);

} /* sign */


static double min_d (double a, double b)
{
  return (a < b)?a:b;

} /* min_d */


static double max_d (double a, double b)
{
  return (a > b)?a:b;

} /* max_d */


static double hinit (unsigned n, FcnEqDiff fcn, CPotential *p, CFrameType *fr, unsigned norbits, unsigned nbody, void *args,
        double x, double* y,
	      double posneg, double* f0, double* f1, double* yy1, int iord,
	      double hmax, double* atoler, double* rtoler, int itoler)
{
  double   dnf, dny, atoli, rtoli, sk, h, h1, der2, der12, sqr;
  unsigned i;

  dnf = 0.0;
  dny = 0.0;
  atoli = atoler[0];
  rtoli = rtoler[0];

  if (!itoler)
    for (i = 0; i < n; i++)
    {
      sk = atoli + rtoli * fabs(y[i]);
      sqr = f0[i] / sk;
      dnf += sqr*sqr;
      sqr = y[i] / sk;
      dny += sqr*sqr;
    }
  else
    for (i = 0; i < n; i++)
    {
      sk = atoler[i] + rtoler[i] * fabs(y[i]);
      sqr = f0[i] / sk;
      dnf += sqr*sqr;
      sqr = y[i] / sk;
      dny += sqr*sqr;
    }

  if ((dnf <= 1.0E-10) || (dny <= 1.0E-10))
    h = 1.0E-6;
  else
    h = sqrt (dny/dnf) * 0.01;

  h = min_d (h, hmax);
  h = sign (h, posneg);

  /* perform an explicit Euler step */
  for (i = 0; i < n; i++)
    yy1[i] = y[i] + h * f0[i];
  fcn (n, x+h, yy1, f1, p, fr, norbits, nbody, args);

  /* estimate the second derivative of the solution */
  der2 = 0.0;
  if (!itoler)
    for (i = 0; i < n; i++)
    {
      sk = atoli + rtoli * fabs(y[i]);
      sqr = (f1[i] - f0[i]) / sk;
      der2 += sqr*sqr;
    }
  else
    for (i = 0; i < n; i++)
    {
      sk = atoler[i] + rtoler[i] * fabs(y[i]);
      sqr = (f1[i] - f0[i]) / sk;
      der2 += sqr*sqr;
    }
  der2 = sqrt (der2) / h;

  /* step size is computed such that h**iord * max_d(norm(f0),norm(der2)) = 0.01 */
  der12 = max_d (fabs(der2), sqrt(dnf));
  if (der12 <= 1.0E-15)
    h1 = max_d (1.0E-6, fabs(h)*1.0E-3);
  else
    h1 = pow (0.01/der12, 1.0/(double)iord);
  h = min_d (100.0 * fabs(h), min_d (h1, hmax));

  return sign (h, posneg);

} /* hinit */


/* core integrator */
static int dopcor (unsigned n, FcnEqDiff fcn, CPotential *p, CFrameType *fr, unsigned norbits, unsigned nbody, void *args,
       double x, double* y, double xend,
		   double hmax, double h, double* rtoler, double* atoler,
		   int itoler, FILE* fileout, SolTrait solout, int iout,
		   long nmax, double uround, int meth, long nstiff, double safe,
		   double beta, double fac1, double fac2, unsigned* icont)
{
  double   facold, expo1, fac, facc1, facc2, fac11, posneg, xph;
  double   atoli, rtoli, hlamb, err, sk, hnew, yd0, ydiff, bspl;
  double   stnum, stden, sqr, err2, erri, deno;
  int      iasti, iord, irtrn, reject, last, nonsti;
  unsigned i, j;
  double   c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c14, c15, c16;
  double   b1, b6, b7, b8, b9, b10, b11, b12, bhh1, bhh2, bhh3;
  double   er1, er6, er7, er8, er9, er10, er11, er12;
  double   a21, a31, a32, a41, a43, a51, a53, a54, a61, a64, a65, a71, a74, a75, a76;
  double   a81, a84, a85, a86, a87, a91, a94, a95, a96, a97, a98;
  double   a101, a104, a105, a106, a107, a108, a109;
  double   a111, a114, a115, a116, a117, a118, a119, a1110;
  double   a121, a124, a125, a126, a127, a128, a129, a1210, a1211;
  double   a141, a147, a148, a149, a1410, a1411, a1412, a1413;
  double   a151, a156, a157, a158, a1511, a1512, a1513, a1514;
  double   a161, a166, a167, a168, a169, a1613, a1614, a1615;
  double   d41, d46, d47, d48, d49, d410, d411, d412, d413, d414, d415, d416;
  double   d51, d56, d57, d58, d59, d510, d511, d512, d513, d514, d515, d516;
  double   d61, d66, d67, d68, d69, d610, d611, d612, d613, d614, d615, d616;
  double   d71, d76, d77, d78, d79, d710, d711, d712, d713, d714, d715, d716;

  /* initialisations */
  switch (meth)
  {
    case 1:

      c2  = 0.526001519587677318785587544488E-01;
      c3  = 0.789002279381515978178381316732E-01;
      c4  = 0.118350341907227396726757197510E+00;
      c5  = 0.281649658092772603273242802490E+00;
      c6  = 0.333333333333333333333333333333E+00;
      c7  = 0.25E+00;
      c8  = 0.307692307692307692307692307692E+00;
      c9  = 0.651282051282051282051282051282E+00;
      c10 = 0.6E+00;
      c11 = 0.857142857142857142857142857142E+00;
      c14 = 0.1E+00;
      c15 = 0.2E+00;
      c16 = 0.777777777777777777777777777778E+00;

      b1 =   5.42937341165687622380535766363E-2;
      b6 =   4.45031289275240888144113950566E0;
      b7 =   1.89151789931450038304281599044E0;
      b8 =  -5.8012039600105847814672114227E0;
      b9 =   3.1116436695781989440891606237E-1;
      b10 = -1.52160949662516078556178806805E-1;
      b11 =  2.01365400804030348374776537501E-1;
      b12 =  4.47106157277725905176885569043E-2;

      bhh1 = 0.244094488188976377952755905512E+00;
      bhh2 = 0.733846688281611857341361741547E+00;
      bhh3 = 0.220588235294117647058823529412E-01;

      er1  =  0.1312004499419488073250102996E-01;
      er6  = -0.1225156446376204440720569753E+01;
      er7  = -0.4957589496572501915214079952E+00;
      er8  =  0.1664377182454986536961530415E+01;
      er9  = -0.3503288487499736816886487290E+00;
      er10 =  0.3341791187130174790297318841E+00;
      er11 =  0.8192320648511571246570742613E-01;
      er12 = -0.2235530786388629525884427845E-01;

      a21 =    5.26001519587677318785587544488E-2;
      a31 =    1.97250569845378994544595329183E-2;
      a32 =    5.91751709536136983633785987549E-2;
      a41 =    2.95875854768068491816892993775E-2;
      a43 =    8.87627564304205475450678981324E-2;
      a51 =    2.41365134159266685502369798665E-1;
      a53 =   -8.84549479328286085344864962717E-1;
      a54 =    9.24834003261792003115737966543E-1;
      a61 =    3.7037037037037037037037037037E-2;
      a64 =    1.70828608729473871279604482173E-1;
      a65 =    1.25467687566822425016691814123E-1;
      a71 =    3.7109375E-2;
      a74 =    1.70252211019544039314978060272E-1;
      a75 =    6.02165389804559606850219397283E-2;
      a76 =   -1.7578125E-2;

      a81 =    3.70920001185047927108779319836E-2;
      a84 =    1.70383925712239993810214054705E-1;
      a85 =    1.07262030446373284651809199168E-1;
      a86 =   -1.53194377486244017527936158236E-2;
      a87 =    8.27378916381402288758473766002E-3;
      a91 =    6.24110958716075717114429577812E-1;
      a94 =   -3.36089262944694129406857109825E0;
      a95 =   -8.68219346841726006818189891453E-1;
      a96 =    2.75920996994467083049415600797E1;
      a97 =    2.01540675504778934086186788979E1;
      a98 =   -4.34898841810699588477366255144E1;
      a101 =   4.77662536438264365890433908527E-1;
      a104 =  -2.48811461997166764192642586468E0;
      a105 =  -5.90290826836842996371446475743E-1;
      a106 =   2.12300514481811942347288949897E1;
      a107 =   1.52792336328824235832596922938E1;
      a108 =  -3.32882109689848629194453265587E1;
      a109 =  -2.03312017085086261358222928593E-2;

      a111 =  -9.3714243008598732571704021658E-1;
      a114 =   5.18637242884406370830023853209E0;
      a115 =   1.09143734899672957818500254654E0;
      a116 =  -8.14978701074692612513997267357E0;
      a117 =  -1.85200656599969598641566180701E1;
      a118 =   2.27394870993505042818970056734E1;
      a119 =   2.49360555267965238987089396762E0;
      a1110 = -3.0467644718982195003823669022E0;
      a121 =   2.27331014751653820792359768449E0;
      a124 =  -1.05344954667372501984066689879E1;
      a125 =  -2.00087205822486249909675718444E0;
      a126 =  -1.79589318631187989172765950534E1;
      a127 =   2.79488845294199600508499808837E1;
      a128 =  -2.85899827713502369474065508674E0;
      a129 =  -8.87285693353062954433549289258E0;
      a1210 =  1.23605671757943030647266201528E1;
      a1211 =  6.43392746015763530355970484046E-1;

      a141 =  5.61675022830479523392909219681E-2;
      a147 =  2.53500210216624811088794765333E-1;
      a148 = -2.46239037470802489917441475441E-1;
      a149 = -1.24191423263816360469010140626E-1;
      a1410 =  1.5329179827876569731206322685E-1;
      a1411 =  8.20105229563468988491666602057E-3;
      a1412 =  7.56789766054569976138603589584E-3;
      a1413 = -8.298E-3;

      a151 =  3.18346481635021405060768473261E-2;
      a156 =  2.83009096723667755288322961402E-2;
      a157 =  5.35419883074385676223797384372E-2;
      a158 = -5.49237485713909884646569340306E-2;
      a1511 = -1.08347328697249322858509316994E-4;
      a1512 =  3.82571090835658412954920192323E-4;
      a1513 = -3.40465008687404560802977114492E-4;
      a1514 =  1.41312443674632500278074618366E-1;
      a161 = -4.28896301583791923408573538692E-1;
      a166 = -4.69762141536116384314449447206E0;
      a167 =  7.68342119606259904184240953878E0;
      a168 =  4.06898981839711007970213554331E0;
      a169 =  3.56727187455281109270669543021E-1;
      a1613 = -1.39902416515901462129418009734E-3;
      a1614 =  2.9475147891527723389556272149E0;
      a1615 = -9.15095847217987001081870187138E0;

      d41  = -0.84289382761090128651353491142E+01;
      d46  =  0.56671495351937776962531783590E+00;
      d47  = -0.30689499459498916912797304727E+01;
      d48  =  0.23846676565120698287728149680E+01;
      d49  =  0.21170345824450282767155149946E+01;
      d410 = -0.87139158377797299206789907490E+00;
      d411 =  0.22404374302607882758541771650E+01;
      d412 =  0.63157877876946881815570249290E+00;
      d413 = -0.88990336451333310820698117400E-01;
      d414 =  0.18148505520854727256656404962E+02;
      d415 = -0.91946323924783554000451984436E+01;
      d416 = -0.44360363875948939664310572000E+01;

      d51  =  0.10427508642579134603413151009E+02;
      d56  =  0.24228349177525818288430175319E+03;
      d57  =  0.16520045171727028198505394887E+03;
      d58  = -0.37454675472269020279518312152E+03;
      d59  = -0.22113666853125306036270938578E+02;
      d510 =  0.77334326684722638389603898808E+01;
      d511 = -0.30674084731089398182061213626E+02;
      d512 = -0.93321305264302278729567221706E+01;
      d513 =  0.15697238121770843886131091075E+02;
      d514 = -0.31139403219565177677282850411E+02;
      d515 = -0.93529243588444783865713862664E+01;
      d516 =  0.35816841486394083752465898540E+02;

      d61 =  0.19985053242002433820987653617E+02;
      d66 = -0.38703730874935176555105901742E+03;
      d67 = -0.18917813819516756882830838328E+03;
      d68 =  0.52780815920542364900561016686E+03;
      d69 = -0.11573902539959630126141871134E+02;
      d610 =  0.68812326946963000169666922661E+01;
      d611 = -0.10006050966910838403183860980E+01;
      d612 =  0.77771377980534432092869265740E+00;
      d613 = -0.27782057523535084065932004339E+01;
      d614 = -0.60196695231264120758267380846E+02;
      d615 =  0.84320405506677161018159903784E+02;
      d616 =  0.11992291136182789328035130030E+02;

      d71  = -0.25693933462703749003312586129E+02;
      d76  = -0.15418974869023643374053993627E+03;
      d77  = -0.23152937917604549567536039109E+03;
      d78  =  0.35763911791061412378285349910E+03;
      d79  =  0.93405324183624310003907691704E+02;
      d710 = -0.37458323136451633156875139351E+02;
      d711 =  0.10409964950896230045147246184E+03;
      d712 =  0.29840293426660503123344363579E+02;
      d713 = -0.43533456590011143754432175058E+02;
      d714 =  0.96324553959188282948394950600E+02;
      d715 = -0.39177261675615439165231486172E+02;
      d716 = -0.14972683625798562581422125276E+03;

      break;
  }

  facold = 1.0E-4;
  expo1 = 1.0/8.0 - beta * 0.2;
  facc1 = 1.0 / fac1;
  facc2 = 1.0 / fac2;
  posneg = sign (1.0, xend-x);

  /* initial preparations */
  atoli = atoler[0];
  rtoli = rtoler[0];
  last  = 0;
  hlamb = 0.0;
  iasti = 0;
  fcn (n, x, y, k1, p, fr, norbits, nbody, args);
  hmax = fabs (hmax);
  iord = 8;
  if (h == 0.0)
    h = hinit (n, fcn, p, fr, norbits, nbody, args, x, y, posneg, k1, k2, k3, iord, hmax, atoler, rtoler, itoler);
  nfcn += 2;
  reject = 0;
  xold = x;

  if (iout)
  {
    irtrn = 1;
    hout = 1.0;
    xout = x;
    solout (naccpt+1, xold, x, y, n, &irtrn);
    if (irtrn < 0)
    {
      if (fileout)
	fprintf (fileout, "Exit of dop853 at x = %.16e\r\n", x);
      return 2;
    }
  }

  /* basic integration step */
  while (1)
  {
    if (nstep > nmax)
    {
      if (fileout)
	fprintf (fileout, "Exit of dop853 at x = %.16e, more than nmax = %li are needed\r\n", x, nmax);
      xout = x;
      hout = h;
      return -2;
    }

    if (0.1 * fabs(h) <= fabs(x) * uround)
    {
      if (fileout)
	fprintf (fileout, "Exit of dop853 at x = %.16e, step size too small h = %.16e\r\n", x, h);
      xout = x;
      hout = h;
      return -3;
    }

    if ((x + 1.01*h - xend) * posneg > 0.0)
    {
      h = xend - x;
      last = 1;
    }

    nstep++;

    /* the twelve stages */
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * a21 * k1[i];
    fcn (n, x+c2*h, yy1, k2, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a31*k1[i] + a32*k2[i]);
    fcn (n, x+c3*h, yy1, k3, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a41*k1[i] + a43*k3[i]);
    fcn (n, x+c4*h, yy1, k4, p, fr, norbits, nbody, args);
    for (i = 0; i <n; i++)
      yy1[i] = y[i] + h * (a51*k1[i] + a53*k3[i] + a54*k4[i]);
    fcn (n, x+c5*h, yy1, k5, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a61*k1[i] + a64*k4[i] + a65*k5[i]);
    fcn (n, x+c6*h, yy1, k6, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a71*k1[i] + a74*k4[i] + a75*k5[i] + a76*k6[i]);
    fcn (n, x+c7*h, yy1, k7, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a81*k1[i] + a84*k4[i] + a85*k5[i] + a86*k6[i] +
			  a87*k7[i]);
    fcn (n, x+c8*h, yy1, k8, p, fr, norbits, nbody, args);
    for (i = 0; i <n; i++)
      yy1[i] = y[i] + h * (a91*k1[i] + a94*k4[i] + a95*k5[i] + a96*k6[i] +
			  a97*k7[i] + a98*k8[i]);
    fcn (n, x+c9*h, yy1, k9, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a101*k1[i] + a104*k4[i] + a105*k5[i] + a106*k6[i] +
			  a107*k7[i] + a108*k8[i] + a109*k9[i]);
    fcn (n, x+c10*h, yy1, k10, p, fr, norbits, nbody, args);
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a111*k1[i] + a114*k4[i] + a115*k5[i] + a116*k6[i] +
			  a117*k7[i] + a118*k8[i] + a119*k9[i] + a1110*k10[i]);
    fcn (n, x+c11*h, yy1, k2, p, fr, norbits, nbody, args);
    xph = x + h;
    for (i = 0; i < n; i++)
      yy1[i] = y[i] + h * (a121*k1[i] + a124*k4[i] + a125*k5[i] + a126*k6[i] +
			  a127*k7[i] + a128*k8[i] + a129*k9[i] +
			  a1210*k10[i] + a1211*k2[i]);
    fcn (n, xph, yy1, k3, p, fr, norbits, nbody, args);
    nfcn += 11;
    for (i = 0; i < n; i++)
    {
      k4[i] = b1*k1[i] + b6*k6[i] + b7*k7[i] + b8*k8[i] + b9*k9[i] +
	      b10*k10[i] + b11*k2[i] + b12*k3[i];
      k5[i] = y[i] + h * k4[i];
    }

    /* error estimation */
    err = 0.0;
    err2 = 0.0;
    if (!itoler)
      for (i = 0; i < n; i++)
      {
	sk = atoli + rtoli * max_d (fabs(y[i]), fabs(k5[i]));
	erri = k4[i] - bhh1*k1[i] - bhh2*k9[i] - bhh3*k3[i];
	sqr = erri / sk;
	err2 += sqr*sqr;
	erri = er1*k1[i] + er6*k6[i] + er7*k7[i] + er8*k8[i] + er9*k9[i] +
	       er10 * k10[i] + er11*k2[i] + er12*k3[i];
	sqr = erri / sk;
	err += sqr*sqr;
      }
    else
      for (i = 0; i < n; i++)
      {
	sk = atoler[i] + rtoler[i] * max_d (fabs(y[i]), fabs(k5[i]));
	erri = k4[i] - bhh1*k1[i] - bhh2*k9[i] - bhh3*k3[i];
	sqr = erri / sk;
	err2 += sqr*sqr;
	erri = er1*k1[i] + er6*k6[i] + er7*k7[i] + er8*k8[i] + er9*k9[i] +
	       er10 * k10[i] + er11*k2[i] + er12*k3[i];
	sqr = erri / sk;
	err += sqr*sqr;
      }
    deno = err + 0.01 * err2;
    if (deno <= 0.0)
      deno = 1.0;
    err = fabs(h) * err * sqrt (1.0 / (deno*(double)n));

    /* computation of hnew */
    fac11 = pow (err, expo1);
    /* Lund-stabilization */
    fac = fac11 / pow(facold,beta);
    /* we require fac1 <= hnew/h <= fac2 */
    fac = max_d (facc2, min_d (facc1, fac/safe));
    hnew = h / fac;

    if (err <= 1.0)
    {
      /* step accepted */

      facold = max_d (err, 1.0E-4);
      naccpt++;
      fcn (n, xph, k5, k4, p, fr, norbits, nbody, args);
      nfcn++;

      /* stiffness detection */
      if (!(naccpt % nstiff) || (iasti > 0))
      {
	stnum = 0.0;
	stden = 0.0;
	for (i = 0; i < n; i++)
	{
	  sqr = k4[i] - k3[i];
	  stnum += sqr*sqr;
	  sqr = k5[i] - yy1[i];
	  stden += sqr*sqr;
	}
	if (stden > 0.0)
	  hlamb = h * sqrt (stnum / stden);
	if (hlamb > 6.1)
	{
	  nonsti = 0;
	  iasti++;
	  if (iasti == 15)
	    if (fileout)
	      fprintf (fileout, "The problem seems to become stiff at x = %.16e\r\n", x);
	    else
	    {
	      xout = x;
	      hout = h;
	      return -4;
	    }
	}
	else
	{
	  nonsti++;
	  if (nonsti == 6)
	    iasti = 0;
	}
      }

      /* final preparation for dense output */
      if (iout == 2)
      {
	/* save the first function evaluations */
	if (nrds == n)
	  for (i = 0; i < n; i++)
	  {
	    rcont1[i] = y[i];
	    ydiff = k5[i] - y[i];
	    rcont2[i] = ydiff;
	    bspl = h * k1[i] - ydiff;
	    rcont3[i] = bspl;
	    rcont4[i] = ydiff - h*k4[i] - bspl;
	    rcont5[i] = d41*k1[i] + d46*k6[i] + d47*k7[i] + d48*k8[i] +
			d49*k9[i] + d410*k10[i] + d411*k2[i] + d412*k3[i];
	    rcont6[i] = d51*k1[i] + d56*k6[i] + d57*k7[i] + d58*k8[i] +
			d59*k9[i] + d510*k10[i] + d511*k2[i] + d512*k3[i];
	    rcont7[i] = d61*k1[i] + d66*k6[i] + d67*k7[i] + d68*k8[i] +
			d69*k9[i] + d610*k10[i] + d611*k2[i] + d612*k3[i];
	    rcont8[i] = d71*k1[i] + d76*k6[i] + d77*k7[i] + d78*k8[i] +
			d79*k9[i] + d710*k10[i] + d711*k2[i] + d712*k3[i];
	  }
	else
	  for (j = 0; j < nrds; j++)
	  {
	    i = icont[j];
	    rcont1[j] = y[i];
	    ydiff = k5[i] - y[i];
	    rcont2[j] = ydiff;
	    bspl = h * k1[i] - ydiff;
	    rcont3[j] = bspl;
	    rcont4[j] = ydiff - h*k4[i] - bspl;
	    rcont5[j] = d41*k1[i] + d46*k6[i] + d47*k7[i] + d48*k8[i] +
			d49*k9[i] + d410*k10[i] + d411*k2[i] + d412*k3[i];
	    rcont6[j] = d51*k1[i] + d56*k6[i] + d57*k7[i] + d58*k8[i] +
			d59*k9[i] + d510*k10[i] + d511*k2[i] + d512*k3[i];
	    rcont7[j] = d61*k1[i] + d66*k6[i] + d67*k7[i] + d68*k8[i] +
			d69*k9[i] + d610*k10[i] + d611*k2[i] + d612*k3[i];
	    rcont8[j] = d71*k1[i] + d76*k6[i] + d77*k7[i] + d78*k8[i] +
			d79*k9[i] + d710*k10[i] + d711*k2[i] + d712*k3[i];
	  }

	/* the next three function evaluations */
	for (i = 0; i < n; i++)
	  yy1[i] = y[i] + h * (a141*k1[i] + a147*k7[i] + a148*k8[i] +
			      a149*k9[i] + a1410*k10[i] + a1411*k2[i] +
			      a1412*k3[i] + a1413*k4[i]);
	fcn (n, x+c14*h, yy1, k10, p, fr, norbits, nbody, args);
	for (i = 0; i < n; i++)
	  yy1[i] = y[i] + h * (a151*k1[i] + a156*k6[i] + a157*k7[i] + a158*k8[i] +
			      a1511*k2[i] + a1512*k3[i] + a1513*k4[i] +
			      a1514*k10[i]);
	fcn (n, x+c15*h, yy1, k2, p, fr, norbits, nbody, args);
	for (i = 0; i < n; i++)
	  yy1[i] = y[i] + h * (a161*k1[i] + a166*k6[i] + a167*k7[i] + a168*k8[i] +
			      a169*k9[i] + a1613*k4[i] + a1614*k10[i] +
			      a1615*k2[i]);
	fcn (n, x+c16*h, yy1, k3, p, fr, norbits, nbody, args);
	nfcn += 3;

	/* final preparation */
	if (nrds == n)
	  for (i = 0; i < n; i++)
	  {
	    rcont5[i] = h * (rcont5[i] + d413*k4[i] + d414*k10[i] +
			     d415*k2[i] + d416*k3[i]);
	    rcont6[i] = h * (rcont6[i] + d513*k4[i] + d514*k10[i] +
			     d515*k2[i] + d516*k3[i]);
	    rcont7[i] = h * (rcont7[i] + d613*k4[i] + d614*k10[i] +
			     d615*k2[i] + d616*k3[i]);
	    rcont8[i] = h * (rcont8[i] + d713*k4[i] + d714*k10[i] +
			     d715*k2[i] + d716*k3[i]);
	  }
        else
	  for (j = 0; j < nrds; j++)
	  {
	    i = icont[j];
	    rcont5[j] = h * (rcont5[j] + d413*k4[i] + d414*k10[i] +
			     d415*k2[i] + d416*k3[i]);
	    rcont6[j] = h * (rcont6[j] + d513*k4[i] + d514*k10[i] +
			     d515*k2[i] + d516*k3[i]);
	    rcont7[j] = h * (rcont7[j] + d613*k4[i] + d614*k10[i] +
			     d615*k2[i] + d616*k3[i]);
	    rcont8[j] = h * (rcont8[j] + d713*k4[i] + d714*k10[i] +
			     d715*k2[i] + d716*k3[i]);
	  }
      }

      memcpy (k1, k4, n * sizeof(double));
      memcpy (y, k5, n * sizeof(double));
      xold = x;
      x = xph;

      if (iout)
      {
	hout = h;
	xout = x;
	solout (naccpt+1, xold, x, y, n, &irtrn);
	if (irtrn < 0)
	{
	  if (fileout)
	    fprintf (fileout, "Exit of dop853 at x = %.16e\r\n", x);
	  return 2;
	}
      }

      /* normal exit */
      if (last)
      {
	hout=hnew;
	xout = x;
	return 1;
      }

      if (fabs(hnew) > hmax)
	hnew = posneg * hmax;
      if (reject)
	hnew = posneg * min_d (fabs(hnew), fabs(h));

      reject = 0;
    }
    else
    {
      /* step rejected */
      hnew = h / min_d (facc1, fac11/safe);
      reject = 1;
      if (naccpt >= 1)
	nrejct=nrejct + 1;
      last = 0;
    }

    h = hnew;
  }

} /* dopcor */


/* front-end */
int dop853
 (unsigned n, FcnEqDiff fcn, CPotential *p, CFrameType *fr, unsigned norbits, unsigned nbody, void *args,
  double x, double* y, double xend, double* rtoler,
  double* atoler, int itoler, SolTrait solout, int iout, FILE* fileout, double uround,
  double safe, double fac1, double fac2, double beta, double hmax, double h,
  long nmax, int meth, long nstiff, unsigned nrdens, unsigned* icont, unsigned licont)
{
  int       arret, idid;
  unsigned  i;

  /* initialisations */
  nfcn = nstep = naccpt = nrejct = arret = 0;
  rcont1 = rcont2 = rcont3 = rcont4 = rcont5 = rcont6 = rcont7 = rcont8 = NULL;
  indir = NULL;

  /* n, the dimension of the system */
  if (n == UINT_MAX)
  {
    if (fileout)
      fprintf (fileout, "System too big, max. n = %u\r\n", UINT_MAX-1);
    arret = 1;
  }

  /* nmax, the maximal number of steps */
  if (!nmax)
    nmax = 100000;
  else if (nmax <= 0)
  {
    if (fileout)
      fprintf (fileout, "Wrong input, nmax = %li\r\n", nmax);
    arret = 1;
  }

  /* meth, coefficients of the method */
  if (!meth)
    meth = 1;
  else if ((meth <= 0) || (meth >= 2))
  {
    if (fileout)
      fprintf (fileout, "Curious input, meth = %i\r\n", meth);
    arret = 1;
  }

  /* nstiff, parameter for stiffness detection */
  if (!nstiff)
    nstiff = 1000;
  else if (nstiff < 0)
    nstiff = nmax + 10;

  /* iout, switch for calling solout */
  if ((iout < 0) || (iout > 2))
  {
    if (fileout)
      fprintf (fileout, "Wrong input, iout = %i\r\n", iout);
    arret = 1;
  }

  /* nrdens, number of dense output components */
  if (nrdens > n)
  {
    if (fileout)
      fprintf (fileout, "Curious input, nrdens = %u\r\n", nrdens);
    arret = 1;
  }
  else if (nrdens)
  {
    /* is there enough memory to allocate rcont12345678&indir ? */
    rcont1 = (double*) malloc (nrdens*sizeof(double));
    rcont2 = (double*) malloc (nrdens*sizeof(double));
    rcont3 = (double*) malloc (nrdens*sizeof(double));
    rcont4 = (double*) malloc (nrdens*sizeof(double));
    rcont5 = (double*) malloc (nrdens*sizeof(double));
    rcont6 = (double*) malloc (nrdens*sizeof(double));
    rcont7 = (double*) malloc (nrdens*sizeof(double));
    rcont8 = (double*) malloc (nrdens*sizeof(double));
    if (nrdens < n)
      indir = (unsigned*) malloc (n*sizeof(unsigned));

    if (!rcont1 || !rcont2 || !rcont3 || !rcont4 || !rcont5 ||
	!rcont6 || !rcont7 || !rcont8 || (!indir && (nrdens < n)))
    {
      if (fileout)
	fprintf (fileout, "Not enough free memory for rcont12345678&indir\r\n");
      arret = 1;
    }

    /* control of length of icont */
    if (nrdens == n)
    {
      if (icont && fileout)
	fprintf (fileout, "Warning : when nrdens = n there is no need allocating memory for icont\r\n");
      nrds = n;
    }
    else if (licont < nrdens)
    {
      if (fileout)
	fprintf (fileout, "Insufficient storage for icont, min. licont = %u\r\n", nrdens);
      arret = 1;
    }
    else
    {
      if ((iout < 2) && fileout)
	fprintf (fileout, "Warning : put iout = 2 for dense output\r\n");
      nrds = nrdens;
      for (i = 0; i < n; i++)
	indir[i] = UINT_MAX;
      for (i = 0; i < nrdens; i++)
	indir[icont[i]] = i;
    }
  }

  /* uround, smallest number satisfying 1.0+uround > 1.0 */
  if (uround == 0.0)
    uround = 2.3E-16;
  else if ((uround <= 1.0E-35) || (uround >= 1.0))
  {
    if (fileout)
      fprintf (fileout, "Which machine do you have ? Your uround was : %.16e\r\n", uround);
    arret = 1;
  }

  /* safety factor */
  if (safe == 0.0)
    safe = 0.9;
  else if ((safe >= 1.0) || (safe <= 1.0E-4))
  {
    if (fileout)
      fprintf (fileout, "Curious input for safety factor, safe = %.16e\r\n", safe);
    arret = 1;
  }

  /* fac1, fac2, parameters for step size selection */
  if (fac1 == 0.0)
    fac1 = 0.333;
  if (fac2 == 0.0)
    fac2 = 6.0;

  /* beta for step control stabilization */
  if (beta == 0.0)
    beta = 0.0;
  else if (beta < 0.0)
    beta = 0.0;
  else if (beta > 0.2)
  {
    if (fileout)
      fprintf (fileout, "Curious input for beta : beta = %.16e\r\n", beta);
    arret = 1;
  }

  /* maximal step size */
  if (hmax == 0.0)
    hmax = xend - x;

  /* is there enough free memory for the method ? */
  yy1 = (double*) malloc (n*sizeof(double));
  k1 = (double*) malloc (n*sizeof(double));
  k2 = (double*) malloc (n*sizeof(double));
  k3 = (double*) malloc (n*sizeof(double));
  k4 = (double*) malloc (n*sizeof(double));
  k5 = (double*) malloc (n*sizeof(double));
  k6 = (double*) malloc (n*sizeof(double));
  k7 = (double*) malloc (n*sizeof(double));
  k8 = (double*) malloc (n*sizeof(double));
  k9 = (double*) malloc (n*sizeof(double));
  k10 = (double*) malloc (n*sizeof(double));

  if (!yy1 || !k1 || !k2 || !k3 || !k4 || !k5 || !k6 || !k7 || !k8 || !k9 || !k10)
  {
    if (fileout)
      fprintf (fileout, "Not enough free memory for the method\r\n");
    arret = 1;
  }

  /* when a failure has occured, we return -1 */
  if (arret)
  {
    if (k10)
      free (k10);
    if (k9)
      free (k9);
    if (k8)
      free (k8);
    if (k7)
      free (k7);
    if (k6)
      free (k6);
    if (k5)
      free (k5);
    if (k4)
      free (k4);
    if (k3)
      free (k3);
    if (k2)
      free (k2);
    if (k1)
      free (k1);
    if (yy1)
      free (yy1);
    if (indir)
      free (indir);
    if (rcont8)
      free (rcont8);
    if (rcont7)
      free (rcont7);
    if (rcont6)
      free (rcont6);
    if (rcont5)
      free (rcont5);
    if (rcont4)
      free (rcont4);
    if (rcont3)
      free (rcont3);
    if (rcont2)
      free (rcont2);
    if (rcont1)
      free (rcont1);

    return -1;
  }
  else
  {
    idid = dopcor (n, fcn, p, fr, norbits, nbody, args, x, y, xend, hmax, h, rtoler, atoler, itoler, fileout,
		   solout, iout, nmax, uround, meth, nstiff, safe, beta, fac1, fac2, icont);
    free (k10);
    free (k9);
    free (k8);
    free (k7);
    free (k6);
    free (k5);    /* reverse order freeing too increase chances */
    free (k4);    /* of efficient dynamic memory managing       */
    free (k3);
    free (k2);
    free (k1);
    free (yy1);
    if (indir)
      free (indir);
    if (rcont8)
    {
      free (rcont8);
      free (rcont7);
      free (rcont6);
      free (rcont5);
      free (rcont4);
      free (rcont3);
      free (rcont2);
      free (rcont1);
    }

    return idid;
  }

} /* dop853 */


/* dense output function */
double contd8 (unsigned ii, double x)
{
  unsigned i, j;
  double   s, s1;

  i = UINT_MAX;

  if (!indir)
    i = ii;
  else
    i = indir[ii];

  if (i == UINT_MAX)
  {
    printf ("No dense output available for %uth component", ii);
    return 0.0;
  }

  s = (x - xold) / hout;
  s1 = 1.0 - s;

  return rcont1[i]+s*(rcont2[i]+s1*(rcont3[i]+s*(rcont4[i]+s1*(rcont5[i]+
	 s*(rcont6[i]+s1*(rcont7[i]+s*rcont8[i]))))));

} /* contd8 */

/* ADDED BY APW */
void Fwrapper (unsigned full_ndim, double t, double *w, double *f,
               CPotential *p, CFrameType *fr, unsigned norbits, unsigned na,
               void *args) {
    /* na can be ignored here - used in nbody wrapper below */

    int i;
    unsigned ndim = full_ndim / norbits; // phase-space dimensionality

    for (i=0; i < norbits; i++) {
        // call gradient function
        hamiltonian_gradient(p, fr, t, &w[i*ndim], &f[i*ndim]);
    }
}

void Fwrapper_direct_nbody (unsigned full_ndim, double t, double *w, double *f,
                            CPotential *p, CFrameType *fr,
                            unsigned norbits, unsigned nbody,
                            void *args) {
    /* Here, the extra args are actually the array of CPotential objects that
       represent the potentials of the individual particles.
    */
    CPotential **pots = (CPotential **)args;

    // Note: only really works with a static frame! This should be enforced
    unsigned ps_ndim = 2 * p->n_dim;  // phase-space dimensionality

    for (int i=0; i < norbits; i++)
        hamiltonian_gradient(p, fr, t, &w[i * ps_ndim], &f[i * ps_ndim]);

    if (nbody > 0)
        c_nbody_acceleration(pots, t, w, norbits, nbody, p->n_dim, f);
}

/* Needed for Lyapunov */
double six_norm (double *x) {
    double norm = 0;
    for (int i=0; i<6; i++) {
        norm = norm + x[i]*x[i];
    }
    return sqrt(norm);
}
</file>

<file path="gala/integrate/cyintegrators/dopri/dop853.h">
/*      DOP853
	------

********************************************
                  WARNING
********************************************
This code has been modified! This is *not*
the original! I have added some extra
functionality to play nice with Python code.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This code computes the numerical solution of a system of first order ordinary
differential equations y'=f(x,y). It uses an explicit Runge-Kutta method of
order 8(5,3) due to Dormand & Prince with step size control and dense output.

Authors : E. Hairer & G. Wanner
	  Universite de Geneve, dept. de Mathematiques
	  CH-1211 GENEVE 4, SWITZERLAND
	  E-mail : HAIRER@DIVSUN.UNIGE.CH, WANNER@DIVSUN.UNIGE.CH

The code is described in : E. Hairer, S.P. Norsett and G. Wanner, Solving
ordinary differential equations I, nonstiff problems, 2nd edition,
Springer Series in Computational Mathematics, Springer-Verlag (1993).

Version of Mai 2, 1994.

Remarks about the C version : this version allocates memory by itself, the
iwork array (among the initial FORTRAN parameters) has been splitted into
independant initial parameters, the statistical variables and last step size
and x have been encapsulated in the module and are now accessible through
dedicated functions; the variable names have been kept to maintain a kind
of reading compatibility between the C and FORTRAN codes; adaptation made by
J.Colinge (COLINGE@DIVSUN.UNIGE.CH).



INPUT PARAMETERS
----------------

n        Dimension of the system (n < UINT_MAX).

fcn      A pointer the the function definig the differential equation, this
	 function must have the following prototype

	   void fcn (unsigned n, double x, double *y, double *f)

	 where the array f will be filled with the function result.

x        Initial x value.

*y       Initial y values (double y[n]).

xend     Final x value (xend-x may be positive or negative).

*rtoler  Relative and absolute error tolerances. They can be both scalars or
*atoler  vectors of length n (in the scalar case pass the addresses of
	 variables where you have placed the tolerance values).

itoler   Switch for atoler and rtoler :
	   itoler=0 : both atoler and rtoler are scalars, the code keeps
		      roughly the local error of y[i] below
		      rtoler*abs(y[i])+atoler.
	   itoler=1 : both rtoler and atoler are vectors, the code keeps
		      the local error of y[i] below
		      rtoler[i]*abs(y[i])+atoler[i].

solout   A pointer to the output function called during integration.
	 If iout >= 1, it is called after every successful step. If iout = 0,
	 pass a pointer equal to NULL. solout must must have the following
	 prototype

	   solout (long nr, double xold, double x, double* y, unsigned n, int* irtrn)

	 where y is the solution the at nr-th grid point x, xold is the
	 previous grid point and irtrn serves to interrupt the integration
	 (if set to a negative value).

	 Continuous output : during the calls to solout, a continuous solution
	 for the interval (xold,x) is available through the function

	   contd8(i,s)

	 which provides an approximation to the i-th component of the solution
	 at the point s (s must lie in the interval (xold,x)).

iout     Switch for calling solout :
	   iout=0 : no call,
	   iout=1 : solout only used for output,
	   iout=2 : dense output is performed in solout (in this case nrdens
		    must be greater than 0).

fileout  A pointer to the stream used for messages, if you do not want any
	 message, just pass NULL.

icont    An array containing the indexes of components for which dense
	 output is required. If no dense output is required, pass NULL.

licont   The number of cells in icont.


Sophisticated setting of parameters
-----------------------------------

	 Several parameters have a default value (if set to 0) but, to better
	 adapt the code to your problem, you can specify particular initial
	 values.

uround   The rounding unit, default 2.3E-16 (this default value can be
	 replaced in the code by DBL_EPSILON providing float.h defines it
	 in your system).

safe     Safety factor in the step size prediction, default 0.9.

fac1     Parameters for step size selection; the new step size is chosen
fac2     subject to the restriction  fac1 <= hnew/hold <= fac2.
	 Default values are fac1=0.333 and fac2=6.0.

beta     The "beta" for stabilized step size control (see section IV.2 of our
	 book). Larger values for beta ( <= 0.1 ) make the step size control
	 more stable. Negative initial value provoke beta=0; default beta=0.

hmax     Maximal step size, default xend-x.

h        Initial step size, default is a guess computed by the function hinit.

nmax     Maximal number of allowed steps, default 100000.

meth     Switch for the choice of the method coefficients; at the moment the
	 only possibility and default value are 1.

nstiff   Test for stiffness is activated when the current step number is a
	 multiple of nstiff. A negative value means no test and the default
	 is 1000.

nrdens   Number of components for which dense outpout is required, default 0.
	 For 0 < nrdens < n, the components have to be specified in icont[0],
	 icont[1], ... icont[nrdens-1]. Note that if nrdens=0 or nrdens=n, no
	 icont is needed, pass NULL.


Memory requirements
-------------------

	 The function dop853 allocates dynamically 11*n doubles for the method
	 stages, 8*nrdens doubles for the interpolation if dense output is
	 performed and n unsigned if 0 < nrdens < n.


OUTPUT PARAMETERS
-----------------

y       numerical solution at x=xRead() (see below).

dopri5 returns the following values

	 1 : computation successful,
	 2 : computation successful interrupted by solout,
	-1 : input is not consistent,
	-2 : larger nmax is needed,
	-3 : step size becomes too small,
	-4 : the problem is probably stff (interrupted).


Several functions provide access to different values :

xRead   x value for which the solution has been computed (x=xend after
	successful return).

hRead   Predicted step size of the last accepted step (useful for a subsequent
	call to dop853).

nstepRead   Number of used steps.
naccptRead  Number of accepted steps.
nrejctRead  Number of rejected steps.
nfcnRead    Number of function calls.


*/


#include <stdio.h>
#include <limits.h>
#include "potential/src/cpotential.h"
#include "frame/src/cframe.h"
#include "hamiltonian/src/chamiltonian.h"

typedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                          CPotential *p, CFrameType *fr, unsigned norbits,
                          unsigned nbody, void *args);

typedef void (*SolTrait)(long nr, double xold, double x, double* y, unsigned n, int* irtrn);

extern int dop853
 (unsigned n,      /* dimension of the system <= UINT_MAX-1*/
  FcnEqDiff fcn,   /* function computing the value of f(x,y) */
  CPotential *p,   /* ADDED BY ADRN: parameters for gradient function */
  CFrameType *fr,       /* ADDED BY ADRN: reference frame */
  unsigned n_orbits, /* ADDED BY ADRN: total number of orbits, i.e. bodies */
  unsigned n_body, /* ADDED BY ADRN: number of nbody particles */
  void *args,      /* ADDED BY ADRN: a container for other stuff */
  double x,        /* initial x-value */
  double* y,       /* initial values for y */
  double xend,     /* final x-value (xend-x may be positive or negative) */
  double* rtoler,  /* relative error tolerance */
  double* atoler,  /* absolute error tolerance */
  int itoler,      /* switch for rtoler and atoler */
  SolTrait solout, /* function providing the numerical solution during integration */
  int iout,        /* switch for calling solout */
  FILE* fileout,   /* messages stream */
  double uround,   /* rounding unit */
  double safe,     /* safety factor */
  double fac1,     /* parameters for step size selection */
  double fac2,
  double beta,     /* for stabilized step size control */
  double hmax,     /* maximal step size */
  double h,        /* initial step size */
  long nmax,       /* maximal number of allowed steps */
  int meth,        /* switch for the choice of the coefficients */
  long nstiff,     /* test for stiffness */
  unsigned nrdens, /* number of components for which dense outpout is required */
  unsigned* icont, /* indexes of components for which dense output is required, >= nrdens */
  unsigned licont  /* declared length of icon */
 );

extern double contd8
 (unsigned ii,     /* index of desired component */
  double x         /* approximation at x */
 );

extern long nfcnRead (void);   /* encapsulation of statistical data */
extern long nstepRead (void);
extern long naccptRead (void);
extern long nrejctRead (void);
extern double hRead (void);
extern double xRead (void);

/* ADDED BY APW */
extern void Fwrapper (unsigned ndim, double t, double *w, double *f,
                      CPotential *p, CFrameType *fr,
                      unsigned norbits, unsigned nbody, void *args);
extern void Fwrapper_direct_nbody(unsigned ndim, double t, double *w, double *f,
                                  CPotential *p, CFrameType *fr,
                                  unsigned norbits, unsigned nbody,
                                  void *args); // here args becomes the particle potentials
extern double six_norm (double *x); /* Needed for Lyapunov */
</file>

<file path="gala/integrate/cyintegrators/dopri/licence.txt">
Copyright (c) 2004, Ernst Hairer

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are 
met:

- Redistributions of source code must retain the above copyright 
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright 
notice, this list of conditions and the following disclaimer in the 
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS 
IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</file>

<file path="gala/integrate/cyintegrators/__init__.py">
from .dop853 import dop853_integrate_hamiltonian
from .leapfrog import leapfrog_integrate_hamiltonian
from .ruth4 import ruth4_integrate_hamiltonian
</file>

<file path="gala/integrate/cyintegrators/dop853.pxd">
# cython: language_level=3

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "dopri/dop853.h":
    ctypedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                              CPotential *p, CFrameType *fr, unsigned norbits,
                              unsigned nbody, void *args) nogil

cdef void dop853_step(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                      double *w, double t1, double t2, double dt0,
                      int ndim, int norbits, int nbody, void *args,
                      double atol, double rtol, int nmax)  except *

cdef dop853_helper(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                   double[:,::1] w0, double[::1] t,
                   int ndim, int norbits, int nbody, void *args, int ntimes,
                   double atol, double rtol, int nmax, int progress)

cdef dop853_helper_save_all(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                            double[:,::1] w0, double[::1] t,
                            int ndim, int norbits, int nbody, void *args,
                            int ntimes, double atol, double rtol, int nmax,
                            int progress)

# cpdef dop853_integrate_hamiltonian(hamiltonian, double[:,::1] w0, double[::1] t,
#                                    double atol=?, double rtol=?, int nmax=?)
</file>

<file path="gala/integrate/cyintegrators/dop853.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" DOP853 integration in Cython. """

import sys
from libc.stdio cimport *
from libc.stdlib cimport malloc, free
from libc.string cimport strcpy

# Third-party
import numpy as np
cimport numpy as np
np.import_array()

from cpython.exc cimport PyErr_CheckSignals
from ...potential.potential.cpotential cimport CPotentialWrapper
from ...potential.frame.cframe cimport CFrameWrapper

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

    void c_gradient(CPotential *p, double t, double *q, double *grad) nogil

cdef extern from "dopri/dop853.h":
    ctypedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f,
                              CPotential *p, CFrameType *fr, unsigned norbits,
                              unsigned nbody, void *args) nogil
    ctypedef void (*SolTrait)(long nr, double xold, double x, double* y,
                              unsigned n, int* irtrn)

    # See dop853.h for full description of all input parameters
    int dop853 (unsigned n, FcnEqDiff fn,
                CPotential *p, CFrameType *fr, unsigned n_orbits, unsigned nbody,
                void *args,
                double x, double* y, double xend,
                double* rtoler, double* atoler, int itoler, SolTrait solout,
                int iout, FILE* fileout, double uround, double safe, double fac1,
                double fac2, double beta, double hmax, double h, long nmax, int meth,
                long nstiff, unsigned nrdens, unsigned* icont, unsigned licont)

    void Fwrapper (unsigned ndim, double t, double *w, double *f,
                   CPotential *p, CFrameType *fr, unsigned norbits)

cdef extern from "stdio.h":
    ctypedef struct FILE
    FILE *stdout


cdef void dop853_step(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                      double *w, double t1, double t2, double dt0,
                      int ndim, int norbits, int nbody, void *args,
                      double atol, double rtol, int nmax) except *:

    cdef:
        int res
        SolTrait solout = NULL

    res = dop853(ndim*norbits, F,
                 cp, cf, norbits, nbody, args, t1, w, t2,
                 &rtol, &atol, 0, solout, 0,
                 NULL, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, dt0, nmax, 0, 1, 0, NULL, 0);

    if res == -1:
        raise RuntimeError("Input is not consistent.")
    elif res == -2:
        raise RuntimeError("Larger nmax is needed.")
    elif res == -3:
        raise RuntimeError("Step size becomes too small.")
    elif res == -4:
        raise RuntimeError("The problem is probably stiff (interrupted).")

cdef dop853_helper(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                   double[:, ::1] w0, double[::1] t,
                   int ndim, int norbits, int nbody, void *args, int ntimes,
                   double atol, double rtol, int nmax, int progress):

    cdef:
        int i, j
        double dt0 = t[1] - t[0]

        # store initial conditions
        double[:, ::1] w = w0.copy()

        int prog_out = ntimes // 100

    if progress == 1:
        for j in range(1, ntimes, 1):
            dop853_step(cp, cf, F,
                        &w[0, 0], t[j-1], t[j], dt0,
                        ndim, norbits, nbody, args,
                        atol, rtol, nmax)

            PyErr_CheckSignals()

            if j % prog_out == 0:
                sys.stdout.write('\r')
                sys.stdout.write(
                    f"Integrating orbits: {100 * j / ntimes: 3.0f}%")
                sys.stdout.flush()

        sys.stdout.write('\r')
        sys.stdout.write(f"Integrating orbits: {100: 3.0f}%")
        sys.stdout.flush()

    else:
        for j in range(1, ntimes, 1):
            dop853_step(cp, cf, F,
                        &w[0, 0], t[j-1], t[j], dt0,
                        ndim, norbits, nbody, args,
                        atol, rtol, nmax)

            PyErr_CheckSignals()

    return np.asarray(w)

cdef dop853_helper_save_all(CPotential *cp, CFrameType *cf, FcnEqDiff F,
                            double[:, ::1] w0, double[::1] t,
                            int ndim, int norbits, int nbody, void *args,
                            int ntimes, double atol, double rtol, int nmax,
                            int progress):

    cdef:
        int i, j, k
        double dt0 = t[1] - t[0]

        double[::1] w = np.empty(ndim*norbits)
        double[:, :, ::1] all_w = np.empty((ntimes, norbits, ndim))

        int prog_out = ntimes // 100

    # store initial conditions
    for i in range(norbits):
        for k in range(ndim):
            w[i*ndim + k] = w0[i, k]
            all_w[0, i, k] = w0[i, k]

    if progress == 1:
        for j in range(1, ntimes, 1):
            dop853_step(cp, cf, F,
                        &w[0], t[j-1], t[j], dt0, ndim, norbits, nbody, args,
                        atol, rtol, nmax)

            for k in range(ndim):
                for i in range(norbits):
                    all_w[j, i, k] = w[i*ndim + k]

            PyErr_CheckSignals()

            if j % prog_out == 0:
                sys.stdout.write('\r')
                sys.stdout.write(
                    f"Integrating orbits: {100 * j / ntimes: 3.0f}%")
                sys.stdout.flush()

        sys.stdout.write('\r')
        sys.stdout.write(f"Integrating orbits: {100: 3.0f}%")
        sys.stdout.flush()

    else:
        for j in range(1, ntimes, 1):
            dop853_step(cp, cf, F,
                        &w[0], t[j-1], t[j], dt0, ndim, norbits, nbody, args,
                        atol, rtol, nmax)

            for k in range(ndim):
                for i in range(norbits):
                    all_w[j, i, k] = w[i*ndim + k]

            PyErr_CheckSignals()

    return np.asarray(all_w)

cpdef dop853_integrate_hamiltonian(hamiltonian, double[:, ::1] w0, double[::1] t,
                                   double atol=1E-10, double rtol=1E-10, int nmax=0, progress=False, int store_all=1):
    """
    CAUTION: Interpretation of axes is different here! We need the
    arrays to be C ordered and easy to iterate over, so here the
    axes are (norbits, ndim).
    """

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian object does not support C-level access.")

    cdef:
        int i, j, k
        unsigned norbits = w0.shape[0]
        unsigned ndim = w0.shape[1]
        void *args

        # define full array of times
        int ntimes = len(t)

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CFrameType cf = (<CFrameWrapper>(hamiltonian.frame.c_instance)).cframe

    # 0 below is for nbody - we ignore that in this test particle integration
    if store_all:
        all_w = dop853_helper_save_all(&cp, &cf, <FcnEqDiff> Fwrapper,
                                    w0, t,
                                    ndim, norbits, 0, args, ntimes,
                                    atol, rtol, nmax, int(progress))

        return np.asarray(t), np.asarray(all_w)

    else:
        w = dop853_helper(
            &cp, &cf, <FcnEqDiff> Fwrapper,
            w0, t,
            ndim, norbits, 0, args, ntimes,
            atol, rtol, nmax, int(progress))

        return np.asarray(t[-1:]), np.asarray(w)
</file>

<file path="gala/integrate/cyintegrators/leapfrog.pxd">
# cython: language_level=3

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "nbody_helper.h":
    const int MAX_NBODY

cdef void c_init_velocity(CPotential *p, int ndim, double t, double dt,
                          double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad) nogil

cdef void c_leapfrog_step(CPotential *p, int ndim, double t, double dt,
                          double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad) nogil
</file>

<file path="gala/integrate/cyintegrators/leapfrog.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" Leapfrog integration in Cython. """

# Third-party
import numpy as np
cimport numpy as np
np.import_array()

# Project
from ...potential.potential.cpotential cimport CPotentialWrapper
from ...potential.frame import StaticFrame
from ...potential import NullPotential

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "potential/src/cpotential.h":
    void c_gradient(CPotential *p, double t, double *q, double *grad) nogil
    void c_nbody_gradient_symplectic(
        CPotential **pots, double t, double *q,
        double *nbody_q, int nbody, int nbody_i,
        int ndim, double *grad
    ) nogil


cdef void c_init_velocity(CPotential *p, int half_ndim, double t, double dt,
                          double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad) nogil:
    cdef int k

    c_gradient(p, t, x_jm1, grad)

    for k in range(half_ndim):
        v_jm1_2[k] = v_jm1[k] - grad[k] * dt/2.  # acceleration is minus gradient

cdef void c_leapfrog_step(CPotential *p, int half_ndim, double t, double dt,
                          double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad) nogil:
    cdef int k

    # full step the positions
    for k in range(half_ndim):
        x_jm1[k] = x_jm1[k] + v_jm1_2[k] * dt

    c_gradient(p, t, x_jm1, grad)  # compute gradient at new position

    # step velocity forward by half step, aligned w/ position, then
    #   finish the full step to leapfrog over position
    for k in range(half_ndim):
        v_jm1[k] = v_jm1_2[k] - grad[k] * dt/2.
        v_jm1_2[k] = v_jm1_2[k] - grad[k] * dt

cpdef leapfrog_integrate_hamiltonian(hamiltonian, double [:, ::1] w0, double[::1] t,
                                     int store_all=1):
    """
    CAUTION: Interpretation of axes is different here! We need the
    arrays to be C ordered and easy to iterate over, so here the
    axes are (norbits, ndim).
    """

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian object does not support C-level access.")

    if not isinstance(hamiltonian.frame, StaticFrame):
        raise TypeError(
            "Leapfrog integration is currently only supported for StaticFrame, "
            f"not {hamiltonian.frame.__class__.__name__}"
        )

    cdef:
        # temporary scalars
        int i, j, k
        int n = w0.shape[0]
        int ndim = w0.shape[1]
        int half_ndim = ndim // 2

        int ntimes = len(t)
        double dt = t[1]-t[0]

        # temporary array containers
        double[::1] grad = np.zeros(half_ndim)
        double[:, ::1] v_jm1_2 = np.zeros((n, half_ndim))

        # return arrays
        double[:, :, ::1] all_w
        double[:, ::1] tmp_w = np.zeros((n, ndim))

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential

    if store_all:
        all_w = np.zeros((ntimes, n, ndim))

        # save initial conditions
        all_w[0, :, :] = w0.copy()

    tmp_w = w0.copy()

    with nogil:
        # first initialize the velocities so they are evolved by a
        #   half step relative to the positions
        for i in range(n):
            c_init_velocity(&cp, half_ndim, t[0], dt,
                            &tmp_w[i, 0], &tmp_w[i, half_ndim],
                            &v_jm1_2[i, 0], &grad[0])

        for j in range(1, ntimes, 1):
            for i in range(n):
                for k in range(half_ndim):
                    grad[k] = 0.

                c_leapfrog_step(&cp, half_ndim, t[j], dt,
                                &tmp_w[i, 0], &tmp_w[i, half_ndim],
                                &v_jm1_2[i, 0],
                                &grad[0])

                if store_all:
                    for k in range(ndim):
                        all_w[j, i, k] = tmp_w[i, k]

    if store_all:
        return np.asarray(t), np.asarray(all_w)
    else:
        return np.asarray(t[-1:]), np.asarray(tmp_w)

# -------------------------------------------------------------------------------------
# N-body stuff - TODO: to be moved, because this is a HACK!

cdef void c_init_velocity_nbody(
    CPotential *p, int half_ndim, double t, double dt,
    CPotential **pots, double *x_nbody_jm1, int nbody, int nbody_i,
    double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad
) nogil:
    cdef int k

    c_gradient(p, t, x_jm1, grad)
    c_nbody_gradient_symplectic(pots, t, x_jm1, x_nbody_jm1, nbody, nbody_i, half_ndim, grad)

    for k in range(half_ndim):
        v_jm1_2[k] = v_jm1[k] - grad[k] * dt/2.  # acceleration is minus gradient


cdef void c_leapfrog_step_nbody(
    CPotential *p, int half_ndim, double t, double dt,
    CPotential **pots, double *x_nbody_jm1, int nbody, int nbody_i,
    double *x_jm1, double *v_jm1, double *v_jm1_2, double *grad
) nogil:
    cdef int k

    # full step the positions
    for k in range(half_ndim):
        x_jm1[k] = x_jm1[k] + v_jm1_2[k] * dt

    c_gradient(p, t, x_jm1, grad)  # compute gradient at new position
    c_nbody_gradient_symplectic(pots, t, x_jm1, x_nbody_jm1, nbody, nbody_i, half_ndim, grad)

    # step velocity forward by half step, aligned w/ position, then
    #   finish the full step to leapfrog over position
    for k in range(half_ndim):
        v_jm1[k] = v_jm1_2[k] - grad[k] * dt/2.
        v_jm1_2[k] = v_jm1_2[k] - grad[k] * dt


cpdef leapfrog_integrate_nbody(hamiltonian, double [:, ::1] w0, double[::1] t,
                               list particle_potentials, int store_all=1):
    """
    CAUTION: Interpretation of axes is different here! We need the
    arrays to be C ordered and easy to iterate over, so here the
    axes are (norbits, ndim).
    """

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian object does not support C-level access.")

    if not isinstance(hamiltonian.frame, StaticFrame):
        raise TypeError(
            "Leapfrog integration is currently only supported for StaticFrame, "
            f"not {hamiltonian.frame.__class__.__name__}"
        )

    cdef:
        # temporary scalars
        int i, j, k
        int n = w0.shape[0]
        int ndim = w0.shape[1]
        int half_ndim = ndim // 2

        int ntimes = len(t)
        double dt = t[1]-t[0]

        # temporary array containers
        double[::1] grad = np.zeros(half_ndim)
        double[:, ::1] v_jm1_2 = np.zeros((n, half_ndim))

        # return arrays
        double[:, :, ::1] all_w
        double[:, ::1] tmp_w = np.zeros((n, ndim))

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CPotential *c_particle_potentials[MAX_NBODY]
        unsigned nbody = 0

    if store_all:
        all_w = np.zeros((ntimes, n, ndim))

        # save initial conditions
        all_w[0, :, :] = w0.copy()

    for pot in particle_potentials:
        if not isinstance(pot, NullPotential):
            nbody += 1

    # Extract the CPotential objects from the particle potentials.
    for i in range(n):
        c_particle_potentials[i] = &(<CPotentialWrapper>(particle_potentials[i].c_instance)).cpotential

    tmp_w = w0.copy()

    with nogil:
        # first initialize the velocities so they are evolved by a
        #   half step relative to the positions
        for i in range(n):
            c_init_velocity_nbody(&cp, half_ndim, t[0], dt,
                                  &c_particle_potentials[0], &tmp_w[0, 0], nbody, i,
                                  &tmp_w[i, 0], &tmp_w[i, half_ndim],
                                  &v_jm1_2[i, 0], &grad[0])

        for j in range(1, ntimes, 1):
            for i in range(n):
                for k in range(half_ndim):
                    grad[k] = 0.

                c_leapfrog_step_nbody(&cp, half_ndim, t[j], dt,
                                      &c_particle_potentials[0], &tmp_w[0, 0], nbody, i,
                                      &tmp_w[i, 0], &tmp_w[i, half_ndim],
                                      &v_jm1_2[i, 0],
                                      &grad[0])

                if store_all:
                    for k in range(ndim):
                        all_w[j, i, k] = tmp_w[i, k]

    if store_all:
        return np.asarray(t), np.asarray(all_w)
    else:
        return np.asarray(t[-1:]), np.asarray(tmp_w)
</file>

<file path="gala/integrate/cyintegrators/ruth4.pxd">
# cython: language_level=3

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "nbody_helper.h":
    const int MAX_NBODY

cdef void c_ruth4_step(CPotential *p, int ndim, double t, double dt,
                       double *cs, double *ds,
                       double *w, double *grad) nogil
</file>

<file path="gala/integrate/cyintegrators/ruth4.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" Leapfrog integration in Cython. """

# Third-party
import numpy as np
cimport numpy as np
np.import_array()

# Project
from ...potential.potential.cpotential cimport CPotentialWrapper
from ...potential.frame import StaticFrame
from ...potential import NullPotential

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

cdef extern from "potential/src/cpotential.h":
    ctypedef struct CPotential:
        pass

cdef extern from "potential/src/cpotential.h":
    void c_gradient(CPotential *p, double t, double *q, double *grad) nogil
    void c_nbody_gradient_symplectic(
        CPotential **pots, double t, double *q,
        double *nbody_q, int nbody, int nbody_i,
        int ndim, double *grad
    ) nogil


cdef void c_ruth4_step(CPotential *p, int half_ndim, double t, double dt,
                       double *cs, double *ds,
                       double *w, double *grad) nogil:
    cdef:
        int j, k

    for j in range(4):
        for k in range(half_ndim):
             grad[k] = 0.
        c_gradient(p, t, w, grad)
        for k in range(half_ndim):
            w[half_ndim + k] = w[half_ndim + k] - ds[j] * grad[k] * dt
            w[k] = w[k] + cs[j] * w[half_ndim + k] * dt

cpdef ruth4_integrate_hamiltonian(hamiltonian,
                                  double[:, ::1] w0,
                                  double[::1] t,
                                  int store_all=1):
    """
    CAUTION: Interpretation of axes is different here! We need the
    arrays to be C ordered and easy to iterate over, so here the
    axes are (norbits, ndim).
    """

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian object does not support C-level access.")

    if not isinstance(hamiltonian.frame, StaticFrame):
        raise TypeError("Leapfrog integration is currently only supported "
                        "for StaticFrame, not {}."
                        .format(hamiltonian.frame.__class__.__name__))

    cdef:
        # temporary scalars
        int i, j, k
        int n = w0.shape[0]
        int ndim = w0.shape[1]
        int half_ndim = ndim // 2

        int ntimes = len(t)
        double dt = t[1] - t[0]

        # Integrator coefficients
        double two_13 = 2 ** (1./3.)
        double[::1] cs = np.array([
            1. / (2. * (2. - two_13)),
            (1. - two_13) / (2.*(2. - two_13)),
            (1. - two_13) / (2.*(2. - two_13)),
            1. / (2.*(2. - two_13))
        ], dtype='f8')

        double[::1] ds = np.array([
            0.,
            1. / (2. - two_13),
            -two_13 / (2. - two_13),
            1. / (2. - two_13)
        ], dtype='f8')

        # temporary array containers
        double[::1] grad = np.zeros(half_ndim)

        # return arrays
        double[:, :, ::1] all_w
        double[:, ::1] tmp_w

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential

    if store_all:
        all_w = np.zeros((ntimes, n, ndim))

        # save initial conditions
        all_w[0, :, :] = w0.copy()

    tmp_w = w0.copy()

    with nogil:

        for j in range(1, ntimes, 1):
            for i in range(n):
                c_ruth4_step(&cp, half_ndim, t[j], dt,
                             &cs[0], &ds[0],
                             &tmp_w[i, 0], &grad[0])

                if store_all:
                    for k in range(ndim):
                        all_w[j, i, k] = tmp_w[i, k]

    if store_all:
        return np.asarray(t), np.asarray(all_w)
    else:
        return np.asarray(t[-1:]), np.asarray(tmp_w)


# -------------------------------------------------------------------------------------
# N-body stuff - TODO: to be moved, because this is a HACK!

cdef void c_ruth4_step_nbody(
    CPotential *p, int half_ndim, double t, double dt,
    CPotential **pots, double *w_nbody, int nbody, int nbody_i,
    double *cs, double *ds,
    double *w, double *grad
) nogil:
    cdef:
        int j, k

    for j in range(4):
        for k in range(half_ndim):
             grad[k] = 0.

        c_gradient(p, t, w, grad)
        c_nbody_gradient_symplectic(pots, t, w, w_nbody, nbody, nbody_i, half_ndim, grad)

        for k in range(half_ndim):
            w[half_ndim + k] = w[half_ndim + k] - ds[j] * grad[k] * dt
            w[k] = w[k] + cs[j] * w[half_ndim + k] * dt

cpdef ruth4_integrate_nbody(hamiltonian, double [:, ::1] w0, double[::1] t,
                            list particle_potentials, int store_all=1):
    """
    CAUTION: Interpretation of axes is different here! We need the
    arrays to be C ordered and easy to iterate over, so here the
    axes are (norbits, ndim).
    """

    if not hamiltonian.c_enabled:
        raise TypeError("Input Hamiltonian object does not support C-level access.")

    if not isinstance(hamiltonian.frame, StaticFrame):
        raise TypeError(
            "Leapfrog integration is currently only supported for StaticFrame, "
            f"not {hamiltonian.frame.__class__.__name__}"
        )

    cdef:
        # temporary scalars
        int i, j, k
        int n = w0.shape[0]
        int ndim = w0.shape[1]
        int half_ndim = ndim // 2

        int ntimes = len(t)
        double dt = t[1]-t[0]

         # Integrator coefficients
        double two_13 = 2 ** (1./3.)
        double[::1] cs = np.array([
            1. / (2. * (2. - two_13)),
            (1. - two_13) / (2.*(2. - two_13)),
            (1. - two_13) / (2.*(2. - two_13)),
            1. / (2.*(2. - two_13))
        ], dtype='f8')

        double[::1] ds = np.array([
            0.,
            1. / (2. - two_13),
            -two_13 / (2. - two_13),
            1. / (2. - two_13)
        ], dtype='f8')

        # temporary array containers
        double[::1] grad = np.zeros(half_ndim)
        double[:, ::1] v_jm1_2 = np.zeros((n, half_ndim))

        # return arrays
        double[:, :, ::1] all_w
        double[:, ::1] tmp_w = np.zeros((n, ndim))

        # whoa, so many dots
        CPotential cp = (<CPotentialWrapper>(hamiltonian.potential.c_instance)).cpotential
        CPotential *c_particle_potentials[MAX_NBODY]
        unsigned nbody = 0

    if store_all:
        all_w = np.zeros((ntimes, n, ndim))

        # save initial conditions
        all_w[0, :, :] = w0.copy()

    for pot in particle_potentials:
        if not isinstance(pot, NullPotential):
            nbody += 1

    # Extract the CPotential objects from the particle potentials.
    for i in range(n):
        c_particle_potentials[i] = &(<CPotentialWrapper>(particle_potentials[i].c_instance)).cpotential

    tmp_w = w0.copy()

    with nogil:

        for j in range(1, ntimes, 1):
            for i in range(n):
                c_ruth4_step_nbody(
                    &cp, half_ndim, t[j], dt,
                    &c_particle_potentials[0], &tmp_w[0, 0], nbody, i,
                    &cs[0], &ds[0],
                    &tmp_w[i, 0], &grad[0]
                )

                if store_all:
                    for k in range(ndim):
                        all_w[j, i, k] = tmp_w[i, k]

    if store_all:
        return np.asarray(t), np.asarray(all_w)
    else:
        return np.asarray(t[-1:]), np.asarray(tmp_w)
</file>

<file path="gala/integrate/pyintegrators/__init__.py">
from .dopri853 import DOPRI853Integrator
from .rk5 import RK5Integrator
from .leapfrog import LeapfrogIntegrator
from .ruth4 import Ruth4Integrator
</file>

<file path="gala/integrate/pyintegrators/dopri853.py">
""" Wrapper around SciPy DOPRI853 integrator. """

# Third-party
from scipy.integrate import ode

# Project
from ..core import Integrator
from ..timespec import parse_time_specification

__all__ = ["DOPRI853Integrator"]


class DOPRI853Integrator(Integrator):
    r"""
    This provides a wrapper around ``Scipy``'s implementation of the
    Dormand-Prince 85(3) integration scheme.

    .. seealso::

        - Numerical recipes (Dopr853)
        - http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method

    Parameters
    ----------
    func : callable
        A callable object that computes the phase-space coordinate
        derivatives with respect to the independent variable at a point
        in phase space.
    func_args : tuple (optional)
        Any extra arguments for the function.
    func_units : `~gala.units.UnitSystem` (optional)
        If using units, this is the unit system assumed by the
        integrand function.
    progress : bool (optional)
        Display a progress bar during integration.

    """

    def __init__(
        self,
        func,
        func_args=(),
        func_units=None,
        progress=False,
        store_all=True,
        **kwargs
    ):
        super(DOPRI853Integrator, self).__init__(
            func, func_args, func_units, progress=progress, store_all=store_all
        )
        self._ode_kwargs = kwargs

    def __call__(self, w0, mmap=None, **time_spec):
        # generate the array of times
        times = parse_time_specification(self._func_units, **time_spec)
        n_steps = len(times) - 1

        w0, arr_w0, ws = self._prepare_ws(w0, mmap, n_steps)
        _size_1d = 2 * self.ndim * self.norbits

        # need this to do resizing, and to handle func_args because there is some
        #   issue with the args stuff in scipy...
        def func_wrapper(t, x):
            _x = x.reshape((2 * self.ndim, self.norbits))
            val = self.F(t, _x, *self._func_args)
            return val.reshape((_size_1d,))

        self._ode = ode(func_wrapper, jac=None)
        self._ode = self._ode.set_integrator("dop853", **self._ode_kwargs)

        # create the return arrays
        if self.store_all:
            ws[:, 0] = arr_w0

        # make 1D
        arr_w0 = arr_w0.reshape((_size_1d,))

        # set the initial conditions
        self._ode.set_initial_value(arr_w0, times[0])

        # Integrate the ODE(s) across each delta_t timestep
        range_ = self._get_range_func()
        for k in range_(1, n_steps + 1):
            self._ode.integrate(times[k])
            outy = self._ode.y

            if self.store_all:
                ws[:, k] = outy.reshape(2 * self.ndim, self.norbits)

            if not self._ode.successful():
                raise RuntimeError("ODE integration failed!")

        if not self.store_all:
            ws = outy.reshape(2 * self.ndim, 1, self.norbits)
            times = times[-1:]

        return self._handle_output(w0, times, ws)
</file>

<file path="gala/integrate/pyintegrators/leapfrog.py">
""" Leapfrog integration. """

# Third-party
import numpy as np

# Project
from ..core import Integrator
from ..timespec import parse_time_specification

__all__ = ["LeapfrogIntegrator"]


class LeapfrogIntegrator(Integrator):
    r"""
    A symplectic, Leapfrog integrator.

    Given a function for computing time derivatives of the phase-space
    coordinates, this object computes the orbit at specified times.

    .. seealso::

        - http://en.wikipedia.org/wiki/Leapfrog_integration
        - http://ursa.as.arizona.edu/~rad/phys305/ODE_III/node11.html

    Naming convention for variables::

        im1 = i-1
        im1_2 = i-1/2
        ip1 = i+1
        ip1_2 = i+1/2

    Examples
    --------

    Using ``q`` as our coordinate variable and ``p`` as the conjugate
    momentum, we want to numerically solve for an orbit in the
    potential (Hamiltonian)

    .. math::

        \Phi &= \frac{1}{2}q^2\\
        H(q, p) &= \frac{1}{2}(p^2 + q^2)


    In this system,

    .. math::

        \dot{q} &= \frac{\partial \Phi}{\partial p} = p \\
        \dot{p} &= -\frac{\partial \Phi}{\partial q} = -q


    We will use the variable ``w`` to represent the full phase-space vector,
    :math:`w = (q, p)`. We define a function that computes the time derivates
    at any given time, ``t``, and phase-space position, ``w``::

        def F(t, w):
            dw = [w[1], -w[0]]
            return dw

    .. note::

        The force here is not time dependent, but this function always has
        to accept the independent variable (e.g., time) as the
        first argument.

    To create an integrator object, just pass this acceleration function in
    to the constructor, and then we can integrate orbits from a given vector
    of initial conditions::

        integrator = LeapfrogIntegrator(acceleration)
        times, ws = integrator(w0=[1., 0.], dt=0.1, n_steps=1000)

    .. note::

        When integrating a single vector of initial conditions, the return
        array will have 2 axes. In the above example, the returned array will
        have shape ``(2, 1001)``. If an array of initial conditions are passed
        in, the return array will have 3 axes, where the last axis is for the
        individual orbits.

    Parameters
    ----------
    func : func
        A callable object that computes the phase-space time derivatives
        at a time and point in phase space.
    func_args : tuple (optional)
        Any extra arguments for the derivative function.
    func_units : `~gala.units.UnitSystem` (optional)
        If using units, this is the unit system assumed by the
        integrand function.

    """

    def step(self, t, x_im1, v_im1_2, dt):
        """
        Step forward the positions and velocities by the given timestep.

        Parameters
        ----------
        dt : numeric
            The timestep to move forward.
        """

        x_i = x_im1 + v_im1_2 * dt
        F_i = self.F(t, np.vstack((x_i, v_im1_2)), *self._func_args)
        a_i = F_i[self.ndim:]

        v_i = v_im1_2 + a_i * dt / 2
        v_ip1_2 = v_i + a_i * dt / 2

        return x_i, v_i, v_ip1_2

    def _init_v(self, t, w0, dt):
        """
        Leapfrog updates the velocities offset a half-step from the
        position updates. If we're given initial conditions aligned in
        time, e.g. the positions and velocities at the same 0th step,
        then we have to initially scoot the velocities forward by a half
        step to prime the integrator.

        Parameters
        ----------
        dt : numeric
            The first timestep.
        """

        # here is where we scoot the velocity at t=t1 to v(t+1/2)
        F0 = self.F(t.copy(), w0.copy(), *self._func_args)
        a0 = F0[self.ndim:]
        v_1_2 = w0[self.ndim:] + a0*dt/2.

        return v_1_2

    def __call__(self, w0, mmap=None, **time_spec):
        # generate the array of times
        times = parse_time_specification(self._func_units, **time_spec)
        n_steps = len(times) - 1
        dt = times[1] - times[0]

        w0_obj, w0, ws = self._prepare_ws(w0, mmap, n_steps)
        x0 = w0[:self.ndim]

        # prime the integrator so velocity is offset from coordinate by a
        #   half timestep
        v_im1_2 = self._init_v(times[0], w0, dt)
        x_im1 = x0

        if self.store_all:
            ws[:, 0] = w0

        range_ = self._get_range_func()
        for ii in range_(1, n_steps+1):
            x_i, v_i, v_ip1_2 = self.step(times[ii], x_im1, v_im1_2, dt)

            if self.store_all:
                slc = (ii, slice(None))
            else:
                slc = (slice(None), )
            ws[(slice(None, self.ndim), ) + slc] = x_i
            ws[(slice(self.ndim, None), ) + slc] = v_i
            x_im1, v_im1_2 = x_i, v_ip1_2

        if not self.store_all:
            times = times[-1:]

        return self._handle_output(w0_obj, times, ws)
</file>

<file path="gala/integrate/pyintegrators/rk5.py">
""" 5th order Runge-Kutta integration. """

# Third-party
import numpy as np

# Project
from ..core import Integrator
from ..timespec import parse_time_specification

__all__ = ["RK5Integrator"]

# These are the Dormand-Prince parameters for embedded Runge-Kutta methods
A = np.array([0.0, 0.2, 0.3, 0.6, 1.0, 0.875])
B = np.array([[0.0, 0.0, 0.0, 0.0, 0.0],
              [1./5., 0.0, 0.0, 0.0, 0.0],
              [3./40., 9./40., 0.0, 0.0, 0.0],
              [3./10., -9./10., 6./5., 0.0, 0.0],
              [-11./54., 5./2., -70./27., 35./27., 0.0],
              [1631./55296., 175./512., 575./13824., 44275./110592., 253./4096.]
              ])
C = np.array([37./378., 0., 250./621., 125./594., 0., 512./1771.])
D = np.array([2825./27648., 0., 18575./48384., 13525./55296.,
              277./14336., 1./4.])


class RK5Integrator(Integrator):
    r"""
    Initialize a 5th order Runge-Kutta integrator given a function for
    computing derivatives with respect to the independent variables. The
    function should, at minimum, take the independent variable as the
    first argument, and the coordinates as a single vector as the second
    argument. For notation and variable names, we assume this independent
    variable is time, t, and the coordinate vector is named x, though it
    could contain a mixture of coordinates and momenta for solving
    Hamilton's equations, for example.

    .. seealso::

        - http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods

    Parameters
    ----------
    func : func
        A callable object that computes the phase-space coordinate
        derivatives with respect to the independent variable at a point
        in phase space.
    func_args : tuple (optional)
        Any extra arguments for the function.
    func_units : `~gala.units.UnitSystem` (optional)
        If using units, this is the unit system assumed by the
        integrand function.

    """

    def step(self, t, w, dt):
        """ Step forward the vector w by the given timestep.

            Parameters
            ----------
            dt : numeric
                The timestep to move forward.
        """

        # Runge-Kutta Fehlberg formulas (see: Numerical Recipes)
        F = lambda t, w: self.F(t, w, *self._func_args)  # noqa

        K = np.zeros((6,)+w.shape)
        K[0] = dt * F(t, w)
        K[1] = dt * F(t + A[1]*dt, w + B[1][0]*K[0])
        K[2] = dt * F(t + A[2]*dt, w + B[2][0]*K[0] + B[2][1]*K[1])
        K[3] = dt * F(t + A[3]*dt, w + B[3][0]*K[0] + B[3][1]*K[1] + B[3][2]*K[2])
        K[4] = dt * F(t + A[4]*dt, w + B[4][0]*K[0] + B[4][1]*K[1] + B[4][2]*K[2] + B[4][3]*K[3])
        K[5] = dt * F(t + A[5]*dt,
                      w + B[5][0]*K[0] + B[5][1]*K[1] + B[5][2]*K[2] + B[5][3]*K[3] + B[5][4]*K[4])

        # shift
        dw = np.zeros_like(w)
        for i in range(6):
            dw = dw + C[i]*K[i]

        return w + dw

    def __call__(self, w0, mmap=None, **time_spec):
        # generate the array of times
        times = parse_time_specification(self._func_units, **time_spec)
        n_steps = len(times)-1
        dt = times[1]-times[0]

        w0_obj, w0, ws = self._prepare_ws(w0, mmap, n_steps=n_steps)

        if self.store_all:
            # Set first step to the initial conditions
            ws[:, 0] = w0
        w = w0.copy()
        range_ = self._get_range_func()
        for ii in range_(1, n_steps+1):
            w = self.step(times[ii], w, dt)

            if self.store_all:
                ws[:, ii] = w

        if not self.store_all:
            ws = w
            times = times[-1:]

        return self._handle_output(w0_obj, times, ws)
</file>

<file path="gala/integrate/pyintegrators/ruth4.py">
""" Leapfrog integration. """

# Project
from ..core import Integrator
from ..timespec import parse_time_specification

__all__ = ["Ruth4Integrator"]


class Ruth4Integrator(Integrator):
    r"""
    A 4th order symplectic integrator.

    Given a function for computing time derivatives of the phase-space
    coordinates, this object computes the orbit at specified times.

    .. seealso::

        - https://en.wikipedia.org/wiki/Symplectic_integrator#A_fourth-order_example

    Naming convention for variables::

        im1 = i-1
        im1_2 = i-1/2
        ip1 = i+1
        ip1_2 = i+1/2

    Examples
    --------

    Using ``q`` as our coordinate variable and ``p`` as the conjugate
    momentum, we want to numerically solve for an orbit in the
    potential (Hamiltonian)

    .. math::

        \Phi &= \frac{1}{2}q^2\\
        H(q, p) &= \frac{1}{2}(p^2 + q^2)


    In this system,

    .. math::

        \dot{q} &= \frac{\partial \Phi}{\partial p} = p \\
        \dot{p} &= -\frac{\partial \Phi}{\partial q} = -q


    We will use the variable ``w`` to represent the full phase-space vector,
    :math:`w = (q, p)`. We define a function that computes the time derivates
    at any given time, ``t``, and phase-space position, ``w``::

        def F(t, w):
            dw = [w[1], -w[0]]
            return dw

    .. note::

        The force here is not time dependent, but this function always has
        to accept the independent variable (e.g., time) as the
        first argument.

    To create an integrator object, just pass this acceleration function in
    to the constructor, and then we can integrate orbits from a given vector
    of initial conditions::

        integrator = Ruth4Integrator(acceleration)
        times, ws = integrator(w0=[1., 0.], dt=0.1, n_steps=1000)

    .. note::

        When integrating a single vector of initial conditions, the return
        array will have 2 axes. In the above example, the returned array will
        have shape ``(2, 1001)``. If an array of initial conditions are passed
        in, the return array will have 3 axes, where the last axis is for the
        individual orbits.

    Parameters
    ----------
    func : func
        A callable object that computes the phase-space time derivatives
        at a time and point in phase space.
    func_args : tuple (optional)
        Any extra arguments for the derivative function.
    func_units : `~gala.units.UnitSystem` (optional)
        If using units, this is the unit system assumed by the
        integrand function.

    """

    # From: https://en.wikipedia.org/wiki/Symplectic_integrator
    _cs = [
        1 / (2 * (2 - 2 ** (1 / 3))),
        (1 - 2 ** (1 / 3)) / (2 * (2 - 2 ** (1 / 3))),
        (1 - 2 ** (1 / 3)) / (2 * (2 - 2 ** (1 / 3))),
        1 / (2 * (2 - 2 ** (1 / 3))),
    ]
    _ds = [
        0,
        1 / (2 - 2 ** (1 / 3)),
        -(2 ** (1 / 3)) / (2 - 2 ** (1 / 3)),
        1 / (2 - 2 ** (1 / 3)),
    ]

    def step(self, t, w, dt):
        """
        Step forward the positions and velocities by the given timestep.

        Parameters
        ----------
        dt : numeric
            The timestep to move forward.
        """

        w_i = w.copy()
        for cj, dj in zip(self._cs, self._ds):
            F_i = self.F(t, w_i, *self._func_args)
            a_i = F_i[self.ndim:]

            w_i[self.ndim:] += dj * a_i * dt
            w_i[: self.ndim] += cj * w_i[self.ndim:] * dt

        return w_i

    def __call__(self, w0, mmap=None, **time_spec):
        # generate the array of times
        times = parse_time_specification(self._func_units, **time_spec)
        n_steps = len(times) - 1
        dt = times[1] - times[0]

        w0_obj, w0, ws = self._prepare_ws(w0, mmap, n_steps=n_steps)

        # Set first step to the initial conditions
        if self.store_all:
            ws[:, 0] = w0
        w = w0.copy()
        range_ = self._get_range_func()
        for ii in range_(1, n_steps + 1):
            w = self.step(times[ii], w, dt)

            if self.store_all:
                ws[:, ii] = w

        if not self.store_all:
            ws = w
            times = times[-1:]

        return self._handle_output(w0_obj, times, ws)
</file>

<file path="gala/integrate/tests/test_cyintegrators.py">
"""
    Test the Cython integrators.
"""

# Standard library
from itertools import product
import time

# Third-party
import numpy as np
import pytest

# Project
from ..pyintegrators.leapfrog import LeapfrogIntegrator
from ..cyintegrators.leapfrog import leapfrog_integrate_hamiltonian
from ..pyintegrators.dopri853 import DOPRI853Integrator
from ..cyintegrators.dop853 import dop853_integrate_hamiltonian
from ..pyintegrators.ruth4 import Ruth4Integrator
from ..cyintegrators.ruth4 import ruth4_integrate_hamiltonian
from ...potential import Hamiltonian, HernquistPotential
from ...units import galactic

integrator_list = [LeapfrogIntegrator, DOPRI853Integrator, Ruth4Integrator]
func_list = [
    leapfrog_integrate_hamiltonian,
    dop853_integrate_hamiltonian,
    ruth4_integrate_hamiltonian,
]

_list = []
for dt in [2, -2]:
    _list.extend([(x, y, dt) for x, y in zip(integrator_list, func_list)])


@pytest.mark.parametrize(
    ["Integrator", "integrate_func", "dt"],
    _list
)
def test_compare_to_py(Integrator, integrate_func, dt):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)
    H = Hamiltonian(potential=p)

    def F(t, w):
        w_T = np.ascontiguousarray(w.T)
        return H._gradient(w_T, np.array([0.0])).T

    cy_w0 = np.array(
        [
            [0.0, 10.0, 0.0, 0.2, 0.0, 0.0],
            [10.0, 0.0, 0.0, 0.0, 0.2, 0.0],
            [0.0, 10.0, 0.0, 0.0, 0.0, 0.2],
        ]
    )
    py_w0 = np.ascontiguousarray(cy_w0.T)

    n_steps = 1024
    t = np.linspace(0, dt * n_steps, n_steps + 1)

    cy_t, cy_w = integrate_func(H, cy_w0, t)
    cy_w = np.rollaxis(cy_w, -1)

    integrator = Integrator(F)
    orbit = integrator(py_w0, dt=dt, n_steps=n_steps)

    py_t = orbit.t.value
    py_w = orbit.w()

    assert py_w.shape == cy_w.shape
    assert np.allclose(cy_w[:, -1], py_w[:, -1])
    assert np.allclose(cy_t, py_t)


@pytest.mark.parametrize(
    ["integrate_func", "dt"],
    product(func_list, [-2., 2])
)
def test_store_all(integrate_func, dt):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)
    H = Hamiltonian(potential=p)

    w0 = np.array(
        [
            [0.0, 10.0, 0.0, 0.2, 0.0, 0.0],
            [10.0, 0.0, 0.0, 0.0, 0.2, 0.0],
            [0.0, 10.0, 0.0, 0.0, 0.0, 0.2],
        ]
    )

    # 1024 steps
    t = np.linspace(0, dt * 1024, 1024 + 1)

    t_all, w_all = integrate_func(H, w0, t)
    t_f, w_f = integrate_func(H, w0, t, store_all=False)

    assert t_all[-1] == t_f[0]
    assert np.allclose(w_all[-1], w_f)


# TODO: move this to only run if a flag like --remote-data is passed, like
# --speed-scaling or something?
@pytest.mark.skipif(True, reason="Slow test - mainly for plotting locally")
@pytest.mark.parametrize(
    ["Integrator", "integrate_func"],
    zip(integrator_list, func_list)
)
def test_scaling(tmpdir, Integrator, integrate_func):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)

    def F(t, w):
        dq = w[3:]
        dp = -p._gradient(w[:3], t=np.array([0.0]))
        return np.vstack((dq, dp))

    step_bins = np.logspace(2, np.log10(25000), 7)
    colors = ["k", "b", "r"]
    dt = 1.0

    for c, nparticles in zip(colors, [1, 100, 1000]):
        cy_w0 = np.array([[0.0, 10.0, 0.0, 0.2, 0.0, 0.0]] * nparticles)
        py_w0 = np.ascontiguousarray(cy_w0.T)

        x = []
        cy_times = []
        py_times = []
        for n_steps in step_bins:
            print(nparticles, n_steps)
            t = np.linspace(0, dt * n_steps, n_steps + 1)
            x.append(n_steps)

            # time the Cython integration
            t0 = time.time()
            integrate_func(p.c_instance, cy_w0, t)
            cy_times.append(time.time() - t0)

            # time the Python integration
            t0 = time.time()
            integrator = Integrator(F)
            orbit = integrator(py_w0, dt=dt, n_steps=n_steps)
            py_times.append(time.time() - t0)

    #     pl.loglog(x, cy_times, linestyle='-', lw=2., c=c, marker='',
    #               label="cy: {} orbits".format(nparticles))
    #     pl.loglog(x, py_times, linestyle='--', lw=2., c=c, marker='',
    #               label="py: {} orbits".format(nparticles))

    # pl.title(Integrator.__name__)
    # pl.legend(loc='upper left')
    # pl.xlim(90, 30000)
    # pl.xlabel("N steps")
    # pl.tight_layout()
    # # pl.show()
    # pl.savefig(os.path.join(tmpdir, "integrate-scaling.png"), dpi=300)
</file>

<file path="gala/integrate/tests/test_pyintegrators.py">
"""
    Test the integrators.
"""
import os

# Third-party
import pytest
import numpy as np
from astropy.utils.exceptions import AstropyDeprecationWarning

# Project
from .. import (
    LeapfrogIntegrator,
    RK5Integrator,
    DOPRI853Integrator,
    Ruth4Integrator,
)
from gala.tests.optional_deps import HAS_TQDM

# Integrators to test
integrator_list = [
    RK5Integrator,
    DOPRI853Integrator,
    LeapfrogIntegrator,
    Ruth4Integrator,
]

# Gradient functions:
def sho_F(t, w, T):  # noqa
    """Simple harmonic oscillator"""
    q, p = w
    wdot = np.zeros_like(w)
    wdot[0] = p
    wdot[1] = -((2 * np.pi / T) ** 2) * q
    return wdot


def forced_sho_F(t, w, A, omega_d):
    q, p = w
    wdot = np.zeros_like(w)
    wdot[0] = p
    wdot[1] = -np.sin(q) + A * np.cos(omega_d * t)
    return wdot


def lorenz_F(t, w, sigma, rho, beta):
    x, y, z, *_ = w
    wdot = np.zeros_like(w)
    wdot[0] = sigma * (y - x)
    wdot[1] = x * (rho - z) - y
    wdot[2] = x * y - beta * z
    return wdot


def ptmass_F(t, w):
    x, y, px, py = w
    a = -1.0 / (x * x + y * y) ** 1.5

    wdot = np.zeros_like(w)
    wdot[0] = px
    wdot[1] = py
    wdot[2] = x * a
    wdot[3] = y * a
    return wdot


@pytest.mark.parametrize("Integrator", integrator_list)
def test_sho_forward_backward(Integrator):
    integrator = Integrator(sho_F, func_args=(1.0,))

    dt = 1e-4
    n_steps = 10_000

    forw = integrator([0.0, 1.0], dt=dt, n_steps=n_steps)
    back = integrator([0.0, 1.0], dt=-dt, n_steps=n_steps)

    assert np.allclose(forw.w()[:, -1], back.w()[:, -1], atol=1e-6)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_deprecated_run_method(Integrator):
    """Test the deprecated run method."""
    integrator = Integrator(sho_F, func_args=(1.0,))

    dt = 1e-4
    n_steps = 10_000

    with pytest.warns(AstropyDeprecationWarning):
        run = integrator.run([0.0, 1.0], dt=dt, n_steps=n_steps)

    call = integrator([0.0, 1.0], dt=dt, n_steps=n_steps)

    assert np.allclose(run.w()[:, -1], call.w()[:, -1], atol=1e-6)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_point_mass(Integrator):
    q0 = np.array([1.0, 0.0])
    p0 = np.array([0.0, 1.0])

    integrator = Integrator(ptmass_F)
    orbit = integrator(np.append(q0, p0), t1=0.0, t2=2 * np.pi, n_steps=1e4)

    assert np.allclose(orbit.w()[:, 0], orbit.w()[:, -1], atol=1e-6)


@pytest.mark.skipif(not HAS_TQDM, reason="requires tqdm to run this test")
@pytest.mark.parametrize("Integrator", integrator_list)
def test_progress(Integrator):
    q0 = np.array([1.0, 0.0])
    p0 = np.array([0.0, 1.0])

    integrator = Integrator(ptmass_F, progress=True)
    _ = integrator(np.append(q0, p0), t1=0.0, t2=2 * np.pi, n_steps=1e2)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_point_mass_multiple(Integrator):
    w0 = np.array(
        [[1.0, 0.0, 0.0, 1.0], [0.8, 0.0, 0.0, 1.1], [2.0, 1.0, -1.0, 1.1]]
    ).T

    integrator = Integrator(ptmass_F)
    _ = integrator(w0, dt=1e-3, n_steps=1e4)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_driven_pendulum(Integrator):
    integrator = Integrator(forced_sho_F, func_args=(0.07, 0.75))
    _ = integrator([3.0, 0.0], dt=1e-2, n_steps=1e4)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_lorenz(Integrator):
    sigma, rho, beta = 10.0, 28.0, 8 / 3.0
    integrator = Integrator(lorenz_F, func_args=(sigma, rho, beta))

    _ = integrator([0.5, 0.5, 0.5, 0, 0, 0], dt=1e-2, n_steps=1e4)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_memmap(tmpdir, Integrator):
    dt = 0.1
    n_steps = 1000
    nw0 = 10000

    filename = os.path.join(str(tmpdir), "test_memmap.npy")
    mmap = np.memmap(filename, mode="w+", shape=(2, n_steps + 1, nw0))

    w0 = np.random.uniform(-1, 1, size=(2, nw0))

    integrator = Integrator(sho_F, func_args=(1.0,))

    _ = integrator(w0, dt=dt, n_steps=n_steps, mmap=mmap)


@pytest.mark.parametrize("Integrator", integrator_list)
def test_py_store_all(Integrator):
    integrator_all = Integrator(sho_F, func_args=(1.3,), store_all=True)
    integrator_final = Integrator(sho_F, func_args=(1.3,), store_all=False)

    dt = 1e-4
    n_steps = 10_000

    out_all = integrator_all([0.0, 1.0], dt=dt, n_steps=n_steps)
    out_final = integrator_final([0.0, 1.0], dt=dt, n_steps=n_steps)

    assert np.allclose(out_all.w()[:, -1], out_final.w()[:, 0])
</file>

<file path="gala/integrate/tests/test_timespec.py">
"""
    Test the time specification parser.
"""

# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..timespec import parse_time_specification
from ...units import DimensionlessUnitSystem, galactic


def test_dt_n_steps():
    # dt, n_steps[, t1] : (numeric, int[, numeric])
    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, n_steps=100)
    np.testing.assert_allclose(np.min(t), 0.)
    np.testing.assert_allclose(np.max(t), 10.)
    assert len(t) == 101

    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, n_steps=100, t1=10.)
    np.testing.assert_allclose(np.min(t), 10.)
    np.testing.assert_allclose(np.max(t), 20.)
    assert len(t) == 101


def test_dt_t1_t2():
    # dt, t1, t2 : (numeric, numeric, numeric)
    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, t1=10., t2=130.)
    np.testing.assert_allclose(np.min(t), 10.)
    np.testing.assert_allclose(np.max(t), 130.)

    t = parse_time_specification(DimensionlessUnitSystem(), dt=-0.1, t1=10., t2=-13.412)
    np.testing.assert_allclose(np.min(t), -13.412)
    np.testing.assert_allclose(np.max(t), 10.)

    with pytest.raises(ValueError):
        parse_time_specification(DimensionlessUnitSystem(), dt=-0.1, t1=10., t2=130.)

    with pytest.raises(ValueError):
        parse_time_specification(DimensionlessUnitSystem(), dt=0.1, t1=130., t2=-10.142)


def test_n_steps_t1_t2():
    # n_steps, t1, t2 : (int, numeric, numeric)
    t = parse_time_specification(DimensionlessUnitSystem(), n_steps=100, t1=24.124, t2=91.412)
    np.testing.assert_allclose(np.min(t), 24.124)
    np.testing.assert_allclose(np.max(t), 91.412)

    t = parse_time_specification(DimensionlessUnitSystem(), n_steps=100, t1=24.124, t2=-91.412)
    np.testing.assert_allclose(np.max(t), 24.124)
    np.testing.assert_allclose(np.min(t), -91.412)


def test_t():
    # t : array_like
    input = np.arange(0., 10., 0.1)
    t = parse_time_specification(DimensionlessUnitSystem(), t=input)
    assert (t == input).all()


def test_t_units():
    # t : array_like
    input = np.linspace(0., 10., 100)*u.Gyr
    t = parse_time_specification(galactic, t=input)

    assert np.allclose(t[-1], 10000.)
</file>

<file path="gala/integrate/__init__.py">
from .pyintegrators import *
from .timespec import *
</file>

<file path="gala/integrate/core.py">
""" Base class for integrators. """

from abc import ABCMeta, abstractmethod

# Third-party
import numpy as np
from astropy.utils.decorators import deprecated

# This project
from gala.units import UnitSystem, DimensionlessUnitSystem

__all__ = ["Integrator"]


class Integrator(metaclass=ABCMeta):
    def __init__(
        self,
        func,
        func_args=(),
        func_units=None,
        progress=False,
        store_all=True,
    ):
        if not hasattr(func, "__call__"):
            raise ValueError(
                "func must be a callable object, e.g., a function."
            )

        self.F = func
        self._func_args = func_args

        if func_units is not None and not isinstance(
            func_units, DimensionlessUnitSystem
        ):
            func_units = UnitSystem(func_units)
        else:
            func_units = DimensionlessUnitSystem()
        self._func_units = func_units

        self.progress = bool(progress)
        self.store_all = store_all

    def _get_range_func(self):
        if self.progress:
            try:
                from tqdm import trange
                return trange
            except ImportError:
                raise ImportError(
                    "tqdm must be installed to use progress=True when running "
                    f"{self.__class__.__name__}"
                )

        return range

    def _prepare_ws(self, w0, mmap, n_steps):
        """
        Decide how to make the return array. If ``mmap`` is False, this returns a full
        array of zeros, but with the correct shape as the output. If ``mmap`` is True,
        return a pointer to a memory-mapped array. The latter is particularly useful for
        integrating a large number of orbits or integrating a large number of time
        steps.
        """
        from ..dynamics import PhaseSpacePosition

        if not isinstance(w0, PhaseSpacePosition):
            w0 = PhaseSpacePosition.from_w(w0)

        arr_w0 = w0.w(self._func_units)

        self.ndim, self.norbits = arr_w0.shape
        self.ndim = self.ndim // 2

        if self.store_all:
            return_shape = (2 * self.ndim, n_steps + 1, self.norbits)
        else:
            return_shape = (2 * self.ndim, self.norbits)

        if mmap is None:
            # create the return arrays
            ws = np.zeros(return_shape, dtype=float)

        else:
            if mmap.shape != return_shape:
                raise ValueError(
                    "Shape of memory-mapped array doesn't match expected shape of "
                    f"return array ({mmap.shape} vs {return_shape})"
                )

            if not mmap.flags.writeable:
                raise TypeError(
                    f"Memory-mapped array must be a writable mode, not '{mmap.mode}'"
                )

            ws = mmap

        return w0, arr_w0, ws

    def _handle_output(self, w0, t, w):
        """ """
        if w.shape[-1] == 1:
            w = w[..., 0]

        pos_unit = self._func_units["length"]
        t_unit = self._func_units["time"]
        vel_unit = pos_unit / t_unit

        from ..dynamics import Orbit

        orbit = Orbit(
            pos=w[:self.ndim] * pos_unit,
            vel=w[self.ndim:] * vel_unit,
            t=t * t_unit,
        )
        return orbit

    @deprecated("1.9", alternative="Integrator call method")
    def run(self, w0, mmap=None, **time_spec):
        """Run the integrator starting from the specified phase-space position.

        .. deprecated:: 1.9
            Use the ``__call__`` method instead.
        """
        return self(w0, mmap=mmap, **time_spec)

    @abstractmethod
    def __call__(self, w0, mmap=None, **time_spec):
        """
        Run the integrator starting from the specified phase-space position.
        The initial conditions ``w0`` should be a
        `~gala.dynamics.PhaseSpacePosition` instance.

        There are a few combinations of keyword arguments accepted for
        specifying the timestepping. For example, you can specify a fixed
        timestep (``dt``) and a number of steps (``n_steps``), or an array of
        times::

            dt, n_steps[, t1] : (numeric, int[, numeric])
                A fixed timestep dt and a number of steps to run for.
            dt, t1, t2 : (numeric, numeric, numeric)
                A fixed timestep dt, an initial time, and a final time.
            t : array-like
                An array of times to solve on.

        Parameters
        ----------
        w0 : `~gala.dynamics.PhaseSpacePosition`
            Initial conditions.
        **time_spec
            Timestep information passed to
            `~gala.integrate.time_spec.parse_time_specification`.

        Returns
        -------
        orbit : `~gala.dynamics.Orbit`

        """
        pass
</file>

<file path="gala/integrate/setup_package.py">
from collections import defaultdict
from distutils.core import Extension


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["include_dirs"].append("gala/dynamics/nbody")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/integrate/cyintegrators/leapfrog.pyx")
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    exts.append(Extension("gala.integrate.cyintegrators.leapfrog", **cfg))

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/potential/hamiltonian/src/chamiltonian.c")
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    cfg["sources"].append("gala/integrate/cyintegrators/dop853.pyx")
    cfg["sources"].append("gala/integrate/cyintegrators/dopri/dop853.c")
    exts.append(Extension("gala.integrate.cyintegrators.dop853", **cfg))

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["include_dirs"].append("gala/dynamics/nbody")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/integrate/cyintegrators/ruth4.pyx")
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    exts.append(Extension("gala.integrate.cyintegrators.ruth4", **cfg))

    return exts
</file>

<file path="gala/integrate/timespec.py">
""" Helper function for turning different ways of specifying the integration
    times into an array of times.
"""

# Third-party
import numpy as np

__all__ = ["parse_time_specification"]


def parse_time_specification(units, dt=None, n_steps=None, t1=None, t2=None, t=None):
    """
    Return an array of times given a few combinations of kwargs that are
    accepted -- see below.

    Parameters
    ----------
    dt, n_steps[, t1] : (numeric, int[, numeric])
        A fixed timestep dt and a number of steps to run for.
    dt, t1, t2 : (numeric, numeric, numeric)
        A fixed timestep dt, an initial time, and an final time.
    dt, t1 : (array_like, numeric)
        An array of timesteps dt and an initial time.
    n_steps, t1, t2 : (int, numeric, numeric)
        Number of steps between an initial time, and a final time.
    t : array_like
        An array of times (dts = t[1:] - t[:-1])

    """
    if n_steps is not None:  # parse and validate n_steps
        n_steps = int(n_steps)

    if hasattr(dt, "unit"):
        dt = dt.decompose(units).value

    if hasattr(t1, "unit"):
        t1 = t1.decompose(units).value

    if hasattr(t2, "unit"):
        t2 = t2.decompose(units).value

    if hasattr(t, "unit"):
        t = t.decompose(units).value

    # t : array_like
    if t is not None:
        times = t
        return times.astype(np.float64)

    else:
        if dt is None and (t1 is None or t2 is None or n_steps is None):
            raise ValueError(
                "Invalid specification of integration time. See docstring for more "
                "information."
            )

        # dt, n_steps[, t1] : (numeric, int[, numeric])
        elif dt is not None and n_steps is not None:
            if t1 is None:
                t1 = 0.0

            times = parse_time_specification(units, dt=np.ones(n_steps + 1) * dt, t1=t1)

        # dt, t1, t2 : (numeric, numeric, numeric)
        elif dt is not None and t1 is not None and t2 is not None:
            if t2 < t1 and dt < 0:
                t_i = t1
                times = []
                ii = 0
                while (t_i > t2) and (ii < 1e6):
                    times.append(t_i)
                    t_i += dt

                if times[-1] != t2:
                    times.append(t2)

                return np.array(times, dtype=np.float64)

            elif t2 > t1 and dt > 0:
                t_i = t1
                times = []
                ii = 0
                while (t_i < t2) and (ii < 1e6):
                    times.append(t_i)
                    t_i += dt

                return np.array(times, dtype=np.float64)

            else:
                if dt == 0:
                    raise ValueError("dt must be non-zero.")
                else:
                    raise ValueError(
                        "If t2 < t1, dt must be negative. If t1 < t2, dt must be "
                        "positive."
                    )

        # dt, t1 : (array_like, numeric)
        elif isinstance(dt, np.ndarray) and t1 is not None:
            times = np.cumsum(np.append([0.0], dt)) + t1
            times = times[:-1]

        # n_steps, t1, t2 : (int, numeric, numeric)
        elif dt is None and not (t1 is None or t2 is None or n_steps is None):
            times = np.linspace(t1, t2, n_steps, endpoint=True)

        else:
            raise ValueError("Invalid options. See docstring.")

        return times.astype(np.float64)
</file>

<file path="gala/potential/frame/builtin/__init__.py">
from .frames import StaticFrame, ConstantRotatingFrame
</file>

<file path="gala/potential/frame/builtin/builtin_frames.c">
#include <math.h>
#include <string.h>

/*
    Static, inertial frame
*/
double static_frame_hamiltonian(double t, double *pars, double *qp, int n_dim) {
    int i;
    double E = 0.;

    for (i=0; i<n_dim; i++) {
        E += qp[i+n_dim]*qp[i+n_dim]; // p^2
    }
    return 0.5*E; // kinetic term
}

void static_frame_gradient(double t, double *pars, double *qp, int n_dim, double *dH) {
    int i;

    for (i=0; i < n_dim; i++) {
        dH[i] = qp[n_dim+i]; // qdot = p
    }
}

void static_frame_hessian(double t, double *pars, double *qp, int n_dim, double *d2H) {
    /* TODO: this is just potential Hessian and identity matrix for d2H/dp2*/
}

/*
    Constantly rotating frame
*/
double constant_rotating_frame_hamiltonian_2d(double t, double *pars, double *qp, int n_dim) {
    /*
        Omega = pars
        TODO: this is klugy, n_dim has to equal 2!
    */
    int i;
    double E = 0.;
    double R2;

    for (i=0; i<n_dim; i++) {
        E += 0.5*qp[i+n_dim]*qp[i+n_dim]; // p^2
    }

    R2 = qp[0]*qp[0] + qp[1]*qp[1];
    return E - 0.5 * pars[0]*pars[0] * R2;
}

void constant_rotating_frame_gradient_2d(double t, double *pars, double *qp, int n_dim, double *dH) {
    /*
        TODO: this is klugy, n_dim has to equal 2!
    */
    double Cx, Cy; // used in cross-products below

    // Omega x q
    Cx = -pars[0]*qp[1];
    Cy = pars[0]*qp[0];
    dH[0] = dH[0] + qp[0+n_dim] - Cx;
    dH[1] = dH[1] + qp[1+n_dim] - Cy;

    // Omega x p
    Cx = -pars[0]*qp[1+n_dim];
    Cy = pars[0]*qp[0+n_dim];
    dH[2] = dH[3] + Cx;
    dH[3] = dH[4] + Cy;
}

void constant_rotating_frame_hessian_2d(double t, double *pars, double *qp, int n_dim, double *d2H) {
    /* TODO: */
}

double constant_rotating_frame_hamiltonian_3d(double t, double *pars, double *qp, int n_dim) {
    /*
        Omega = pars
    */
    int i;
    double E = 0.;
    double Lx, Ly, Lz;

    for (i=0; i<n_dim; i++) {
        E += 0.5*qp[i+n_dim]*qp[i+n_dim]; // p^2
    }

    Lx = qp[1]*qp[2+n_dim] - qp[2]*qp[1+n_dim];
    Ly = -qp[0]*qp[2+n_dim] + qp[2]*qp[0+n_dim];
    Lz = qp[0]*qp[1+n_dim] - qp[1]*qp[0+n_dim];

    // kinetic term and effective potential for rotation:
    //  - Omega dot L
    return E - (pars[0]*Lx + pars[1]*Ly + pars[2]*Lz);
}

void constant_rotating_frame_gradient_3d(double t, double *pars, double *qp, int n_dim, double *dH) {
    double Cx, Cy, Cz; // used in cross-products below

    // Omega x q
    Cx = pars[1]*qp[2] - pars[2]*qp[1];
    Cy = -pars[0]*qp[2] + pars[2]*qp[0];
    Cz = pars[0]*qp[1] - pars[1]*qp[0];
    dH[0] = dH[0] + qp[0+n_dim] - Cx;
    dH[1] = dH[1] + qp[1+n_dim] - Cy;
    dH[2] = dH[2] + qp[2+n_dim] - Cz;

    // Omega x p
    Cx = pars[1]*qp[2+n_dim] - pars[2]*qp[1+n_dim];
    Cy = -pars[0]*qp[2+n_dim] + pars[2]*qp[0+n_dim];
    Cz = pars[0]*qp[1+n_dim] - pars[1]*qp[0+n_dim];
    dH[3] = dH[3] + Cx;
    dH[4] = dH[4] + Cy;
    dH[5] = dH[5] + Cz;
}

void constant_rotating_frame_hessian_3d(double t, double *pars, double *qp, int n_dim, double *d2H) {
    /* TODO: */
}
</file>

<file path="gala/potential/frame/builtin/builtin_frames.h">
extern double static_frame_hamiltonian(double t, double *pars, double *qp, int n_dim);
extern void static_frame_gradient(double t, double *pars, double *qp, int n_dim, double *grad);
extern void static_frame_hessian(double t, double *pars, double *qp, int n_dim, double *hess);

extern double constant_rotating_frame_hamiltonian_2d(double t, double *pars, double *qp, int n_dim);
extern void constant_rotating_frame_gradient_2d(double t, double *pars, double *qp, int n_dim, double *grad);
extern void constant_rotating_frame_hessian_2d(double t, double *pars, double *qp, int n_dim, double *hess);

extern double constant_rotating_frame_hamiltonian_3d(double t, double *pars, double *qp, int n_dim);
extern void constant_rotating_frame_gradient_3d(double t, double *pars, double *qp, int n_dim, double *grad);
extern void constant_rotating_frame_hessian_3d(double t, double *pars, double *qp, int n_dim, double *hess);
</file>

<file path="gala/potential/frame/builtin/frames.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

# Third-party
from astropy.utils.misc import isiterable
import astropy.units as u
import numpy as np
cimport numpy as np
np.import_array()

# Project
from ..cframe import CFrameBase
from ..cframe cimport CFrameWrapper
from ...common import PotentialParameter
from ....units import dimensionless, DimensionlessUnitSystem

cdef extern from "src/funcdefs.h":
    ctypedef double (*energyfunc)(double t, double *pars, double *q, int n_dim) nogil
    ctypedef void (*gradientfunc)(double t, double *pars, double *q, int n_dim, double *grad) nogil
    ctypedef void (*hessianfunc)(double t, double *pars, double *q, int n_dim, double *hess) nogil

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        energyfunc energy
        gradientfunc gradient
        hessianfunc hessian

        int n_params
        double *parameters;

cdef extern from "frame/builtin/builtin_frames.h":
    double static_frame_hamiltonian(double t, double *pars, double *qp, int n_dim) nogil
    void static_frame_gradient(double t, double *pars, double *qp, int n_dim, double *grad) nogil
    void static_frame_hessian(double t, double *pars, double *qp, int n_dim, double *hess) nogil

    double constant_rotating_frame_hamiltonian_2d(double t, double *pars, double *qp, int n_dim) nogil
    void constant_rotating_frame_gradient_2d(double t, double *pars, double *qp, int n_dim, double *grad) nogil
    void constant_rotating_frame_hessian_2d(double t, double *pars, double *qp, int n_dim, double *hess) nogil

    double constant_rotating_frame_hamiltonian_3d(double t, double *pars, double *qp, int n_dim) nogil
    void constant_rotating_frame_gradient_3d(double t, double *pars, double *qp, int n_dim, double *grad) nogil
    void constant_rotating_frame_hessian_3d(double t, double *pars, double *qp, int n_dim, double *hess) nogil

__all__ = ['StaticFrame', 'ConstantRotatingFrame']

cdef class StaticFrameWrapper(CFrameWrapper):

    def __init__(self, list params):
        cdef CFrameType cf

        self.init(params)

        cf.energy = <energyfunc>(static_frame_hamiltonian)
        cf.gradient = <gradientfunc>(static_frame_gradient)
        cf.hessian = <hessianfunc>(static_frame_hessian)
        cf.n_params = 0
        cf.parameters = NULL

        self.cframe = cf

class StaticFrame(CFrameBase):
    """
    Represents a static intertial reference frame.

    Parameters
    ----------
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.

    """
    Wrapper = StaticFrameWrapper
    ndim = None

    # NOTE: this is a workaround to allow units as a positional arg for this
    # class, because a lot of existing code assumes that...
    def __init__(self, units=None):
        super().__init__(units=units)

# ---

cdef class ConstantRotatingFrameWrapper2D(CFrameWrapper):

    def __init__(self, list params):
        cdef:
            CFrameType cf

        assert len(params) == 1
        self._params = np.array([params[0]], dtype=np.float64)

        cf.energy = <energyfunc>(constant_rotating_frame_hamiltonian_2d)
        cf.gradient = <gradientfunc>(constant_rotating_frame_gradient_2d)
        cf.hessian = <hessianfunc>(constant_rotating_frame_hessian_2d)
        cf.n_params = 1
        cf.parameters = &(self._params[0])

        self.cframe = cf

cdef class ConstantRotatingFrameWrapper3D(CFrameWrapper):

    def __init__(self, list params):
        cdef:
            CFrameType cf

        assert len(params) == 3
        self._params = np.array([params[0], params[1], params[2]],
                                dtype=np.float64)

        cf.energy = <energyfunc>(constant_rotating_frame_hamiltonian_3d)
        cf.gradient = <gradientfunc>(constant_rotating_frame_gradient_3d)
        cf.hessian = <hessianfunc>(constant_rotating_frame_hessian_3d)
        cf.n_params = 3
        cf.parameters = &(self._params[0])

        self.cframe = cf

class ConstantRotatingFrame(CFrameBase):
    """
    Represents a constantly rotating reference frame.

    The reference frame rotates with constant angular velocity set by the
    magnitude of the vector parameter ``Omega`` around the axis defined by
    the unit vector computed from the input frequency vector.

    Parameters
    ----------
    Omega : :class:`~astropy.units.Quantity`
        The frequency vector, which specifies the axis of rotation and the
        angular velocity of the frame.
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.

    """
    Omega = PotentialParameter('Omega', physical_type='frequency',
                               equivalencies=u.dimensionless_angles())

    def _setup_frame(self, parameters, units=None):
        super()._setup_frame(parameters, units=units)

        Omega = np.atleast_1d(self.parameters['Omega'])

        if Omega.shape == (1,):
            # assumes ndim=2, must be associated with a 2D potential
            self.ndim = 2
            self.Wrapper = ConstantRotatingFrameWrapper2D

        elif Omega.shape == (3,):
            # assumes ndim=3, must be associated with a 3D potential
            self.ndim = 3
            self.Wrapper = ConstantRotatingFrameWrapper3D

        else:
            raise ValueError("Invalid input for rotation vector Omega.")
</file>

<file path="gala/potential/frame/builtin/transformations.py">
# Third-party
from astropy.utils.misc import isiterable
import numpy as np

# Gala
from gala.dynamics import Orbit
from gala.units import DimensionlessUnitSystem

__all__ = ['static_to_constantrotating', 'constantrotating_to_static']


def rodrigues_axis_angle_rotate(x, vec, theta):
    """
    Rotated the input vector or set of vectors `x` around the axis
    `vec` by the angle `theta`.

    Parameters
    ----------
    x : array_like
        The vector or array of vectors to transform. Must have shape


    """
    x = np.array(x).T
    vec = np.array(vec).T
    theta = np.array(theta).T[..., None]

    out = np.cos(theta)*x + np.sin(theta) * np.cross(vec, x) + \
        (1 - np.cos(theta)) * (vec * x).sum(axis=-1)[..., None] * vec

    return out.T


def z_angle_rotate(xy, theta):
    """
    Rotated the input vector or set of vectors `xy` by the angle `theta`.

    Parameters
    ----------
    xy : array_like
        The vector or array of vectors to transform. Must have shape


    """
    xy = np.array(xy).T
    theta = np.array(theta).T

    out = np.zeros_like(xy)
    out[..., 0] = np.cos(theta)*xy[..., 0] - np.sin(theta)*xy[..., 1]
    out[..., 1] = np.sin(theta)*xy[..., 0] + np.cos(theta)*xy[..., 1]

    return out.T


def _constantrotating_static_helper(frame_r, frame_i, w, t=None, sign=1.):
    # TODO: use representation arithmetic instead
    Omega = -frame_r.parameters['Omega'].decompose(frame_i.units).value

    if not isinstance(w, Orbit) and t is None:
        raise ValueError("Time array must be provided if not passing an "
                         "Orbit subclass.")

    if t is None:
        t = w.t

    elif not hasattr(t, 'unit'):
        t = t * frame_i.units['time']

    if t is None:
        raise ValueError('Time must be supplied either through the input '
                         'Orbit class instance or through the t argument.')
    t = t.decompose(frame_i.units).value

    # HACK: this is a little bit crazy...this makes it so that !=3D
    #   representations will work here
    if hasattr(w.pos, 'xyz'):
        pos = w.pos
        vel = w.vel
    else:
        cart = w.cartesian
        pos = cart.pos
        vel = cart.vel

    pos = pos.xyz.decompose(frame_i.units).value
    vel = vel.d_xyz.decompose(frame_i.units).value

    # get rotation angle, axis vs. time
    if isiterable(Omega):  # 3D
        vec = Omega / np.linalg.norm(Omega)
        theta = np.linalg.norm(Omega) * t

        x_i2r = rodrigues_axis_angle_rotate(pos, vec, sign*theta)
        v_i2r = rodrigues_axis_angle_rotate(vel, vec, sign*theta)

    else:  # 2D
        vec = Omega * np.array([0, 0, 1.])
        theta = sign * Omega * t

        x_i2r = z_angle_rotate(pos, theta)
        v_i2r = z_angle_rotate(vel, theta)

    return x_i2r * frame_i.units['length'], v_i2r * frame_i.units['length']/frame_i.units['time']


def static_to_constantrotating(frame_i, frame_r, w, t=None):
    """
    Transform from an inertial static frame to a rotating frame.

    Parameters
    ----------
    frame_i : `~gala.potential.StaticFrame`
    frame_r : `~gala.potential.ConstantRotatingFrame`
    w : `~gala.dynamics.PhaseSpacePosition`, `~gala.dynamics.Orbit`
    t : quantity_like (optional)
        Required if input coordinates are just a phase-space position.

    Returns
    -------
    pos : `~astropy.units.Quantity`
        Position in rotating frame.
    vel : `~astropy.units.Quantity`
        Velocity in rotating frame.
    """
    return _constantrotating_static_helper(frame_r=frame_r, frame_i=frame_i,
                                           w=w, t=t, sign=1.)


def constantrotating_to_static(frame_r, frame_i, w, t=None):
    """
    Transform from a constantly rotating frame to a static, inertial frame.

    Parameters
    ----------
    frame_i : `~gala.potential.StaticFrame`
    frame_r : `~gala.potential.ConstantRotatingFrame`
    w : `~gala.dynamics.PhaseSpacePosition`, `~gala.dynamics.Orbit`
    t : quantity_like (optional)
        Required if input coordinates are just a phase-space position.

    Returns
    -------
    pos : `~astropy.units.Quantity`
        Position in static, inertial frame.
    vel : `~astropy.units.Quantity`
        Velocity in static, inertial frame.
    """
    return _constantrotating_static_helper(frame_r=frame_r, frame_i=frame_i,
                                           w=w, t=t, sign=-1.)


def static_to_static(frame_r, frame_i, w, t=None):
    """
    No-op transform

    Parameters
    ----------
    frame_i : `~gala.potential.StaticFrame`
    frame_r : `~gala.potential.ConstantRotatingFrame`
    w : `~gala.dynamics.PhaseSpacePosition`, `~gala.dynamics.Orbit`
    t : quantity_like (optional)
        Required if input coordinates are just a phase-space position.

    Returns
    -------
    pos : `~astropy.units.Quantity`
        Position in static, inertial frame.
    vel : `~astropy.units.Quantity`
        Velocity in static, inertial frame.
    """
    tmp = [isinstance(frame_r.units, DimensionlessUnitSystem),
           isinstance(frame_i.units, DimensionlessUnitSystem)]
    if not all(tmp) and any(tmp):
        raise ValueError(
            "StaticFrame to StaticFrame transformations are only allowed if "
            "both unit systems are physical, or both are dimensionless.")
    return w.pos.xyz, w.vel.d_xyz
</file>

<file path="gala/potential/frame/src/cframe.c">
#include "frame/src/cframe.h"

double frame_hamiltonian(CFrameType *fr, double t, double *qp, int n_dim) {
    double v = (fr->energy)(t, (fr->parameters), qp, n_dim);
    return v;
}

void frame_gradient(CFrameType *fr, double t, double *qp, int n_dim, double *dH) {
    (fr->gradient)(t, (fr->parameters), qp, n_dim, dH);
}

void frame_hessian(CFrameType *fr, double t, double *qp, int n_dim, double *d2H) {
    // TODO: not implemented!!
    // TODO: can I just add in the terms from the frame here?
    // (fr->hessian)(t, (fr->parameters), qp, n_dim, d2H);
}
</file>

<file path="gala/potential/frame/src/cframe.h">
#include "src/funcdefs.h"

#ifndef _CFRAME_H
#define _CFRAME_H
    // typedef struct CFrameType CFrame;

    typedef struct {
        // arrays of pointers to each of the function types above
        energyfunc energy;
        gradientfunc gradient;
        hessianfunc hessian;

        int n_params;

        // pointer to the parameter array
        double *parameters;
    } CFrameType;
#endif

extern double frame_hamiltonian(CFrameType *fr, double t, double *qp, int n_dim);
extern void frame_gradient(CFrameType *fr, double t, double *qp, int n_dim, double *dH);
extern void frame_hessian(CFrameType *fr, double t, double *qp, int n_dim, double *d2H);
</file>

<file path="gala/potential/frame/tests/test_builtin.py">
import pickle

# Third-party
import astropy.units as u
import pytest

# Project
from ..builtin import StaticFrame, ConstantRotatingFrame
from ....units import galactic, DimensionlessUnitSystem


class TestStaticFrame(object):

    def test_init(self):
        fr = StaticFrame()
        assert isinstance(fr.units, DimensionlessUnitSystem)

        fr = StaticFrame(galactic)

    def test_compare(self):
        fr1 = StaticFrame(galactic)
        fr2 = StaticFrame(galactic)
        assert fr1 == fr2

        fr2 = StaticFrame()
        assert fr1 != fr2

    def test_pickle(self, tmpdir):
        fr1 = StaticFrame(galactic)

        filename = tmpdir / 'static.pkl'
        with open(filename, 'wb') as f:
            pickle.dump(fr1, f)

        with open(filename, 'rb') as f:
            fr2 = pickle.load(f)

        assert fr1 == fr2


class TestConstantRotatingFrame(object):

    def test_init(self):
        fr = ConstantRotatingFrame(Omega=[1E-3, 0., 0.])
        assert isinstance(fr.units, DimensionlessUnitSystem)

        fr = ConstantRotatingFrame(Omega=1E-3)
        assert isinstance(fr.units, DimensionlessUnitSystem)

        with pytest.raises(ValueError):
            fr = ConstantRotatingFrame(Omega=[-13., 1., 40.]*u.km/u.s/u.kpc)

        with pytest.raises(ValueError):
            fr = ConstantRotatingFrame(Omega=40.*u.km/u.s/u.kpc)

        fr = ConstantRotatingFrame(Omega=[-13., 1., 40.]*u.km/u.s/u.kpc,
                                   units=galactic)
        fr = ConstantRotatingFrame(Omega=40.*u.km/u.s/u.kpc,
                                   units=galactic)
        fr = ConstantRotatingFrame([-13., 1., 40.]*u.km/u.s/u.kpc,
                                   units=galactic)

    def test_compare(self):
        # frame comparison
        fr1 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)
        fr2 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)
        fr3 = ConstantRotatingFrame(Omega=[2E-3, 0., 0.]/u.Myr, units=galactic)
        fr4 = ConstantRotatingFrame(Omega=[2E-3, 0., 0.])
        assert fr1 == fr2
        assert fr1 != fr3
        assert fr3 != fr4

        st_fr = StaticFrame(galactic)
        assert st_fr != fr1

        st_fr = StaticFrame(DimensionlessUnitSystem())
        assert st_fr != fr1

    def test_pickle(self, tmpdir):
        fr1 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)

        filename = tmpdir / 'rotating.pkl'
        with open(filename, 'wb') as f:
            pickle.dump(fr1, f)

        with open(filename, 'rb') as f:
            fr2 = pickle.load(f)

        assert fr1 == fr2
</file>

<file path="gala/potential/frame/tests/test_transformations.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..builtin import StaticFrame, ConstantRotatingFrame
from ..builtin.transformations import (static_to_constantrotating,
                                       constantrotating_to_static,
                                       rodrigues_axis_angle_rotate)
from ....dynamics import Orbit, PhaseSpacePosition
from ....units import galactic


def test_axis_angle_rotate():

    for x in [np.random.random(size=(3, 32)),
              np.random.random(size=(3, 32, 8))]:
        vec = np.random.random(size=(3, 32))
        theta = np.random.random(size=(32,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape

        vec = np.random.random(size=(3,))
        theta = np.random.random(size=(32,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape

        vec = np.random.random(size=(3,))
        theta = np.random.random(size=(1,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape


def _helper(fi, fr, w, t=None):

    pos_r, vel_r = static_to_constantrotating(fi, fr, w, t=t)
    if isinstance(w, Orbit):
        w2 = Orbit(pos=pos_r, vel=vel_r, t=t)
    else:
        w2 = PhaseSpacePosition(pos=pos_r, vel=vel_r)
    pos_i, vel_i = constantrotating_to_static(fr, fi, w2, t=t)

    assert u.allclose(pos_i, w.xyz)
    assert u.allclose(vel_i, w.v_xyz)

    pos_i, vel_i = constantrotating_to_static(fr, fi, w, t=t)
    if isinstance(w, Orbit):
        w2 = Orbit(pos=pos_i, vel=vel_i, t=t)
    else:
        w2 = PhaseSpacePosition(pos=pos_i, vel=vel_i)
    pos_r, vel_r = static_to_constantrotating(fi, fr, w2, t=t)

    assert u.allclose(pos_r, w.xyz)
    assert u.allclose(vel_r, w.v_xyz)


def test_frame_transforms_3d():
    frame_i = StaticFrame(units=galactic)
    frame_r = ConstantRotatingFrame(Omega=[0.112, 1.235, 0.8656]*u.rad/u.Myr,
                                    units=galactic)

    w = Orbit(pos=np.random.random(size=(3, 32))*u.kpc,
              vel=np.random.random(size=(3, 32))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = Orbit(pos=np.random.random(size=(3, 32, 8))*u.kpc,
              vel=np.random.random(size=(3, 32, 8))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = PhaseSpacePosition(pos=np.random.random(size=3)*u.kpc,
                           vel=np.random.random(size=3)*u.kpc/u.Myr)
    with pytest.raises(ValueError):
        _helper(frame_i, frame_r, w)
    _helper(frame_i, frame_r, w, t=0.*u.Myr)
    _helper(frame_i, frame_r, w, t=0.)


def test_frame_transforms_2d():
    frame_i = StaticFrame(units=galactic)
    frame_r = ConstantRotatingFrame(Omega=0.529*u.rad/u.Myr,
                                    units=galactic)

    w = Orbit(pos=np.random.random(size=(2, 32))*u.kpc,
              vel=np.random.random(size=(2, 32))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = Orbit(pos=np.random.random(size=(2, 32, 8))*u.kpc,
              vel=np.random.random(size=(2, 32, 8))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = PhaseSpacePosition(pos=np.random.random(size=2)*u.kpc,
                           vel=np.random.random(size=2)*u.kpc/u.Myr)
    with pytest.raises(ValueError):
        _helper(frame_i, frame_r, w)
    _helper(frame_i, frame_r, w, t=0.*u.Myr)
    _helper(frame_i, frame_r, w, t=0.)
</file>

<file path="gala/potential/frame/__init__.py">
from .core import FrameBase
from .cframe import CFrameBase
from .builtin import *
</file>

<file path="gala/potential/frame/cframe.pxd">
# cython: language_level=3

cdef extern from "frame/src/cframe.h":
    ctypedef struct CFrameType:
        pass

    double frame_hamiltonian(CFrameType *fr, double t, double *qp, int n_dim) nogil
    void frame_gradient(CFrameType *fr, double t, double *qp, int n_dim, double *dH) nogil
    void frame_hessian(CFrameType *fr, double t, double *qp, int n_dim, double *d2H) nogil

cdef class CFrameWrapper:
    cdef CFrameType cframe
    cdef double[::1] _params
    cpdef init(self, list parameters)
    cpdef energy(self, double[:,::1] w, double[::1] t)
    cpdef gradient(self, double[:,::1] w, double[::1] t)
    cpdef hessian(self, double[:,::1] w, double[::1] t)
</file>

<file path="gala/potential/frame/cframe.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

__all__ = ['CFrameBase']


# Third-party
import numpy as np
cimport numpy as np
np.import_array()

from .core import FrameBase
from ..potential.cpotential import _validate_pos_arr
from ..potential.cpotential cimport energyfunc, gradientfunc, hessianfunc


cdef class CFrameWrapper:
    """ Wrapper class for C implementation of reference frames. """

    cpdef init(self, list parameters):
        # save the array of parameters so it doesn't get garbage-collected
        self._params = np.array(parameters, dtype=np.float64)

    cpdef energy(self, double[:, ::1] w, double[::1] t):
        """
        w should have shape (n, ndim).
        """
        cdef:
            int n, ndim, i
            CFrameType cf = self.cframe
        n, ndim = _validate_pos_arr(w)

        cdef double [::1] pot = np.zeros(n)
        if len(t) == 1:
            for i in range(n):
                pot[i] = frame_hamiltonian(&cf, t[0], &w[i, 0], ndim//2)
        else:
            for i in range(n):
                pot[i] = frame_hamiltonian(&cf, t[i], &w[i, 0], ndim//2)


        return np.array(pot)

    cpdef gradient(self, double[:, ::1] w, double[::1] t):
        """
        w should have shape (n, ndim).
        """
        cdef:
            int n, ndim, i
            CFrameType cf = self.cframe
        n, ndim = _validate_pos_arr(w)

        cdef double[:, ::1] dH = np.zeros((n, ndim))
        if len(t) == 1:
            for i in range(n):
                frame_gradient(&cf, t[0], &w[i, 0], ndim//2, &dH[i, 0])
        else:
            for i in range(n):
                frame_gradient(&cf, t[i], &w[i, 0], ndim//2, &dH[i, 0])


        return np.array(dH)

    cpdef hessian(self, double[:, ::1] w, double[::1] t):
        """
        w should have shape (n, ndim).
        """
        cdef:
            int n, ndim, i
            CFrameType cf = self.cframe
        n, ndim = _validate_pos_arr(w)

        cdef double[:, :, ::1] d2H = np.zeros((n, ndim, ndim))
        if len(t) == 1:
            for i in range(n):
                frame_hessian(&cf, t[0], &w[i, 0], ndim//2, &d2H[i, 0, 0])
        else:
            for i in range(n):
                frame_hessian(&cf, t[i], &w[i, 0], ndim//2, &d2H[i, 0, 0])

        return np.array(d2H)

    def __reduce__(self):
        return (self.__class__, (list(self._params), ))


class CFrameBase(FrameBase):
    Wrapper = None

    def __init__(self, *args, units=None, **kwargs):
        super().__init__(*args, units=units, **kwargs)
        self._setup_wrapper()

    def _setup_wrapper(self):
        if self.Wrapper is None:
            raise ValueError("C potential wrapper class not defined for "
                             f"potential class {self.__class__}")

        # to support array parameters, but they get unraveled
        arrs = [np.atleast_1d(v.value).ravel()
                for v in self.parameters.values()]

        if len(arrs) > 0:
            self.c_parameters = np.concatenate(arrs)
        else:
            self.c_parameters = np.array([])

        self.c_instance = self.Wrapper(list(self.c_parameters))

    def __str__(self):
        return self.__class__.__name__

    def _energy(self, q, t):
        return self.c_instance.energy(q, t=t)

    def _gradient(self, q, t):
        return self.c_instance.gradient(q, t=t)

    def _density(self, q, t):
        return self.c_instance.density(q, t=t)

    def _hessian(self, q, t):
        return self.c_instance.hessian(q, t=t)
</file>

<file path="gala/potential/frame/core.py">
__all__ = ['FrameBase']

# This package
from ..common import CommonBase


class FrameBase(CommonBase):
    ndim = 3

    def __init__(self, *args, units=None, **kwargs):
        parameter_values = self._parse_parameter_values(*args, **kwargs)
        self._setup_frame(parameters=parameter_values,
                          units=units)

    def _setup_frame(self, parameters, units=None):
        self.units = self._validate_units(units)
        self.parameters = self._prepare_parameters(parameters, self.units)
</file>

<file path="gala/potential/frame/setup_package.py">
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/frame/cframe.pyx')
    cfg['sources'].append('gala/potential/frame/src/cframe.c')
    exts.append(Extension('gala.potential.frame.cframe', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/frame/builtin/frames.pyx')
    cfg['sources'].append('gala/potential/frame/builtin/builtin_frames.c')
    cfg['sources'].append('gala/potential/frame/src/cframe.c')
    exts.append(Extension('gala.potential.frame.builtin.frames', **cfg))

    return exts


def get_package_data():
    return {'gala.potential.frame':
            ['*.h', '*.pyx', '*.pxd', '*/*.pyx', '*/*.pxd',
             'builtin/*.h', 'src/*.h',
             'builtin/builtin_frames.c', 'src/*.c',
             'tests/*.yml']}
</file>

<file path="gala/potential/hamiltonian/src/chamiltonian.c">
#include <math.h>
#include "potential/src/cpotential.h"
#include "frame/src/cframe.h"

double hamiltonian_value(CPotential *p, CFrameType *fr, double t, double *qp) {
    double v = 0;
    int i;

    v = v + (fr->energy)(t, (fr->parameters), qp, p->n_dim);

    for (i=0; i < p->n_components; i++) {
        // TODO: change potential 'value' -> 'energy'
        v = v + (p->value)[i](t, (p->parameters)[i], qp, p->n_dim);
    }

    return v;
}

void hamiltonian_gradient(CPotential *p, CFrameType *fr, double t, double *qp, double *dH) {
    int i;

    for (i=0; i < 2*(p->n_dim); i++) {
        dH[i] = 0.;
    }

    // potential gradient has to be first
    c_gradient(p, t, qp, &(dH[p->n_dim]));

    (fr->gradient)(t, (fr->parameters), qp, p->n_dim, dH);

    for (i=p->n_dim; i < 2*(p->n_dim); i++) {
        dH[i] = -dH[i]; // pdot = -dH/dq
    }
}

void hamiltonian_hessian(CPotential *p, CFrameType *fr, double t, double *qp, double *d2H) {
    int i;

    for (i=0; i < p->n_components; i++) {
        (p->hessian)[i](t, (p->parameters)[i], qp, p->n_dim, d2H);
    }

    // TODO: not implemented!!
    // TODO: can I just add in the terms from the frame here?
    // (fr->hessian)(t, (fr->parameters), qp, p->n_dim, d2H);
}
</file>

<file path="gala/potential/hamiltonian/src/chamiltonian.h">
#include "potential/src/cpotential.h"
#include "frame/src/cframe.h"

extern double hamiltonian_value(CPotential *p, CFrameType *fr, double t, double *q);
extern void hamiltonian_gradient(CPotential *p, CFrameType *fr, double t, double *q, double *grad);
extern void hamiltonian_hessian(CPotential *p, CFrameType *fr, double t, double *q, double *hess);
</file>

<file path="gala/potential/hamiltonian/tests/helpers.py">
# Third-party
import astropy.units as u
import numpy as np

# Project
from ....dynamics import PhaseSpacePosition, Orbit
from ....units import galactic
PSP = PhaseSpacePosition
ORB = Orbit


class _TestBase(object):
    use_half_ndim = False
    E_unit = u.erg/u.kg

    @classmethod
    def setup_class(cls):
        np.random.seed(42)

        ndim = 6
        r_ndim = ndim  # return ndim
        if cls.use_half_ndim:
            r_ndim = r_ndim // 2
        norbits = 16
        ntimes = 8

        # some position or phase-space position arrays we will test methods on:
        cls.w0s = []
        cls.energy_return_shapes = []
        cls.gradient_return_shapes = []
        cls.hessian_return_shapes = []

        # 1D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=ndim//2),
                           vel=np.random.random(size=ndim//2)))
        cls.w0s.append(PSP(pos=np.random.random(size=ndim//2)*u.kpc,
                           vel=np.random.random(size=ndim//2)*u.km/u.s))
        cls.energy_return_shapes += [(1,)]*2
        cls.gradient_return_shapes += [(r_ndim, 1)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, 1)]*2

        # 2D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits)),
                           vel=np.random.random(size=(ndim//2, norbits))))
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits))*u.kpc,
                           vel=np.random.random(size=(ndim//2, norbits))*u.km/u.s))
        cls.energy_return_shapes += [(norbits,)]*2
        cls.gradient_return_shapes += [(r_ndim, norbits)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, norbits)]*2

        # 3D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits, ntimes)),
                           vel=np.random.random(size=(ndim//2, norbits, ntimes))))
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits, ntimes))*u.kpc,
                           vel=np.random.random(size=(ndim//2, norbits, ntimes))*u.km/u.s))
        cls.energy_return_shapes += [(norbits, ntimes)]*2
        cls.gradient_return_shapes += [(r_ndim, norbits, ntimes)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, norbits, ntimes)]*2

        # 2D - orbit
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes)),
                           vel=np.random.random(size=(ndim//2, ntimes))))
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes))*u.kpc,
                           vel=np.random.random(size=(ndim//2, ntimes))*u.km/u.s))
        cls.energy_return_shapes += [(ntimes,)]*2
        cls.gradient_return_shapes += [(r_ndim, ntimes,)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, ntimes,)]*2

        # 3D - orbit
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes, norbits)),
                           vel=np.random.random(size=(ndim//2, ntimes, norbits))))
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes, norbits))*u.kpc,
                           vel=np.random.random(size=(ndim//2, ntimes, norbits))*u.km/u.s))
        cls.energy_return_shapes += [(ntimes, norbits)]*2
        cls.gradient_return_shapes += [(r_ndim, ntimes, norbits)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, ntimes, norbits)]*2

        _obj_w0s = cls.w0s[:]
        for w0, eshp, gshp, hshp in zip(_obj_w0s,
                                        cls.energy_return_shapes,
                                        cls.gradient_return_shapes,
                                        cls.hessian_return_shapes):
            cls.w0s.append(w0.w(galactic))
            cls.energy_return_shapes.append(eshp)
            cls.gradient_return_shapes.append(gshp)
            cls.hessian_return_shapes.append(hshp)

    def test_energy(self):
        for arr, shp in zip(self.w0s, self.energy_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            v = self.obj.energy(arr)
            assert v.shape == shp
            assert v.unit.is_equivalent(self.E_unit)

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            self.obj.energy(arr, t=0.1)
            self.obj.energy(arr, t=t)
            self.obj.energy(arr, t=0.1*self.obj.units['time'])

    def test_gradient(self):
        for arr, shp in zip(self.w0s, self.gradient_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            v = self.obj.gradient(arr)
            assert v.shape == shp
            # TODO: check return units

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            self.obj.gradient(arr, t=0.1)
            self.obj.gradient(arr, t=t)
            self.obj.gradient(arr, t=0.1*self.obj.units['time'])

    def test_hessian(self):
        for arr, shp in zip(self.w0s, self.hessian_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            g = self.obj.hessian(arr)
            assert g.shape == shp
            # TODO: check return units
</file>

<file path="gala/potential/hamiltonian/tests/test_hamiltonian.py">
import pickle

# Third-party
import astropy.units as u
import pytest

# Project
from .. import Hamiltonian
from ...potential.builtin import KeplerPotential
from ...frame.builtin import StaticFrame, ConstantRotatingFrame
from ....units import solarsystem, galactic


def test_init():
    p = KeplerPotential(m=1.)
    f = StaticFrame()
    H = Hamiltonian(potential=p, frame=f)
    H2 = Hamiltonian(H)
    assert H2.potential is H.potential

    p = KeplerPotential(m=1., units=solarsystem)
    f = StaticFrame(units=solarsystem)
    H = Hamiltonian(potential=p, frame=f)
    H = Hamiltonian(potential=p)

    p = KeplerPotential(m=1.)
    f = StaticFrame(galactic)
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)

    p = KeplerPotential(m=1., units=solarsystem)
    f = StaticFrame()
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)

    p = KeplerPotential(m=1., units=solarsystem)
    f = ConstantRotatingFrame(Omega=1./u.yr, units=solarsystem)
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)


def test_pickle(tmpdir):
    filename = tmpdir / 'hamil.pkl'

    p = KeplerPotential(m=1., units=solarsystem)

    for fr in [StaticFrame(units=solarsystem),
               ConstantRotatingFrame(Omega=[0, 0, 1]/u.yr, units=solarsystem)]:
        H = Hamiltonian(potential=p, frame=fr)

        with open(filename, 'wb') as f:
            pickle.dump(H, f)

        with open(filename, 'rb') as f:
            H2 = pickle.load(f)
</file>

<file path="gala/potential/hamiltonian/tests/test_with_frame_potential.py">
# Third-party
import astropy.units as u
import pytest
import numpy as np

# Project
from .helpers import _TestBase
from .. import Hamiltonian
from ...potential.builtin import NFWPotential, KeplerPotential, HernquistPotential
from ...frame.builtin import StaticFrame, ConstantRotatingFrame
from ....units import galactic, dimensionless
from ....dynamics import PhaseSpacePosition, Orbit
from ....integrate import DOPRI853Integrator

# ----------------------------------------------------------------------------


def to_rotating_frame(omega, w, t=None):
    """
    TODO: figure out units shit for omega and t
    TODO: move this to be a ConstantRotatingFrame method
    """

    if not hasattr(omega, 'unit'):
        raise TypeError("Input frequency vector must be a Quantity object.")

    try:
        omega = omega.to(u.rad/u.Myr, equivalencies=u.dimensionless_angles()).value
    except:  # noqa
        omega = omega.value

    if isinstance(w, Orbit) and t is not None:
        raise TypeError("If passing in an Orbit object, do not also specify "
                        "a time array, t.")

    elif not isinstance(w, Orbit) and t is None:
        raise TypeError("If not passing in an Orbit object, you must also specify "
                        "a time array, t.")

    elif t is not None and not hasattr(t, 'unit'):
        raise TypeError("Input time must be a Quantity object.")

    if t is not None:
        t = np.atleast_1d(t)  # works with Quantity's
    else:
        t = w.t

    try:
        t = t.to(u.Myr).value
    except:  # noqa
        t = t.value

    if isinstance(w, PhaseSpacePosition) or isinstance(w, Orbit):
        Cls = w.__class__
        x_shape = w.xyz.shape
        x_unit = w.x.unit
        v_unit = w.v_x.unit

        x = w.xyz.reshape(3, -1).value
        v = w.v_xyz.reshape(3, -1).value

    else:
        Cls = None
        ndim = w.shape[0]
        x_shape = (ndim//2,) + w.shape[1:]
        x = w[:ndim//2]
        v = w[ndim//2:]

        if hasattr(x, 'unit'):
            raise TypeError("If w is not an Orbit or PhaseSpacePosition, w "
                            "cannot have units!")

        x_unit = u.one
        v_unit = u.one

    # now need to compute rotation vector, ee, and angle, theta
    ee = omega / np.linalg.norm(omega)
    theta = (np.linalg.norm(omega) * t)[None]

    # we use Rodrigues' rotation formula to rotate the position
    x_rot = np.cos(theta)*x + np.sin(theta)*np.cross(ee, x, axisa=0, axisb=0, axisc=0) \
        + (1 - np.cos(theta)) * np.einsum("i, ij->j", ee, x) * ee[:, None]

    v_cor = np.cross(omega, x, axisa=0, axisb=0, axisc=0) * x_unit
    v_rot = v - v_cor.to(v_unit, u.dimensionless_angles()).value

    x_rot = x_rot.reshape(x_shape) * x_unit
    v_rot = v_rot.reshape(x_shape) * v_unit

    if Cls is None:
        return np.vstack((x_rot, v_rot))

    else:
        if issubclass(Cls, Orbit):
            return Cls(pos=x_rot, vel=v_rot, t=t)
        else:
            return Cls(pos=x_rot, vel=v_rot)

# ----------------------------------------------------------------------------


class TestWithPotentialStaticFrame(_TestBase):
    obj = Hamiltonian(NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.,
                                                          units=galactic),
                      StaticFrame(units=galactic))

    @pytest.mark.skip("Not implemented")
    def test_hessian(self):
        pass


class TestKeplerRotatingFrame(_TestBase):
    Omega = [0., 0, 1.]*u.one
    E_unit = u.one
    obj = Hamiltonian(KeplerPotential(m=1., units=dimensionless),
                      ConstantRotatingFrame(Omega=Omega, units=dimensionless))

    @pytest.mark.skip("Not implemented")
    def test_hessian(self):
        pass

    def test_integrate(self):

        w0 = PhaseSpacePosition(pos=[1., 0, 0.], vel=[0, 1., 0.])

        for bl in [True, False]:
            orbit = self.obj.integrate_orbit(w0, dt=1., n_steps=1000,
                                             cython_if_possible=bl,
                                             Integrator=DOPRI853Integrator)

            assert np.allclose(orbit.x.value, 1., atol=1E-7)
            assert np.allclose(orbit.xyz.value[1:], 0., atol=1E-7)


class TestKepler2RotatingFrame(_TestBase):
    Omega = [1., 1., 1.]*u.one
    E_unit = u.one
    obj = Hamiltonian(KeplerPotential(m=1., units=dimensionless),
                      ConstantRotatingFrame(Omega=Omega, units=dimensionless))

    @pytest.mark.skip("Not implemented")
    def test_hessian(self):
        pass

    def test_integrate(self):

        # --------------------------------------------------------------
        # when Omega is off from orbital frequency
        #
        w0 = PhaseSpacePosition(pos=[1., 0, 0.], vel=[0, 1.1, 0.])

        for bl in [True, False]:
            orbit = self.obj.integrate_orbit(w0, dt=0.1, n_steps=10000,
                                             cython_if_possible=bl,
                                             Integrator=DOPRI853Integrator)

            L = orbit.angular_momentum()
            C = orbit.energy() - np.sum(self.Omega[:, None] * L, axis=0)
            dC = np.abs((C[1:]-C[0])/C[0])
            assert np.all(dC < 1E-9)  # conserve Jacobi constant


@pytest.mark.parametrize("name, Omega, tol", [
    ("z-aligned co-rotating", [0, 0, 1.]*u.one, 1E-12),
    ("z-aligned", [0, 0, 1.5834]*u.one, 1E-12),
    ("random", [0.95792653, 0.82760659, 0.66443135]*u.one, 1E-10),
])
def test_velocity_rot_frame(name, Omega, tol):
    # _i = inertial
    # _r = rotating

    r0 = 1.245246
    potential = HernquistPotential(m=1., c=0.2, units=dimensionless)
    vc = potential.circular_velocity([r0, 0, 0]).value[0]
    w0 = PhaseSpacePosition(pos=[r0, 0, 0.],
                            vel=[0, vc, 0.])
    Omega = Omega * [1., 1., vc/r0]

    H_r = Hamiltonian(potential, ConstantRotatingFrame(Omega=Omega, units=dimensionless))
    H = Hamiltonian(potential, StaticFrame(units=dimensionless))

    orbit_i = H.integrate_orbit(w0, dt=0.1, n_steps=1000, Integrator=DOPRI853Integrator)
    orbit_r = H_r.integrate_orbit(w0, dt=0.1, n_steps=1000, Integrator=DOPRI853Integrator)

    orbit_i2r = orbit_i.to_frame(ConstantRotatingFrame(Omega=Omega, units=dimensionless))
    orbit_r2i = orbit_r.to_frame(StaticFrame(units=dimensionless))

    assert u.allclose(orbit_i.xyz, orbit_r2i.xyz, atol=tol)
    assert u.allclose(orbit_i.v_xyz, orbit_r2i.v_xyz, atol=tol)

    assert u.allclose(orbit_r.xyz, orbit_i2r.xyz, atol=tol)
    assert u.allclose(orbit_r.v_xyz, orbit_i2r.v_xyz, atol=tol)
</file>

<file path="gala/potential/hamiltonian/__init__.py">
from .chamiltonian import *
</file>

<file path="gala/potential/hamiltonian/chamiltonian.pyx">
# cython: language_level=3

# Standard-library
import warnings

# Third-party
import numpy as np
import astropy.units as u

# Project
from ..common import CommonBase
from ..potential import PotentialBase, CPotentialBase
from ..frame import FrameBase, CFrameBase, StaticFrame
from ...integrate import LeapfrogIntegrator, DOPRI853Integrator, Ruth4Integrator

__all__ = ["Hamiltonian"]


class Hamiltonian(CommonBase):
    """
    Represents a composition of a gravitational potential and a reference frame.

    This class is used to integrate orbits and compute quantities when working
    in non-inertial reference frames. The input potential and frame objects
    must have the same dimensionality and the same unit system. If both the
    potential and the frame are implemented in C, numerical orbit integration
    will use the C-implemented integrators and will be fast (to check if your
    object is C-enabled, check the ``.c_enabled`` attribute).

    Parameters
    ----------
    potential : :class:`~gala.potential.potential.PotentialBase` subclass
        The gravitational potential.
    frame : :class:`~gala.potential.frame.FrameBase` subclass (optional)
        The reference frame.

    """
    def __init__(self, potential, frame=None):
        if isinstance(potential, Hamiltonian):
            frame = potential.frame
            potential = potential.potential

        if frame is None:
            frame = StaticFrame(units=potential.units)

        elif not isinstance(frame, FrameBase):
            raise ValueError("Invalid input for reference frame. Must be a "
                             "FrameBase subclass.")

        if not isinstance(potential, PotentialBase):
            raise ValueError("Invalid input for potential. Must be a "
                             "PotentialBase subclass.")

        self.potential = potential
        self.frame = frame
        self._pot_ndim = self.potential.ndim
        self.ndim = 2 * self._pot_ndim

        if frame is not None:
            if frame.units != potential.units:
                raise ValueError(
                    "Potential and Frame must have compatible unit systems "
                    f"({potential.units} vs {frame.units})")

            if frame.ndim is not None and frame.ndim != potential.ndim:
                raise ValueError(
                    "Potential and Frame must have compatible phase-space "
                    f"dimensionality ({potential.ndim} vs {frame.ndim})")

        # TODO: document this attribute
        if isinstance(self.potential, CPotentialBase) and isinstance(self.frame, CFrameBase):
            self.c_enabled = True

        else:
            self.c_enabled = False

    @property
    def units(self):
        return self.potential.units

    def _energy(self, w, t):
        pot_E = self.potential._energy(np.ascontiguousarray(w[:, :self._pot_ndim]), t=t)
        other_E = self.frame._energy(w, t=t)
        return pot_E + other_E

    def _gradient(self, w, t):
        q = np.ascontiguousarray(w[:, :self._pot_ndim])

        dH = np.zeros_like(w)

        # extra terms from the frame
        dH += self.frame._gradient(w, t=t)
        dH[:, self._pot_ndim:] += self.potential._gradient(q, t=t)
        for i in range(self._pot_ndim):
            dH[:, self._pot_ndim+i] = -dH[:, self._pot_ndim+i]

        return dH

    def _hessian(self, w, t):
        raise NotImplementedError()

    # ========================================================================
    # Core methods that use the above implemented functions
    #
    def energy(self, w, t=0.):
        """
        Compute the energy (the value of the Hamiltonian) at the given phase-space position(s).

        Parameters
        ----------
        w : `~gala.dynamics.PhaseSpacePosition`, array_like
            The phase-space position to compute the value of the Hamiltonian.
            If the input object has no units (i.e. is an `~numpy.ndarray`), it
            is assumed to be in the same unit system as the potential class.

        Returns
        -------
        H : `~astropy.units.Quantity`
            Energy per unit mass or value of the Hamiltonian. If the input
            phase-space position has shape ``w.shape``, the output energy
            will have shape ``w.shape[1:]``.
        """
        w = self._remove_units_prepare_shape(w)
        orig_shape, w = self._get_c_valid_arr(w)
        t = self._validate_prepare_time(t, w)
        return self._energy(w, t=t).T.reshape(orig_shape[1:]) * self.units['energy'] / self.units['mass']

    def gradient(self, w, t=0.):
        """
        Compute the gradient of the Hamiltonian at the given phase-space position(s).

        Parameters
        ----------
        w : `~gala.dynamics.PhaseSpacePosition`, array_like
            The phase-space position to compute the value of the Hamiltonian.
            If the input object has no units (i.e. is an `~numpy.ndarray`), it
            is assumed to be in the same unit system as the potential class.

        Returns
        -------
        TODO: this can't return a quantity, because units are different dH/dq vs. dH/dp
        grad : `~astropy.units.Quantity`
            The gradient of the potential. Will have the same shape as
            the input phase-space position, ``w``.
        """
        w = self._remove_units_prepare_shape(w)
        orig_shape, w = self._get_c_valid_arr(w)
        t = self._validate_prepare_time(t, w)

        # TODO: wat do about units here?
        # ret_unit = self.units['length'] / self.units['time']**2
        return self._gradient(w, t=t).T.reshape(orig_shape)

    def hessian(self, w, t=0.):
        """
        Compute the Hessian of the Hamiltonian at the given phase-space position(s).

        Parameters
        ----------
        w : `~gala.dynamics.PhaseSpacePosition`, array_like
            The phase-space position to compute the value of the Hamiltonian.
            If the input object has no units (i.e. is an `~numpy.ndarray`), it
            is assumed to be in the same unit system as the potential class.

        Returns
        -------
        # TODO: see TODO about units about
        hess : `~astropy.units.Quantity`
            The Hessian matrix of second derivatives of the potential. If the input
            position has shape ``w.shape``, the output energy will have shape
            ``(w.shape[0],w.shape[0]) + w.shape[1:]``. That is, an ``n_dim`` by
            ``n_dim`` array (matrix) for each position, where the dimensionality of
            phase-space is ``n_dim``.
        """
        raise NotImplementedError()

    # def jacobi_energy(self, w, t=0.):
    #     """
    #     TODO: docstring
    #     TODO: if not rotating frame, raise error
    #     """

    #     if not isinstance(self.frame, gp.ConstantRotatingFrame):
    #         raise TypeError("The frame must be a ConstantRotatingFrame "
    #                         "to compute the Jacobi energy.")

    #     w = self._remove_units_prepare_shape(w)
    #     orig_shape, w = self._get_c_valid_arr(w)
    #     t = self._validate_prepare_time(t, w)

    #     E = self._energy(w, t=t).T.reshape(orig_shape[1:])
    #     L = np.cross(w[:, :3], w[:, 3:])

    #     Omega = self.frame.parameters['Omega']
    #     C = E - np.einsum('i, ...i->...', Omega, L).reshape(E.shape)
    #     return C * self.units['energy'] / self.units['mass']

    # ========================================================================
    # Python special methods
    #
    def __call__(self, w):
        return self.energy(w)

    # def __repr__(self):
    #     pars = ""
    #     keys = self.parameters.keys()

    #     for k in keys:
    #         v = self.parameters[k].value
    #         par_fmt = "{}"
    #         post = ""

    #         if hasattr(v,'unit'):
    #             post = " {}".format(v.unit)
    #             v = v.value

    #         if isinstance(v, float):
    #             if v == 0:
    #                 par_fmt = "{:.0f}"
    #             elif np.log10(v) < -2 or np.log10(v) > 5:
    #                 par_fmt = "{:.2e}"
    #             else:
    #                 par_fmt = "{:.2f}"

    #         elif isinstance(v, int) and np.log10(v) > 5:
    #             par_fmt = "{:.2e}"

    #         pars += ("{}=" + par_fmt + post).format(k, v) + ", "

    #     if isinstance(self.units, DimensionlessUnitSystem):
    #         return "<{}: {} (dimensionless)>".format(self.__class__.__name__, pars.rstrip(", "))
    #     else:
    #         return "<{}: {} ({})>".format(self.__class__.__name__, pars.rstrip(", "), ",".join(map(str, self.units._core_units)))

    def __str__(self):
        return self.__class__.__name__

    def __eq__(self, other):
        return (self.potential == other.potential) and (self.frame == other.frame)

    def __ne__(self, other):
        return not self.__eq__(other)

    def integrate_orbit(self,
        w0,
        Integrator=None,
        Integrator_kwargs=dict(),
        cython_if_possible=True,
        store_all=True,
        **time_spec
    ):
        """
        Integrate an orbit in the current potential using the integrator class
        provided. Uses same time specification as `Integrator.run()` -- see
        the documentation for `gala.integrate` for more information.

        Parameters
        ----------
        w0 : `~gala.dynamics.PhaseSpacePosition`, array_like
            Initial conditions.
        Integrator : `~gala.integrate.Integrator` (optional)
            Integrator class to use. By default, uses
            `~gala.integrate.LeapfrogIntegrator` if the frame is static and
            `~gala.integrate.DOPRI853Integrator` else.
        Integrator_kwargs : dict (optional)
            Any extra keyword argumets to pass to the integrator class
            when initializing. Only works in non-Cython mode.
        cython_if_possible : bool (optional)
            If there is a Cython version of the integrator implemented,
            and the potential object has a C instance, using Cython
            will be *much* faster.
        store_all : bool (optional)
            Controls whether to store the phase-space position at all intermediate
            timesteps. Set to False to store only the final values (i.e. the
            phase-space position(s) at the final timestep). Default is True.
        **time_spec
            Specification of how long to integrate. Most commonly, this is a
            timestep ``dt`` and number of steps ``n_steps``, or a timestep
            ``dt``, initial time ``t1``, and final time ``t2``. You may also
            pass in a time array with ``t``. See documentation for
            `~gala.integrate.parse_time_specification` for more information.

        Returns
        -------
        orbit : `~gala.dynamics.Orbit`

        """
        from gala.dynamics import PhaseSpacePosition, Orbit

        if Integrator is None and isinstance(self.frame, StaticFrame):
            Integrator = LeapfrogIntegrator
        elif Integrator is None:
            Integrator = DOPRI853Integrator
        else:
            # use the Integrator provided
            pass

        symplectic_integrators = [LeapfrogIntegrator, Ruth4Integrator]
        if (Integrator in symplectic_integrators and
                not isinstance(self.frame, StaticFrame)):
            warnings.warn(
                "Using a symplectic integrator with a non-static frame can "
                "lead to wildly incorrect orbits. It is recommended that you "
                "use DOPRI853Integrator instead.", RuntimeWarning)

        if not isinstance(w0, PhaseSpacePosition):
            w0 = np.asarray(w0)
            ndim = w0.shape[0]//2
            w0 = PhaseSpacePosition(pos=w0[:ndim], vel=w0[ndim:])

        ndim = w0.ndim
        arr_w0 = w0.w(self.units)
        arr_w0 = self._remove_units_prepare_shape(arr_w0)
        orig_shape, arr_w0 = self._get_c_valid_arr(arr_w0)

        if self.c_enabled and cython_if_possible:
            # array of times
            from ...integrate.timespec import parse_time_specification
            t = np.ascontiguousarray(parse_time_specification(self.units, **time_spec))

            # TODO: these replacements should be defined in gala.integrate...
            if Integrator == LeapfrogIntegrator:
                from ...integrate.cyintegrators import leapfrog_integrate_hamiltonian
                t, w = leapfrog_integrate_hamiltonian(self, arr_w0, t, store_all=store_all)

            elif Integrator == Ruth4Integrator:
                from ...integrate.cyintegrators import ruth4_integrate_hamiltonian
                t, w = ruth4_integrate_hamiltonian(self, arr_w0, t, store_all=store_all)

            elif Integrator == DOPRI853Integrator:
                from ...integrate.cyintegrators import dop853_integrate_hamiltonian
                t, w = dop853_integrate_hamiltonian(
                    self, arr_w0, t,
                    Integrator_kwargs.get('atol', 1E-10),
                    Integrator_kwargs.get('rtol', 1E-10),
                    Integrator_kwargs.get('nmax', 0),
                    Integrator_kwargs.get('progress', False),
                    store_all=store_all
                )
            else:
                raise ValueError(f"Cython integration not supported for '{Integrator!r}'")

            # because shape is different from normal integrator return
            w = np.rollaxis(w, -1)
            if w.shape[-1] == 1:
                w = w[..., 0]

        else:
            def F(t, w):
                # TODO: these Transposes are shitty and probably make it much slower?
                w_T = np.ascontiguousarray(w.T)
                return self._gradient(w_T, t=np.array([t])).T
            integrator = Integrator(F, func_units=self.units, **Integrator_kwargs)
            orbit = integrator(arr_w0.T, **time_spec)
            orbit.potential = self.potential
            orbit.frame = self.frame
            return orbit

        if not store_all:
            w = w[:, None]

        try:
            tunit = self.units['time']
        except (TypeError, AttributeError):
            tunit = u.dimensionless_unscaled

        return Orbit.from_w(w=w, units=self.units, t=t*tunit,
                            hamiltonian=self)

    # def save(self, f):
    #     """
    #     Save the potential to a text file. See :func:`~gala.potential.save`
    #     for more information.

    #     Parameters
    #     ----------
    #     f : str, file_like
    #         A filename or file-like object to write the input potential object to.

    #     """
    #     from .io import save
    #     save(self, f)
</file>

<file path="gala/potential/hamiltonian/setup_package.py">
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    cfg = defaultdict(list)
    cfg['include_dirs'].append(np.get_include())
    cfg['include_dirs'].append(mac_incl_path)
    cfg['include_dirs'].append('gala/potential')
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/hamiltonian/chamiltonian.pyx')
    cfg['sources'].append('gala/potential/hamiltonian/src/chamiltonian.c')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    exts.append(Extension('gala.potential.hamiltonian.chamiltonian', **cfg))

    return exts


def get_package_data():

    return {'gala.potential.hamiltonian':
            ['src/*.h', 'src/*.c', '*.pyx', '*.pxd']}
</file>

<file path="gala/potential/potential/builtin/__init__.py">
from .pybuiltin import *
from .special import *
from .core import *
</file>

<file path="gala/potential/potential/builtin/builtin_potentials.c">
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "extra_compile_macros.h"

#if USE_GSL == 1
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_math.h>
#endif

double nan_density(double t, double *pars, double *q, int n_dim) { return NAN; }
double nan_value(double t, double *pars, double *q, int n_dim) { return NAN; }
void nan_gradient(double t, double *pars, double *q, int n_dim, double *grad) {}
void nan_hessian(double t, double *pars, double *q, int n_dim, double *hess) {}

double null_density(double t, double *pars, double *q, int n_dim) { return 0; }
double null_value(double t, double *pars, double *q, int n_dim) { return 0; }
void null_gradient(double t, double *pars, double *q, int n_dim, double *grad){}
void null_hessian(double t, double *pars, double *q, int n_dim, double *hess) {}

/* Note: many Hessians generated with sympy in
    gala-notebooks/Make-all-Hessians.ipynb
*/

/* ---------------------------------------------------------------------------
    Henon-Heiles potential
*/
double henon_heiles_value(double t, double *pars, double *q, int n_dim) {
    /*  no parameters... */
    return 0.5 * (q[0]*q[0] + q[1]*q[1] + 2*q[0]*q[0]*q[1] - 2/3.*q[1]*q[1]*q[1]);
}

void henon_heiles_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  no parameters... */
    grad[0] = grad[0] + q[0] + 2*q[0]*q[1];
    grad[1] = grad[1] + q[1] + q[0]*q[0] - q[1]*q[1];
}

void henon_heiles_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  no parameters... */
    double x = q[0];
    double y = q[1];

    double tmp_0 = 2.0 * y;
    double tmp_1 = 2.0 * x;

    hess[0] = hess[0] + tmp_0 + 1.0;
    hess[1] = hess[1] + tmp_1;
    hess[2] = hess[2] + tmp_1;
    hess[3] = hess[3] + 1.0 - tmp_0;
}

/* ---------------------------------------------------------------------------
    Kepler potential
*/
double kepler_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
    */
    double R;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    return -pars[0] * pars[1] / R;
}

void kepler_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
    */
    double R, fac;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    fac = pars[0] * pars[1] / (R*R*R);

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2];
}

double kepler_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
    */
    double r2;
    r2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];

    if (r2 == 0.) {
        return INFINITY;
    } else {
        return 0.;
    }
}

void kepler_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
    */
    double G = pars[0];
    double m = pars[1];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = G*m;
    double tmp_5 = tmp_4/pow(tmp_3, 3.0/2.0);
    double tmp_6 = 3*tmp_4/pow(tmp_3, 5.0/2.0);
    double tmp_7 = tmp_6*x;
    double tmp_8 = -tmp_7*y;
    double tmp_9 = -tmp_7*z;
    double tmp_10 = -tmp_6*y*z;

    hess[0] = hess[0] + -tmp_0*tmp_6 + tmp_5;
    hess[1] = hess[1] + tmp_8;
    hess[2] = hess[2] + tmp_9;
    hess[3] = hess[3] + tmp_8;
    hess[4] = hess[4] + -tmp_1*tmp_6 + tmp_5;
    hess[5] = hess[5] + tmp_10;
    hess[6] = hess[6] + tmp_9;
    hess[7] = hess[7] + tmp_10;
    hess[8] = hess[8] + -tmp_2*tmp_6 + tmp_5;
}

/* ---------------------------------------------------------------------------
    Isochrone potential
*/
double isochrone_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (core scale)
    */
    double R2;
    R2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];
    return -pars[0] * pars[1] / (sqrt(R2 + pars[2]*pars[2]) + pars[2]);
}

void isochrone_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (core scale)
    */
    double sqrt_r2_b2, fac, denom;
    sqrt_r2_b2 = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + pars[2]*pars[2]);
    denom = sqrt_r2_b2 * (sqrt_r2_b2 + pars[2])*(sqrt_r2_b2 + pars[2]);
    fac = pars[0] * pars[1] / denom;

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2];
}

double isochrone_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (core scale)
    */
    double r2, a, b;
    b = pars[2];
    r2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];
    a = sqrt(b*b + r2);

    return pars[1] * (3*(b+a)*a*a - r2*(b+3*a)) / (4*M_PI*pow(b+a,3)*a*a*a);
}

void isochrone_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (length scale)
    */
    double G = pars[0];
    double m = pars[1];
    double b = pars[2];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = pow(b, 2) + tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = sqrt(tmp_3);
    double tmp_5 = b + tmp_4;
    double tmp_6 = G*m;
    double tmp_7 = tmp_6/pow(tmp_5, 2);
    double tmp_8 = tmp_7/tmp_4;
    double tmp_9 = 2*tmp_6/(tmp_3*pow(tmp_5, 3));
    double tmp_10 = tmp_7/pow(tmp_3, 3.0/2.0);
    double tmp_11 = tmp_9*x;
    double tmp_12 = tmp_10*x;
    double tmp_13 = -tmp_11*y - tmp_12*y;
    double tmp_14 = -tmp_11*z - tmp_12*z;
    double tmp_15 = y*z;
    double tmp_16 = -tmp_10*tmp_15 - tmp_15*tmp_9;

    hess[0] = hess[0] + -tmp_0*tmp_10 - tmp_0*tmp_9 + tmp_8;
    hess[1] = hess[1] + tmp_13;
    hess[2] = hess[2] + tmp_14;
    hess[3] = hess[3] + tmp_13;
    hess[4] = hess[4] + -tmp_1*tmp_10 - tmp_1*tmp_9 + tmp_8;
    hess[5] = hess[5] + tmp_16;
    hess[6] = hess[6] + tmp_14;
    hess[7] = hess[7] + tmp_16;
    hess[8] = hess[8] + -tmp_10*tmp_2 - tmp_2*tmp_9 + tmp_8;

}

/* ---------------------------------------------------------------------------
    Hernquist sphere
*/
double hernquist_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double R;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    return -pars[0] * pars[1] / (R + pars[2]);
}

void hernquist_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double R, fac;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    fac = pars[0] * pars[1] / ((R + pars[2]) * (R + pars[2]) * R);

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2];
}

double hernquist_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double r, rho0;
    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    rho0 = pars[1]/(2*M_PI*pars[2]*pars[2]*pars[2]);
    return rho0 / ((r/pars[2]) * pow(1+r/pars[2],3));
}

void hernquist_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double G = pars[0];
    double m = pars[1];
    double c = pars[2];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = sqrt(tmp_3);
    double tmp_5 = c + tmp_4;
    double tmp_6 = G*m;
    double tmp_7 = tmp_6/pow(tmp_5, 2);
    double tmp_8 = tmp_7/tmp_4;
    double tmp_9 = 2*tmp_6/(tmp_3*pow(tmp_5, 3));
    double tmp_10 = tmp_7/pow(tmp_3, 3.0/2.0);
    double tmp_11 = tmp_9*x;
    double tmp_12 = tmp_10*x;
    double tmp_13 = -tmp_11*y - tmp_12*y;
    double tmp_14 = -tmp_11*z - tmp_12*z;
    double tmp_15 = y*z;
    double tmp_16 = -tmp_10*tmp_15 - tmp_15*tmp_9;

    hess[0] = hess[0] + -tmp_0*tmp_10 - tmp_0*tmp_9 + tmp_8;
    hess[1] = hess[1] + tmp_13;
    hess[2] = hess[2] + tmp_14;
    hess[3] = hess[3] + tmp_13;
    hess[4] = hess[4] + -tmp_1*tmp_10 - tmp_1*tmp_9 + tmp_8;
    hess[5] = hess[5] + tmp_16;
    hess[6] = hess[6] + tmp_14;
    hess[7] = hess[7] + tmp_16;
    hess[8] = hess[8] + -tmp_10*tmp_2 - tmp_2*tmp_9 + tmp_8;
}


/* ---------------------------------------------------------------------------
    Plummer sphere
*/
double plummer_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (length scale)
    */
    double R2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];
    return -pars[0]*pars[1] / sqrt(R2 + pars[2]*pars[2]);
}

void plummer_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (length scale)
    */
    double R2b, fac;
    R2b = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + pars[2]*pars[2];
    fac = pars[0] * pars[1] / sqrt(R2b) / R2b;

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2];
}

double plummer_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (length scale)
    */
    double r2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];
    return 3*pars[1] / (4*M_PI*pars[2]*pars[2]*pars[2]) * pow(1 + r2/(pars[2]*pars[2]), -2.5);
}

void plummer_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - b (length scale)
    */
    double G = pars[0];
    double m = pars[1];
    double b = pars[2];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = pow(b, 2) + tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = G*m;
    double tmp_5 = tmp_4/pow(tmp_3, 3.0/2.0);
    double tmp_6 = 3*tmp_4/pow(tmp_3, 5.0/2.0);
    double tmp_7 = tmp_6*x;
    double tmp_8 = -tmp_7*y;
    double tmp_9 = -tmp_7*z;
    double tmp_10 = -tmp_6*y*z;

    hess[0] = hess[0] + -tmp_0*tmp_6 + tmp_5;
    hess[1] = hess[1] + tmp_8;
    hess[2] = hess[2] + tmp_9;
    hess[3] = hess[3] + tmp_8;
    hess[4] = hess[4] + -tmp_1*tmp_6 + tmp_5;
    hess[5] = hess[5] + tmp_10;
    hess[6] = hess[6] + tmp_9;
    hess[7] = hess[7] + tmp_10;
    hess[8] = hess[8] + -tmp_2*tmp_6 + tmp_5;
}

/* ---------------------------------------------------------------------------
    Jaffe sphere
*/
double jaffe_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double R;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    return -pars[0] * pars[1] / pars[2] * log(1 + pars[2]/R);
}

void jaffe_gradient(double t, double *pars, double *q, int n_dim, double *grad){
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double R, fac;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    fac = pars[0] * pars[1] / pars[2] * (pars[2] / (R * (pars[2] + R)));

    grad[0] = grad[0] + fac*q[0]/R;
    grad[1] = grad[1] + fac*q[1]/R;
    grad[2] = grad[2] + fac*q[2]/R;
}

double jaffe_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double r, rho0;
    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    rho0 = pars[1] / (4*M_PI*pars[2]*pars[2]*pars[2]);
    return rho0 / (pow(r/pars[2],2) * pow(1+r/pars[2],2));
}

void jaffe_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - c (length scale)
    */
    double G = pars[0];
    double m = pars[1];
    double c = pars[2];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = 1.0/tmp_3;
    double tmp_5 = sqrt(tmp_3);
    double tmp_6 = c + tmp_5;
    double tmp_7 = pow(tmp_6, -2);
    double tmp_8 = tmp_7*x;
    double tmp_9 = 1.0/tmp_5;
    double tmp_10 = 1.0/tmp_6;
    double tmp_11 = tmp_10*tmp_9;
    double tmp_12 = G*m/c;
    double tmp_13 = tmp_12*(tmp_11*x - tmp_8);
    double tmp_14 = tmp_13*tmp_4;
    double tmp_15 = pow(tmp_3, -3.0/2.0);
    double tmp_16 = tmp_13*tmp_15*tmp_6;
    double tmp_17 = tmp_10*tmp_15;
    double tmp_18 = tmp_4*tmp_7;
    double tmp_19 = 2*tmp_9/pow(tmp_6, 3);
    double tmp_20 = tmp_11 - tmp_7;
    double tmp_21 = tmp_12*tmp_6;
    double tmp_22 = tmp_21*tmp_9;
    double tmp_23 = tmp_19*x;
    double tmp_24 = tmp_4*tmp_8;
    double tmp_25 = tmp_17*x;
    double tmp_26 = tmp_14*y - tmp_16*y + tmp_22*(tmp_23*y - tmp_24*y - tmp_25*y);
    double tmp_27 = tmp_4*z;
    double tmp_28 = tmp_13*tmp_27 - tmp_16*z + tmp_22*(tmp_23*z - tmp_24*z - tmp_25*z);
    double tmp_29 = tmp_7*y;
    double tmp_30 = tmp_11*y - tmp_29;
    double tmp_31 = tmp_12*tmp_30;
    double tmp_32 = tmp_15*tmp_21;
    double tmp_33 = tmp_30*tmp_32;
    double tmp_34 = y*z;
    double tmp_35 = tmp_22*(-tmp_17*tmp_34 + tmp_19*tmp_34 - tmp_27*tmp_29) + tmp_27*tmp_31 - tmp_33*z;
    double tmp_36 = tmp_11*z - tmp_7*z;

    hess[0] = hess[0] + tmp_14*x - tmp_16*x + tmp_22*(-tmp_0*tmp_17 - tmp_0*tmp_18 + tmp_0*tmp_19 + tmp_20);
    hess[1] = hess[1] + tmp_26;
    hess[2] = hess[2] + tmp_28;
    hess[3] = hess[3] + tmp_26;
    hess[4] = hess[4] + tmp_22*(-tmp_1*tmp_17 - tmp_1*tmp_18 + tmp_1*tmp_19 + tmp_20) + tmp_31*tmp_4*y - tmp_33*y;
    hess[5] = hess[5] + tmp_35;
    hess[6] = hess[6] + tmp_28;
    hess[7] = hess[7] + tmp_35;
    hess[8] = hess[8] + tmp_12*tmp_27*tmp_36 + tmp_22*(-tmp_17*tmp_2 - tmp_18*tmp_2 + tmp_19*tmp_2 + tmp_20) - tmp_32*tmp_36*z;
}

/* ---------------------------------------------------------------------------
    Power-law potential with exponential cutoff
*/
#if USE_GSL == 1

double safe_gamma_inc(double a, double x) {
    int N, m, n;
    double A = 1.;
    double B = 0.;
    double tmp;

    if (a > 0) {
        return gsl_sf_gamma_inc_P(a, x) * gsl_sf_gamma(a);;
    } else {
        N = (int) ceil(-a);

        for (n=0; n < N; n++) {
            A = A * (a + n);

            tmp = 1.;
            for (m=N-1; m > n; m--) {
                tmp = tmp * (a + m);
            }
            B = B + pow(x, a+n) * exp(-x) * tmp;
        }
        return (B + gsl_sf_gamma_inc_P(a + N, x) * gsl_sf_gamma(a + N)) / A;
    }
}

double powerlawcutoff_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            0 - G (Gravitational constant)
            1 - m (total mass)
            2 - a (power-law index)
            3 - c (cutoff radius)
    */
    double G = pars[0];
    double m = pars[1];
    double alpha = pars[2];
    double r_c = pars[3];
    double x = q[0];
    double y = q[1];
    double z = q[2];
    double r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);

    if (r == 0.) {
        return -INFINITY;
    } else {
        double tmp_0 = (1.0/2.0)*alpha;
        double tmp_1 = -tmp_0;
        double tmp_2 = tmp_1 + 1.5;
        double tmp_3 = pow(x, 2) + pow(y, 2) + pow(z, 2);
        double tmp_4 = tmp_3/pow(r_c, 2);
        double tmp_5 = G*m;
        double tmp_6 = tmp_5*safe_gamma_inc(tmp_2, tmp_4)/(sqrt(tmp_3)*tgamma(tmp_1 + 2.5));
        return tmp_0*tmp_6 - 3.0/2.0*tmp_6 + tmp_5*safe_gamma_inc(tmp_1 + 1, tmp_4)/(r_c*tgamma(tmp_2));
    }
}

double powerlawcutoff_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            0 - G (Gravitational constant)
            1 - m (total mass)
            2 - a (power-law index)
            3 - c (cutoff radius)
    */
    double r, A;
    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    A = pars[1] / (2*M_PI) * pow(pars[3], pars[2] - 3) / gsl_sf_gamma(0.5 * (3 - pars[2]));
    return A * pow(r, -pars[2]) * exp(-r*r / (pars[3]*pars[3]));
}

void powerlawcutoff_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            0 - G (Gravitational constant)
            1 - m (total mass)
            2 - a (power-law index)
            3 - c (cutoff radius)
    */
    double r, dPhi_dr;
    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    dPhi_dr = (pars[0] * pars[1] / (r*r) *
        gsl_sf_gamma_inc_P(0.5 * (3-pars[2]), r*r/(pars[3]*pars[3]))); // / gsl_sf_gamma(0.5 * (3-pars[2])));

    grad[0] = grad[0] + dPhi_dr * q[0]/r;
    grad[1] = grad[1] + dPhi_dr * q[1]/r;
    grad[2] = grad[2] + dPhi_dr * q[2]/r;
}

void powerlawcutoff_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - alpha (exponent)
            - r_c (cutoff radius)
    */
    double G = pars[0];
    double m = pars[1];
    double alpha = pars[2];
    double r_c = pars[3];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = (1.0/2.0)*alpha;
    double tmp_5 = -tmp_4;
    double tmp_6 = tmp_5 + 1.5;
    double tmp_7 = pow(r_c, -2);
    double tmp_8 = tmp_3*tmp_7;
    double tmp_9 = G*m;
    double tmp_10 = tmp_9/tgamma(tmp_5 + 2.5);
    double tmp_11 = tmp_10*safe_gamma_inc(tmp_6, tmp_8);
    double tmp_12 = tmp_11/pow(tmp_3, 5.0/2.0);
    double tmp_13 = (9.0/2.0)*tmp_12;
    double tmp_14 = exp(-tmp_8);
    double tmp_15 = tmp_0*tmp_14;
    double tmp_16 = pow(tmp_8, -tmp_4)*tmp_9/tgamma(tmp_6);
    double tmp_17 = 4*tmp_16/pow(r_c, 5);
    double tmp_18 = alpha*tmp_0;
    double tmp_19 = (3.0/2.0)*tmp_12;
    double tmp_20 = 6*tmp_15;
    double tmp_21 = pow(r_c, -4);
    double tmp_22 = tmp_5 + 0.5;
    double tmp_23 = pow(tmp_8, tmp_22);
    double tmp_24 = tmp_10*tmp_23/sqrt(tmp_3);
    double tmp_25 = tmp_21*tmp_24;
    double tmp_26 = pow(tmp_3, -3.0/2.0);
    double tmp_27 = tmp_10*tmp_23*tmp_26*tmp_7;
    double tmp_28 = tmp_20*tmp_27;
    double tmp_29 = 2*tmp_14;
    double tmp_30 = tmp_18*tmp_29;
    double tmp_31 = tmp_16*tmp_29/pow(r_c, 3);
    double tmp_32 = tmp_31/tmp_3;
    double tmp_33 = tmp_27*tmp_30;
    double tmp_34 = tmp_11*tmp_26;
    double tmp_35 = tmp_14*tmp_24;
    double tmp_36 = tmp_35*tmp_7;
    double tmp_37 = alpha*tmp_36 + tmp_31 - tmp_34*tmp_4 + (3.0/2.0)*tmp_34 - 3*tmp_36;
    double tmp_38 = tmp_13*x;
    double tmp_39 = alpha*tmp_19;
    double tmp_40 = x*y;
    double tmp_41 = tmp_14*tmp_17;
    double tmp_42 = alpha*tmp_40;
    double tmp_43 = tmp_21*tmp_35;
    double tmp_44 = 6*tmp_40;
    double tmp_45 = tmp_14*tmp_27;
    double tmp_46 = tmp_44*tmp_45;
    double tmp_47 = tmp_29*tmp_42;
    double tmp_48 = tmp_27*tmp_47;
    double tmp_49 = -tmp_22*tmp_46 + tmp_22*tmp_48 - tmp_25*tmp_47 - tmp_32*tmp_42 - tmp_38*y + tmp_39*tmp_40 - tmp_40*tmp_41 + tmp_43*tmp_44 + tmp_46 - tmp_48;
    double tmp_50 = x*z;
    double tmp_51 = alpha*tmp_50;
    double tmp_52 = 6*tmp_50;
    double tmp_53 = tmp_45*tmp_52;
    double tmp_54 = tmp_29*tmp_51;
    double tmp_55 = tmp_27*tmp_54;
    double tmp_56 = -tmp_22*tmp_53 + tmp_22*tmp_55 - tmp_25*tmp_54 - tmp_32*tmp_51 - tmp_38*z + tmp_39*tmp_50 - tmp_41*tmp_50 + tmp_43*tmp_52 + tmp_53 - tmp_55;
    double tmp_57 = 6*tmp_1;
    double tmp_58 = tmp_45*tmp_57;
    double tmp_59 = alpha*tmp_1;
    double tmp_60 = tmp_29*tmp_59;
    double tmp_61 = tmp_27*tmp_60;
    double tmp_62 = y*z;
    double tmp_63 = alpha*tmp_62;
    double tmp_64 = 6*tmp_62;
    double tmp_65 = tmp_45*tmp_64;
    double tmp_66 = tmp_29*tmp_63;
    double tmp_67 = tmp_27*tmp_66;
    double tmp_68 = -tmp_13*tmp_62 - tmp_22*tmp_65 + tmp_22*tmp_67 - tmp_25*tmp_66 - tmp_32*tmp_63 + tmp_39*tmp_62 - tmp_41*tmp_62 + tmp_43*tmp_64 + tmp_65 - tmp_67;
    double tmp_69 = 6*tmp_2;
    double tmp_70 = tmp_45*tmp_69;
    double tmp_71 = alpha*tmp_2;
    double tmp_72 = tmp_29*tmp_71;
    double tmp_73 = tmp_27*tmp_72;

    hess[0] = hess[0] + -tmp_0*tmp_13 - tmp_15*tmp_17 + tmp_18*tmp_19 - tmp_18*tmp_32 + tmp_20*tmp_25 - tmp_22*tmp_28 + tmp_22*tmp_33 - tmp_25*tmp_30 + tmp_28 - tmp_33 + tmp_37;
    hess[1] = hess[1] + tmp_49;
    hess[2] = hess[2] + tmp_56;
    hess[3] = hess[3] + tmp_49;
    hess[4] = hess[4] + -tmp_1*tmp_13 + tmp_1*tmp_39 - tmp_1*tmp_41 - tmp_22*tmp_58 + tmp_22*tmp_61 - tmp_25*tmp_60 - tmp_32*tmp_59 + tmp_37 + tmp_43*tmp_57 + tmp_58 - tmp_61;
    hess[5] = hess[5] + tmp_68;
    hess[6] = hess[6] + tmp_56;
    hess[7] = hess[7] + tmp_68;
    hess[8] = hess[8] + -tmp_13*tmp_2 + tmp_2*tmp_39 - tmp_2*tmp_41 - tmp_22*tmp_70 + tmp_22*tmp_73 - tmp_25*tmp_72 - tmp_32*tmp_71 + tmp_37 + tmp_43*tmp_69 + tmp_70 - tmp_73;
}

#endif

/* ---------------------------------------------------------------------------
    Stone-Ostriker potential from Stone & Ostriker (2015)
*/
double stone_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - M (total mass)
            - r_c (core radius)
            - r_h (halo radius)
    */
    double r, u_c, u_h, fac;

    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    u_c = r / pars[2];
    u_h = r / pars[3];

    fac = 2*pars[0]*pars[1] / M_PI / (pars[3] - pars[2]);

    if (r == 0) {
        return -fac * 0.5 * log(pars[3]*pars[3] / (pars[2] * pars[2]));
    } else {
        return -fac * (
            atan(u_h)/u_h - atan(u_c)/u_c +
            0.5*log((r*r + pars[3]*pars[3])/(r*r + pars[2]*pars[2]))
        );
    }

}

void stone_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - M (total mass)
            - r_c (core radius)
            - r_h (halo radius)
    */
    double r, u_c, u_h, fac, dphi_dr;

    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    u_c = r / pars[2];
    u_h = r / pars[3];

    fac = 2*pars[0]*pars[1] / (M_PI*r*r) / (pars[2] - pars[3]);  // order flipped from value
    dphi_dr = fac * (pars[2]*atan(u_c) - pars[3]*atan(u_h));

    grad[0] = grad[0] + dphi_dr*q[0]/r;
    grad[1] = grad[1] + dphi_dr*q[1]/r;
    grad[2] = grad[2] + dphi_dr*q[2]/r;
}

double stone_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - M (total mass)
            - r_c (core radius)
            - r_h (halo radius)
    */
    double r, u_c, u_t, rho;
    rho = pars[1] * (pars[2] + pars[3]) / (2*M_PI*M_PI*pars[2]*pars[2]*pars[3]*pars[3]);

    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    u_c = r / pars[2];
    u_t = r / pars[3];

    return rho / ((1 + u_c*u_c)*(1 + u_t*u_t));
}

void stone_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_c (core radius)
            - r_h (halo radius)
    */
    double G = pars[0];
    double m = pars[1];
    double r_c = pars[2];
    double r_h = pars[3];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(r_h, 2);
    double tmp_1 = 1.0/tmp_0;
    double tmp_2 = pow(x, 2);
    double tmp_3 = pow(y, 2);
    double tmp_4 = pow(z, 2);
    double tmp_5 = tmp_2 + tmp_3 + tmp_4;
    double tmp_6 = tmp_1*tmp_5 + 1;
    double tmp_7 = 1.0/tmp_6;
    double tmp_8 = 3/pow(tmp_5, 2);
    double tmp_9 = tmp_2*tmp_8;
    double tmp_10 = pow(r_c, 2);
    double tmp_11 = 1.0/tmp_10;
    double tmp_12 = tmp_11*tmp_5 + 1;
    double tmp_13 = 1.0/tmp_12;
    double tmp_14 = tmp_10 + tmp_5;
    double tmp_15 = pow(tmp_14, -2);
    double tmp_16 = 8*tmp_15;
    double tmp_17 = tmp_0 + tmp_5;
    double tmp_18 = 8*tmp_17/pow(tmp_14, 3);
    double tmp_19 = 2/tmp_14;
    double tmp_20 = 2*tmp_15*tmp_17;
    double tmp_21 = tmp_19 - tmp_20;
    double tmp_22 = 1.0/tmp_17;
    double tmp_23 = 0.5*tmp_14*tmp_22;
    double tmp_24 = tmp_19*x - tmp_20*x;
    double tmp_25 = 1.0*tmp_22;
    double tmp_26 = tmp_24*tmp_25;
    double tmp_27 = sqrt(tmp_5);
    double tmp_28 = r_c*atan(tmp_27/r_c);
    double tmp_29 = 3/pow(tmp_5, 5.0/2.0);
    double tmp_30 = tmp_2*tmp_29;
    double tmp_31 = 1.0/tmp_5;
    double tmp_32 = 2*tmp_31;
    double tmp_33 = tmp_2*tmp_32;
    double tmp_34 = tmp_1/pow(tmp_6, 2);
    double tmp_35 = tmp_11/pow(tmp_12, 2);
    double tmp_36 = r_h*atan(tmp_27/r_h);
    double tmp_37 = 1.0*tmp_14/pow(tmp_17, 2);
    double tmp_38 = tmp_24*tmp_37;
    double tmp_39 = pow(tmp_5, -3.0/2.0);
    double tmp_40 = -tmp_13*tmp_31 + tmp_28*tmp_39 + tmp_31*tmp_7 - tmp_36*tmp_39;
    double tmp_41 = 2*G*m/(-3.1415926535897931*r_c + 3.1415926535897931*r_h);
    double tmp_42 = x*y;
    double tmp_43 = tmp_42*tmp_8;
    double tmp_44 = tmp_29*tmp_42;
    double tmp_45 = tmp_32*tmp_42;
    double tmp_46 = tmp_16*x;
    double tmp_47 = -tmp_41*(tmp_13*tmp_43 + tmp_23*(tmp_18*tmp_42 - tmp_46*y) + tmp_26*y - tmp_28*tmp_44 - tmp_34*tmp_45 + tmp_35*tmp_45 + tmp_36*tmp_44 - tmp_38*y - tmp_43*tmp_7);
    double tmp_48 = x*z;
    double tmp_49 = tmp_48*tmp_8;
    double tmp_50 = tmp_29*tmp_48;
    double tmp_51 = tmp_32*tmp_48;
    double tmp_52 = -tmp_41*(tmp_13*tmp_49 + tmp_23*(tmp_18*tmp_48 - tmp_46*z) + tmp_26*z - tmp_28*tmp_50 - tmp_34*tmp_51 + tmp_35*tmp_51 + tmp_36*tmp_50 - tmp_38*z - tmp_49*tmp_7);
    double tmp_53 = tmp_3*tmp_8;
    double tmp_54 = tmp_19*y - tmp_20*y;
    double tmp_55 = tmp_25*tmp_54;
    double tmp_56 = tmp_29*tmp_3;
    double tmp_57 = tmp_3*tmp_32;
    double tmp_58 = tmp_37*tmp_54;
    double tmp_59 = y*z;
    double tmp_60 = tmp_59*tmp_8;
    double tmp_61 = tmp_29*tmp_59;
    double tmp_62 = tmp_32*tmp_59;
    double tmp_63 = -tmp_41*(tmp_13*tmp_60 + tmp_23*(-tmp_16*tmp_59 + tmp_18*tmp_59) - tmp_28*tmp_61 - tmp_34*tmp_62 + tmp_35*tmp_62 + tmp_36*tmp_61 + tmp_55*z - tmp_58*z - tmp_60*tmp_7);
    double tmp_64 = tmp_4*tmp_8;
    double tmp_65 = z*(tmp_19*z - tmp_20*z);
    double tmp_66 = tmp_29*tmp_4;
    double tmp_67 = tmp_32*tmp_4;

    hess[0] = hess[0] + -tmp_41*(tmp_13*tmp_9 + tmp_23*(-tmp_16*tmp_2 + tmp_18*tmp_2 + tmp_21) + tmp_26*x - tmp_28*tmp_30 + tmp_30*tmp_36 - tmp_33*tmp_34 + tmp_33*tmp_35 - tmp_38*x + tmp_40 - tmp_7*tmp_9);
    hess[1] = hess[1] + tmp_47;
    hess[2] = hess[2] + tmp_52;
    hess[3] = hess[3] + tmp_47;
    hess[4] = hess[4] + -tmp_41*(tmp_13*tmp_53 + tmp_23*(-tmp_16*tmp_3 + tmp_18*tmp_3 + tmp_21) - tmp_28*tmp_56 - tmp_34*tmp_57 + tmp_35*tmp_57 + tmp_36*tmp_56 + tmp_40 - tmp_53*tmp_7 + tmp_55*y - tmp_58*y);
    hess[5] = hess[5] + tmp_63;
    hess[6] = hess[6] + tmp_52;
    hess[7] = hess[7] + tmp_63;
    hess[8] = hess[8] + -tmp_41*(tmp_13*tmp_64 + tmp_23*(-tmp_16*tmp_4 + tmp_18*tmp_4 + tmp_21) + tmp_25*tmp_65 - tmp_28*tmp_66 - tmp_34*tmp_67 + tmp_35*tmp_67 + tmp_36*tmp_66 - tmp_37*tmp_65 + tmp_40 - tmp_64*tmp_7);
}

/* ---------------------------------------------------------------------------
    Spherical NFW
*/
double sphericalnfw_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
    */
    double u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = -pars[0] * pars[1] / pars[2];
    u = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]) / pars[2];
    if (u == 0) {
        return v_h2;
    } else {
        return v_h2 * log(1 + u) / u;
    }
}

void sphericalnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
    */
    double fac, u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = pars[0] * pars[1] / pars[2];

    u = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]) / pars[2];
    fac = v_h2 / (u*u*u) / (pars[2]*pars[2]) * (log(1+u) - u/(1+u));

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2];
}

double sphericalnfw_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
    */
    // double v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    double v_h2 = pars[0] * pars[1] / pars[2];
    double r, rho0;
    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);

    rho0 = v_h2 / (4*M_PI*pars[0]*pars[2]*pars[2]);
    return rho0 / ((r/pars[2]) * pow(1+r/pars[2],2));
}

void sphericalnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
    */
    double G = pars[0];
    double m = pars[1];
    double r_s = pars[2];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = tmp_0 + tmp_1 + tmp_2;
    double tmp_4 = pow(tmp_3, 7);
    double tmp_5 = 3*tmp_0;
    double tmp_6 = sqrt(tmp_3);
    double tmp_7 = r_s + tmp_6;
    double tmp_8 = pow(tmp_3, 13.0/2.0)*tmp_7;
    double tmp_9 = pow(tmp_7, 2);
    double tmp_10 = 1.0/r_s;
    double tmp_11 = tmp_9*log(tmp_10*tmp_7);
    double tmp_12 = tmp_11*pow(tmp_3, 6);
    double tmp_13 = tmp_11*tmp_4 - pow(tmp_3, 15.0/2.0)*tmp_7;
    double tmp_14 = G*m;
    double tmp_15 = tmp_14/tmp_9;
    double tmp_16 = tmp_15/pow(tmp_3, 17.0/2.0);
    double tmp_17 = x*y;
    double tmp_18 = 4*tmp_15/pow(tmp_3, 3.0/2.0);
    double tmp_19 = 3*tmp_17;
    double tmp_20 = r_s*tmp_15/pow(tmp_3, 2);
    double tmp_21 = tmp_14*log(tmp_10*tmp_6 + 1)/pow(tmp_3, 5.0/2.0);
    double tmp_22 = tmp_17*tmp_18 + tmp_19*tmp_20 - tmp_19*tmp_21;
    double tmp_23 = x*z;
    double tmp_24 = 3*tmp_20;
    double tmp_25 = 3*tmp_21;
    double tmp_26 = tmp_18*tmp_23 + tmp_23*tmp_24 - tmp_23*tmp_25;
    double tmp_27 = 3*tmp_8;
    double tmp_28 = 3*tmp_12;
    double tmp_29 = y*z;
    double tmp_30 = tmp_18*tmp_29 + tmp_24*tmp_29 - tmp_25*tmp_29;

    hess[0] = hess[0] + tmp_16*(tmp_0*tmp_4 - tmp_12*tmp_5 + tmp_13 + tmp_5*tmp_8);
    hess[1] = hess[1] + tmp_22;
    hess[2] = hess[2] + tmp_26;
    hess[3] = hess[3] + tmp_22;
    hess[4] = hess[4] + tmp_16*(tmp_1*tmp_27 - tmp_1*tmp_28 + tmp_1*tmp_4 + tmp_13);
    hess[5] = hess[5] + tmp_30;
    hess[6] = hess[6] + tmp_26;
    hess[7] = hess[7] + tmp_30;
    hess[8] = hess[8] + tmp_16*(tmp_13 + tmp_2*tmp_27 - tmp_2*tmp_28 + tmp_2*tmp_4);
}

/* ---------------------------------------------------------------------------
    Flattened NFW
*/
double flattenednfw_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (scale mass)
            - r_s (scale radius)
            - a (ignore)
            - b (ignore)
            - c (z flattening)
    */
    double u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = -pars[0] * pars[1] / pars[2];
    u = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]/(pars[5]*pars[5])) / pars[2];
    if (u == 0) {
        return v_h2;
    } else {
        return v_h2 * log(1 + u) / u;
    }
}

void flattenednfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (scale mass)
            - r_s (scale radius)
            - a (ignore)
            - b (ignore)
            - c (z flattening)
    */
    double fac, u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = pars[0] * pars[1] / pars[2];
    u = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]/(pars[5]*pars[5])) / pars[2];

    fac = v_h2 / (u*u*u) / (pars[2]*pars[2]) * (log(1+u) - u/(1+u));

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2]/(pars[5]*pars[5]);
}

void flattenednfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
            - a (ignore)
            - b (ignore)
            - c (z flattening)
    */
    double G = pars[0];
    double m = pars[1];
    double r_s = pars[2];
    double c = pars[5];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(z, 2);
    double tmp_2 = pow(c, 2);
    double tmp_3 = pow(y, 2);
    double tmp_4 = tmp_1 + tmp_2*(tmp_0 + tmp_3);
    double tmp_5 = pow(tmp_4, 4);
    double tmp_6 = 3*tmp_0;
    double tmp_7 = tmp_4/tmp_2;
    double tmp_8 = sqrt(tmp_7);
    double tmp_9 = r_s + tmp_8;
    double tmp_10 = pow(c, 8);
    double tmp_11 = tmp_10*tmp_9;
    double tmp_12 = tmp_11*pow(tmp_7, 7.0/2.0);
    double tmp_13 = pow(tmp_4, 3);
    double tmp_14 = pow(tmp_9, 2);
    double tmp_15 = tmp_14*log(tmp_9/r_s);
    double tmp_16 = tmp_15*tmp_2;
    double tmp_17 = -tmp_11*pow(tmp_7, 9.0/2.0) + tmp_15*tmp_5;
    double tmp_18 = G*m/tmp_14;
    double tmp_19 = tmp_18/pow(tmp_7, 11.0/2.0);
    double tmp_20 = tmp_19/tmp_10;
    double tmp_21 = pow(c, 4);
    double tmp_22 = pow(tmp_4, 2);
    double tmp_23 = 3*tmp_9;
    double tmp_24 = pow(tmp_7, 3.0/2.0);
    double tmp_25 = tmp_18*x;
    double tmp_26 = tmp_21*tmp_25*y*(-3*tmp_15*tmp_21*tmp_24 + tmp_21*pow(tmp_7, 5.0/2.0) + tmp_22*tmp_23)/tmp_5;
    double tmp_27 = 3*tmp_16;
    double tmp_28 = tmp_2*z*(tmp_2*tmp_24 + tmp_23*tmp_4 - tmp_27*tmp_8)/tmp_13;
    double tmp_29 = tmp_25*tmp_28;
    double tmp_30 = tmp_18*tmp_28*y;

    hess[0] = hess[0] + tmp_20*(tmp_0*tmp_5 + tmp_12*tmp_6 - tmp_13*tmp_16*tmp_6 + tmp_17);
    hess[1] = hess[1] + tmp_26;
    hess[2] = hess[2] + tmp_29;
    hess[3] = hess[3] + tmp_26;
    hess[4] = hess[4] + tmp_20*(3*tmp_12*tmp_3 - tmp_13*tmp_27*tmp_3 + tmp_17 + tmp_3*tmp_5);
    hess[5] = hess[5] + tmp_30;
    hess[6] = hess[6] + tmp_29;
    hess[7] = hess[7] + tmp_30;
    hess[8] = hess[8] + tmp_13*tmp_19*(tmp_1*tmp_2*tmp_23*tmp_8 - tmp_1*tmp_27 + tmp_1*tmp_4 + tmp_16*tmp_4 - tmp_22*tmp_9/tmp_8)/pow(c, 12);

}

/* ---------------------------------------------------------------------------
    Triaxial NFW - triaxiality in potential!
*/
double triaxialnfw_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (scale mass)
            - r_s (scale radius)
            - a (major axis)
            - b (intermediate axis)
            - c (minor axis)
    */
    double u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = -pars[0] * pars[1] / pars[2];
    u = sqrt(q[0]*q[0]/(pars[3]*pars[3])
           + q[1]*q[1]/(pars[4]*pars[4])
           + q[2]*q[2]/(pars[5]*pars[5])) / pars[2];

    if (u == 0) {
        return v_h2;
    } else {
        return v_h2 * log(1 + u) / u;
    }
}

void triaxialnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - v_c (circular velocity at the scale radius)
            - r_s (scale radius)
            - a (major axis)
            - b (intermediate axis)
            - c (minor axis)
    */
    double fac, u, v_h2;
    // v_h2 = pars[1]*pars[1] / (log(2.) - 0.5);
    v_h2 = pars[0] * pars[1] / pars[2];
    u = sqrt(q[0]*q[0]/(pars[3]*pars[3])
           + q[1]*q[1]/(pars[4]*pars[4])
           + q[2]*q[2]/(pars[5]*pars[5])) / pars[2];

    fac = v_h2 / (u*u*u) / (pars[2]*pars[2]) * (log(1+u) - u/(1+u));

    grad[0] = grad[0] + fac*q[0]/(pars[3]*pars[3]);
    grad[1] = grad[1] + fac*q[1]/(pars[4]*pars[4]);
    grad[2] = grad[2] + fac*q[2]/(pars[5]*pars[5]);
}

void triaxialnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - r_s (scale radius)
            - a (major axis)
            - b (intermediate axis)
            - c (minor axis)
    */
    double G = pars[0];
    double m = pars[1];
    double r_s = pars[2];
    double a = pars[3];
    double b = pars[4];
    double c = pars[5];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(a, -2);
    double tmp_1 = G*m;
    double tmp_2 = tmp_0*tmp_1;
    double tmp_3 = pow(x, 2);
    double tmp_4 = pow(b, -2);
    double tmp_5 = pow(y, 2);
    double tmp_6 = pow(c, -2);
    double tmp_7 = pow(z, 2);
    double tmp_8 = tmp_0*tmp_3 + tmp_4*tmp_5 + tmp_6*tmp_7;
    double tmp_9 = pow(tmp_8, -3.0/2.0);
    double tmp_10 = 1.0/r_s;
    double tmp_11 = tmp_10*sqrt(tmp_8) + 1;
    double tmp_12 = log(tmp_11);
    double tmp_13 = tmp_12*tmp_9;
    double tmp_14 = tmp_3/pow(a, 4);
    double tmp_15 = 3*tmp_1;
    double tmp_16 = tmp_12/pow(tmp_8, 5.0/2.0);
    double tmp_17 = tmp_15*tmp_16;
    double tmp_18 = tmp_10/tmp_11;
    double tmp_19 = tmp_18/tmp_8;
    double tmp_20 = tmp_9/(pow(r_s, 2)*pow(tmp_11, 2));
    double tmp_21 = tmp_1*tmp_20;
    double tmp_22 = tmp_18/pow(tmp_8, 2);
    double tmp_23 = tmp_15*tmp_22;
    double tmp_24 = tmp_4*y;
    double tmp_25 = tmp_2*x;
    double tmp_26 = 3*tmp_25;
    double tmp_27 = tmp_16*tmp_26;
    double tmp_28 = tmp_20*tmp_25;
    double tmp_29 = tmp_22*tmp_26;
    double tmp_30 = -tmp_24*tmp_27 + tmp_24*tmp_28 + tmp_24*tmp_29;
    double tmp_31 = tmp_6*z;
    double tmp_32 = -tmp_27*tmp_31 + tmp_28*tmp_31 + tmp_29*tmp_31;
    double tmp_33 = tmp_1*tmp_13;
    double tmp_34 = tmp_5/pow(b, 4);
    double tmp_35 = tmp_1*tmp_19;
    double tmp_36 = tmp_24*tmp_31;
    double tmp_37 = -tmp_17*tmp_36 + tmp_21*tmp_36 + tmp_23*tmp_36;
    double tmp_38 = tmp_7/pow(c, 4);

    hess[0] = hess[0] + tmp_13*tmp_2 - tmp_14*tmp_17 + tmp_14*tmp_21 + tmp_14*tmp_23 - tmp_19*tmp_2;
    hess[1] = hess[1] + tmp_30;
    hess[2] = hess[2] + tmp_32;
    hess[3] = hess[3] + tmp_30;
    hess[4] = hess[4] + -tmp_17*tmp_34 + tmp_21*tmp_34 + tmp_23*tmp_34 + tmp_33*tmp_4 - tmp_35*tmp_4;
    hess[5] = hess[5] + tmp_37;
    hess[6] = hess[6] + tmp_32;
    hess[7] = hess[7] + tmp_37;
    hess[8] = hess[8] + -tmp_17*tmp_38 + tmp_21*tmp_38 + tmp_23*tmp_38 + tmp_33*tmp_6 - tmp_35*tmp_6;
}

/* ---------------------------------------------------------------------------
    Satoh potential
*/
double satoh_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */
    double S2;
    S2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + pars[2]*(pars[2] + 2*sqrt(q[2]*q[2] + pars[3]*pars[3]));
    return -pars[0] * pars[1] / sqrt(S2);
}

void satoh_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */

    double S2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + pars[2]*(pars[2] + 2*sqrt(q[2]*q[2] + pars[3]*pars[3]));
    double dPhi_dS = pars[0] * pars[1] / S2;

    grad[0] = grad[0] + dPhi_dS*q[0]/sqrt(S2);
    grad[1] = grad[1] + dPhi_dS*q[1]/sqrt(S2);
    grad[2] = grad[2] + dPhi_dS/sqrt(S2) * q[2]*(1 + pars[2] / sqrt(q[2]*q[2] + pars[3]*pars[3]));
}

double satoh_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */
    double z2b2 = q[2]*q[2] + pars[3]*pars[3];
    double xyz2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];
    double S2 = xyz2 + pars[2]*(pars[2] + 2*sqrt(z2b2));
    double A = pars[1] * pars[2] * pars[3]*pars[3] / (4*M_PI*S2*sqrt(S2)*z2b2);
    return A * (1/sqrt(z2b2) + 3/pars[2]*(1 - xyz2/S2));
}

void satoh_hessian(double t, double *pars, double *q, int n_dim, double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a ()
            - b ()
    */
    double G = pars[0];
    double m = pars[1];
    double a = pars[2];
    double b = pars[3];

    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = pow(b, 2) + tmp_2;
    double tmp_4 = sqrt(tmp_3);
    double tmp_5 = a*(a + 2*tmp_4) + tmp_0 + tmp_1 + tmp_2;
    double tmp_6 = G*m;
    double tmp_7 = tmp_6/pow(tmp_5, 3.0/2.0);
    double tmp_8 = tmp_6/pow(tmp_5, 5.0/2.0);
    double tmp_9 = 3*tmp_8;
    double tmp_10 = -tmp_9*x*y;
    double tmp_11 = 3*z;
    double tmp_12 = a/tmp_4;
    double tmp_13 = tmp_8*(-tmp_11*tmp_12 - tmp_11);
    double tmp_14 = tmp_13*x;
    double tmp_15 = tmp_13*y;

    hess[0] = hess[0] + -tmp_0*tmp_9 + tmp_7;
    hess[1] = hess[1] + tmp_10;
    hess[2] = hess[2] + tmp_14;
    hess[3] = hess[3] + tmp_10;
    hess[4] = hess[4] + -tmp_1*tmp_9 + tmp_7;
    hess[5] = hess[5] + tmp_15;
    hess[6] = hess[6] + tmp_14;
    hess[7] = hess[7] + tmp_15;
    hess[8] = hess[8] + -tmp_13*(-tmp_12*z - z) - tmp_7*(a*tmp_2/pow(tmp_3, 3.0/2.0) - tmp_12 - 1);
}

/* ---------------------------------------------------------------------------
    Kuzmin potential
*/
double kuzmin_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
    */
    double S2 = q[0]*q[0] + q[1]*q[1] + pow(pars[2] + fabs(q[2]), 2);
    return -pars[0] * pars[1] / sqrt(S2);
}

void kuzmin_gradient(double t, double *pars, double *q, int n_dim,
                     double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
    */

    double S2 = q[0]*q[0] + q[1]*q[1] + pow(pars[2] + fabs(q[2]), 2);
    double fac = pars[0] * pars[1] * pow(S2, -1.5);
    double zsign;

    if (q[2] > 0) {
        zsign = 1.;
    } else if (q[2] < 0) {
        zsign = -1.;
    } else {
        zsign = 0.;
    }

    grad[0] = grad[0] + fac * q[0];
    grad[1] = grad[1] + fac * q[1];
    grad[2] = grad[2] + fac * zsign * (pars[2] + fabs(q[2]));
}

double kuzmin_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
    */
    if (q[2] != 0.) {
        return 0.;
    } else {
        return pars[1] * pars[2] / (2 * M_PI) *
            pow(q[0]*q[0] + q[1]*q[1] + pars[2]*pars[2], -1.5);
   }

}

/* ---------------------------------------------------------------------------
    Miyamoto-Nagai flattened potential
*/
double miyamotonagai_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */
    double zd;
    zd = (pars[2] + sqrt(q[2]*q[2] + pars[3]*pars[3]));
    return -pars[0] * pars[1] / sqrt(q[0]*q[0] + q[1]*q[1] + zd*zd);
}

void miyamotonagai_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */
    double sqrtz, zd, fac;

    sqrtz = sqrt(q[2]*q[2] + pars[3]*pars[3]);
    zd = pars[2] + sqrtz;
    fac = pars[0]*pars[1] * pow(q[0]*q[0] + q[1]*q[1] + zd*zd, -1.5);

    grad[0] = grad[0] + fac*q[0];
    grad[1] = grad[1] + fac*q[1];
    grad[2] = grad[2] + fac*q[2] * (1. + pars[2] / sqrtz);
}

double miyamotonagai_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */

    double M, a, b;
    M = pars[1];
    a = pars[2];
    b = pars[3];

    double R2 = q[0]*q[0] + q[1]*q[1];
    double sqrt_zb = sqrt(q[2]*q[2] + b*b);
    double numer = (b*b*M / (4*M_PI)) * (a*R2 + (a + 3*sqrt_zb)*(a + sqrt_zb)*(a + sqrt_zb));
    double denom = pow(R2 + (a + sqrt_zb)*(a + sqrt_zb), 2.5) * sqrt_zb*sqrt_zb*sqrt_zb;

    return numer/denom;
}

void miyamotonagai_hessian(double t, double *pars, double *q, int n_dim,
                           double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - m (mass scale)
            - a (length scale 1) TODO
            - b (length scale 2) TODO
    */
    double G = pars[0];
    double m = pars[1];
    double a = pars[2];
    double b = pars[3];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(x, 2);
    double tmp_1 = pow(y, 2);
    double tmp_2 = pow(z, 2);
    double tmp_3 = pow(b, 2) + tmp_2;
    double tmp_4 = sqrt(tmp_3);
    double tmp_5 = a + tmp_4;
    double tmp_6 = pow(tmp_5, 2);
    double tmp_7 = tmp_0 + tmp_1 + tmp_6;
    double tmp_8 = G*m;
    double tmp_9 = tmp_8/pow(tmp_7, 3.0/2.0);
    double tmp_10 = 3*tmp_8/pow(tmp_7, 5.0/2.0);
    double tmp_11 = tmp_10*x;
    double tmp_12 = -tmp_11*y;
    double tmp_13 = tmp_5/tmp_4;
    double tmp_14 = tmp_13*z;
    double tmp_15 = -tmp_11*tmp_14;
    double tmp_16 = -tmp_10*tmp_14*y;
    double tmp_17 = 1.0/tmp_3;
    double tmp_18 = tmp_2*tmp_9;

    hess[0] = hess[0] + -tmp_0*tmp_10 + tmp_9;
    hess[1] = hess[1] + tmp_12;
    hess[2] = hess[2] + tmp_15;
    hess[3] = hess[3] + tmp_12;
    hess[4] = hess[4] + -tmp_1*tmp_10 + tmp_9;
    hess[5] = hess[5] + tmp_16;
    hess[6] = hess[6] + tmp_15;
    hess[7] = hess[7] + tmp_16;
    hess[8] = hess[8] + -tmp_10*tmp_17*tmp_2*tmp_6 + tmp_13*tmp_9 + tmp_17*tmp_18 - tmp_18*tmp_5/pow(tmp_3, 3.0/2.0);
}

/* ---------------------------------------------------------------------------
    MN3 exponential disk approximation

    pars:
    - G (Gravitational constant)
    - m1, a1, b1
    - m2, a2, b2
    - m3, a3, b3
*/
double mn3_value(double t, double *pars, double *q, int n_dim) {
    double tmp_pars[4] = {0., 0., 0., 0.};
    tmp_pars[0] = pars[0];

    double val = 0.;
    for (int i=0; i < 3; i++) {
        tmp_pars[1] = pars[1+3*i];
        tmp_pars[2] = pars[1+3*i+1];
        tmp_pars[3] = pars[1+3*i+2];
        val += miyamotonagai_value(t, &tmp_pars[0], q, n_dim);
    }
    return val;
}

void mn3_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    double tmp_pars[4] = {0., 0., 0., 0.};
    tmp_pars[0] = pars[0];

    for (int i=0; i < 3; i++) {
        tmp_pars[1] = pars[1+3*i];
        tmp_pars[2] = pars[1+3*i+1];
        tmp_pars[3] = pars[1+3*i+2];
        miyamotonagai_gradient(t, &tmp_pars[0], q, n_dim, grad);
    }
}

double mn3_density(double t, double *pars, double *q, int n_dim) {
    double tmp_pars[4] = {0., 0., 0., 0.};
    tmp_pars[0] = pars[0];

    double val = 0.;
    for (int i=0; i < 3; i++) {
        tmp_pars[1] = pars[1+3*i];
        tmp_pars[2] = pars[1+3*i+1];
        tmp_pars[3] = pars[1+3*i+2];
        val += miyamotonagai_density(t, &tmp_pars[0], q, n_dim);
    }
    return val;
}

void mn3_hessian(double t, double *pars, double *q, int n_dim,
                 double *hess) {
    double tmp_pars[4] = {0., 0., 0., 0.};
    tmp_pars[0] = pars[0];

    for (int i=0; i < 3; i++) {
        tmp_pars[1] = pars[1+3*i];
        tmp_pars[2] = pars[1+3*i+1];
        tmp_pars[3] = pars[1+3*i+2];
        miyamotonagai_hessian(t, &tmp_pars[0], q, n_dim, hess);
    }
}

/* ---------------------------------------------------------------------------
    Lee-Suto triaxial NFW from Lee & Suto (2003)
*/
double leesuto_value(double t, double *pars, double *q, int n_dim) {
    /*  pars: (alpha = 1)
            0 - G
            1 - v_c
            2 - r_s
            3 - a
            4 - b
            5 - c
    */
    double x, y, z, _r, u, phi0;
    double e_b2 = 1-pow(pars[4]/pars[3],2);
    double e_c2 = 1-pow(pars[5]/pars[3],2);
    double F1,F2,F3,costh2,sinth2,sinph2;

    phi0 = pars[1]*pars[1] / (log(2.) - 0.5 + (log(2.)-0.75)*e_b2 + (log(2.)-0.75)*e_c2);

    x = q[0];
    y = q[1];
    z = q[2];

    _r = sqrt(x*x + y*y + z*z);
    u = _r / pars[2];

    F1 = -log(1+u)/u;
    F2 = -1/3. + (2*u*u - 3*u + 6)/(6*u*u) + (1/u - pow(u,-3.))*log(1+u);
    F3 = (u*u - 3*u - 6)/(2*u*u*(1+u)) + 3*pow(u,-3)*log(1+u);
    costh2 = z*z / (_r*_r);
    sinth2 = 1 - costh2;
    sinph2 = y*y / (x*x + y*y);
    //return phi0 * ((e_b2/2 + e_c2/2)*((1/u - 1/(u*u*u))*log(u + 1) - 1 + (2*u*u - 3*u + 6)/(6*u*u)) + (e_b2*y*y/(2*_r*_r) + e_c2*z*z/(2*_r*_r))*((u*u - 3*u - 6)/(2*u*u*(u + 1)) + 3*log(u + 1)/(u*u*u)) - log(u + 1)/u);
    if (u == 0) {
        return phi0;
    } else {
        return phi0 * (F1 + (e_b2+e_c2)/2.*F2 + (e_b2*sinth2*sinph2 + e_c2*costh2)/2. * F3);
    }
}

void leesuto_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars: (alpha = 1)
            0 - G
            1 - v_c
            2 - r_s
            3 - a
            4 - b
            5 - c
    */
    double x, y, z, _r, _r2, _r4, ax, ay, az;
    double v_h2, x0, x2, x22;
    double x20, x21, x7, x1;
    double x10, x13, x15, x16, x17;
    double e_b2 = 1-pow(pars[4]/pars[3],2);
    double e_c2 = 1-pow(pars[5]/pars[3],2);

    v_h2 = pars[1]*pars[1] / (log(2.) - 0.5 + (log(2.)-0.75)*e_b2 + (log(2.)-0.75)*e_c2);

    x = q[0];
    y = q[1];
    z = q[2];

    _r2 = x*x + y*y + z*z;
    _r = sqrt(_r2);
    _r4 = _r2*_r2;

    x0 = _r + pars[2];
    x1 = x0*x0;
    x2 = v_h2/(12.*_r4*_r2*_r*x1);
    x10 = log(x0/pars[2]);

    x13 = _r*3.*pars[2];
    x15 = x13 - _r2;
    x16 = x15 + 6.*(pars[2]*pars[2]);
    x17 = 6.*pars[2]*x0*(_r*x16 - x0*x10*6.*(pars[2]*pars[2]));
    x20 = x0*_r2;
    x21 = 2.*_r*x0;
    x7 = e_b2*y*y + e_c2*z*z;
    x22 = -12.*_r4*_r*pars[2]*x0 + 12.*_r4*pars[2]*x1*x10 + 3.*pars[2]*x7*(x16*_r2 - 18.*x1*x10*(pars[2]*pars[2]) + x20*(2.*_r - 3.*pars[2]) + x21*(x15 + 9.*(pars[2]*pars[2]))) - x20*(e_b2 + e_c2)*(-6.*_r*pars[2]*(_r2 - (pars[2]*pars[2])) + 6.*pars[2]*x0*x10*(_r2 - 3.*(pars[2]*pars[2])) + x20*(-4.*_r + 3.*pars[2]) + x21*(-x13 + 2.*_r2 + 6.*(pars[2]*pars[2])));

    ax = x2*x*(x17*x7 + x22);
    ay = x2*y*(x17*(x7 - _r2*e_b2) + x22);
    az = x2*z*(x17*(x7 - _r2*e_c2) + x22);

    grad[0] = grad[0] + ax;
    grad[1] = grad[1] + ay;
    grad[2] = grad[2] + az;
}

double leesuto_density(double t, double *pars, double *q, int n_dim) {
    /*  pars: (alpha = 1)
            0 - G
            1 - v_c
            2 - r_s
            3 - a
            4 - b
            5 - c
    */
    double x, y, z, u, v_h2;
    double b_a2, c_a2;
    b_a2 = pars[4]*pars[4] / (pars[3]*pars[3]);
    c_a2 = pars[5]*pars[5] / (pars[3]*pars[3]);
    double e_b2 = 1-b_a2;
    double e_c2 = 1-c_a2;
    v_h2 = pars[1]*pars[1] / (log(2.) - 0.5 + (log(2.)-0.75)*e_b2 + (log(2.)-0.75)*e_c2);

    x = q[0];
    y = q[1];
    z = q[2];

    u = sqrt(x*x + y*y/b_a2 + z*z/c_a2) / pars[2];
    return v_h2 / (u * (1+u)*(1+u)) / (4.*M_PI*pars[2]*pars[2]*pars[0]);
}

/* ---------------------------------------------------------------------------
    Logarithmic (triaxial)
*/
double logarithmic_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - v_c (velocity scale)
            - r_h (length scale)
            - q1
            - q2
            - q3
    */
    double x, y, z;

    x = q[0]*cos(pars[6]) + q[1]*sin(pars[6]);
    y = -q[0]*sin(pars[6]) + q[1]*cos(pars[6]);
    z = q[2];

    return 0.5*pars[1]*pars[1] * log(pars[2]*pars[2] + // scale radius
                                     x*x/(pars[3]*pars[3]) +
                                     y*y/(pars[4]*pars[4]) +
                                     z*z/(pars[5]*pars[5]));
}

double logarithmic_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - v_c (velocity scale)
            - r_h (length scale)
            - q1
            - q2
            - q3
    */
    double tmp_0 = pow(pars[3], 2);
    double tmp_1 = pow(pars[4], 2);
    double tmp_2 = tmp_0*tmp_1;
    double tmp_3 = tmp_2*pow(q[2], 2);
    double tmp_4 = pow(pars[5], 2);
    double tmp_5 = tmp_0*tmp_4;
    double tmp_6 = tmp_5*pow(q[1], 2);
    double tmp_7 = tmp_1*tmp_4;
    double tmp_8 = tmp_7*pow(q[0], 2);
    double tmp_9 = pow(pars[2], 2)*tmp_2*tmp_4;
    double tmp_10 = tmp_6 + tmp_8 + tmp_9;
    double tmp_11 = tmp_3 + tmp_9;
    return pow(pars[1], 2)*(tmp_2*(tmp_10 - tmp_3) + tmp_5*(tmp_11 - tmp_6 + tmp_8) + tmp_7*(tmp_11 + tmp_6 - tmp_8))/pow(tmp_10 + tmp_3, 2) / (4*M_PI*pars[0]);
}

void logarithmic_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - v_c (velocity scale)
            - r_h (length scale)
            - q1
            - q2
            - q3
    */
    double x, y, z, ax, ay, az, fac;

    x = q[0]*cos(pars[6]) + q[1]*sin(pars[6]);
    y = -q[0]*sin(pars[6]) + q[1]*cos(pars[6]);
    z = q[2];

    fac = pars[1]*pars[1] / (pars[2]*pars[2] + x*x/(pars[3]*pars[3]) + y*y/(pars[4]*pars[4]) + z*z/(pars[5]*pars[5]));
    ax = fac*x/(pars[3]*pars[3]);
    ay = fac*y/(pars[4]*pars[4]);
    az = fac*z/(pars[5]*pars[5]);

    grad[0] = grad[0] + (ax*cos(pars[6]) - ay*sin(pars[6]));
    grad[1] = grad[1] + (ax*sin(pars[6]) + ay*cos(pars[6]));
    grad[2] = grad[2] + az;
}

void logarithmic_hessian(double t, double *pars, double *q, int n_dim,
                         double *hess) {
    /*  pars:
            - G (Gravitational constant)
            - v_c (velocity scale)
            - r_h (length scale)
            - q1
            - q2
            - q3
    */
    double v_c = pars[1];
    double r_h = pars[2];
    double q1 = pars[3];
    double q2 = pars[4];
    double q3 = pars[5];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = pow(q1, -2);
    double tmp_1 = pow(v_c, 2);
    double tmp_2 = tmp_0*tmp_1;
    double tmp_3 = pow(x, 2);
    double tmp_4 = pow(q2, -2);
    double tmp_5 = pow(y, 2);
    double tmp_6 = pow(q3, -2);
    double tmp_7 = pow(z, 2);
    double tmp_8 = pow(r_h, 2) + tmp_0*tmp_3 + tmp_4*tmp_5 + tmp_6*tmp_7;
    double tmp_9 = 1.0/tmp_8;
    double tmp_10 = 2.0/pow(tmp_8, 2);
    double tmp_11 = tmp_1*tmp_10;
    double tmp_12 = tmp_4*y;
    double tmp_13 = tmp_10*tmp_2*x;
    double tmp_14 = tmp_12*tmp_13;
    double tmp_15 = tmp_6*z;
    double tmp_16 = tmp_13*tmp_15;
    double tmp_17 = tmp_1*tmp_9;
    double tmp_18 = tmp_11*tmp_12*tmp_15;

    // minus signs because I initially borked the sympy definition
    hess[0] = hess[0] - (-tmp_2*tmp_9 + tmp_11*tmp_3/pow(q1, 4));
    hess[1] = hess[1] - (tmp_14);
    hess[2] = hess[2] - (tmp_16);
    hess[3] = hess[3] - (tmp_14);
    hess[4] = hess[4] - (-tmp_17*tmp_4 + tmp_11*tmp_5/pow(q2, 4));
    hess[5] = hess[5] - (tmp_18);
    hess[6] = hess[6] - (tmp_16);
    hess[7] = hess[7] - (tmp_18);
    hess[8] = hess[8] - (-tmp_17*tmp_6 + tmp_11*tmp_7/pow(q3, 4));
}

/* ---------------------------------------------------------------------------
    Logarithmic (triaxial)
*/
double longmuralibar_value(double t, double *pars, double *q, int n_dim) {
    /*  http://adsabs.harvard.edu/abs/1992ApJ...397...44L

        pars:
        - G (Gravitational constant)
        - m (mass scale)
        - a
        - b
        - c
        - alpha
    */
    double x, y, z;
    double a, b, c;
    double Tm, Tp;

    x = q[0]*cos(pars[5]) + q[1]*sin(pars[5]);
    y = -q[0]*sin(pars[5]) + q[1]*cos(pars[5]);
    z = q[2];

    a = pars[2];
    b = pars[3];
    c = pars[4];

    Tm = sqrt((a-x)*(a-x) + y*y + pow(b + sqrt(c*c + z*z),2));
    Tp = sqrt((a+x)*(a+x) + y*y + pow(b + sqrt(c*c + z*z),2));

    return pars[0]*pars[1]/(2*a) * log((x - a + Tm) / (x + a + Tp));
}

void longmuralibar_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  http://adsabs.harvard.edu/abs/1992ApJ...397...44L

        pars:
        - G (Gravitational constant)
        - m (mass scale)
        - a
        - b
        - c
        - alpha
    */
    double x, y, z;
    double a, b, c;
    double Tm, Tp, fac1, fac2, fac3, bcz;
    double gx, gy, gz;

    x = q[0]*cos(pars[5]) + q[1]*sin(pars[5]);
    y = -q[0]*sin(pars[5]) + q[1]*cos(pars[5]);
    z = q[2];

    a = pars[2];
    b = pars[3];
    c = pars[4];

    bcz = b + sqrt(c*c + z*z);
    Tm = sqrt((a-x)*(a-x) + y*y + bcz*bcz);
    Tp = sqrt((a+x)*(a+x) + y*y + bcz*bcz);

    fac1 = pars[0]*pars[1] / (2*Tm*Tp);
    fac2 = 1 / (y*y + bcz*bcz);
    fac3 = Tp + Tm - (4*x*x)/(Tp+Tm);

    gx = 4 * fac1 * x / (Tp + Tm);
    gy = fac1 * y * fac2 * fac3;
    gz = fac1 * z * fac2 * fac3 * bcz / sqrt(z*z + c*c);

    grad[0] = grad[0] + (gx*cos(pars[5]) - gy*sin(pars[5]));
    grad[1] = grad[1] + (gx*sin(pars[5]) + gy*cos(pars[5]));
    grad[2] = grad[2] + gz;
}

double longmuralibar_density(double t, double *pars, double *q, int n_dim) {
    /*
        Generated by sympy...

        pars:
        - G (Gravitational constant)
        - m (mass scale)
        - a
        - b
        - c
        - alpha
    */
    double a = pars[2];
    double b = pars[3];
    double c = pars[4];

    double x = q[0]*cos(pars[5]) + q[1]*sin(pars[5]);
    double y = -q[0]*sin(pars[5]) + q[1]*cos(pars[5]);
    double z = q[2];

    double tmp0 = a - x;
    double tmp1 = pow(tmp0, 2);
    double tmp2 = pow(y, 2);
    double tmp3 = pow(z, 2);
    double tmp4 = pow(c, 2) + tmp3;
    double tmp5 = sqrt(tmp4);
    double tmp6 = b + tmp5;
    double tmp7 = pow(tmp6, 2);
    double tmp8 = tmp2 + tmp7;
    double tmp9 = tmp1 + tmp8;
    double tmp10 = sqrt(tmp9);
    double tmp11 = -a + tmp10 + x;
    double tmp12 = 1.0/tmp11;
    double tmp13 = 1.0/tmp10;
    double tmp14 = pow(tmp9, -1.5);
    double tmp15 = 1.0/tmp4;
    double tmp16 = tmp13*tmp3;
    double tmp17 = tmp6/tmp5;
    double tmp18 = pow(tmp4, -1.5);
    double tmp19 = tmp15*tmp3*tmp7;
    double tmp20 = 2*tmp2;
    double tmp21 = a + x;
    double tmp22 = pow(tmp21, 2);
    double tmp23 = tmp22 + tmp8;
    double tmp24 = sqrt(tmp23);
    double tmp25 = 1.0/tmp24;
    double tmp26 = tmp21 + tmp24;
    double tmp27 = 1.0/tmp26;
    double tmp28 = tmp25*tmp27;
    double tmp29 = tmp11*tmp28;
    double tmp30 = tmp11*tmp27/pow(tmp23, 1.5);
    double tmp31 = 1.0/tmp23;
    double tmp32 = pow(tmp26, -2);
    double tmp33 = tmp11*tmp31*tmp32;
    double tmp34 = tmp21*tmp25 + 1;
    double tmp35 = tmp27*tmp34;
    double tmp36 = tmp13*tmp15*tmp3*tmp7;
    double tmp37 = -tmp13 + tmp29;
    double tmp38 = tmp2*tmp37;
    double tmp39 = tmp0*tmp13;
    double tmp40 = tmp11*tmp27*tmp34 + tmp39 - 1;
    return pars[1]/8.*tmp12*(2*tmp11*tmp32*pow(tmp34, 2) +
        tmp12*tmp13*tmp38 + tmp12*tmp36*tmp37 + tmp12*tmp40*(-tmp39 + 1) +
        tmp13*tmp17 - tmp13*tmp20*tmp25*tmp27 + tmp13*(-tmp1/tmp9 + 1) + tmp13 -
        tmp14*tmp19 - tmp14*tmp2 + tmp15*tmp16 - tmp15*tmp28*tmp3*tmp37*tmp7 -
        tmp15*tmp29*tmp3 + 2*tmp15*tmp3*tmp33*tmp7 - tmp16*tmp18*tmp6 -
        tmp17*tmp29 + tmp18*tmp29*tmp3*tmp6 + tmp19*tmp30 + tmp2*tmp30 +
        tmp20*tmp33 - 2*tmp25*tmp27*tmp36 - tmp28*tmp38 - tmp29*(-tmp22*tmp31 +
        1) - tmp29 - tmp35*tmp40 - tmp35*(-2*tmp0*tmp13 + 2))/(M_PI*a);
}

void longmuralibar_hessian(double t, double *pars, double *q, int n_dim,
                         double *hess) {
    /* Generated by sympy...

        pars:
        - G (Gravitational constant)
        - m (mass scale)
        - a
        - b
        - c
        - alpha
    */
    double G = pars[0];
    double m = pars[1];
    double a = pars[2];
    double b = pars[3];
    double c = pars[4];
    double alpha = pars[5];
    double x = q[0];
    double y = q[1];
    double z = q[2];

    double tmp_0 = cos(alpha);
    double tmp_1 = tmp_0*x;
    double tmp_2 = sin(alpha);
    double tmp_3 = tmp_2*y;
    double tmp_4 = tmp_1 + tmp_3;
    double tmp_5 = a + tmp_4;
    double tmp_6 = tmp_0*tmp_5;
    double tmp_7 = tmp_0*y - tmp_2*x;
    double tmp_8 = tmp_2*tmp_7;
    double tmp_9 = -tmp_8;
    double tmp_10 = tmp_6 + tmp_9;
    double tmp_11 = pow(z, 2);
    double tmp_12 = pow(c, 2) + tmp_11;
    double tmp_13 = sqrt(tmp_12);
    double tmp_14 = b + tmp_13;
    double tmp_15 = pow(tmp_14, 2);
    double tmp_16 = tmp_15 + pow(tmp_7, 2);
    double tmp_17 = tmp_16 + pow(tmp_5, 2);
    double tmp_18 = sqrt(tmp_17);
    double tmp_19 = 1.0/tmp_18;
    double tmp_20 = tmp_10*tmp_19;
    double tmp_21 = tmp_18 + tmp_5;
    double tmp_22 = 1.0/tmp_21;
    double tmp_23 = a - tmp_1 - tmp_3;
    double tmp_24 = tmp_0*tmp_23;
    double tmp_25 = -tmp_24 + tmp_9;
    double tmp_26 = tmp_16 + pow(tmp_23, 2);
    double tmp_27 = sqrt(tmp_26);
    double tmp_28 = 1.0/tmp_27;
    double tmp_29 = tmp_25*tmp_28;
    double tmp_30 = tmp_0 + tmp_29;
    double tmp_31 = -tmp_0;
    double tmp_32 = -tmp_20 + tmp_31;
    double tmp_33 = pow(tmp_21, -2);
    double tmp_34 = -a + tmp_27 + tmp_4;
    double tmp_35 = tmp_33*tmp_34;
    double tmp_36 = tmp_22*tmp_30 + tmp_32*tmp_35;
    double tmp_37 = (1.0/2.0)*G*m/a;
    double tmp_38 = tmp_37/tmp_34;
    double tmp_39 = tmp_36*tmp_38;
    double tmp_40 = tmp_21*tmp_37/pow(tmp_34, 2);
    double tmp_41 = tmp_36*tmp_40;
    double tmp_42 = tmp_32*tmp_33;
    double tmp_43 = pow(tmp_0, 2) + pow(tmp_2, 2);
    double tmp_44 = tmp_28*tmp_43;
    double tmp_45 = pow(tmp_26, -3.0/2.0);
    double tmp_46 = tmp_25*tmp_45;
    double tmp_47 = -tmp_19*tmp_43;
    double tmp_48 = pow(tmp_17, -3.0/2.0);
    double tmp_49 = tmp_10*tmp_48;
    double tmp_50 = tmp_34/pow(tmp_21, 3);
    double tmp_51 = tmp_32*tmp_50;
    double tmp_52 = tmp_21*tmp_38;
    double tmp_53 = tmp_0*tmp_7;
    double tmp_54 = tmp_2*tmp_5;
    double tmp_55 = tmp_53 + tmp_54;
    double tmp_56 = tmp_19*tmp_55;
    double tmp_57 = tmp_2 + tmp_56;
    double tmp_58 = -tmp_2;
    double tmp_59 = tmp_2*tmp_23;
    double tmp_60 = tmp_53 - tmp_59;
    double tmp_61 = tmp_28*tmp_60;
    double tmp_62 = tmp_58 - tmp_61;
    double tmp_63 = -tmp_53;
    double tmp_64 = tmp_59 + tmp_63;
    double tmp_65 = tmp_22*tmp_46;
    double tmp_66 = -tmp_56 + tmp_58;
    double tmp_67 = tmp_33*tmp_66;
    double tmp_68 = tmp_2 + tmp_61;
    double tmp_69 = -tmp_54 + tmp_63;
    double tmp_70 = tmp_35*tmp_49;
    double tmp_71 = -2*tmp_2 - 2*tmp_56;
    double tmp_72 = tmp_39*tmp_57 + tmp_41*tmp_62 + tmp_52*(tmp_30*tmp_67 + tmp_42*tmp_68 + tmp_51*tmp_71 + tmp_64*tmp_65 - tmp_69*tmp_70);
    double tmp_73 = 1.0/tmp_13;
    double tmp_74 = tmp_14*tmp_73;
    double tmp_75 = tmp_74*z;
    double tmp_76 = tmp_19*tmp_75;
    double tmp_77 = tmp_28*tmp_75;
    double tmp_78 = tmp_19*tmp_33;
    double tmp_79 = tmp_75*tmp_78;
    double tmp_80 = 2*tmp_76;
    double tmp_81 = tmp_39*tmp_76 - tmp_41*tmp_77 + tmp_52*(-tmp_30*tmp_79 + tmp_42*tmp_77 - tmp_51*tmp_80 - tmp_65*tmp_75 + tmp_70*tmp_75);
    double tmp_82 = tmp_22*tmp_68 + tmp_35*tmp_66;
    double tmp_83 = tmp_38*tmp_82;
    double tmp_84 = tmp_40*tmp_82;
    double tmp_85 = tmp_45*tmp_60;
    double tmp_86 = tmp_50*tmp_66;
    double tmp_87 = tmp_48*tmp_55;
    double tmp_88 = tmp_52*(-tmp_22*tmp_75*tmp_85 + tmp_35*tmp_75*tmp_87 + tmp_67*tmp_77 - tmp_68*tmp_79 - tmp_80*tmp_86) + tmp_76*tmp_83 - tmp_77*tmp_84;
    double tmp_89 = tmp_22*tmp_28;
    double tmp_90 = tmp_14*tmp_89;
    double tmp_91 = tmp_73*tmp_90;
    double tmp_92 = tmp_19*tmp_35;
    double tmp_93 = tmp_74*tmp_92;
    double tmp_94 = tmp_91*z - tmp_93*z;
    double tmp_95 = tmp_11/tmp_12;
    double tmp_96 = tmp_11/pow(tmp_12, 3.0/2.0);
    double tmp_97 = tmp_15*tmp_95;
    double tmp_98 = 2*tmp_97;

    hess[0] = hess[0] + tmp_39*(tmp_0 + tmp_20) + tmp_41*(-tmp_29 + tmp_31) + tmp_52*(tmp_22*(tmp_44 + tmp_46*(tmp_24 + tmp_8)) + 2*tmp_30*tmp_42 + tmp_35*(tmp_47 - tmp_49*(-tmp_6 + tmp_8)) + tmp_51*(-2*tmp_0 - 2*tmp_20));
    hess[1] = hess[1] + tmp_72;
    hess[2] = hess[2] + tmp_81;
    hess[3] = hess[3] + tmp_72;
    hess[4] = hess[4] + tmp_52*(tmp_22*(tmp_44 + tmp_64*tmp_85) + tmp_35*(tmp_47 - tmp_69*tmp_87) + 2*tmp_67*tmp_68 + tmp_71*tmp_86) + tmp_57*tmp_83 + tmp_62*tmp_84;
    hess[5] = hess[5] + tmp_88;
    hess[6] = hess[6] + tmp_81;
    hess[7] = hess[7] + tmp_88;
    hess[8] = hess[8] + tmp_38*tmp_76*tmp_94 - tmp_40*tmp_77*tmp_94 + tmp_52*(tmp_14*tmp_92*tmp_96 - tmp_22*tmp_45*tmp_97 - tmp_28*tmp_78*tmp_98 + tmp_35*tmp_48*tmp_97 + tmp_89*tmp_95 - tmp_90*tmp_96 + tmp_91 - tmp_92*tmp_95 - tmp_93 + tmp_50*tmp_98/tmp_17);
}


/* ---------------------------------------------------------------------------
    Burkert potential
    (from Mori and Burkert 2000: https://iopscience.iop.org/article/10.1086/309140/fulltext/50172.text.html)
*/
double burkert_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - rho (mass scale)
            - r0
    */
    double R, x;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    x = R / pars[2];
    
    // pi G rho r0^2 (pi - 2(1 - r0/r)arctan(r/r0) + 2(1 - r0/r)log(1 + r/r0) - (1 - r0/r)log(1 + (r/r0)^2))
    return -M_PI * pars[0] * pars[1] * pars[2] * pars[2] * (M_PI - 2 * (1 + 1 / x) * atan(x) + 2 * (1 + 1/x) * log(1 + x) - (1 - 1/x) * log(1 + x * x) );
}


void burkert_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
            - G (Gravitational constant)
            - rho (mass scale)
            - r0
    */
    double R, x, dphi_dr;
    R = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    x = R / pars[2];

    dphi_dr = -M_PI * pars[0] * pars[1] * pars[2] / (x * x) * (2 * atan(x) - 2 * log(1 + x) - log(1 + x * x));

    grad[0] = grad[0] + dphi_dr*q[0]/R;
    grad[1] = grad[1] + dphi_dr*q[1]/R;
    grad[2] = grad[2] + dphi_dr*q[2]/R;
}


double burkert_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
            - G (Gravitational constant)
            - rho (mass scale)
            - r0
    */
    double r, x, rho;

    r = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
    x = r / pars[2];
    rho = pars[1] / ((1 + x) * (1 + x * x));

    return rho;
}
</file>

<file path="gala/potential/potential/builtin/builtin_potentials.h">
extern double nan_density(double t, double *pars, double *q, int n_dim);
extern double nan_value(double t, double *pars, double *q, int n_dim);
extern void nan_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void nan_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double null_density(double t, double *pars, double *q, int n_dim);
extern double null_value(double t, double *pars, double *q, int n_dim);
extern void null_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void null_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double henon_heiles_value(double t, double *pars, double *q, int n_dim);
extern void henon_heiles_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void henon_heiles_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double kepler_value(double t, double *pars, double *q, int n_dim);
extern double kepler_density(double t, double *pars, double *q, int n_dim);
extern void kepler_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void kepler_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double isochrone_value(double t, double *pars, double *q, int n_dim);
extern void isochrone_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double isochrone_density(double t, double *pars, double *q, int n_dim);
extern void isochrone_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double hernquist_value(double t, double *pars, double *q, int n_dim);
extern void hernquist_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double hernquist_density(double t, double *pars, double *q, int n_dim);
extern void hernquist_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double plummer_value(double t, double *pars, double *q, int n_dim);
extern void plummer_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double plummer_density(double t, double *pars, double *q, int n_dim);
extern void plummer_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double jaffe_value(double t, double *pars, double *q, int n_dim);
extern void jaffe_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double jaffe_density(double t, double *pars, double *q, int n_dim);
extern void jaffe_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double powerlawcutoff_value(double t, double *pars, double *q, int n_dim);
extern void powerlawcutoff_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double powerlawcutoff_density(double t, double *pars, double *q, int n_dim);
extern void powerlawcutoff_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double stone_value(double t, double *pars, double *q, int n_dim);
extern void stone_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void stone_density(double t, double *pars, double *q, int n_dim);
extern void stone_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double sphericalnfw_value(double t, double *pars, double *q, int n_dim);
extern void sphericalnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double sphericalnfw_density(double t, double *pars, double *q, int n_dim);
extern void sphericalnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double flattenednfw_value(double t, double *pars, double *q, int n_dim);
extern void flattenednfw_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void flattenednfw_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double triaxialnfw_value(double t, double *pars, double *q, int n_dim);
extern void triaxialnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void triaxialnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double satoh_value(double t, double *pars, double *q, int n_dim);
extern void satoh_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double satoh_density(double t, double *pars, double *q, int n_dim);
extern void satoh_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double kuzmin_value(double t, double *pars, double *q, int n_dim);
extern void kuzmin_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double kuzmin_density(double t, double *pars, double *q, int n_dim);

extern double miyamotonagai_value(double t, double *pars, double *q, int n_dim);
extern void miyamotonagai_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void miyamotonagai_hessian(double t, double *pars, double *q, int n_dim, double *hess);
extern double miyamotonagai_density(double t, double *pars, double *q, int n_dim);

extern double mn3_value(double t, double *pars, double *q, int n_dim);
extern void mn3_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void mn3_hessian(double t, double *pars, double *q, int n_dim, double *hess);
extern double mn3_density(double t, double *pars, double *q, int n_dim);

extern double leesuto_value(double t, double *pars, double *q, int n_dim);
extern void leesuto_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double leesuto_density(double t, double *pars, double *q, int n_dim);

extern double logarithmic_value(double t, double *pars, double *q, int n_dim);
extern void logarithmic_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern void logarithmic_hessian(double t, double *pars, double *q, int n_dim, double *hess);
extern double logarithmic_density(double t, double *pars, double *q, int n_dim);

extern double longmuralibar_value(double t, double *pars, double *q, int n_dim);
extern void longmuralibar_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double longmuralibar_density(double t, double *pars, double *q, int n_dim);
extern void longmuralibar_hessian(double t, double *pars, double *q, int n_dim, double *hess);

extern double burkert_value(double t, double *pars, double *q, int n_dim);
extern void burkert_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double burkert_density(double t, double *pars, double *q, int n_dim);
</file>

<file path="gala/potential/potential/builtin/core.py">
""" Built-in potentials implemented in Cython """

# HACK: This hack brought to you by a bug in cython, and a solution from here:
# https://stackoverflow.com/questions/57138496/class-level-classmethod-can-only-be-called-on-a-method-descriptor-or-instance
try:
    myclassmethod = __builtins__.classmethod
except AttributeError:
    myclassmethod = __builtins__["classmethod"]

# Third-party
import astropy.units as u
import numpy as np
from astropy.constants import G

from gala.potential.common import PotentialParameter
from gala.potential.potential.builtin.cybuiltin import (
    BurkertWrapper,
    CylSplineWrapper,
    FlattenedNFWWrapper,
    HenonHeilesWrapper,
    HernquistWrapper,
    IsochroneWrapper,
    JaffeWrapper,
    KeplerWrapper,
    KuzminWrapper,
    LeeSutoTriaxialNFWWrapper,
    LogarithmicWrapper,
    LongMuraliBarWrapper,
    MiyamotoNagaiWrapper,
    MN3ExponentialDiskWrapper,
    MultipoleWrapper,
    NullWrapper,
    PlummerWrapper,
    PowerLawCutoffWrapper,
    SatohWrapper,
    SphericalNFWWrapper,
    StoneWrapper,
    TriaxialNFWWrapper,
)

# Project
from ..core import PotentialBase, _potential_docstring
from ..cpotential import CPotentialBase
from ..util import format_doc, sympy_wrap

__all__ = [
    "NullPotential",
    "HenonHeilesPotential",
    "KeplerPotential",
    "HernquistPotential",
    "IsochronePotential",
    "PlummerPotential",
    "JaffePotential",
    "StonePotential",
    "PowerLawCutoffPotential",
    "SatohPotential",
    "KuzminPotential",
    "MiyamotoNagaiPotential",
    "MN3ExponentialDiskPotential",
    "NFWPotential",
    "LeeSutoTriaxialNFWPotential",
    "LogarithmicPotential",
    "LongMuraliBarPotential",
    "MultipolePotential",
    "CylSplinePotential",
    "BurkertPotential",
]


def __getattr__(name):
    if name in __all__ and name in globals():
        return globals()[name]

    if not (name.startswith("MultipolePotentialLmax")):
        raise AttributeError(f"Module {__name__!r} has no attribute {name!r}.")

    if name in mp_cache:
        return mp_cache[name]

    else:
        try:
            lmax = int(name.split("Lmax")[1])
        except Exception:
            raise ImportError("Invalid")  # shouldn't ever get here!

        return make_multipole_cls(lmax, timedep="TimeDependent" in name)


@format_doc(common_doc=_potential_docstring)
class HenonHeilesPotential(CPotentialBase):
    r"""
    The Hénon-Heiles potential.

    Parameters
    ----------
    {common_doc}
    """

    ndim = 2
    Wrapper = HenonHeilesWrapper

    @myclassmethod
    @sympy_wrap(var="x y")
    def to_sympy(cls, v, p):
        expr = (
            1.0
            / 2
            * (
                v["x"] ** 2
                + v["y"] ** 2
                + 2 * v["x"] ** 2 * v["y"]
                - 2.0 / 3 * v["y"] ** 3
            )
        )
        return expr, v, p


# ============================================================================
# Spherical models
#


@format_doc(common_doc=_potential_docstring)
class KeplerPotential(CPotentialBase):
    r"""
    The Kepler potential for a point mass.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Point mass value.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    Wrapper = KeplerWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        expr = -p["G"] * p["m"] / r
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class IsochronePotential(CPotentialBase):
    r"""
    The Isochrone potential.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    b : :class:`~astropy.units.Quantity`, numeric [length]
        Core concentration.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    b = PotentialParameter("b", physical_type="length")

    Wrapper = IsochroneWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        expr = -p["G"] * p["m"] / (sy.sqrt(r**2 + p["b"] ** 2) + p["b"])
        return expr, v, p

    def action_angle(self, w):
        """
        Transform the input cartesian position and velocity to action-angle
        coordinates the Isochrone potential. See Section 3.5.2 in
        Binney & Tremaine (2008), and be aware of the errata entry for
        Eq. 3.225.

        This transformation is analytic and can be used as a "toy potential"
        in the Sanders & Binney 2014 formalism for computing action-angle
        coordinates in _any_ potential.

        Adapted from Jason Sanders' code
        `here <https://github.com/jlsanders/genfunc>`_.

        Parameters
        ----------
        w : :class:`gala.dynamics.PhaseSpacePosition`, :class:`gala.dynamics.Orbit`
            The positions or orbit to compute the actions, angles, and
            frequencies at.
        """
        from gala.dynamics.actionangle import isochrone_xv_to_aa

        return isochrone_xv_to_aa(w, self)


@format_doc(common_doc=_potential_docstring)
class HernquistPotential(CPotentialBase):
    r"""
    Hernquist potential for a spheroid.
    See: http://adsabs.harvard.edu/abs/1990ApJ...356..359H

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    c : :class:`~astropy.units.Quantity`, numeric [length]
        Core concentration.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    c = PotentialParameter("c", physical_type="length")

    Wrapper = HernquistWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        expr = -p["G"] * p["m"] / (r + p["c"])
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class PlummerPotential(CPotentialBase):
    r"""
    Plummer potential for a spheroid.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
       Mass.
    b : :class:`~astropy.units.Quantity`, numeric [length]
        Core concentration.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    b = PotentialParameter("b", physical_type="length")

    Wrapper = PlummerWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        expr = -p["G"] * p["m"] / sy.sqrt(r**2 + p["b"] ** 2)
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class JaffePotential(CPotentialBase):
    r"""
    Jaffe potential for a spheroid.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    c : :class:`~astropy.units.Quantity`, numeric [length]
        Core concentration.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    c = PotentialParameter("c", physical_type="length")

    Wrapper = JaffeWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        expr = p["G"] * p["m"] / p["c"] * sy.log(r / (r + p["c"]))
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class StonePotential(CPotentialBase):
    r"""
    StonePotential(m, r_c, r_h, units=None, origin=None, R=None)

    Stone potential from `Stone & Ostriker (2015)
    <http://dx.doi.org/10.1088/2041-8205/806/2/L28>`_.

    Parameters
    ----------
    m_tot : :class:`~astropy.units.Quantity`, numeric [mass]
        Total mass.
    r_c : :class:`~astropy.units.Quantity`, numeric [length]
        Core radius.
    r_h : :class:`~astropy.units.Quantity`, numeric [length]
        Halo radius.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    r_c = PotentialParameter("r_c", physical_type="length")
    r_h = PotentialParameter("r_h", physical_type="length")

    Wrapper = StoneWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)
        A = -2 * p["G"] * p["m"] / (np.pi * (p["r_h"] - p["r_c"]))
        expr = A * (
            p["r_h"] / r * sy.atan(r / p["r_h"])
            - p["r_c"] / r * sy.atan(r / p["r_c"])
            + 1.0 / 2 * sy.log((r**2 + p["r_h"] ** 2) / (r**2 + p["r_c"] ** 2))
        )
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class PowerLawCutoffPotential(CPotentialBase, GSL_only=True):
    r"""
    A spherical power-law density profile with an exponential cutoff.

    The power law index must be ``0 <= alpha < 3``.

    .. note::

        This potential requires GSL to be installed, and Gala must have been
        built and installed with GSL support enaled (the default behavior).
        See http://gala.adrian.pw/en/latest/install.html for more information.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Total mass.
    alpha : numeric
        Power law index. Must satisfy: ``alpha < 3``
    r_c : :class:`~astropy.units.Quantity`, numeric [length]
        Cutoff radius.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    alpha = PotentialParameter("alpha", physical_type="dimensionless")
    r_c = PotentialParameter("r_c", physical_type="length")

    Wrapper = PowerLawCutoffWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        G = p["G"]
        m = p["m"]
        alpha = p["alpha"]
        r_c = p["r_c"]
        r = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + v["z"] ** 2)

        expr = (
            G
            * alpha
            * m
            * sy.lowergamma(3.0 / 2 - alpha / 2, r**2 / r_c**2)
            / (2 * r * sy.gamma(5.0 / 2 - alpha / 2))
            + G
            * m
            * sy.lowergamma(1 - alpha / 2, r**2 / r_c**2)
            / (r_c * sy.gamma(3.0 / 2 - alpha / 2))
            - 3
            * G
            * m
            * sy.lowergamma(3.0 / 2 - alpha / 2, r**2 / r_c**2)
            / (2 * r * sy.gamma(5.0 / 2 - alpha / 2))
        )

        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class BurkertPotential(CPotentialBase):
    r"""
    The Burkert potential that well-matches the rotation curve of dwarf galaxies.
    See https://iopscience.iop.org/article/10.1086/309140/fulltext/50172.text.html

    Parameters
    ----------
    rho : :class:`~astropy.units.Quantity`, numeric [mass density]
        Central mass density.
    r0 : :class:`~astropy.units.Quantity`, numeric [length]
        The core radius.
    {common_doc}
    """

    rho = PotentialParameter("rho", physical_type="mass density")
    r0 = PotentialParameter("r0", physical_type="length")

    Wrapper = BurkertWrapper

    
    @classmethod
    def from_r0(cls, r0, units=None):
        r"""
        from_r0(r0, units=None)

        Initialize a Burkert potential from the core radius, ``r0``.
        See Equations 4 and 5 of Mori & Burkert.

        Parameters
        ----------
        r0 : :class:`~astropy.units.Quantity`, numeric [length]
            The core radius of the Burkert potential.
        """
        a = 0.021572405792749372 * u.Msun / u.pc**3  # converted: 1.46e-24 g/cm**3
        rho_d0 = a * (r0 / (3.07 * u.kpc))**(-2/3)
        return cls(rho=rho_d0, r0=r0, units=units)


# ============================================================================
# Flattened, axisymmetric models
#


@format_doc(common_doc=_potential_docstring)
class SatohPotential(CPotentialBase):
    r"""
    SatohPotential(m, a, b, units=None, origin=None, R=None)

    Satoh potential for a flattened mass distribution.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    a : :class:`~astropy.units.Quantity`, numeric [length]
        Scale length.
    b : :class:`~astropy.units.Quantity`, numeric [length]
        Scale height.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    a = PotentialParameter("a", physical_type="length")
    b = PotentialParameter("b", physical_type="length")

    Wrapper = SatohWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        R = sy.sqrt(v["x"] ** 2 + v["y"] ** 2)
        z = v["z"]
        term = R**2 + z**2 + p["a"] * (p["a"] + 2 * sy.sqrt(z**2 + p["b"] ** 2))
        expr = -p["G"] * p["m"] / sy.sqrt(term)
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class KuzminPotential(CPotentialBase):
    r"""
    KuzminPotential(m, a, units=None, origin=None, R=None)

    Kuzmin potential for a flattened mass distribution.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    a : :class:`~astropy.units.Quantity`, numeric [length]
        Flattening parameter.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    a = PotentialParameter("a", physical_type="length")

    Wrapper = KuzminWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        denom = sy.sqrt(v["x"] ** 2 + v["y"] ** 2 + (p["a"] + sy.Abs(v["z"])) ** 2)
        expr = -p["G"] * p["m"] / denom
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class MiyamotoNagaiPotential(CPotentialBase):
    r"""
    MiyamotoNagaiPotential(m, a, b, units=None, origin=None, R=None)

    Miyamoto-Nagai potential for a flattened mass distribution.

    See: http://adsabs.harvard.edu/abs/1975PASJ...27..533M

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    a : :class:`~astropy.units.Quantity`, numeric [length]
        Scale length.
    b : :class:`~astropy.units.Quantity`, numeric [length]
        Scale height.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    a = PotentialParameter("a", physical_type="length")
    b = PotentialParameter("b", physical_type="length")

    Wrapper = MiyamotoNagaiWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        R = sy.sqrt(v["x"] ** 2 + v["y"] ** 2)
        z = v["z"]
        term = R**2 + (p["a"] + sy.sqrt(z**2 + p["b"] ** 2)) ** 2
        expr = -p["G"] * p["m"] / sy.sqrt(term)
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class MN3ExponentialDiskPotential(CPotentialBase):
    """
    MN3ExponentialDiskPotential(m, h_R, h_z, positive_density=True, sech2_z=True,
    units=None, origin=None, R=None)

    A sum of three Miyamoto-Nagai disk potentials that approximate the potential
    generated by a double exponential disk.

    This model is taken from `Smith et al. (2015)
    <https://ui.adsabs.harvard.edu/abs/2015MNRAS.448.2934S/abstract>`_ - if you
    use this potential class, please also cite that work.

    As described in the above reference, this approximation has two options: (1)
    with the ``positive_density=True`` argument set, this density will be
    positive everywhere, but is only a good approximation of the exponential
    density within about 5 disk scale lengths, and (2) with
    ``positive_density=False``, this density will be negative in some regions,
    but is a better approximation out to about 7 or 8 disk scale lengths.

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Mass.
    h_R : :class:`~astropy.units.Quantity`, numeric [length]
        Radial (exponential) scale length.
    h_z : :class:`~astropy.units.Quantity`, numeric [length]
        If ``sech2_z=True``, this is the scale height in a sech^2 vertical
        profile. If ``sech2_z=False``, this is an exponential scale height.
    {common_doc}

    """

    m = PotentialParameter("m", physical_type="mass")
    h_R = PotentialParameter("h_R", physical_type="length")
    h_z = PotentialParameter("h_z", physical_type="length")
    Wrapper = MN3ExponentialDiskWrapper

    _K_pos_dens = np.array(
        [
            [0.0036, -0.0330, 0.1117, -0.1335, 0.1749],
            [-0.0131, 0.1090, -0.3035, 0.2921, -5.7976],
            [-0.0048, 0.0454, -0.1425, 0.1012, 6.7120],
            [-0.0158, 0.0993, -0.2070, -0.7089, 0.6445],
            [-0.0319, 0.1514, -0.1279, -0.9325, 2.6836],
            [-0.0326, 0.1816, -0.2943, -0.6329, 2.3193],
        ]
    )
    _K_neg_dens = np.array(
        [
            [-0.0090, 0.0640, -0.1653, 0.1164, 1.9487],
            [0.0173, -0.0903, 0.0877, 0.2029, -1.3077],
            [-0.0051, 0.0287, -0.0361, -0.0544, 0.2242],
            [-0.0358, 0.2610, -0.6987, -0.1193, 2.0074],
            [-0.0830, 0.4992, -0.7967, -1.2966, 4.4441],
            [-0.0247, 0.1718, -0.4124, -0.5944, 0.7333],
        ]
    )

    def __init__(
        self,
        *args,
        units=None,
        origin=None,
        R=None,
        positive_density=True,
        sech2_z=True,
        **kwargs,
    ):
        PotentialBase.__init__(self, *args, units=units, origin=origin, R=R, **kwargs)
        hzR = (self.parameters["h_z"] / self.parameters["h_R"]).decompose()

        if positive_density:
            K = self._K_pos_dens
        else:
            K = self._K_neg_dens

        # get b / h_R
        if sech2_z:
            b_hR = -0.033 * hzR**3 + 0.262 * hzR**2 + 0.659 * hzR
        else:
            b_hR = -0.269 * hzR**3 + 1.08 * hzR**2 + 1.092 * hzR

        self.positive_density = positive_density
        self.sech2_z = sech2_z

        x = np.vander([b_hR], N=5)[0]

        param_vec = K @ x

        self._ms = param_vec[:3] * self.parameters["m"].value
        self._as = param_vec[3:] * self.parameters["h_R"].value
        self._b = b_hR * self.parameters["h_R"]

        c_only = {}
        for i in range(3):
            c_only[f"m{i+1}"] = self._ms[i]
            c_only[f"a{i+1}"] = self._as[i]
            c_only[f"b{i+1}"] = self._b.value

        self._setup_wrapper(c_only)

    def get_three_potentials(self):
        """
        Return three MiyamotoNagaiPotential instances that represent the three internal
        components of this MN3 potential model
        """
        pots = {}
        for i in range(3):
            name = f"disk{i+1}"
            pots[name] = MiyamotoNagaiPotential(
                m=self._ms[i], a=self._as[i], b=self._b, units=self.units
            )
        return pots


# ============================================================================
# Triaxial models
#


@format_doc(common_doc=_potential_docstring)
class NFWPotential(CPotentialBase):
    r"""
    NFWPotential(m, r_s, a=1, b=1, c=1, units=None, origin=None, R=None)

    General Navarro-Frenk-White potential. Supports spherical, flattened, and
    triaxiality but the flattening is introduced into the potential, not the
    density, and can therefore lead to unphysical mass distributions. For a
    triaxial NFW potential that supports flattening in the density, see
    :class:`gala.potential.LeeSutoTriaxialNFWPotential`.

    See also the alternate initializers: `NFWPotential.from_circular_velocity`
    and `NFWPotential.from_M200_c`

    Parameters
    ----------
    m : :class:`~astropy.units.Quantity`, numeric [mass]
        Scale mass.
    r_s : :class:`~astropy.units.Quantity`, numeric [length]
        Scale radius.
    a : numeric
        Major axis scale.
    b : numeric
        Intermediate axis scale.
    c : numeric
        Minor axis scale.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    r_s = PotentialParameter("r_s", physical_type="length")
    a = PotentialParameter("a", physical_type="dimensionless", default=1.0)
    b = PotentialParameter("b", physical_type="dimensionless", default=1.0)
    c = PotentialParameter("c", physical_type="dimensionless", default=1.0)

    def _setup_potential(self, parameters, origin=None, R=None, units=None):
        super()._setup_potential(parameters, origin=origin, R=R, units=units)

        a = self.parameters["a"]
        b = self.parameters["b"]
        c = self.parameters["c"]

        if np.allclose([a, b, c], 1.0):
            self.Wrapper = SphericalNFWWrapper

        elif np.allclose([a, b], 1.0):
            self.Wrapper = FlattenedNFWWrapper

        else:
            self.Wrapper = TriaxialNFWWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        uu = (
            sy.sqrt(
                (v["x"] / p["a"]) ** 2 + (v["y"] / p["b"]) ** 2 + (v["z"] / p["c"]) ** 2
            )
            / p["r_s"]
        )
        v_h2 = p["G"] * p["m"] / p["r_s"]
        expr = -v_h2 * sy.log(1 + uu) / uu
        return expr, v, p

    @staticmethod
    def from_M200_c(M200, c, rho_c=None, units=None, origin=None, R=None):
        r"""
        from_M200_c(M200, c, rho_c=None, units=None, origin=None, R=None)

        Initialize an NFW potential from a virial mass, ``M200``, and a
        concentration, ``c``.

        Parameters
        ----------
        M200 : :class:`~astropy.units.Quantity`, numeric [mass]
            Virial mass, or mass at 200 times the critical density, ``rho_c``.
        c : numeric
            NFW halo concentration.
        rho_c : :class:`~astropy.units.Quantity`, numeric [density]
            Critical density at z=0. If not specified, uses the default astropy
            cosmology to obtain this, `~astropy.cosmology.default_cosmology`.
        """
        if rho_c is None:
            from astropy.constants import G
            from astropy.cosmology import default_cosmology

            cosmo = default_cosmology.get()
            rho_c = (3 * cosmo.H(0.0) ** 2 / (8 * np.pi * G)).to(u.Msun / u.kpc**3)

        Rvir = np.cbrt(M200 / (200 * rho_c) / (4.0 / 3 * np.pi)).to(u.kpc)
        r_s = Rvir / c

        A_NFW = np.log(1 + c) - c / (1 + c)
        m = M200 / A_NFW

        return NFWPotential(
            m=m, r_s=r_s, a=1.0, b=1.0, c=1.0, units=units, origin=origin, R=R
        )

    @staticmethod
    def from_circular_velocity(
        v_c,
        r_s,
        a=1.0,
        b=1.0,
        c=1.0,
        r_ref=None,
        units=None,
        origin=None,
        R=None,
    ):
        r"""
        Initialize an NFW potential from a circular velocity, scale radius, and
        reference radius for the circular velocity.

        For scale mass :math:`m_s`, scale radius :math:`r_s`, scaled
        reference radius :math:`u_{\rm ref} = r_{\rm ref}/r_s`:

        .. math::

            \frac{G\,m_s}{r_s} = \frac{v_c^2}{u_{\rm ref}} \,
                \left[\frac{u_{\rm ref}}{1+u_{\rm ref}} -
                \frac{\ln(1+u_{\rm ref})}{u_{\rm ref}^2} \right]^{-1}

        Parameters
        ----------
        v_c : :class:`~astropy.units.Quantity`, numeric [velocity]
            Circular velocity at the reference radius ``r_ref`` (see below).
        r_s : :class:`~astropy.units.Quantity`, numeric [length]
            Scale radius.
        a : numeric
            Major axis scale.
        b : numeric
            Intermediate axis scale.
        c : numeric
            Minor axis scale.
        r_ref : :class:`~astropy.units.Quantity`, numeric [length] (optional)
            Reference radius at which the circular velocity is given. By default,
            this is assumed to be the scale radius, ``r_s``.

        """

        if not hasattr(v_c, "unit"):
            v_c = v_c * units["length"] / units["time"]

        if not hasattr(r_s, "unit"):
            r_s = r_s * units["length"]

        if r_ref is None:
            r_ref = r_s

        m = NFWPotential._vc_rs_rref_to_m(v_c, r_s, r_ref)
        m = m.to(units["mass"])

        return NFWPotential(
            m=m, r_s=r_s, a=a, b=b, c=c, units=units, origin=origin, R=R
        )

    @staticmethod
    def _vc_rs_rref_to_m(v_c, r_s, r_ref):
        uu = r_ref / r_s
        vs2 = v_c**2 / uu / (np.log(1 + uu) / uu**2 - 1 / (uu * (1 + uu)))
        return r_s * vs2 / G


@format_doc(common_doc=_potential_docstring)
class LogarithmicPotential(CPotentialBase):
    r"""
    LogarithmicPotential(v_c, r_h, q1, q2, q3, phi=0, theta=0, psi=0, units=None,
    origin=None, R=None)

    Triaxial logarithmic potential.

    Parameters
    ----------
    v_c : :class:`~astropy.units.Quantity`, numeric [velocity]
        Circular velocity.
    r_h : :class:`~astropy.units.Quantity`, numeric [length]
        Scale radius.
    q1 : numeric
        Flattening in X.
    q2 : numeric
        Flattening in Y.
    q3 : numeric
        Flattening in Z.
    phi : `~astropy.units.Quantity`, numeric
        First euler angle in the z-x-z convention.
    {common_doc}
    """

    v_c = PotentialParameter("v_c", physical_type="speed")
    r_h = PotentialParameter("r_h", physical_type="length")
    q1 = PotentialParameter("q1", physical_type="dimensionless", default=1.0)
    q2 = PotentialParameter("q2", physical_type="dimensionless", default=1.0)
    q3 = PotentialParameter("q3", physical_type="dimensionless", default=1.0)
    phi = PotentialParameter("phi", physical_type="angle", default=0.0)

    Wrapper = LogarithmicWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        r2 = (v["x"] / p["q1"]) ** 2 + (v["y"] / p["q2"]) ** 2 + (v["z"] / p["q3"]) ** 2
        expr = 1.0 / 2 * p["v_c"] ** 2 * sy.log(p["r_h"] ** 2 + r2)
        return expr, v, p


@format_doc(common_doc=_potential_docstring)
class LeeSutoTriaxialNFWPotential(CPotentialBase):
    r"""
    LeeSutoTriaxialNFWPotential(v_c, r_s, a, b, c, units=None, origin=None, R=None)

    Approximation of a Triaxial NFW Potential with the flattening in the density,
    not the potential.
    See `Lee & Suto (2003) <http://adsabs.harvard.edu/abs/2003ApJ...585..151L>`_
    for details.

    Parameters
    ----------
    v_c : `~astropy.units.Quantity`, numeric [velocity]
        Circular velocity at the scale radius.
    r_h : `~astropy.units.Quantity`, numeric [length]
        Scale radius.
    a : numeric
        Major axis.
    b : numeric
        Intermediate axis.
    c : numeric
        Minor axis.
    {common_doc}
    """

    v_c = PotentialParameter("v_c", physical_type="speed")
    r_s = PotentialParameter("r_s", physical_type="length")
    a = PotentialParameter("a", physical_type="dimensionless", default=1.0)
    b = PotentialParameter("b", physical_type="dimensionless", default=1.0)
    c = PotentialParameter("c", physical_type="dimensionless", default=1.0)

    Wrapper = LeeSutoTriaxialNFWWrapper

    # TODO: implement to_sympy()


@format_doc(common_doc=_potential_docstring)
class LongMuraliBarPotential(CPotentialBase):
    r"""
    LongMuraliBarPotential(m, a, b, c, alpha=0, units=None, origin=None, R=None)

    A simple, triaxial model for a galaxy bar. This is a softened "needle"
    density distribution with an analytic potential form.
    See `Long & Murali (1992) <http://adsabs.harvard.edu/abs/1992ApJ...397...44L>`_
    for details.

    Parameters
    ----------
    m : `~astropy.units.Quantity`, numeric [mass]
        Mass scale.
    a : `~astropy.units.Quantity`, numeric [length]
        Bar half-length.
    b : `~astropy.units.Quantity`, numeric [length]
        Like the Miyamoto-Nagai ``b`` parameter.
    c : `~astropy.units.Quantity`, numeric [length]
        Like the Miyamoto-Nagai ``c`` parameter.
    {common_doc}
    """

    m = PotentialParameter("m", physical_type="mass")
    a = PotentialParameter("a", physical_type="length")
    b = PotentialParameter("b", physical_type="length")
    c = PotentialParameter("c", physical_type="length")
    alpha = PotentialParameter("alpha", physical_type="angle", default=0)

    Wrapper = LongMuraliBarWrapper

    @myclassmethod
    @sympy_wrap
    def to_sympy(cls, v, p):
        import sympy as sy

        x = v["x"] * sy.cos(p["alpha"]) + v["y"] * sy.sin(p["alpha"])
        y = -v["x"] * sy.sin(p["alpha"]) + v["y"] * sy.cos(p["alpha"])
        z = v["z"]

        Tm = sy.sqrt(
            (p["a"] - x) ** 2 + y**2 + (p["b"] + sy.sqrt(p["c"] ** 2 + z**2)) ** 2
        )
        Tp = sy.sqrt(
            (p["a"] + x) ** 2 + y**2 + (p["b"] + sy.sqrt(p["c"] ** 2 + z**2)) ** 2
        )

        expr = (
            p["G"]
            * p["m"]
            / (2 * p["a"])
            * sy.log((x - p["a"] + Tm) / (x + p["a"] + Tp))
        )

        return expr, v, p


# ==============================================================================
# Special
#


@format_doc(common_doc=_potential_docstring)
class NullPotential(CPotentialBase):
    r"""
    NullPotential(units=None, origin=None, R=None)

    A null potential with 0 mass. Does nothing.

    Parameters
    ----------
    {common_doc}
    """

    Wrapper = NullWrapper


# ==============================================================================
# Multipole and flexible potential models
#
mp_cache = {}


def make_multipole_cls(lmax, timedep=False):
    """Create a MultipolePotential or MultipoleTimeDependentPotential class
    (not an instance!) with the specified value of lmax.

    Parameters:
    -----------
    lmax : int
    timedep : bool

    """
    if timedep:
        raise NotImplementedError("Time dependent potential coming soon!")
        # cls = MultipoleTimeDependentPotential
        # param_default = [0.]
    else:
        cls = MultipolePotential
        param_default = 0.0
    cls_name = f"{cls.__name__}Lmax{lmax}"

    if cls_name in mp_cache:
        return mp_cache[cls_name]

    parameters = {
        "_lmax": lmax,
        "inner": PotentialParameter("inner", default=False),
        "m": PotentialParameter("m", physical_type="mass", default=1.0),
        "r_s": PotentialParameter("r_s", physical_type="length", default=1.0),
    }
    doc_lines = []
    ab_callsig = []
    for l in range(lmax + 1):
        for m in range(0, l + 1):
            if timedep:
                a = f"alpha{l}{m}"
                b = f"beta{l}{m}"
                dtype = "array-like"
            else:
                a = f"S{l}{m}"
                b = f"T{l}{m}"
                dtype = "float"

            parameters[a] = PotentialParameter(
                a, physical_type="dimensionless", default=param_default
            )
            parameters[b] = PotentialParameter(
                b, physical_type="dimensionless", default=param_default
            )

            doc_lines.append(f"{a} : {dtype}\n{b} : {dtype}")
            ab_callsig.append(f"{a}, {b}")

    ab_callsig = ", ".join(ab_callsig)
    call_signature = f"{cls.__name__}(m, r_s, {ab_callsig})"
    parameters["__doc__"] = call_signature + cls.__doc__ + "\n".join(doc_lines)

    # https://stackoverflow.com/a/58716798/623453
    parameters["__module__"] = __name__

    # Create a new SkyOffsetFrame subclass for this frame class.
    potential_cls = type(cls_name, (cls,), parameters)
    mp_cache[cls_name] = potential_cls
    return mp_cache[cls_name]


class MultipolePotential(CPotentialBase, GSL_only=True):
    r"""

    A perturbing potential represented by a multipole expansion.

    Inner:

    .. math::

        \Phi^l_\mathrm{max}(r,\theta,\phi) = \sum_{l=1}^{l=l_\mathrm{max}}\sum_{m=0}^{m=l}
            r^l \, (S_{lm} \, \cos{m\,\phi} + T_{lm} \, \sin{m\,\phi})
            \, P_l^m(\cos\theta)

    Outer:

    .. math::

        \Phi^l_\mathrm{max}(r,\theta,\phi) = \sum_{l=1}^{l=l_\mathrm{max}}\sum_{m=0}^{m=l}
            r^{-(l+1)} \, (S_{lm} \, \cos{m\,\phi} + T_{lm} \, \sin{m\,\phi})
            \, P_l^m(\cos\theta)


    The allowed coefficient parameter names will depend on how you set ``lmax``, and the
    default value for all coefficient parameter values is 0.

    Parameters
    ----------
    m : numeric
        Scale mass.
    r_s : numeric
        Scale length.
    lmax : int
        The maximum ``l`` order.
    inner : bool (optional)
        Controls whether to use the inner expansion, or the outer expansion (see above).
        Default value = ``False``.
    S00 : float (optional)
    S10 : float (optional)
    S11 : float (optional)
    T11 : float (optional)
    etc.

    Examples
    --------
    To create a potential object with only a dipole:

        >>> pot = MultipolePotential(lmax=1, S10=5.)
    """

    Wrapper = MultipoleWrapper

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        kwargs.pop("lmax", None)

        PotentialBase.__init__(self, *args, units=units, origin=origin, R=R, **kwargs)

        self._setup_wrapper(
            {"lmax": self._lmax, "n_coeffs": sum(range(self._lmax + 2))}
        )

    def __new__(cls, *args, **kwargs):
        # We don't want to call this method if we've already set up
        # an skyoffset frame for this class.
        if not (issubclass(cls, MultipolePotential) and cls is not MultipolePotential):
            try:
                lmax = kwargs["lmax"]
            except KeyError:
                raise TypeError(
                    "Can't initialize a MultipolePotential without specifying "
                    "the `lmax` keyword argument."
                )
            newcls = make_multipole_cls(lmax)
            return newcls.__new__(newcls, *args, **kwargs)

        if super().__new__ is object.__new__:
            return super().__new__(cls)
        return super().__new__(cls, *args, **kwargs)


@format_doc(common_doc=_potential_docstring)
class CylSplinePotential(CPotentialBase):
    r"""
    A flexible potential model that uses spline interpolation over a 2D grid in
    cylindrical R-z coordinates.

    Parameters
    ----------
    grid_R : `~astropy.units.Quantity`, numeric [length]
        A 1D grid of cylindrical radius R values. This should start at 0.
    grid_z : `~astropy.units.Quantity`, numeric [length]
        A 1D grid of cylindrical z values. This should start at 0.
    grid_Phi : `~astropy.units.Quantity`, numeric [specific energy]
        A 2D grid of potential values, evaluated at all R,z locations.
    {common_doc}
    """

    grid_R = PotentialParameter("grid_R", physical_type="length")
    grid_z = PotentialParameter("grid_z", physical_type="length")
    grid_Phi = PotentialParameter("grid_Phi", physical_type="specific energy")

    Wrapper = CylSplineWrapper

    @classmethod
    def from_file(cls, filename, **kwargs):
        """Load a potential instance from an Agama export file.

        Parameters
        ----------
        filename : path-like
            The path to the Agama expoirt file, either as a string or ``pathlib.Path`` object.
        **kwargs
            Other keyword arguments are passed to the initializer.
        """
        with open(filename, "r") as f:
            raw_lines = f.readlines()

        start = r"#R(row)\z(col)"
        Phi_lines = []
        for i, line in enumerate(raw_lines):
            if line.startswith(start):
                Phi_lines.append(
                    [np.nan]
                    + [float(y) for y in line[len(start) :].strip().split("\t")]
                )
                break

        Phi_lines.extend(
            [[float(y) for y in x.strip().split("\t")] for x in raw_lines[i + 1 :]]
        )
        Phi_lines = np.array(Phi_lines)

        gridR = Phi_lines[1:, 0] * u.kpc
        gridz = Phi_lines[0, 1:] * u.kpc
        gridPhi = Phi_lines[1:, 1:] * (u.km / u.s) ** 2

        return cls(gridR, gridz, gridPhi, **kwargs)

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        PotentialBase.__init__(self, *args, units=units, origin=origin, R=R, **kwargs)

        grid_R = self.parameters["grid_R"]
        grid_z = self.parameters["grid_z"]
        grid_Phi = self.parameters["grid_Phi"]
        Phi0 = grid_Phi[0, 0]  # potential at R=0,z=0

        self._multipole_pot = self._fit_asympt(grid_R, grid_z, grid_Phi)
        Phi_Rmax = self._multipole_pot.energy([1.0, 0, 0] * grid_R.max())
        Mtot = -Phi_Rmax[0] * grid_R.max()

        if Phi0 < 0 and Mtot > 0:
            # assign Rscale so that it approximately equals -Mtotal/Phi(r=0),
            # i.e. would equal the scale radius of a Plummer potential
            Rscale = (-Mtot / Phi0).to(self.units["length"])
        else:
            Rscale = grid_R[len(grid_R) // 2]  # "rather arbitrary"

        # APW: assumed / enforced mmax=0 - different from Agama

        sizeR = len(grid_R)

        # grid in z assumed to only cover half-space z>=0; the density is assumed
        # to be z-reflection symmetric:
        sizez_orig = len(grid_z)
        grid_z = np.concatenate((-grid_z[::-1], grid_z[1:]))
        sizez = len(grid_z)

        # transform the grid to log-scaled coordinates
        grid_R_asinh = np.arcsinh((grid_R / Rscale).decompose().value)
        grid_z_asinh = np.arcsinh((grid_z / Rscale).decompose().value)

        logScaling = np.all(grid_Phi < 0)

        # temporary containers of scaled potential and derivatives used to
        # construct 2d splines

        if grid_Phi.shape[0] != sizeR or grid_Phi.shape[1] != sizez_orig:
            raise ValueError("CylSpline: incorrect coefs array size")

        grid_Phi_full = np.zeros((sizeR, sizez))
        grid_Phi_full[:, : sizez_orig - 1] = grid_Phi[:, :0:-1]
        grid_Phi_full[:, sizez_orig - 1 :] = grid_Phi
        if logScaling:
            grid_Phi_full = np.log(-grid_Phi_full)
        else:
            grid_Phi_full = grid_Phi_full

        from scipy.interpolate import RectBivariateSpline

        self.spl = RectBivariateSpline(grid_R_asinh, grid_z_asinh, grid_Phi_full)

        # Note: if MultipolePotential parameter order changes, this needs to be updated!
        multipole_pars = np.concatenate(
            [
                [
                    self.G,
                    self._multipole_pot._lmax,
                    sum(range(self._multipole_pot._lmax + 2)),
                ],
                [x.value for x in self._multipole_pot.parameters.values()],
            ]
        )

        self._c_only = {
            "log_scaling": logScaling,
            "Rscale": Rscale.value,
            "sizeR": sizeR,
            "sizez": sizez,
            "grid_R_trans": grid_R_asinh,
            "grid_z_trans": grid_z_asinh,
            "grid_Phi_trans": grid_Phi_full.T,
            "multipole_pars": multipole_pars,
        }
        self._setup_wrapper(self._c_only)

    def _fit_asympt(self, grid_R, grid_z, grid_Phi, lmax_fit=8):
        """
        Assumes z reflection symmetry

        lmax_fit : int
            Number of meridional harmonics to fit - don't set too large

        """
        from scipy.special import sph_harm

        sizeR = len(grid_R)
        sizez = len(grid_z)

        # assemble the boundary points and their indices
        assert grid_Phi.shape == (sizeR, sizez)
        maxz = np.max(grid_z.value)

        # first run along R at the max-z and min-z edges
        points = np.concatenate(
            ([[R, maxz] for R in grid_R.value], [[R, -maxz] for R in grid_R.value])
        )
        Phis = np.concatenate(
            (grid_Phi[:, np.argmax(grid_z)].value, grid_Phi[:, np.argmax(grid_z)].value)
        )

        maxR = np.max(grid_R.value)
        points = np.concatenate(
            (
                points,
                [[maxR, z] for z in grid_z.value],
                [[maxR, -z] for z in grid_z.value],
            )
        )
        Phis = np.concatenate(
            (
                Phis,
                grid_Phi[np.argmax(grid_R), :].value,
                grid_Phi[np.argmax(grid_R), :].value,
            )
        )

        npoints = len(points)
        # ncoefs = lmax_fit + 1

        r0 = min(np.max(grid_R), np.max(grid_z))

        i, j = len(grid_R) // 2, len(grid_z) // 2
        rr = np.sqrt(grid_R[i] ** 2 + grid_z[j] ** 2)
        m = np.abs(grid_Phi[i, j] * rr / G).to(self.units["mass"])
        scale = (G * m / r0).decompose(self.units).value

        # find values of spherical harmonic coefficients
        # that best match the potential at the array of boundary points

        # for m-th harmonic, we may have lmax-m+1 different l-terms
        matr = np.zeros((npoints, lmax_fit + 1))

        # The linear system to solve in the least-square sense is M_{p,l} * S_l = R_p,
        # where R_p = Phi at p-th boundary point (0<=p<npoints),
        # M_{l,p}   = value of l-th harmonic coefficient at p-th boundary point,
        # S_l       = the amplitude of l-th coefficient to be determined.
        r = np.sqrt(points[:, 0] ** 2 + points[:, 1] ** 2)
        theta = np.arctan2(points[:, 0], points[:, 1])

        ls = np.arange(lmax_fit + 1)
        Pl0 = np.stack([sph_harm(0, l, 0.0, theta).real for l in ls]).T

        matr = (r[:, None] / r0.value) ** -(ls[None] + 1) * Pl0
        y = Phis / scale
        sol, resid, rank, s = np.linalg.lstsq(matr, y, rcond=None)

        pars = {f"S{l}0": sol[l].real for l in ls}
        return MultipolePotential(
            lmax=lmax_fit, m=m, r_s=r0, inner=False, units=self.units, **pars
        )
</file>

<file path="gala/potential/potential/builtin/cybuiltin.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" Built-in potential wrappers """

# Standard library
import warnings

# Third-party
from astropy.constants import G
import astropy.units as u
import numpy as np
cimport numpy as np
np.import_array()

# Project
from ..core import CompositePotential, _potential_docstring, PotentialBase
from ..util import format_doc, sympy_wrap
from ..cpotential import CPotentialBase
from ..cpotential cimport CPotential, CPotentialWrapper
from ..cpotential cimport densityfunc, energyfunc, gradientfunc, hessianfunc
from ...common import PotentialParameter
from ...frame.cframe cimport CFrameWrapper
from ....units import dimensionless, DimensionlessUnitSystem

cdef extern from "extra_compile_macros.h":
    int USE_GSL

cdef extern from "potential/potential/builtin/builtin_potentials.h":
    double null_value(double t, double *pars, double *q, int n_dim) nogil
    void null_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double null_density(double t, double *pars, double *q, int n_dim) nogil
    void null_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double henon_heiles_value(double t, double *pars, double *q, int n_dim) nogil
    void henon_heiles_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void henon_heiles_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double kepler_value(double t, double *pars, double *q, int n_dim) nogil
    void kepler_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double kepler_density(double t, double *pars, double *q, int n_dim) nogil
    void kepler_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double isochrone_value(double t, double *pars, double *q, int n_dim) nogil
    void isochrone_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double isochrone_density(double t, double *pars, double *q, int n_dim) nogil
    void isochrone_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double hernquist_value(double t, double *pars, double *q, int n_dim) nogil
    void hernquist_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double hernquist_density(double t, double *pars, double *q, int n_dim) nogil
    void hernquist_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double plummer_value(double t, double *pars, double *q, int n_dim) nogil
    void plummer_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double plummer_density(double t, double *pars, double *q, int n_dim) nogil
    void plummer_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double jaffe_value(double t, double *pars, double *q, int n_dim) nogil
    void jaffe_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double jaffe_density(double t, double *pars, double *q, int n_dim) nogil
    void jaffe_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double powerlawcutoff_value(double t, double *pars, double *q, int n_dim) nogil
    void powerlawcutoff_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double powerlawcutoff_density(double t, double *pars, double *q, int n_dim) nogil
    void powerlawcutoff_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double stone_value(double t, double *pars, double *q, int n_dim) nogil
    void stone_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double stone_density(double t, double *pars, double *q, int n_dim) nogil
    void stone_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double sphericalnfw_value(double t, double *pars, double *q, int n_dim) nogil
    void sphericalnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double sphericalnfw_density(double t, double *pars, double *q, int n_dim) nogil
    void sphericalnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double flattenednfw_value(double t, double *pars, double *q, int n_dim) nogil
    void flattenednfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void flattenednfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double triaxialnfw_value(double t, double *pars, double *q, int n_dim) nogil
    void triaxialnfw_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void triaxialnfw_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double satoh_value(double t, double *pars, double *q, int n_dim) nogil
    void satoh_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double satoh_density(double t, double *pars, double *q, int n_dim) nogil
    void satoh_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double kuzmin_value(double t, double *pars, double *q, int n_dim) nogil
    void kuzmin_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double kuzmin_density(double t, double *pars, double *q, int n_dim) nogil

    double miyamotonagai_value(double t, double *pars, double *q, int n_dim) nogil
    void miyamotonagai_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void miyamotonagai_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil
    double miyamotonagai_density(double t, double *pars, double *q, int n_dim) nogil

    double mn3_value(double t, double *pars, double *q, int n_dim) nogil
    void mn3_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void mn3_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil
    double mn3_density(double t, double *pars, double *q, int n_dim) nogil

    double leesuto_value(double t, double *pars, double *q, int n_dim) nogil
    void leesuto_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double leesuto_density(double t, double *pars, double *q, int n_dim) nogil

    double logarithmic_value(double t, double *pars, double *q, int n_dim) nogil
    void logarithmic_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void logarithmic_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil
    double logarithmic_density(double t, double *pars, double *q, int n_dim) nogil

    double longmuralibar_value(double t, double *pars, double *q, int n_dim) nogil
    void longmuralibar_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double longmuralibar_density(double t, double *pars, double *q, int n_dim) nogil
    void longmuralibar_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

    double burkert_value(double t, double *pars, double *q, int n_dim) nogil
    void burkert_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double burkert_density(double t, double *pars, double *q, int n_dim) nogil


cdef extern from "potential/potential/builtin/multipole.h":
    double mp_potential(double t, double *pars, double *q, int n_dim) nogil
    void mp_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double mp_density(double t, double *pars, double *q, int n_dim) nogil

    double axisym_cylspline_value(double t, double *pars, double *q, int n_dim) nogil
    void axisym_cylspline_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    double axisym_cylspline_density(double t, double *pars, double *q, int n_dim) nogil

# cdef extern from "gsl/gsl_interp.h":
#     ctypedef struct gsl_interp_accel:
#         pass

# cdef extern from "gsl/gsl_interp2d.h":
#     ctypedef struct gsl_interp2d_type:
#         pass

#     ctypedef struct gsl_interp2d:
#         pass

#     gsl_interp2d_type * gsl_interp2d_bicubic
#     gsl_interp_accel gsl_interp_accel_alloc()
#     double gsl_interp2d_eval(const gsl_interp2d *, const double xa[], const double ya[], const double za[], const double, const double, gsl_interp_accel *, gsl_interp_accel *)

# cdef extern from "gsl/gsl_spline2d.h":
#     ctypedef struct gsl_spline2d:
#         pass

#     int gsl_spline2d_init(gsl_spline2d *spline, const double xa[], const double ya[], const double za[], size_t xsize, size_t ysize)
#     double gsl_spline2d_eval(const gsl_spline2d *spline, const double x, const double y, gsl_interp_accel *xacc, gsl_interp_accel *yacc)


__all__ = [
    'HenonHeilesWrapper',
    'KeplerWrapper',
    'HernquistWrapper',
    'IsochroneWrapper',
    'PlummerWrapper',
    'JaffeWrapper',
    'StoneWrapper',
    'PowerLawCutoffWrapper',
    'SatohWrapper',
    'KuzminWrapper',
    'MiyamotoNagaiWrapper',
    'MN3ExponentialDiskWrapper',
    'SphericalNFWWrapper',
    'FlattenedNFWWrapper',
    'TriaxialNFWWrapper',
    'LeeSutoTriaxialNFWWrapper',
    'LogarithmicWrapper',
    'LongMuraliBarWrapper',
    'NullWrapper',
    'MultipoleWrapper',
    'CylSplineWrapper'
    'BurkertWrapper'
]

# ============================================================================

cdef class HenonHeilesWrapper(CPotentialWrapper):

    def __init__(self, G, _, q0, R):
        self.init([G],
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R),
                  n_dim=2)
        self.cpotential.value[0] = <energyfunc>(henon_heiles_value)
        self.cpotential.gradient[0] = <gradientfunc>(henon_heiles_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(henon_heiles_hessian)


# ============================================================================
# Spherical models
#
cdef class KeplerWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(kepler_value)
        self.cpotential.density[0] = <densityfunc>(kepler_density)
        self.cpotential.gradient[0] = <gradientfunc>(kepler_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(kepler_hessian)


cdef class IsochroneWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(isochrone_value)
        self.cpotential.density[0] = <densityfunc>(isochrone_density)
        self.cpotential.gradient[0] = <gradientfunc>(isochrone_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(isochrone_hessian)


cdef class HernquistWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(hernquist_value)
        self.cpotential.density[0] = <densityfunc>(hernquist_density)
        self.cpotential.gradient[0] = <gradientfunc>(hernquist_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(hernquist_hessian)


cdef class PlummerWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(plummer_value)
        self.cpotential.density[0] = <densityfunc>(plummer_density)
        self.cpotential.gradient[0] = <gradientfunc>(plummer_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(plummer_hessian)


cdef class JaffeWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(jaffe_value)
        self.cpotential.density[0] = <densityfunc>(jaffe_density)
        self.cpotential.gradient[0] = <gradientfunc>(jaffe_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(jaffe_hessian)


cdef class StoneWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(stone_value)
        self.cpotential.density[0] = <densityfunc>(stone_density)
        self.cpotential.gradient[0] = <gradientfunc>(stone_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(stone_hessian)


cdef class PowerLawCutoffWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))

        if USE_GSL == 1:
            self.cpotential.value[0] = <energyfunc>(powerlawcutoff_value)
            self.cpotential.density[0] = <densityfunc>(powerlawcutoff_density)
            self.cpotential.gradient[0] = <gradientfunc>(powerlawcutoff_gradient)
            self.cpotential.hessian[0] = <hessianfunc>(powerlawcutoff_hessian)

cdef class BurkertWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(burkert_value)
        self.cpotential.density[0] = <densityfunc>(burkert_density)
        self.cpotential.gradient[0] = <gradientfunc>(burkert_gradient)


# ============================================================================
# Flattened, axisymmetric models
#
cdef class SatohWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(satoh_value)
        self.cpotential.density[0] = <densityfunc>(satoh_density)
        self.cpotential.gradient[0] = <gradientfunc>(satoh_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(satoh_hessian)


cdef class KuzminWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(kuzmin_value)
        self.cpotential.density[0] = <densityfunc>(kuzmin_density)
        self.cpotential.gradient[0] = <gradientfunc>(kuzmin_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(null_hessian)


cdef class MiyamotoNagaiWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(miyamotonagai_value)
        self.cpotential.density[0] = <densityfunc>(miyamotonagai_density)
        self.cpotential.gradient[0] = <gradientfunc>(miyamotonagai_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(miyamotonagai_hessian)


cdef class MN3ExponentialDiskWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(mn3_value)
        self.cpotential.density[0] = <densityfunc>(mn3_density)
        self.cpotential.gradient[0] = <gradientfunc>(mn3_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(mn3_hessian)


# ============================================================================
# Triaxial models
#

cdef class SphericalNFWWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(sphericalnfw_value)
        self.cpotential.density[0] = <densityfunc>(sphericalnfw_density)
        self.cpotential.gradient[0] = <gradientfunc>(sphericalnfw_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(sphericalnfw_hessian)

cdef class FlattenedNFWWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(flattenednfw_value)
        self.cpotential.gradient[0] = <gradientfunc>(flattenednfw_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(flattenednfw_hessian)

cdef class TriaxialNFWWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(triaxialnfw_value)
        self.cpotential.gradient[0] = <gradientfunc>(triaxialnfw_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(triaxialnfw_hessian)


cdef class LogarithmicWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(logarithmic_value)
        self.cpotential.gradient[0] = <gradientfunc>(logarithmic_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(logarithmic_hessian)
        self.cpotential.density[0] = <energyfunc>(logarithmic_density)


cdef class LeeSutoTriaxialNFWWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(leesuto_value)
        self.cpotential.density[0] = <densityfunc>(leesuto_density)
        self.cpotential.gradient[0] = <gradientfunc>(leesuto_gradient)


cdef class LongMuraliBarWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(longmuralibar_value)
        self.cpotential.gradient[0] = <gradientfunc>(longmuralibar_gradient)
        self.cpotential.density[0] = <densityfunc>(longmuralibar_density)
        self.cpotential.hessian[0] = <hessianfunc>(longmuralibar_hessian)


# ==============================================================================
# Special
#
cdef class NullWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G],
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        self.cpotential.value[0] = <energyfunc>(null_value)
        self.cpotential.density[0] = <densityfunc>(null_density)
        self.cpotential.gradient[0] = <gradientfunc>(null_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(null_hessian)
        self.cpotential.null = 1


# ==============================================================================
# Multipole and flexible potential models
#
cdef class MultipoleWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))

        if USE_GSL == 1:
            self.cpotential.value[0] = <energyfunc>(mp_potential)
            self.cpotential.density[0] = <densityfunc>(mp_density)
            self.cpotential.gradient[0] = <gradientfunc>(mp_gradient)


cdef class CylSplineWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))

        if USE_GSL == 1:
            self.cpotential.value[0] = <energyfunc>(axisym_cylspline_value)
            self.cpotential.gradient[0] = <gradientfunc>(axisym_cylspline_gradient)
            self.cpotential.density[0] = <densityfunc>(axisym_cylspline_density)
            #self.cpotential.hessian[0] = <hessianfunc>(axisym_cylspline_hessian)
</file>

<file path="gala/potential/potential/builtin/multipole.c">
/*
copied from https://github.com/adrn/gala/blob/main/gala/potential/scf/src/bfe.c
and https://github.com/adrn/gala/blob/main/gala/potential/scf/src/bfe_helper.c
*/
#include <stdlib.h>
#include <stdio.h>
#include "extra_compile_macros.h"
#include <math.h>
#include <string.h>

#define SQRT_FOURPI 3.544907701811031

#if USE_GSL == 1

#include "gsl/gsl_sf_legendre.h"
#include "gsl/gsl_sf_gegenbauer.h"
#include "gsl/gsl_sf_gamma.h"
#include <gsl/gsl_math.h>
#include <gsl/gsl_interp2d.h>
#include <gsl/gsl_spline2d.h>

/* --------------------------------------------------------------------------

    Low-level helper functions

*/

/*
    Density
*/
double mp_rho_l_outer(double r, int l) {
    return l * (l+1) * pow(r, -(l+3));
}

double mp_rho_l_inner(double r, int l) {
    return l * (l+1) * pow(r, l-2);
}

double mp_rho_lm(double r, double phi, double X, int l, int m, int inner) {
    if (inner > 0) {
        return mp_rho_l_inner(r, l) * gsl_sf_legendre_sphPlm(l, m, X);
    } else {
        return mp_rho_l_outer(r, l) * gsl_sf_legendre_sphPlm(l, m, X);
    }
}

/*
    Potential
*/
double mp_phi_l_outer(double r, int l) {
    return pow(r, -(l + 1));
}

double mp_phi_l_inner(double r, int l) {
    return pow(r, l);
}

double mp_phi_lm(double r, double phi, double X, int l, int m, int inner) {
    if (inner > 0) {
        return mp_phi_l_inner(r, l) * gsl_sf_legendre_sphPlm(l, m, X);
    } else {
        return mp_phi_l_outer(r, l) * gsl_sf_legendre_sphPlm(l, m, X);
    }
}

/*
    Gradient
*/
void mp_sph_grad_phi_lm(double r, double phi, double X, int l, int m,
                        int lmax, int inner, double *sphgrad) {
    double A, dYlm_dtheta;
    double dPhil_dr, dPhi_dphi, dPhi_dtheta;

    // spherical coord stuff
    double sintheta = sqrt(1 - X*X);

    double Phi_l, Ylm, Plm, Pl1m;
    Ylm = gsl_sf_legendre_sphPlm(l, m, X);

    // Correct: associated Legendre polynomial -- not sphPlm!
    if (m <= l) {
        Plm = gsl_sf_legendre_Plm(l, m, X);
    } else {
        Plm = 0.;
    }

    if (inner > 0) {
        Phi_l = mp_phi_l_inner(r, l);
        dPhil_dr = l*pow(r, l-1) * Ylm;
    } else {
        Phi_l = mp_phi_l_outer(r, l);
        dPhil_dr = -(l+1) * pow(r, -l-2) * Ylm;
    }

    if (l==0) {
        dYlm_dtheta = 0.;
    } else {
        // Correct: associated Legendre polynomial -- not sphPlm!
        if (m <= (l-1)) {
            Pl1m = gsl_sf_legendre_Plm(l-1, m, X);
        } else {
            Pl1m = 0.;
        }

        if (l == m) {
            A = sqrt(2*l+1) / SQRT_FOURPI * sqrt(1. / gsl_sf_gamma(l+m+1.));
        } else {
            A = sqrt(2*l+1) / SQRT_FOURPI * sqrt(gsl_sf_gamma(l-m+1.)
                                                 / gsl_sf_gamma(l+m+1.));
        }

        // fixed at sintheta = 0
        if (sintheta != 0) {
            dYlm_dtheta = A / sintheta * (l*X*Plm - (l+m)*Pl1m);
        } else {
            dYlm_dtheta = 0;
        }
    }
    dPhi_dtheta = dYlm_dtheta * Phi_l / r;

    if (m == 0) {
        dPhi_dphi = 0.;
    } else {
        dPhi_dphi = m;
    }
    dPhi_dphi *= Ylm * Phi_l;

    if (r > 0) {
        sphgrad[0] = dPhil_dr;
        sphgrad[1] = dPhi_dtheta;
        sphgrad[2] = dPhi_dphi;
    } else {
        sphgrad[0] = 0;
        sphgrad[1] = 0;
        sphgrad[2] = 0;
    }
}

/*
    High-level functions and helpers
*/

void mp_density_helper(double *xyz, int K,
                       double M, double r_s,
                       double *Slm, double *Tlm,
                       int lmax, int inner, double *dens) {

    int i,j,k, l,m;
    double s, r, X, phi;
    double cosmphi[lmax+1], sinmphi[lmax+1];
    memset(cosmphi, 0, (lmax+1)*sizeof(double));
    memset(sinmphi, 0, (lmax+1)*sizeof(double));
    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r / r_s;
        X = xyz[j+2] / r; // = cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m*phi);
            sinmphi[m] = sin(m*phi);
        }

        i = 0;
        for (l=0; l < (lmax+1); l++) {
            for (m=0; m <= l; m++) {
                if ((Slm[i] == 0.) & (Tlm[i] == 0.)) {
                    i++;
                    continue;
                }
                dens[k] += mp_rho_lm(s, phi, X, l, m, inner) * (
                    Slm[i] * cosmphi[m] + Tlm[i] * sinmphi[m]
                );
                i++;
            }
        }
        dens[k] *= M / (r_s*r_s*r_s);
    }
}

void mp_potential_helper(double *xyz, int K,
                         double G, double M, double r_s,
                         double *Slm, double *Tlm,
                         int lmax, int inner, double *val) {

    int i,j,k, l,m;
    double s, r, X, phi;
    double cosmphi[lmax+1], sinmphi[lmax+1];

    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r / r_s;
        X = xyz[j+2] / r; // = cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        // HACK: zero out before filling;
        val[k] = 0.;

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m * phi);
            sinmphi[m] = sin(m * phi);
        }

        i = 0;
        for (l=0; l < (lmax+1); l++) {
            for (m=0; m < (l+1); m++) {
                if ((Slm[i] == 0.) & (Tlm[i] == 0.)) {
                    i++;
                    continue;
                }
                val[k] += mp_phi_lm(s, phi, X, l, m, inner) * (
                    Slm[i] * cosmphi[m] + Tlm[i] * sinmphi[m]
                );
                i++;
            }
        }
        if((r==0) && inner) {val[k] = 0.;}
        val[k] *= G*M/r_s;
    }
}

void mp_gradient_helper(double *xyz, int K,
                        double G, double M, double r_s,
                        double *Slm, double *Tlm,
                        int lmax, int inner, double *grad) {

    int i,j,k, l,m;
    double s, r, X, phi;
    double sintheta, cosphi, sinphi, tmp;
    double tmp_grad[3], tmp_grad2[3*K]; // TODO: this might be really inefficient
    double cosmphi[lmax+1], sinmphi[lmax+1];

    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r / r_s;
        X = xyz[j+2]/r; // cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        sintheta = sqrt(1 - X*X);
        cosphi = cos(phi);
        sinphi = sin(phi);

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m*phi);
            sinmphi[m] = sin(m*phi);
        }

        // zero out
        tmp_grad2[j+0] = 0.;
        tmp_grad2[j+1] = 0.;
        tmp_grad2[j+2] = 0.;

        i = 0;
        // gsl_sf_legendre_deriv_array(GSL_SF_LEGENDRE_SPHARM, lmax, X,
        //                             double result_array[], double result_deriv_array[]);
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(l+1); m++) {
                tmp = (Slm[i]*cosmphi[m] + Tlm[i]*sinmphi[m]);
                if ((Slm[i] == 0.) & (Tlm[i] == 0.)) {
                    i++;
                    continue;
                }

                mp_sph_grad_phi_lm(s, phi, X, l, m, lmax, inner, &tmp_grad[0]);
                tmp_grad2[j+0] += tmp_grad[0] * tmp; // r
                tmp_grad2[j+1] += tmp_grad[1] * tmp; // phi??

                if (sintheta != 0) {
                    tmp_grad2[j+2] += tmp_grad[2] * (
                        Tlm[i]*cosmphi[m] - Slm[i]*sinmphi[m]
                    ) / (s * sintheta); // theta??
                } else {
                    tmp_grad2[j+2] = 0.;
                }


                i++;
            }
        }
        tmp_grad[0] = tmp_grad2[j+0];
        tmp_grad[1] = tmp_grad2[j+1];
        tmp_grad[2] = tmp_grad2[j+2];

        // transform to cartesian
        tmp_grad2[j+0] = sintheta*cosphi*tmp_grad[0] + X*cosphi*tmp_grad[1]
            - sinphi*tmp_grad[2];
        tmp_grad2[j+1] = sintheta*sinphi*tmp_grad[0] + X*sinphi*tmp_grad[1]
            + cosphi*tmp_grad[2];
        tmp_grad2[j+2] = X*tmp_grad[0] - sintheta*tmp_grad[1];

        grad[j+0] = grad[j+0] + tmp_grad2[j+0] * G*M/(r_s*r_s);
        grad[j+1] = grad[j+1] + tmp_grad2[j+1] * G*M/(r_s*r_s);
        grad[j+2] = grad[j+2] + tmp_grad2[j+2] * G*M/(r_s*r_s);
  }
}

double mp_potential(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - inner
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */

    double G = pars[0];
    int lmax = (int)pars[1];
    int num_coeff = (int)pars[2];
    int inner = (int)pars[3];
    double M = pars[4];
    double r_s = pars[5];

    double val[1] = {0.};

    double Slm[num_coeff], Tlm[num_coeff];
    for(int i=0; i < num_coeff; i++){
        Slm[i] = pars[6 + 2*i];
        Tlm[i] = pars[7 + 2*i];
    }

    mp_potential_helper(&q[0], 1,
                        G, M, r_s,
                        &Slm[0], &Tlm[0],
                        lmax, inner, &val[0]);

    return val[0];
}

void mp_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - inner
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    double G = pars[0];
    int lmax = (int)pars[1];
    int num_coeff = (int)pars[2];
    int inner = (int)pars[3];
    double M = pars[4];
    double r_s = pars[5];

    double Slm[num_coeff], Tlm[num_coeff];
    for(int i=0; i<num_coeff; i++){
        Slm[i] = pars[6 + 2*i];
        Tlm[i] = pars[7 + 2*i];
    }

    mp_gradient_helper(&q[0], 1,
                       G, M, r_s,
                       &Slm[0], &Tlm[0],
                       lmax, inner, &grad[0]);
}

double mp_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    // double G = pars[0];
    // int lmax = (int)pars[1];
    // int num_coeff = (int)pars[2];
    // int inner = (int)pars[3];
    // double M = pars[4];
    // double r_s = pars[5];

    double val[1] = {0.};

    /* BUG HERE, to do: work out the full density as the laplacian of the
    potential and implement that as a consistency check (should be always 0)
    until then, we set the density to 0
    */
    // mp_density_helper(&q[0], 1,
    //                    M, r_s,
    //                    &pars[4], &pars[4+num_coeff],
    //                    lmax, &val[0]);

    val[0] = 0.;
    return val[0];
}

/* --------------------------------------------------------------------------

    Time-dependent Multipole Expansion

*/
double mpetd_polynomial(double t, double *coeffs, int deg) {
    double val = 0;
    for (int k=0; k < deg; k++){
        val += coeffs[k] * pow(t, k);
    }
    return val;
}

double mpetd_potential(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - deg_a (time polynomial degree); len of num_coeff
        - deg_b (time polynomial degree); len of num_coeff
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */

    double G = pars[0];
    int lmax = (int)pars[1];
    int num_coeff = (int)pars[2];

    int deg_a[num_coeff];
    int deg_b[num_coeff];
    for(int i=0; i < num_coeff; i++){
        deg_a[i] = (int)pars[3 + i];
        deg_b[i] = (int)pars[3 + num_coeff + i];
    }

    double M = pars[2*num_coeff + 3];
    double r_s = pars[2*num_coeff + 4];

    // printf("mpetd_potential: lmax: %d, M: %f, r_s: %f, deg_a[0]: %d, deg_b[0]: %d, first coeff: %f\n",
    //        lmax, M, r_s, deg_a[0], deg_b[0], pars[2*num_coeff + 5]);

    // Construct the alm and blm values:
    double alm[num_coeff], blm[num_coeff];

    double val[1] = {0.};

    int i = 0;
    int k_stride = 2*num_coeff + 5;
    for (int l=0; l<(lmax+1); l++) {
        for (int m=0; m<(l+1); m++) {
            // printf("mpetd_potential: l=%d m=%d deg_a=%d deg_b=%d alpha0=%f beta0=%f\n",
            //        l, m, deg_a[i], deg_b[i], pars[k_stride], pars[k_stride + deg_a[i]]);

            alm[i] = mpetd_polynomial(t, &pars[k_stride], deg_a[i]);
            blm[i] = mpetd_polynomial(t, &pars[k_stride + deg_a[i]], deg_b[i]);
            k_stride += deg_a[i] + deg_b[i];
            i++;
        }
    }

    // for(i=0; i<num_coeff; i++)
    //     printf("in potential.c:mpetd_potential: a, b [%d]: %f %f\n", i, alm[i], blm[i]);

    mp_potential_helper(&q[0], 1,
                        G, M, r_s,
                        &alm[0], &blm[0],
                        lmax, 1, &val[0]);

    return val[0];
}

void mpetd_gradient(double t, double *pars, double *q,
                    int n_dim, double *grad) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - deg_a (time polynomial degree); len of num_coeff
        - deg_b (time polynomial degree); len of num_coeff
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    double G = pars[0];
    int lmax = (int)pars[1];
    int num_coeff = (int)pars[2];

    int deg_a[num_coeff];
    int deg_b[num_coeff];
    for(int i=0; i < num_coeff; i++){
        deg_a[i] = (int)pars[3 + i];
        deg_b[i] = (int)pars[3 + num_coeff + i];
    }

    double M = pars[2*num_coeff + 3];
    double r_s = pars[2*num_coeff + 4];


    // Construct the alm and blm values:
    double alm[num_coeff], blm[num_coeff];

    double val[1] = {0.};
    int i = 0;
    int k_stride = 2*num_coeff + 5;
    for (int l=0; l<(lmax+1); l++) {
        for (int m=0; m<(l+1); m++) {
            alm[i] = mpetd_polynomial(t, &pars[k_stride], deg_a[i]);
            blm[i] = mpetd_polynomial(t, &pars[k_stride + deg_a[i]], deg_b[i]);
            k_stride += deg_a[i]+deg_b[i];
            i++;
        }
    }



    mp_gradient_helper(&q[0], 1,
                        G, M, r_s,
                        &alm[0], &blm[0],
                        lmax, 1, &grad[0]);
}

double mpetd_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - lmax
        - num_coeff
        - deg_a (time polynomial degree); len of num_coeff
        - deg_b (time polynomial degree); len of num_coeff
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    // double G = pars[0];

    ////until this is fixed, we can just comment all the next lines
//     double G = pars[0];
//     int lmax = (int)pars[1];
//     int num_coeff = (int)pars[2];
//     int deg_a[num_coeff];
//     int deg_b[num_coeff];
//     memset(deg_a, 0, num_coeff * sizeof(int));
//     memset(deg_b, 0, num_coeff * sizeof(int));

//     for(int i=0; i<num_coeff; i++){
//         deg_a[i] = pars[3+i];
//         deg_b[i] = pars[3+num_coeff+i];
//     }

//     double M = pars[2*num_coeff + 3];
//     double r_s = pars[2*num_coeff + 4];


//     // Construct the alm and blm values:
//     double alm[num_coeff], blm[num_coeff];
//     memset(alm, 0, num_coeff * sizeof(double));
//     memset(blm, 0, num_coeff * sizeof(double));


//     double val[1] = {0.};
//     int i, l, m;
//     i = 0;
//     int k_stride = 0;
//     for (l=0; l<(lmax+1); l++) {
//         for (m=0; m<(l+1); m++) {
//             // i = m + (lmax+1) * l;
//             alm[i] = mpetd_polynomial(t, &pars[2*num_coeff + 5 + k_stride],
//                                       deg_a[i]);
//             blm[i] = mpetd_polynomial(t, &pars[2*num_coeff + 5 + k_stride +
//                                                deg_a[i]], deg_b[i]);
//             k_stride += deg_a[i]+deg_b[i];
//             i++;
//         }
//     }

    double val[1] = {0.};

    /* BUG HERE, to do: work out the full density as the laplacian of the
    potential and implement that as a consistency check (should be always 0)
    until then, we set the density to 0
    */
    // mp_density_helper(&q[0], 1,
    //                    M, r_s,
    //                    &alm[0], &blm[0],
    //                    lmax, &val[0]);

    // _val = val[0];
    val[0] = 0.;
    return val[0];
}

/* ---------------------------------------------------------------------------
    Axisymmetric CylSpline (from Agama)

    Parameters
    ----------
    G (Gravitational constant)
    logScaling (whether the interpolated potential is log scaled)
    Rscale (length scale)
    ngridR (number of grid points in R)
    ngridz (number of grid points in z)
    gridR (length `ngridR`) - not actually R values, arcsinh(R/Rscale)
    gridz (length `ngridz`) - not actually z values, arcsinh(z/Rscale)
    gridPhi (length `ngridR` * `ngridz`) - transformed Phi values
    multipole_pars
    -- grid_R, grid_z, grid_Phi to ignore --
*/

double axisym_cylspline_value(double t, double *pars, double *q, int n_dim) {
    int logScaling = (int)pars[1];
    double Rscale = pars[2];
    int nR = (int)pars[3];
    int nz = (int)pars[4];

    double Phi;
    double Rasinh = sqrt(q[0]*q[0] + q[1]*q[1]);
    double zasinh = q[2];
    Rasinh = asinh(Rasinh / Rscale);
    zasinh = asinh(zasinh / Rscale);

    double gridR[nR];
    double gridz[nz];
    double gridPhi[nz * nR];
    for (int i=0; i < nR; i++)
        gridR[i] = pars[5 + i];
    for (int i=0; i < nz; i++)
        gridz[i] = pars[5 + nR + i];
    for (int i=0; i < nR; i++)
        for (int j=0; j < nz; j++)
            gridPhi[i * nz + j] = pars[5 + nR + nz + i * nz + j];

    const gsl_interp2d_type *T = gsl_interp2d_bicubic;
    gsl_spline2d *spline = gsl_spline2d_alloc(T, nR, nz);
    gsl_interp_accel *xacc = gsl_interp_accel_alloc();
    gsl_interp_accel *yacc = gsl_interp_accel_alloc();

    // TODO: interpolation is very slow I think because this setup is done every
    // time the function is called...

    if ((Rasinh >= gridR[0]) && (Rasinh <= gridR[nR-1]) &&
        (zasinh >= gridz[0]) && (zasinh <= gridz[nz-1])) { // Use CylSpline

        /* initialize interpolation */
        // TODO: define this in wrapper, make all CPotential's have a void
        // pointer array to store things like this, all these functions then
        // need to accept one more parameter (or is there a way to do optional
        // args in C?), ??, profit.
        gsl_spline2d_init(spline, gridR, gridz, gridPhi, nR, nz);
        Phi = gsl_spline2d_eval(spline, Rasinh, zasinh, xacc, yacc);

        if (logScaling)
            Phi = -exp(Phi);

    } else {  // Use external Multipole
        Phi = mp_potential(t, &pars[5 + nR + nz + nR * nz], q, n_dim);
    }

    gsl_spline2d_free(spline);
    gsl_interp_accel_free(xacc);
    gsl_interp_accel_free(yacc);

    return Phi;
}

void axisym_cylspline_gradient(double t, double *pars, double *q, int n_dim,
                               double *grad) {

    int logScaling = (int)pars[1];
    double Rscale = pars[2];
    int nR = (int)pars[3];
    int nz = (int)pars[4];

    double Phi, dPhi_dR, dPhi_dz;
    double R = sqrt(q[0]*q[0] + q[1]*q[1]);
    double Rasinh = asinh(R / Rscale);
    double zasinh = asinh(q[2] / Rscale);

    double gridR[nR];
    double gridz[nz];
    double gridPhi[nz * nR];
    for (int i=0; i < nR; i++)
        gridR[i] = pars[5 + i];
    for (int i=0; i < nz; i++)
        gridz[i] = pars[5 + nR + i];
    for (int i=0; i < nR; i++)
        for (int j=0; j < nz; j++)
            gridPhi[i * nz + j] = pars[5 + nR + nz + i * nz + j];

    const gsl_interp2d_type *T = gsl_interp2d_bicubic;
    gsl_spline2d *spline = gsl_spline2d_alloc(T, nR, nz);
    gsl_interp_accel *xacc = gsl_interp_accel_alloc();
    gsl_interp_accel *yacc = gsl_interp_accel_alloc();

    // TODO: interpolation is very slow I think because this setup is done every
    // time the function is called...

    if ((Rasinh >= gridR[0]) && (Rasinh <= gridR[nR-1]) &&
        (zasinh >= gridz[0]) && (zasinh <= gridz[nz-1])) { // Use CylSpline

        /* initialize interpolation */
        // TODO: define this in wrapper, make all CPotential's have a void
        // pointer array to store things like this, all these functions then
        // need to accept one more parameter (or is there a way to do optional
        // args in C?), ??, profit.
        gsl_spline2d_init(spline, gridR, gridz, gridPhi, nR, nz);

        dPhi_dR = gsl_spline2d_eval_deriv_x(spline, Rasinh, zasinh, xacc, yacc);
        dPhi_dR = dPhi_dR / (Rscale * cosh(Rasinh));

        dPhi_dz = gsl_spline2d_eval_deriv_y(spline, Rasinh, zasinh, xacc, yacc);
        dPhi_dz = dPhi_dz / (Rscale * cosh(zasinh));

        if (logScaling) {
            Phi = gsl_spline2d_eval(spline, Rasinh, zasinh, xacc, yacc);
            Phi = -exp(Phi);
            dPhi_dR = dPhi_dR * Phi;
            dPhi_dz = dPhi_dz * Phi;
        }

        if (R > 0) {
            grad[0] = grad[0] + dPhi_dR * q[0] / R;
            grad[1] = grad[1] + dPhi_dR * q[1] / R;
            grad[2] = grad[2] + dPhi_dz;
        } else {
            grad[2] = grad[2] + dPhi_dz;
        }

    } else {  // Use external Multipole
        mp_gradient(t, &pars[5 + nR + nz + nR * nz], q, n_dim, grad);
    }
    gsl_spline2d_free(spline);
    gsl_interp_accel_free(xacc);
    gsl_interp_accel_free(yacc);
}

double axisym_cylspline_density(double t, double *pars, double *q, int n_dim) {
    double G = pars[0];
    int logScaling = (int)pars[1];
    double Rscale = pars[2];
    int nR = (int)pars[3];
    int nz = (int)pars[4];

    return 0.0/0.0;

    /* TODO: bug in the below... */

    double dens;
    double Phi, dPhi_dR, dPhi_dz, d2Phi_dR2, d2Phi_dz2;
    double R = sqrt(q[0]*q[0] + q[1]*q[1]);
    double Rasinh = asinh(R / Rscale);
    double zasinh = asinh(q[2] / Rscale);

    double gridR[nR];
    double gridz[nz];
    double gridPhi[nz * nR];
    for (int i=0; i < nR; i++)
        gridR[i] = pars[5 + i];
    for (int i=0; i < nz; i++)
        gridz[i] = pars[5 + nR + i];
    for (int i=0; i < nR; i++)
        for (int j=0; j < nz; j++)
            gridPhi[i * nz + j] = pars[5 + nR + nz + i * nz + j];

    const gsl_interp2d_type *T = gsl_interp2d_bicubic;
    gsl_spline2d *spline = gsl_spline2d_alloc(T, nR, nz);
    gsl_interp_accel *xacc = gsl_interp_accel_alloc();
    gsl_interp_accel *yacc = gsl_interp_accel_alloc();

    // TODO: interpolation is very slow I think because this setup is done every
    // time the function is called...

    if ((Rasinh >= gridR[0]) && (Rasinh <= gridR[nR-1]) &&
        (zasinh >= gridz[0]) && (zasinh <= gridz[nz-1])) { // Use CylSpline

        /* initialize interpolation */
        // TODO: define this in wrapper, make all CPotential's have a void
        // pointer array to store things like this, all these functions then
        // need to accept one more parameter (or is there a way to do optional
        // args in C?), ??, profit.
        gsl_spline2d_init(spline, gridR, gridz, gridPhi, nR, nz);

        dPhi_dR = gsl_spline2d_eval_deriv_x(spline, Rasinh, zasinh, xacc, yacc);
        dPhi_dR = dPhi_dR / (Rscale * cosh(Rasinh));

        dPhi_dz = gsl_spline2d_eval_deriv_y(spline, Rasinh, zasinh, xacc, yacc);
        dPhi_dz = dPhi_dz / (Rscale * cosh(zasinh));

        d2Phi_dR2 = gsl_spline2d_eval_deriv_xx(spline, Rasinh, zasinh, xacc, yacc);
        d2Phi_dR2 = d2Phi_dR2 / pow(Rscale * cosh(Rasinh), 2);

        d2Phi_dz2 = gsl_spline2d_eval_deriv_yy(spline, Rasinh, zasinh, xacc, yacc);
        d2Phi_dz2 = d2Phi_dz2 / pow(Rscale * cosh(zasinh), 2);

        if (logScaling) {
            Phi = gsl_spline2d_eval(spline, Rasinh, zasinh, xacc, yacc);
            Phi = -exp(Phi);
            dPhi_dR = dPhi_dR * Phi;
            d2Phi_dR2 = (d2Phi_dR2 + pow(dPhi_dR / Phi, 2)) * Phi;

            dPhi_dz = dPhi_dz * Phi;
            d2Phi_dz2 = (d2Phi_dz2 + pow(dPhi_dz / Phi, 2)) * Phi;
        }

        dens = (dPhi_dR / R + d2Phi_dR2 + d2Phi_dz2) / (4 * M_PI * G);

    } else {  // Use external Multipole
        dens = mp_density(t, &pars[5 + nR + nz + nR * nz], q, n_dim);
    }
    gsl_spline2d_free(spline);
    gsl_interp_accel_free(xacc);
    gsl_interp_accel_free(yacc);

    return dens;
}



#endif
</file>

<file path="gala/potential/potential/builtin/multipole.h">
extern double mp_potential(double t, double *pars, double *q, int n_dim);
extern double mp_density(double t, double *pars, double *q, int n_dim);
extern void mp_gradient(double t, double *pars, double *q, int n_dim, double *grad);

extern double mpetd_potential(double t, double *pars, double *q, int n_dim);
extern double mpetd_density(double t, double *pars, double *q, int n_dim);
extern void mpetd_gradient(double t, double *pars, double *q, int n_dim, double *grad);

extern void mp_density_helper(double *xyz, int K,
                               double M, double r_s,
                               double *anlm, double *bnlm,
                               int lmax, int inner, double *dens);

extern void mp_potential_helper(double *xyz, int K,
                                 double G, double M, double r_s,
                                 double *anlm, double *bnlm,
                                 int lmax, int inner, double *val);

extern void mp_gradient_helper(double *xyz, int K,
                                double G, double M, double r_s,
                                double *anlm, double *bnlm,
                                int lmax, int inner, double *grad);

extern double mp_rho_lm(double r, double phi, double X, int l, int m, int inner);
extern double mp_phi_lm(double r, double phi, double X, int l, int m, int inner);
extern void mp_sph_grad_phi_lm(double r, double phi, double X, int l, int m, int lmax, int inner, double *sphgrad);


extern double axisym_cylspline_value(double t, double *pars, double *q, int n_dim);
extern void axisym_cylspline_gradient(double t, double *pars, double *q, int n_dim, double *grad);
extern double axisym_cylspline_density(double t, double *pars, double *q, int n_dim);
</file>

<file path="gala/potential/potential/builtin/pybuiltin.py">
# Third-party
import numpy as np

from gala.potential.potential.core import PotentialBase
from gala.potential.potential.util import sympy_wrap
from gala.potential.common import PotentialParameter

__all__ = ["HarmonicOscillatorPotential"]


class HarmonicOscillatorPotential(PotentialBase):
    r"""
    Represents an N-dimensional harmonic oscillator.

    .. math::

        \Phi = \frac{1}{2}\omega^2 x^2

    Parameters
    ----------
    omega : numeric
        Frequency.
    units : iterable(optional)
        Unique list of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    """
    omega = PotentialParameter('omega', physical_type='frequency')

    def _setup_potential(self, parameters, origin=None, R=None, units=None):
        parameters['omega'] = np.atleast_1d(parameters['omega'])
        super()._setup_potential(parameters, origin=origin, R=R, units=units)
        self.ndim = len(self.parameters['omega'])

    def _energy(self, q, t=0.):
        om = np.atleast_1d(self.parameters['omega'].value)
        return np.sum(0.5 * om[None]**2 * q**2, axis=1)

    def _gradient(self, q, t=0.):
        om = np.atleast_1d(self.parameters['omega'].value)
        return om[None]**2 * q

    def _hessian(self, q, t=0.):
        om = np.atleast_1d(self.parameters['omega'].value)
        return np.tile(np.diag(om)[:, :, None], reps=(1, 1, q.shape[0]))

    @classmethod
    @sympy_wrap(var='x')
    def to_sympy(cls, v, p):
        expr = 1/2 * p['omega']**2 * v['x']**2
        return expr, v, p

    def action_angle(self, w):
        """
        Transform the input cartesian position and velocity to action-angle
        coordinates the Harmonic Oscillator potential. This transformation
        is analytic and can be used as a "toy potential" in the
        Sanders & Binney 2014 formalism for computing action-angle coordinates
        in _any_ potential.

        Adapted from Jason Sanders' code
        `genfunc <https://github.com/jlsanders/genfunc>`_.

        Parameters
        ----------
        w : :class:`gala.dynamics.PhaseSpacePosition`, :class:`gala.dynamics.Orbit`
            The positions or orbit to compute the actions, angles, and frequencies at.
        """
        from gala.dynamics.actionangle import harmonic_oscillator_xv_to_aa
        return harmonic_oscillator_xv_to_aa(w, self)

    # def phase_space(self, actions, angles):
    #     """
    #     Transform the input action-angle coordinates to cartesian position and velocity
    #     assuming a Harmonic Oscillator potential. This transformation
    #     is analytic and can be used as a "toy potential" in the
    #     Sanders & Binney 2014 formalism for computing action-angle coordinates
    #     in _any_ potential.

    #     Adapted from Jason Sanders' code
    #     `genfunc <https://github.com/jlsanders/genfunc>`_.

    #     Parameters
    #     ----------
    #     x : array_like
    #         Positions.
    #     v : array_like
    #         Velocities.
    #     """
    #     from gala.dynamics.actionangle import harmonic_oscillator_aa_to_xv
    #     return harmonic_oscillator_aa_to_xv(actions, angles, self)
</file>

<file path="gala/potential/potential/builtin/special.py">
# Third-party
import astropy.units as u
import numpy as np

# Project
from gala.potential.potential.builtin.core import (
    HernquistPotential,
    LogarithmicPotential,
    MiyamotoNagaiPotential,
    MN3ExponentialDiskPotential,
    NFWPotential,
    PowerLawCutoffPotential,
)
from gala.potential.potential.ccompositepotential import CCompositePotential
from gala.units import galactic

__all__ = [
    "LM10Potential",
    "MilkyWayPotential",
    "MilkyWayPotential2022",
    "BovyMWPotential2014",
]


class LM10Potential(CCompositePotential):
    """
    The Galactic potential used by Law and Majewski (2010) to represent
    the Milky Way as a three-component sum of disk, bulge, and halo.

    The disk potential is an axisymmetric
    :class:`~gala.potential.MiyamotoNagaiPotential`, the bulge potential
    is a spherical :class:`~gala.potential.HernquistPotential`, and the
    halo potential is a triaxial :class:`~gala.potential.LogarithmicPotential`.

    Default parameters are fixed to those found in LM10 by fitting N-body
    simulations to the Sagittarius stream.

    Parameters
    ----------
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    disk : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.MiyamotoNagaiPotential`.
    bulge : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.HernquistPotential`.
    halo : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.LogarithmicPotential`.

    Note: in subclassing, order of arguments must match order of potential
    components added at bottom of init.
    """

    def __init__(self, units=galactic, disk=dict(), bulge=dict(), halo=dict()):
        default_disk = dict(m=1e11 * u.Msun, a=6.5 * u.kpc, b=0.26 * u.kpc)
        default_bulge = dict(m=3.4e10 * u.Msun, c=0.7 * u.kpc)
        default_halo = dict(
            q1=1.38,
            q2=1.0,
            q3=1.36,
            r_h=12.0 * u.kpc,
            phi=97 * u.degree,
            v_c=np.sqrt(2) * 121.858 * u.km / u.s,
        )

        for k, v in default_disk.items():
            if k not in disk:
                disk[k] = v

        for k, v in default_bulge.items():
            if k not in bulge:
                bulge[k] = v

        for k, v in default_halo.items():
            if k not in halo:
                halo[k] = v

        super().__init__()

        self["disk"] = MiyamotoNagaiPotential(units=units, **disk)
        self["bulge"] = HernquistPotential(units=units, **bulge)
        self["halo"] = LogarithmicPotential(units=units, **halo)
        self.lock = True


class MilkyWayPotential(CCompositePotential):
    """
    A simple mass-model for the Milky Way consisting of a spherical nucleus and
    bulge, a Miyamoto-Nagai disk, and a spherical NFW dark matter halo.

    The disk model is taken from `Bovy (2015)
    <https://ui.adsabs.harvard.edu/#abs/2015ApJS..216...29B/abstract>`_ - if you
    use this potential, please also cite that work.

    Default parameters are fixed by fitting to a compilation of recent mass
    measurements of the Milky Way, from 10 pc to ~150 kpc.

    Parameters
    ----------
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    disk : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.MiyamotoNagaiPotential`.
    bulge : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.HernquistPotential`.
    halo : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.NFWPotential`.
    nucleus : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.HernquistPotential`.

    Note: in subclassing, order of arguments must match order of potential
    components added at bottom of init.
    """

    def __init__(self, units=galactic, disk=None, halo=None, bulge=None, nucleus=None):
        default_disk = dict(m=6.8e10 * u.Msun, a=3.0 * u.kpc, b=0.28 * u.kpc)
        default_bulge = dict(m=5e9 * u.Msun, c=1.0 * u.kpc)
        default_nucl = dict(m=1.71e9 * u.Msun, c=0.07 * u.kpc)
        default_halo = dict(m=5.4e11 * u.Msun, r_s=15.62 * u.kpc)

        if disk is None:
            disk = dict()

        if halo is None:
            halo = dict()

        if bulge is None:
            bulge = dict()

        if nucleus is None:
            nucleus = dict()

        for k, v in default_disk.items():
            if k not in disk:
                disk[k] = v

        for k, v in default_bulge.items():
            if k not in bulge:
                bulge[k] = v

        for k, v in default_halo.items():
            if k not in halo:
                halo[k] = v

        for k, v in default_nucl.items():
            if k not in nucleus:
                nucleus[k] = v

        super().__init__()

        self["disk"] = MiyamotoNagaiPotential(units=units, **disk)
        self["bulge"] = HernquistPotential(units=units, **bulge)
        self["nucleus"] = HernquistPotential(units=units, **nucleus)
        self["halo"] = NFWPotential(units=units, **halo)
        self.lock = True


class MilkyWayPotential2022(CCompositePotential):
    """
    A mass-model for the Milky Way consisting of a spherical nucleus and bulge, a
    3-component sum of Miyamoto-Nagai disks to represent an exponential disk, and a
    spherical NFW dark matter halo.

    The disk model is fit to the Eilers et al. 2019 rotation curve for the radial
    dependence, and the shape of the phase-space spiral in the solar neighborhood is
    used to set the vertical structure in Darragh-Ford et al. 2023.

    Other parameters are fixed by fitting to a compilation of recent mass measurements
    of the Milky Way, from 10 pc to ~150 kpc.

    Parameters
    ----------
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    disk : dict (optional)
        Parameters to be passed to the
        :class:`~gala.potential.MN3ExponentialDiskPotential`.
    bulge : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.HernquistPotential`.
    halo : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.NFWPotential`.
    nucleus : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.HernquistPotential`.

    Note: in subclassing, order of arguments must match order of potential
    components added at bottom of init.
    """

    def __init__(self, units=galactic, disk=None, halo=None, bulge=None, nucleus=None):
        default_disk = dict(m=4.7717e10 * u.Msun, h_R=2.6 * u.kpc, h_z=0.3 * u.kpc)
        default_bulge = dict(m=5e9 * u.Msun, c=1.0 * u.kpc)
        default_nucl = dict(m=1.8142e9 * u.Msun, c=0.0688867 * u.kpc)
        default_halo = dict(m=5.5427e11 * u.Msun, r_s=15.626 * u.kpc)

        if disk is None:
            disk = dict()

        if halo is None:
            halo = dict()

        if bulge is None:
            bulge = dict()

        if nucleus is None:
            nucleus = dict()

        for k, v in default_disk.items():
            if k not in disk:
                disk[k] = v

        for k, v in default_bulge.items():
            if k not in bulge:
                bulge[k] = v

        for k, v in default_halo.items():
            if k not in halo:
                halo[k] = v

        for k, v in default_nucl.items():
            if k not in nucleus:
                nucleus[k] = v

        super().__init__()

        self["disk"] = MN3ExponentialDiskPotential(units=units, **disk)
        self["bulge"] = HernquistPotential(units=units, **bulge)
        self["nucleus"] = HernquistPotential(units=units, **nucleus)
        self["halo"] = NFWPotential(units=units, **halo)
        self.lock = True


class BovyMWPotential2014(CCompositePotential):
    """
    An implementation of the ``MWPotential2014``
    `from galpy <https://galpy.readthedocs.io/en/latest/potential.html>`_
    and described in `Bovy (2015)
    <https://ui.adsabs.harvard.edu/#abs/2015ApJS..216...29B/abstract>`_.

    This potential consists of a spherical bulge and dark matter halo, and a
    Miyamoto-Nagai disk component.

    .. note::

        Because it internally uses the PowerLawCutoffPotential,
        this potential requires GSL to be installed, and Gala must have been
        built and installed with GSL support enaled (the default behavior).
        See http://gala.adrian.pw/en/latest/install.html for more information.

    Parameters
    ----------
    units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    disk : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.MiyamotoNagaiPotential`.
    bulge : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.PowerLawCutoffPotential`.
    halo : dict (optional)
        Parameters to be passed to the :class:`~gala.potential.NFWPotential`.

    Note: in subclassing, order of arguments must match order of potential
    components added at bottom of init.
    """

    def __init__(self, units=galactic, disk=None, halo=None, bulge=None):
        default_disk = dict(m=68193902782.346756 * u.Msun, a=3.0 * u.kpc, b=280 * u.pc)
        default_bulge = dict(m=4501365375.06545 * u.Msun, alpha=1.8, r_c=1.9 * u.kpc)
        default_halo = dict(m=4.3683325e11 * u.Msun, r_s=16 * u.kpc)

        if disk is None:
            disk = dict()

        if halo is None:
            halo = dict()

        if bulge is None:
            bulge = dict()

        for k, v in default_disk.items():
            if k not in disk:
                disk[k] = v

        for k, v in default_bulge.items():
            if k not in bulge:
                bulge[k] = v

        for k, v in default_halo.items():
            if k not in halo:
                halo[k] = v

        super().__init__()

        self["disk"] = MiyamotoNagaiPotential(units=units, **disk)
        self["bulge"] = PowerLawCutoffPotential(units=units, **bulge)
        self["halo"] = NFWPotential(units=units, **halo)
        self.lock = True


# --------------------------------------------------------------------
# class TriaxialMWPotential(CCompositePotential):

#     def __init__(self, units=galactic,
#                  disk=dict(), bulge=dict(), halo=dict()):
#         """ Axis ratio values taken from Jing & Suto (2002). Other
#             parameters come from a by-eye fit to Bovy's MW2014Potential.
#             Choice of v_c sets circular velocity at Sun to 220 km/s
#         """

#         default_disk = dict(m=7E10, a=3.5, b=0.14)
#         default_bulge = dict(m=1E10, c=1.1)
#         default_halo = dict(a=1., b=0.75, c=0.55,
#                             v_c=0.239225, r_s=30.,
#                             phi=0., theta=0., psi=0.)

#         for k, v in default_disk.items():
#             if k not in disk:
#                 disk[k] = v

#         for k, v in default_bulge.items():
#             if k not in bulge:
#                 bulge[k] = v

#         for k, v in default_halo.items():
#             if k not in halo:
#                 halo[k] = v

#         kwargs = dict()
#         kwargs["disk"] = MiyamotoNagaiPotential(units=units, **disk)
#         kwargs["bulge"] = HernquistPotential(units=units, **bulge)
#         kwargs["halo"] = LeeSutoTriaxialNFWPotential(units=units, **halo)
#         super(TriaxialMWPotential, self).__init__(**kwargs)
# --------------------------------------------------------------------
</file>

<file path="gala/potential/potential/src/cpotential.c">
#include <math.h>
#include "cpotential.h"


void apply_rotate(double *q_in, double *R, int n_dim, int transpose,
                  double *q_out) {
    // NOTE: elsewhere, we enforce that rotation matrix only works for
    // ndim=2 or ndim=3, so here we can assume that!
    if (n_dim == 3) {
        if (transpose == 0) {
            q_out[0] = q_out[0] + R[0] * q_in[0] + R[1] * q_in[1] + R[2] * q_in[2];
            q_out[1] = q_out[1] + R[3] * q_in[0] + R[4] * q_in[1] + R[5] * q_in[2];
            q_out[2] = q_out[2] + R[6] * q_in[0] + R[7] * q_in[1] + R[8] * q_in[2];
        } else {
            q_out[0] = q_out[0] + R[0] * q_in[0] + R[3] * q_in[1] + R[6] * q_in[2];
            q_out[1] = q_out[1] + R[1] * q_in[0] + R[4] * q_in[1] + R[7] * q_in[2];
            q_out[2] = q_out[2] + R[2] * q_in[0] + R[5] * q_in[1] + R[8] * q_in[2];
        }
    } else if (n_dim == 2) {
        if (transpose == 0) {
            q_out[0] = q_out[0] + R[0] * q_in[0] + R[1] * q_in[1];
            q_out[1] = q_out[1] + R[2] * q_in[0] + R[3] * q_in[1];
        } else {
            q_out[0] = q_out[0] + R[0] * q_in[0] + R[2] * q_in[1];
            q_out[1] = q_out[1] + R[1] * q_in[0] + R[3] * q_in[1];
        }
    } else {
        for (int j=0; j < n_dim; j++)
            q_out[j] = q_out[j] + q_in[j];
    }
}


void apply_shift_rotate(double *q_in, double *q0, double *R, int n_dim,
                        int transpose, double *q_out) {
    double tmp[n_dim];
    int j;

    // Shift to the specified origin
    for (j=0; j < n_dim; j++) {
        tmp[j] = q_in[j] - q0[j];
    }

    // Apply rotation matrix
    apply_rotate(&tmp[0], R, n_dim, transpose, q_out);
}


double c_potential(CPotential *p, double t, double *qp) {
    double v = 0;
    int i, j;
    double qp_trans[p->n_dim];

    for (i=0; i < p->n_components; i++) {
        for (j=0; j < p->n_dim; j++)
            qp_trans[j] = 0.;
        apply_shift_rotate(qp, (p->q0)[i], (p->R)[i], p->n_dim, 0,
                           &qp_trans[0]);
        v = v + (p->value)[i](t, (p->parameters)[i], &qp_trans[0], p->n_dim);
    }

    return v;
}


double c_density(CPotential *p, double t, double *qp) {
    double v = 0;
    int i, j;
    double qp_trans[p->n_dim];

    for (i=0; i < p->n_components; i++) {
        for (j=0; j < p->n_dim; j++)
            qp_trans[j] = 0.;
        apply_shift_rotate(qp, (p->q0)[i], (p->R)[i], p->n_dim, 0,
                           &qp_trans[0]);
        v = v + (p->density)[i](t, (p->parameters)[i], &qp_trans[0], p->n_dim);
    }

    return v;
}


void c_gradient(CPotential *p, double t, double *qp, double *grad) {
    int i, j;
    double qp_trans[p->n_dim];
    double tmp_grad[p->n_dim];

    for (i=0; i < p->n_dim; i++) {
        grad[i] = 0.;
        tmp_grad[i] = 0.;
        qp_trans[i] = 0.;
    }

    for (i=0; i < p->n_components; i++) {
        for (j=0; j < p->n_dim; j++) {
            tmp_grad[j] = 0.;
            qp_trans[j] = 0.;
        }

        apply_shift_rotate(qp, (p->q0)[i], (p->R)[i], p->n_dim, 0,
                           &qp_trans[0]);
        (p->gradient)[i](t, (p->parameters)[i], &qp_trans[0], p->n_dim,
                         &tmp_grad[0]);
        apply_rotate(&tmp_grad[0], (p->R)[i], p->n_dim, 1, &grad[0]);
    }
}


void c_hessian(CPotential *p, double t, double *qp, double *hess) {
    int i;
    double qp_trans[p->n_dim];

    for (i=0; i < pow(p->n_dim,2); i++) {
        hess[i] = 0.;

        if (i < p->n_dim) {
            qp_trans[i] = 0.;
        }
    }

    for (i=0; i < p->n_components; i++) {
        apply_shift_rotate(qp, (p->q0)[i], (p->R)[i], p->n_dim, 0,
                           &qp_trans[0]);
        (p->hessian)[i](t, (p->parameters)[i], &qp_trans[0], p->n_dim, hess);
        // TODO: here - need to apply inverse rotation to the Hessian!
        // - Hessian calculation for potentials with rotations are disabled
    }

}


double c_d_dr(CPotential *p, double t, double *qp, double *epsilon) {
    double h, r, dPhi_dr;
    int j;
    double r2 = 0;

    for (j=0; j<p->n_dim; j++) {
        r2 = r2 + qp[j]*qp[j];
    }

    // TODO: allow user to specify fractional step-size
    h = 1E-4;

    // Step-size for estimating radial gradient of the potential
    r = sqrt(r2);

    for (j=0; j < (p->n_dim); j++)
        epsilon[j] = qp[j] + h * qp[j]/r;

    dPhi_dr = c_potential(p, t, epsilon);

    for (j=0; j < (p->n_dim); j++)
        epsilon[j] = qp[j] - h * qp[j]/r;

    dPhi_dr = dPhi_dr - c_potential(p, t, epsilon);

    return dPhi_dr / (2.*h);
}


double c_d2_dr2(CPotential *p, double t, double *qp, double *epsilon) {
    double h, r, d2Phi_dr2;
    int j;
    double r2 = 0;
    for (j=0; j<p->n_dim; j++) {
        r2 = r2 + qp[j]*qp[j];
    }

    // TODO: allow user to specify fractional step-size
    h = 1E-2;

    // Step-size for estimating radial gradient of the potential
    r = sqrt(r2);

    for (j=0; j < (p->n_dim); j++)
        epsilon[j] = qp[j] + h * qp[j]/r;
    d2Phi_dr2 = c_potential(p, t, epsilon);

    d2Phi_dr2 = d2Phi_dr2 - 2.*c_potential(p, t, qp);

    for (j=0; j < (p->n_dim); j++)
        epsilon[j] = qp[j] - h * qp[j]/r;
    d2Phi_dr2 = d2Phi_dr2 + c_potential(p, t, epsilon);

    return d2Phi_dr2 / (h*h);
}


double c_mass_enclosed(CPotential *p, double t, double *qp, double G,
                       double *epsilon) {
    double r2, dPhi_dr;
    int j;

    r2 = 0;
    for (j=0; j<p->n_dim; j++) {
        r2 = r2 + qp[j]*qp[j];
    }
    dPhi_dr = c_d_dr(p, t, qp, epsilon);
    return fabs(r2 * dPhi_dr / G);
}


// TODO: This isn't really the right place for this...
void c_nbody_acceleration(CPotential **pots, double t, double *qp,
                          int norbits, int nbody, int ndim, double *acc) {
    int i, j, k;
    CPotential *body_pot;
    int ps_ndim = 2 * ndim; // 6, for 3D position/velocity
    double f2[ndim];

    for (j=0; j < nbody; j++) { // the particles generating force
        body_pot = pots[j];

        if ((body_pot->null) == 1)
            continue;

        for (i=0; i < body_pot->n_components; i++)
            (body_pot->q0)[i] = &qp[j * ps_ndim];

        for (i=0; i < norbits; i++) {
            if (i != j) {
                c_gradient(body_pot, t, &qp[i * ps_ndim], &f2[0]);
                for (k=0; k < ndim; k++)
                   acc[i*ps_ndim + ndim + k] += -f2[k];
            }
        }
    }
}

// TODO: this is a hack to get nbody leapfrog working
void c_nbody_gradient_symplectic(
    CPotential **pots, double t, double *w,
    double *nbody_w, int nbody, int nbody_i,
    int ndim, double *grad
) {
    int i, j, k;
    CPotential *body_pot;
    double f2[ndim];

    for (j=0; j < nbody; j++) { // the particles generating force
        body_pot = pots[j];

        if ((body_pot->null == 1) || (j == nbody_i))
            continue;

        for (i=0; i < body_pot->n_components; i++) {
            (body_pot->q0)[i] = &nbody_w[j * 2 * ndim]; // p-s ndim
        }

        c_gradient(body_pot, t, w, &f2[0]);
        for (k=0; k < ndim; k++)
            grad[k] += f2[k];
    }
}
</file>

<file path="gala/potential/potential/src/cpotential.h">
#include "src/funcdefs.h"

#ifndef MAX_N_COMPONENTS_H
    #define MAX_N_COMPONENTS_H
    #define MAX_N_COMPONENTS 16
#endif

#ifndef _CPotential_H
#define _CPotential_H
    typedef struct _CPotential CPotential;

    struct _CPotential {
        int n_components; // number of potential components
        int n_dim; // coordinate system dimensionality
        int null; // a short circuit: if null, can skip evaluation

        // arrays of pointers to each of the function types above
        densityfunc density[MAX_N_COMPONENTS];
        energyfunc value[MAX_N_COMPONENTS];
        gradientfunc gradient[MAX_N_COMPONENTS];
        hessianfunc hessian[MAX_N_COMPONENTS];

        // array containing the number of parameters in each component
        int n_params[MAX_N_COMPONENTS];

        // pointer to array of pointers to the parameter arrays
        double *parameters[MAX_N_COMPONENTS];

        // pointer to array of pointers containing the origin coordinates
        double *q0[MAX_N_COMPONENTS];

        // pointer to array of pointers containing rotation matrix elements
        double *R[MAX_N_COMPONENTS];
    };
#endif

extern double c_potential(CPotential *p, double t, double *q);
extern double c_density(CPotential *p, double t, double *q);
extern void c_gradient(CPotential *p, double t, double *q, double *grad);
extern void c_hessian(CPotential *p, double t, double *q, double *hess);

// TODO: err, what about reference frames...
extern double c_d_dr(CPotential *p, double t, double *q, double *epsilon);
extern double c_d2_dr2(CPotential *p, double t, double *q, double *epsilon);
extern double c_mass_enclosed(CPotential *p, double t, double *q, double G, double *epsilon);

// TODO: move this elsewhere?
void c_nbody_acceleration(CPotential **pots, double t, double *qp,
                          int norbits, int nbody, int ndim, double *acc);
void c_nbody_gradient_symplectic(
    CPotential **pots, double t, double *q,
    double *nbody_q, int nbody, int nbody_i,
    int ndim, double *grad
);
</file>

<file path="gala/potential/potential/tests/ccomposite.yml">
type: composite
class: CCompositePotential
components:
- class: KeplerPotential
  name: halo
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      m: 100000000000.0
      m_unit: ''
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: IsochronePotential
  name: bulge
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      b: 0.76
      b_unit: ''
      m: 100000000000.0
      m_unit: ''
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
</file>

<file path="gala/potential/potential/tests/Composite.yml">
type: composite
class: CompositePotential
components:
  -
    class: PlummerPotential
    name: halo
    parameters:
      b: 0.26
      m: 100000000000.0
    units:
      angle: rad
      angular speed: mas / yr
      length: kpc
      mass: solMass
      speed: km / s
      time: Myr
  -
    class: MiyamotoNagaiPotential
    name: disk
    parameters:
      a: 6.5
      b: 0.26
      m: 100000000000.0
    units:
      angle: rad
      angular speed: mas / yr
      length: kpc
      mass: solMass
      speed: km / s
      time: Myr
</file>

<file path="gala/potential/potential/tests/generate_agama.py">
import pathlib
import astropy.table as at
import astropy.units as u
import numpy as np

this_path = pathlib.Path(__file__).absolute().parent


def main():
    # For pytest:
    import agama

    agama.setUnits(mass=1, length=1, time=1)

    # Shared by Ana Bonaca
    agama_pot = agama.Potential(file=str(this_path / 'pot_disk_506151.pot'))

    # Generate a grid of points to evaluate at:
    test_R = np.linspace(0, 150, 128)
    test_z = np.linspace(-100, 100, 128)
    test_Rz = np.stack(list(map(np.ravel, np.meshgrid(test_R, test_z))))
    test_xyz = np.zeros((3, test_Rz.shape[1]))
    test_xyz[0] = test_Rz[0]
    test_xyz[2] = test_Rz[1]

    pot = agama_pot.potential(test_xyz.T)[:, None]
    acc = agama_pot.force(test_xyz.T)

    tbl = at.QTable()
    tbl['xyz'] = test_xyz.T * u.kpc
    tbl['pot'] = pot * (u.km/u.s)**2
    tbl['acc'] = acc * (u.km/u.s)**2 / u.kpc

    tbl.write(this_path / 'agama_cylspline_test.fits')


if __name__ == '__main__':
    main()
</file>

<file path="gala/potential/potential/tests/HarmonicOscillator1D.yml">
class: HarmonicOscillatorPotential
parameters:
  omega: 1.0
</file>

<file path="gala/potential/potential/tests/helpers.py">
# Standard library
import copy
import pickle
import time

# Third-party
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
from scipy.misc import derivative
import pytest

# Project
from ..io import load
from ...frame import StaticFrame
from ...hamiltonian import Hamiltonian
from ....units import UnitSystem, DimensionlessUnitSystem
from ....dynamics import PhaseSpacePosition
from gala.tests.optional_deps import HAS_SYMPY


def partial_derivative(func, point, dim_ix=0, **kwargs):
    xyz = np.array(point, copy=True)

    def wraps(a):
        xyz[dim_ix] = a
        return func(xyz)

    return derivative(wraps, point[dim_ix], **kwargs)


class PotentialTestBase:
    name = None
    potential = None  # MUST SET THIS
    frame = None
    tol = 1e-5
    show_plots = False

    sympy_hessian = True
    sympy_density = True
    check_finite_at_origin = True

    def setup_method(self):
        # set up hamiltonian
        if self.frame is None:
            self.frame = StaticFrame(units=self.potential.units)
        self.H = Hamiltonian(self.potential, self.frame)
        self.rnd = np.random.default_rng(seed=42)

        cls = self.__class__
        if cls.name is None:
            cls.name = cls.__name__[4:]  # removes "Test"
        print(f"Testing potential: {cls.name}")
        self.w0 = np.array(self.w0)
        self.ndim = self.w0.size // 2

        # TODO: need to test also quantity objects and phasespacepositions!

        # these are arrays we will test the methods on:
        w0_2d = np.repeat(self.w0[:, None], axis=1, repeats=16)
        w0_3d = np.repeat(w0_2d[..., None], axis=2, repeats=8)
        w0_list = list(self.w0)
        w0_slice = w0_2d[:, :4]
        self.w0s = [self.w0, w0_2d, w0_3d, w0_list, w0_slice]
        self._grad_return_shapes = [
            self.w0[: self.ndim].shape + (1,),
            w0_2d[: self.ndim].shape,
            w0_3d[: self.ndim].shape,
            self.w0[: self.ndim].shape + (1,),
            w0_slice[: self.ndim].shape,
        ]
        self._hess_return_shapes = [
            (self.ndim,) + self.w0[: self.ndim].shape + (1,),
            (self.ndim,) + w0_2d[: self.ndim].shape,
            (self.ndim,) + w0_3d[: self.ndim].shape,
            (self.ndim,) + self.w0[: self.ndim].shape + (1,),
            (self.ndim,) + w0_slice[: self.ndim].shape,
        ]
        self._valu_return_shapes = [x[1:] for x in self._grad_return_shapes]

    def test_unitsystem(self):
        assert isinstance(self.potential.units, UnitSystem)

        if isinstance(self.potential.units, DimensionlessUnitSystem):
            # Don't do a replace_units test for dimensionless potentials
            return

        # check that we can replace the units as expected
        usys = UnitSystem([u.pc, u.Gyr, u.radian, u.Msun])
        pot = copy.deepcopy(self.potential)

        pot2 = pot.replace_units(usys)
        assert pot2.units == usys
        assert pot.units == self.potential.units

    def test_energy(self):
        assert self.ndim == self.potential.ndim

        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            v = self.potential.energy(arr[: self.ndim])
            assert v.shape == shp

            g = self.potential.energy(arr[: self.ndim], t=0.1)
            g = self.potential.energy(
                arr[: self.ndim], t=0.1 * self.potential.units["time"]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.energy(arr[: self.ndim], t=t)
            g = self.potential.energy(
                arr[: self.ndim], t=t * self.potential.units["time"]
            )

        if self.check_finite_at_origin:
            val = self.potential.energy([0.0, 0, 0])
            assert np.isfinite(val)

    def test_gradient(self):
        for arr, shp in zip(self.w0s, self._grad_return_shapes):
            g = self.potential.gradient(arr[: self.ndim])
            assert g.shape == shp

            g = self.potential.gradient(arr[: self.ndim], t=0.1)
            g = self.potential.gradient(
                arr[: self.ndim], t=0.1 * self.potential.units["time"]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.gradient(arr[: self.ndim], t=t)
            g = self.potential.gradient(
                arr[: self.ndim], t=t * self.potential.units["time"]
            )

    def test_hessian(self):
        for arr, shp in zip(self.w0s, self._hess_return_shapes):
            g = self.potential.hessian(arr[: self.ndim])
            assert g.shape == shp

            g = self.potential.hessian(arr[: self.ndim], t=0.1)
            g = self.potential.hessian(
                arr[: self.ndim], t=0.1 * self.potential.units["time"]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.hessian(arr[: self.ndim], t=t)
            g = self.potential.hessian(
                arr[: self.ndim], t=t * self.potential.units["time"]
            )

    def test_mass_enclosed(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.mass_enclosed(arr[: self.ndim])
            assert g.shape == shp
            assert np.all(g > 0.0)

            g = self.potential.mass_enclosed(arr[: self.ndim], t=0.1)
            g = self.potential.mass_enclosed(
                arr[: self.ndim], t=0.1 * self.potential.units["time"]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.mass_enclosed(arr[: self.ndim], t=t)
            g = self.potential.mass_enclosed(
                arr[: self.ndim], t=t * self.potential.units["time"]
            )

    def test_circular_velocity(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.circular_velocity(arr[: self.ndim])
            assert g.shape == shp
            assert np.all(g > 0.0)

            g = self.potential.circular_velocity(arr[: self.ndim], t=0.1)
            g = self.potential.circular_velocity(
                arr[: self.ndim], t=0.1 * self.potential.units["time"]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.circular_velocity(arr[: self.ndim], t=t)
            g = self.potential.circular_velocity(
                arr[: self.ndim], t=t * self.potential.units["time"]
            )

    def test_repr(self):
        pot_repr = repr(self.potential)
        if isinstance(self.potential.units, DimensionlessUnitSystem):
            assert "dimensionless" in pot_repr
        else:
            assert str(self.potential.units["length"]) in pot_repr
            assert str(self.potential.units["time"]) in pot_repr
            assert str(self.potential.units["mass"]) in pot_repr

        for k in self.potential.parameters.keys():
            assert "{}=".format(k) in pot_repr

    def test_compare(self):
        # skip if composite potentials
        if len(self.potential.parameters) == 0:
            return

        other = self.potential.__class__(
            units=self.potential.units, **self.potential.parameters
        )
        assert other == self.potential

        pars = self.potential.parameters.copy()
        for k in pars.keys():
            if k != 0:
                pars[k] = 1.1 * pars[k]
        other = self.potential.__class__(units=self.potential.units, **pars)
        assert other != self.potential

        # check that comparing to non-potentials works
        assert not self.potential == "sup"
        assert self.potential is not None

    def test_plot(self):
        p = self.potential

        f = p.plot_contours(
            grid=(np.linspace(-10.0, 10.0, 100), 0.0, 0.0), labels=["X"]
        )

        f = p.plot_contours(
            grid=(
                np.linspace(-10.0, 10.0, 100),
                np.linspace(-10.0, 10.0, 100),
                0.0,
            ),
            cmap="Blues",
        )

        f = p.plot_contours(
            grid=(
                np.linspace(-10.0, 10.0, 100),
                1.0,
                np.linspace(-10.0, 10.0, 100),
            ),
            cmap="Blues",
            labels=["X", "Z"],
        )

        f, a = p.plot_rotation_curve(R_grid=np.linspace(0.1, 10.0, 100))

        plt.close("all")

        if self.show_plots:
            plt.show()

    def test_save_load(self, tmpdir):
        """
        Test writing to a YAML file, and reading back in
        """
        fn = str(tmpdir.join("{}.yml".format(self.name)))
        self.potential.save(fn)
        p = load(fn)
        p.energy(self.w0[: self.w0.size // 2])
        p.gradient(self.w0[: self.w0.size // 2])

    def test_numerical_gradient_vs_gradient(self):
        """
        Check that the value of the implemented gradient function is close to a
        numerically estimated value. This is to check the coded-up version.
        """

        dx = 1e-3 * np.sqrt(np.sum(self.w0[: self.w0.size // 2] ** 2))
        max_x = np.sqrt(np.sum([x ** 2 for x in self.w0[: self.w0.size // 2]]))

        grid = np.linspace(-max_x, max_x, 8)
        grid = grid[grid != 0.0]
        grids = [grid for i in range(self.w0.size // 2)]
        xyz = np.ascontiguousarray(
            np.vstack(list(map(np.ravel, np.meshgrid(*grids)))).T
        )

        def energy_wrap(xyz):
            xyz = np.ascontiguousarray(xyz[None])
            return self.potential._energy(xyz, t=np.array([0.0]))[0]

        num_grad = np.zeros_like(xyz)
        for i in range(xyz.shape[0]):
            num_grad[i] = np.squeeze(
                [
                    partial_derivative(
                        energy_wrap, xyz[i], dim_ix=dim_ix, n=1, dx=dx, order=5
                    )
                    for dim_ix in range(self.w0.size // 2)
                ]
            )
        grad = self.potential._gradient(xyz, t=np.array([0.0]))
        assert np.allclose(num_grad, grad, rtol=self.tol)

    def test_orbit_integration(self):
        """
        Make sure we can integrate an orbit in this potential
        """
        w0 = self.w0
        w0 = np.vstack((w0, w0, w0)).T

        t1 = time.time()
        orbit = self.H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        print("Integration time (10000 steps): {}".format(time.time() - t1))

        if self.show_plots:
            f = orbit.plot()
            f.suptitle("Vector w0")
            plt.show()
            plt.close(f)

        us = self.potential.units
        w0 = PhaseSpacePosition(
            pos=w0[: self.ndim] * us["length"],
            vel=w0[self.ndim :] * us["length"] / us["time"],
        )
        orbit = self.H.integrate_orbit(w0, dt=0.1, n_steps=10000)

        if self.show_plots:
            f = orbit.plot()
            f.suptitle("Object w0")
            plt.show()
            plt.close(f)

    def test_pickle(self, tmpdir):
        fn = str(tmpdir.join("{}.pickle".format(self.name)))
        with open(fn, "wb") as f:
            pickle.dump(self.potential, f)

        with open(fn, "rb") as f:
            p = pickle.load(f)

        p.energy(self.w0[: self.w0.size // 2])

    @pytest.mark.skipif(not HAS_SYMPY, reason="requires sympy to run this test")
    def test_against_sympy(self):
        # TODO: should really split this into separate tests for each check...

        import sympy as sy
        from sympy import Q

        # compare Gala gradient, hessian, and density to sympy values

        pot = self.potential
        Phi, v, p = pot.to_sympy()

        # Derive sympy gradient and hessian functions to evaluate:
        from scipy.special import gamma, gammainc

        def lowergamma(a, x):  # noqa
            # Differences between scipy and sympy lower gamma
            return gammainc(a, x) * gamma(a)

        modules = [
            {
                "atan": np.arctan,
                # "lowergamma": lowergamma,
                "gamma": gamma,
                "re": np.real,
                "im": np.imag,
            },
            "numpy",
            "scipy",
            "sympy",
        ]

        vars_ = list(p.values()) + list(v.values())
        assums = np.bitwise_and.reduce([Q.real(x) for x in vars_])
        # Phi = sy.refine(Phi, assums)
        e_func = sy.lambdify(vars_, Phi, modules=modules)

        if self.sympy_density:
            dens_tmp = sum([sy.diff(Phi, var, 2) for var in v.values()]) / (
                4 * sy.pi * p["G"]
            )
            # dens_tmp = sy.refine(dens_tmp, assums)
            dens_func = sy.lambdify(vars_, dens_tmp, modules=modules)

        grad = sy.derive_by_array(Phi, list(v.values()))
        # grad = sy.refine(grad, assums)
        grad_func = sy.lambdify(vars_, grad, modules=modules)

        if self.sympy_hessian:
            Hess = sy.hessian(Phi, list(v.values()))
            # Hess = sy.refine(Hess, assums)
            Hess_func = sy.lambdify(vars_, Hess, modules=modules)

        # Make a dict of potential parameter values without units:
        par_vals = {}
        for k, v in pot.parameters.items():
            par_vals[k] = v.value

        N = 64  # MAGIC NUMBER:
        trial_x = self.rnd.uniform(-10.0, 10.0, size=(pot.ndim, N))
        x_dict = {k: v for k, v in zip(["x", "y", "z"], trial_x)}

        f_gala = pot.energy(trial_x).value
        f_sympy = e_func(G=pot.G, **par_vals, **x_dict)
        e_close = np.allclose(f_gala, f_sympy)
        test_cases = [e_close]
        vals = [(f_gala, f_sympy)]

        if self.sympy_density:
            d_gala = pot.density(trial_x).value
            d_sympy = dens_func(G=pot.G, **par_vals, **x_dict)
            d_close = np.allclose(d_gala, d_sympy)
            test_cases.append(d_close)
            vals.append((d_gala, d_sympy))

        G_gala = pot.gradient(trial_x).value
        G_sympy = grad_func(G=pot.G, **par_vals, **x_dict)
        g_close = np.allclose(G_gala, G_sympy)
        test_cases.append(g_close)
        vals.append((G_gala, G_sympy))

        if self.sympy_hessian:
            H_gala = pot.hessian(trial_x).value
            H_sympy = Hess_func(G=pot.G, **par_vals, **x_dict)
            h_close = np.allclose(H_gala, H_sympy)
            test_cases.append(h_close)
            vals.append((H_gala, H_sympy))

        if not all(test_cases):
            names = ["energy", "density", "gradient", "hessian"]
            for name, (val1, val2), test in zip(names, vals, test_cases):
                if not test:
                    print(trial_x)
                    print(f"{pot}: {name}\nGala:{val1}\nSympy:{val2}")

        assert all(test_cases)

    def test_regression_165(self):
        if self.potential.ndim == 1:
            # Skip!
            return

        with pytest.raises(ValueError):
            self.potential.energy(8.0)

        with pytest.raises(ValueError):
            self.potential.gradient(8.0)

        with pytest.raises(ValueError):
            self.potential.circular_velocity(8.0)


class CompositePotentialTestBase(PotentialTestBase):
    @pytest.mark.skip(reason="Skip composite potential repr test")
    def test_repr(self):
        pass

    @pytest.mark.skip(reason="Skip composite potential compare test")
    def test_compare(self):
        pass

    @pytest.mark.skip(reason="to_sympy() not implemented yet")
    def test_against_sympy(self):
        pass
</file>

<file path="gala/potential/potential/tests/lm10.yml">
class: LM10Potential
type: custom
components:
- class: MiyamotoNagaiPotential
  name: disk
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      a: 10.
      a_unit: kpc
      b: 0.26
      b_unit: kpc
      m: 150000.
      m_unit: solMass
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: HernquistPotential
  name: bulge
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      c: 0.7
      c_unit: kpc
      m: 34000000000.0
      m_unit: solMass
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: LogarithmicPotential
  name: halo
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      phi: 1.6929693744344996
      phi_unit: rad
      q1: 1.38
      q1_unit: ''
      q2: 1.0
      q2_unit: ''
      q3: 1.36
      q3_unit: ''
      r_h: 12.0
      r_h_unit: kpc
      v_c: 0.17624729719037474
      v_c_unit: kpc / Myr
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
</file>

<file path="gala/potential/potential/tests/Plummer.yml">
class: PlummerPotential
parameters:
  b: 0.26
  b_unit: kpc
  m: 100000000000.0
units:
  angle: rad
  angular speed: mas / yr
  length: kpc
  mass: solMass
  speed: km / s
  time: Myr
</file>

<file path="gala/potential/potential/tests/pot_disk_506151.pot">
[Potential]
type=CylSpline
gridSizeR=20
gridSizez=20
mmax=0
symmetry=Axisymmetric
Coefficients
#Phi
0	#m
#R(row)\z(col)	0.0000000000000	0.0500000000000	0.1182084351260	0.2112562475729	0.3381891611508	0.5113470691736	0.7475636678922	1.0698029588800	1.5093917143679	2.1090649365845	2.9271203780720	4.0430860082759	5.5654513940886	7.6422146072148	10.475269985108	14.340035464136	19.612227573209	26.804387042081	36.615705893054	50.000000000000
0.0000000000000	-193083.9835733	-192881.3561670	-191891.9715573	-189165.7369903	-182924.5538425	-170282.3740697	-149752.5827582	-126522.8039230	-105364.3779252	-88024.87295139	-73653.63552806	-61403.37335216	-50633.66793865	-41158.54208657	-33029.89798508	-26233.91737483	-20578.11036170	-16050.17864046	-12442.49854384	-9497.018205116
0.2000000000000	-182985.1026772	-182821.7336359	-182024.9095618	-179814.0120575	-174718.3184644	-163981.5922608	-146470.1113922	-125067.5015756	-104779.9772947	-87795.69591026	-73562.61719733	-61363.53515720	-50611.12130506	-41148.22944545	-33026.32985394	-26232.41344440	-20577.37197326	-16049.86342535	-12442.35379495	-9496.958476333
0.4605725372340	-156490.5981046	-156373.9690757	-155827.9389683	-154386.0526858	-151205.0589636	-144990.9075482	-134385.8576847	-119063.8707808	-102311.7354562	-86814.12011168	-73157.63658825	-61181.79916917	-50521.67383332	-41108.40630268	-33009.25946528	-26224.94351114	-20574.19421564	-16048.50962097	-12441.70610307	-9496.701469852
0.8000627730368	-129131.2481255	-129073.0771498	-128804.9566747	-128093.3510701	-126522.4924737	-123398.1774971	-117747.9062156	-108845.1986019	-97244.26209366	-84579.58420341	-72190.15559026	-60740.05523100	-50312.26908819	-41012.82168665	-32968.78285122	-26206.33390076	-20566.14017878	-16045.15603360	-12440.08443799	-9496.055020928
1.2423719335833	-107417.9826790	-107391.1600953	-107265.5607590	-106927.8232932	-106179.3787593	-104658.6803654	-101811.3464336	-96994.69300055	-89831.65942338	-80633.21376082	-70333.13802607	-59855.37283735	-49883.16247849	-40814.45540267	-32880.72943220	-26167.06229135	-20549.36262023	-16038.10955945	-12436.44540814	-9494.627052585
1.8186400346104	-90443.69182166	-90430.63232787	-90371.21544605	-90212.48103679	-89854.15462719	-89120.07642065	-87712.90765744	-85194.46641429	-81058.68233550	-74995.37863466	-67199.56890338	-58266.42198071	-49089.83454262	-40439.32884162	-32710.83360891	-26090.55366392	-20516.57169411	-16024.43159788	-12429.81334389	-9491.889912637
2.5694382406688	-76741.28171409	-76734.71558581	-76706.22954863	-76631.10517475	-76461.62787453	-76105.19946269	-75404.31315821	-74093.65789533	-71792.41721720	-68068.81350061	-62664.12048128	-55672.80067414	-47737.66357225	-39776.08503968	-32402.58721895	-25950.80898647	-20455.74337016	-15998.95373735	-12417.53514035	-9486.875217393
3.5476252081855	-65227.91502614	-65224.86086274	-65210.79732821	-65172.81913290	-65086.25890730	-64905.67396420	-64545.98856570	-63859.96311301	-62605.23587835	-60427.96780983	-56950.52019904	-51943.90112876	-45605.14731861	-38670.45515991	-31866.54079731	-25703.54810934	-20347.11908580	-15951.67119138	-12395.65388718	-9477.740813335
4.8220685082607	-55263.47914702	-55261.83271677	-55254.31192636	-55234.16975001	-55189.15166583	-55095.57445953	-54905.77330226	-54537.57855134	-53845.58480797	-52597.70347448	-50473.41435205	-47163.64532328	-42542.86126035	-36950.28977443	-30986.29888122	-25283.17631969	-20158.44980545	-15867.76289054	-12357.18682877	-9461.405988605
6.4824931295681	-46432.40717833	-46431.45633504	-46427.41232505	-46416.85507957	-46392.22654413	-46340.41517460	-46236.36183769	-46033.68862172	-45652.34346654	-44956.90721732	-43735.10065116	-41710.74648300	-38638.37781120	-34505.26366497	-29636.30800805	-24601.51841444	-19841.13591027	-15723.78787091	-12291.24391228	-9433.141325115
8.6457984118673	-38724.75987539	-38724.38386520	-38722.40426819	-38717.04113926	-38704.58838059	-38678.44024600	-38625.87221032	-38522.16849513	-38322.81162147	-37951.95724679	-37278.63171831	-36111.86475523	-34212.34088632	-31397.63307072	-27734.61487270	-23558.23054954	-19326.34284149	-15484.08430705	-12180.83726563	-9384.844704087
11.464288142969	-32206.71021465	-32206.46774760	-32205.38070797	-32202.42038747	-32195.73985299	-32181.76435588	-32153.80908794	-32098.75105028	-31994.02068534	-31794.51130533	-31424.82147295	-30764.11431181	-29635.16064780	-27840.15182784	-25289.86696417	-22076.52630102	-18535.87681154	-15097.29167672	-11999.12357705	-9303.167376542
15.136393244975	-26640.04672322	-26639.88381504	-26639.22599206	-26637.57252539	-26633.88389696	-26626.05994450	-26610.26758946	-26579.83155762	-26521.04254926	-26409.28164372	-26202.21077722	-25828.76150703	-25174.09079711	-24082.91239559	-22424.07664142	-20148.34226722	-17407.45419620	-14502.23659918	-11707.85814955	-9167.276917246
19.920641962073	-21853.50651826	-21853.43151144	-21853.10481094	-21852.23023926	-21850.25194826	-21845.96152583	-21837.35505485	-21820.34209898	-21787.50649459	-21725.17021692	-21608.77286140	-21395.22806753	-21016.57122747	-20380.12728230	-19367.06237517	-17879.24388801	-15924.52621440	-13643.77221867	-11257.77148841	-8947.779956972
26.153861096936	-17795.66259379	-17795.63287487	-17795.48317649	-17795.05205427	-17793.95844327	-17791.65307201	-17787.03670278	-17778.05822269	-17760.60510171	-17726.98072197	-17662.65095173	-17542.35018719	-17324.12719914	-16950.96864423	-16346.98777167	-15427.99856920	-14139.99996878	-12493.12690623	-10596.48376764	-8604.811123070
34.274889722469	-14262.96581361	-14262.94813615	-14262.85811915	-14262.62842809	-14262.13216129	-14261.03024387	-14258.83351230	-14254.41783366	-14245.69639377	-14228.67651040	-14196.08889287	-14134.93603045	-14021.83080611	-13817.95831938	-13474.47753358	-12940.73000382	-12157.46622578	-11074.39237204	-9692.377749117	-8096.377293632
44.855474891995	-11146.02368008	-11146.01607772	-11145.98267782	-11145.87284467	-11145.62350655	-11145.10913636	-11144.08614252	-11142.07304883	-11138.15353923	-11130.64250955	-11116.43612918	-11089.84747050	-11040.98211757	-10952.95989603	-10798.53530734	-10537.80051182	-10116.62989964	-9475.428806423	-8568.624198929	-7403.172203861
58.640524507213	-8647.733438060	-8647.730015542	-8647.714179532	-8647.672265978	-8647.578361318	-8647.376247806	-8646.957099701	-8646.149252759	-8644.600874742	-8641.626535330	-8635.990299432	-8625.394135177	-8605.744795890	-8569.535075820	-8503.528247188	-8385.361899053	-8180.914042105	-7840.839647591	-7307.599563596	-6541.192971769
76.600551277882	-6710.722783172	-6710.720908549	-6710.711885570	-6710.690634953	-6710.648223346	-6710.560492257	-6710.380305783	-6710.039615070	-6709.368824500	-6708.083727301	-6705.657292678	-6701.046750902	-6692.321074993	-6676.085406396	-6645.872448470	-6590.697735295	-6491.622866646	-6318.466890510	-6028.238959283	-5572.187624221
100.00000000000	-5159.834215568	-5159.833624334	-5159.830851275	-5159.823269738	-5159.804827292	-5159.763269011	-5159.679804704	-5159.519494671	-5159.203064749	-5158.593943652	-5157.451458302	-5155.305577978	-5151.294552974	-5143.839894602	-5130.021755140	-5104.449311679	-5057.633801864	-4973.372825153	-4826.374797863	-4581.319512478
</file>

<file path="gala/potential/potential/tests/test_all_builtin.py">
"""
    Test the builtin CPotential classes
"""

# Third-party
import numpy as np
import astropy.table as at
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import pytest
from scipy.spatial.transform import Rotation

# This project
from ..core import CompositePotential
from ..ccompositepotential import CCompositePotential
from .. import builtin as p
from ...frame import ConstantRotatingFrame
from ....units import solarsystem, galactic, DimensionlessUnitSystem
from .helpers import PotentialTestBase, CompositePotentialTestBase
from gala._cconfig import GSL_ENABLED
from gala.tests.optional_deps import HAS_SYMPY

##############################################################################
# Python
##############################################################################


class TestHarmonicOscillator1D(PotentialTestBase):
    potential = p.HarmonicOscillatorPotential(omega=1.)
    w0 = [1., 0.1]
    sympy_density = False
    check_finite_at_origin = False

    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass


class TestHarmonicOscillator2D(PotentialTestBase):
    potential = p.HarmonicOscillatorPotential(omega=[1., 2])
    w0 = [1., 0.5, 0., 0.1]
    sympy_density = False
    check_finite_at_origin = False

    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass

    @pytest.mark.skip(reason="to_sympy() won't support multi-dim HO")
    def test_against_sympy(self):
        pass

##############################################################################
# Cython
##############################################################################


class TestNull(PotentialTestBase):
    potential = p.NullPotential()
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]

    def test_mass_enclosed(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.mass_enclosed(arr[:self.ndim])
            assert g.shape == shp
            assert np.all(g == 0.)

            g = self.potential.mass_enclosed(arr[:self.ndim], t=0.1)
            g = self.potential.mass_enclosed(arr[:self.ndim], t=0.1*self.potential.units['time'])

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.mass_enclosed(arr[:self.ndim], t=t)
            g = self.potential.mass_enclosed(arr[:self.ndim], t=t*self.potential.units['time'])

    def test_circular_velocity(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.circular_velocity(arr[:self.ndim])
            assert g.shape == shp
            assert np.all(g == 0.)

            g = self.potential.circular_velocity(arr[:self.ndim], t=0.1)
            g = self.potential.circular_velocity(arr[:self.ndim],
                                                 t=0.1*self.potential.units['time'])

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.circular_velocity(arr[:self.ndim], t=t)
            g = self.potential.circular_velocity(arr[:self.ndim], t=t*self.potential.units['time'])

    @pytest.mark.skip(reason="Nothing to compare to for Null potential!")
    def test_against_sympy(self):
        pass


class TestHenonHeiles(PotentialTestBase):
    potential = p.HenonHeilesPotential()
    w0 = [1., 0., 0., 2*np.pi]
    sympy_density = False
    check_finite_at_origin = False

    @pytest.mark.skip(reason="Not relevant")
    def test_plot(self):
        pass


class TestKepler(PotentialTestBase):
    potential = p.KeplerPotential(units=solarsystem, m=1.)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]
    # show_plots = True
    check_finite_at_origin = False


class TestKeplerUnitInput(PotentialTestBase):
    potential = p.KeplerPotential(units=solarsystem, m=(1*u.Msun).to(u.Mjup))
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]
    check_finite_at_origin = False


class TestIsochrone(PotentialTestBase):
    potential = p.IsochronePotential(units=solarsystem, m=1., b=0.1)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]


class TestIsochroneDimensionless(PotentialTestBase):
    potential = p.IsochronePotential(units=DimensionlessUnitSystem(),
                                     m=1., b=0.1)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]


class TestHernquist(PotentialTestBase):
    potential = p.HernquistPotential(units=galactic, m=1.E11, c=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestPlummer(PotentialTestBase):
    potential = p.PlummerPotential(units=galactic, m=1.E11, b=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestJaffe(PotentialTestBase):
    check_finite_at_origin = False
    potential = p.JaffePotential(units=galactic, m=1.E11, c=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestMiyamotoNagai(PotentialTestBase):
    potential = p.MiyamotoNagaiPotential(units=galactic, m=1.E11, a=6.5, b=0.26)
    w0 = [8., 0., 0., 0., 0.22, 0.1]

    @pytest.mark.skipif(not HAS_SYMPY,
                        reason="requires sympy to run this test")
    def test_hessian_analytic(self):
        from astropy.constants import G
        from sympy import symbols
        import sympy as sy

        x, y, z = symbols('x y z')

        usys = self.potential.units
        GM = (G * self.potential.parameters['m']).decompose(usys).value
        a = self.potential.parameters['a'].decompose(usys).value
        b = self.potential.parameters['b'].decompose(usys).value
        Phi = -GM / sy.sqrt(x**2 + y**2 + (a + sy.sqrt(z**2 + b**2))**2)

        d2Phi_dx2 = sy.lambdify((x, y, z), sy.diff(Phi, x, 2))
        d2Phi_dy2 = sy.lambdify((x, y, z), sy.diff(Phi, y, 2))
        d2Phi_dz2 = sy.lambdify((x, y, z), sy.diff(Phi, z, 2))

        d2Phi_dxdy = sy.lambdify((x, y, z), sy.diff(Phi, x, y))
        d2Phi_dxdz = sy.lambdify((x, y, z), sy.diff(Phi, x, z))
        d2Phi_dydz = sy.lambdify((x, y, z), sy.diff(Phi, y, z))

        rnd = np.random.default_rng(42)
        xyz = rnd.normal(0, 25, size=(3, 64))

        H1 = self.potential.hessian(xyz).decompose(usys).value

        H2 = np.zeros((3, 3, xyz.shape[1]))
        H2[0, 0] = d2Phi_dx2(*xyz)
        H2[1, 1] = d2Phi_dy2(*xyz)
        H2[2, 2] = d2Phi_dz2(*xyz)

        H2[0, 1] = H2[1, 0] = d2Phi_dxdy(*xyz)
        H2[0, 2] = H2[2, 0] = d2Phi_dxdz(*xyz)
        H2[1, 2] = H2[2, 1] = d2Phi_dydz(*xyz)

        assert np.allclose(H1, H2)


class TestMN3(PotentialTestBase):
    potential = p.MN3ExponentialDiskPotential(
        units=galactic, m=1.E11, h_R=3.5, h_z=0.26
    )
    w0 = [8., 0., 0., 0., 0.22, 0.1]

    # TODO:
    @pytest.mark.skip(reason="to_sympy() not implemented yet")
    def test_against_sympy(self):
        pass

    def test_get_three(self):
        pots = self.potential.get_three_potentials()
        assert len(pots) == 3


class TestSatoh(PotentialTestBase):
    potential = p.SatohPotential(units=galactic, m=1.E11, a=6.5, b=0.26)
    w0 = [8., 0., 0., 0., 0.22, 0.1]


class TestKuzmin(PotentialTestBase):
    potential = p.KuzminPotential(units=galactic, m=1.E11, a=3.5)
    w0 = [8., 0., 0., 0., 0.22, 0.1]
    sympy_hessian = False
    sympy_density = False


class TestStone(PotentialTestBase):
    potential = p.StonePotential(units=galactic, m=1E11, r_c=0.1, r_h=10.)
    w0 = [8., 0., 0., 0., 0.18, 0.1]


@pytest.mark.skipif(not GSL_ENABLED,
                    reason="requires GSL to run this test")
class TestPowerLawCutoff(PotentialTestBase):
    w0 = [8., 0., 0., 0., 0.1, 0.1]
    atol = 1e-3
    sympy_density = False  # weird underflow issues??
    check_finite_at_origin = False

    def setup_method(self):
        self.potential = p.PowerLawCutoffPotential(units=galactic,
                                                   m=1E10, r_c=1., alpha=1.8)
        super().setup_method()


class TestSphericalNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12.)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestFlattenedNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12., c=0.7)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]
    sympy_density = False  # not defined

    def test_against_spherical(self):
        """
        Note: This is a regression test for Issue #254
        """

        sph = p.NFWPotential(units=galactic, m=1E11, r_s=12.)
        assert not u.allclose(self.potential.gradient(self.w0[:3]),
                              sph.gradient(self.w0[:3]))


class TestTriaxialNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12.,
                               a=1., b=0.95, c=0.9)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]
    sympy_density = False  # not defined


class TestSphericalNFWFromCircVel(PotentialTestBase):
    potential = p.NFWPotential.from_circular_velocity(
        v_c=220.*u.km/u.s,
        r_s=20*u.kpc,
        r_ref=8.*u.kpc,
        units=galactic)
    w0 = [19.0, 2.7, -0.9, 0.00352238, -0.165134, 0.0075]

    def test_circ_vel(self):
        for r_ref in [3., 8., 21.7234]:
            pot = p.NFWPotential.from_circular_velocity(
                v_c=220.*u.km/u.s, r_s=20*u.kpc,
                r_ref=r_ref*u.kpc, units=galactic)
            vc = pot.circular_velocity([r_ref, 0, 0]*u.kpc)  # at ref. velocity
            assert u.allclose(vc, 220*u.km/u.s)

    def test_against_triaxial(self):
        this = p.NFWPotential.from_circular_velocity(
            v_c=220.*u.km/u.s, r_s=20*u.kpc, units=galactic)
        other = p.LeeSutoTriaxialNFWPotential(
            units=galactic,
            v_c=220.*u.km/u.s, r_s=20.*u.kpc,
            a=1., b=1., c=1.)

        v1 = this.energy(self.w0[:3])
        v2 = other.energy(self.w0[:3])
        assert u.allclose(v1, v2)

        a1 = this.gradient(self.w0[:3])
        a2 = other.gradient(self.w0[:3])
        assert u.allclose(a1, a2)

        d1 = this.density(self.w0[:3])
        d2 = other.density(self.w0[:3])
        assert u.allclose(d1, d2)

    def test_mass_enclosed(self):

        # true mass profile
        m = self.potential.parameters['m'].value
        rs = self.potential.parameters['r_s'].value

        r = np.linspace(1., 400, 100)
        fac = np.log(1 + r/rs) - (r/rs) / (1 + (r/rs))
        true_mprof = m * fac

        R = np.zeros((3, len(r)))
        R[0, :] = r
        esti_mprof = self.potential.mass_enclosed(R)

        assert np.allclose(true_mprof, esti_mprof.value, rtol=1E-6)


class TestNFW(PotentialTestBase):
    potential = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, a=1., b=0.9, c=0.75,
                               units=galactic)
    w0 = [19.0, 2.7, -0.9, 0.00352238, -0.15134, 0.0075]
    sympy_density = False  # like triaxial case

    def test_compare(self):

        sph = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, units=galactic)
        fla = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, c=0.8, units=galactic)
        tri = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, b=0.9, c=0.8, units=galactic)

        xyz = np.zeros((3, 128))
        xyz[0] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.energy(xyz), tri.energy(xyz))

        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))
        assert u.allclose(sph.gradient(xyz), tri.gradient(xyz))

        # assert u.allclose(sph.density(xyz), fla.density(xyz)) # TODO: fla density not implemented
        # assert u.allclose(sph.density(xyz), tri.density(xyz)) # TODO: tri density not implemented

        # ---

        tri = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, a=0.9, c=0.8, units=galactic)

        xyz = np.zeros((3, 128))
        xyz[1] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.energy(xyz), tri.energy(xyz))

        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))
        assert u.allclose(sph.gradient(xyz), tri.gradient(xyz))

        # assert u.allclose(sph.density(xyz), fla.density(xyz)) # TODO: fla density not implemented
        # assert u.allclose(sph.density(xyz), tri.density(xyz)) # TODO: tri density not implemented

        # ---

        xyz = np.zeros((3, 128))
        xyz[0] = np.logspace(-1., 3, xyz.shape[1])
        xyz[1] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))


class TestLeeSutoTriaxialNFW(PotentialTestBase):
    potential = p.LeeSutoTriaxialNFWPotential(units=galactic, v_c=0.35, r_s=12.,
                                              a=1.3, b=1., c=0.8)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]

    @pytest.mark.skip(reason="to_sympy() not implemented yet")
    def test_against_sympy(self):
        pass


class TestLogarithmic(PotentialTestBase):
    potential = p.LogarithmicPotential(units=galactic, v_c=0.17, r_h=10.,
                                       q1=1.2, q2=1., q3=0.8)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestLongMuraliBar(PotentialTestBase):
    potential = p.LongMuraliBarPotential(units=galactic, m=1E11,
                                         a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]


class TestLongMuraliBarRotate(PotentialTestBase):
    potential = p.LongMuraliBarPotential(
        units=galactic, m=1E11,
        a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc,
        R=np.array([[0.63302222, 0.75440651, 0.17364818],
                    [-0.76604444, 0.64278761, 0.],
                    [-0.1116189, -0.13302222, 0.98480775]]))
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    def test_hessian(self):
        # TODO: when hessian for rotated potentials implemented, remove this
        with pytest.raises(NotImplementedError):
            self.potential.hessian([1., 2., 3.])

    @pytest.mark.skip(reason="Not implemented for rotated potentials")
    def test_against_sympy(self):
        pass


class TestLongMuraliBarRotationScipy(PotentialTestBase):
    potential = p.LongMuraliBarPotential(
        units=galactic, m=1E11,
        a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc,
        R=Rotation.from_euler('zxz', [90., 0, 0.], degrees=True))
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    def test_hessian(self):
        # TODO: when hessian for rotated potentials implemented, remove this
        with pytest.raises(NotImplementedError):
            self.potential.hessian([1., 2., 3.])

    @pytest.mark.skip(reason="Not implemented for rotated potentials")
    def test_against_sympy(self):
        pass


class TestComposite(CompositePotentialTestBase):
    p1 = p.LogarithmicPotential(units=galactic,
                                v_c=0.17, r_h=10.,
                                q1=1.2, q2=1., q3=0.8)
    p2 = p.MiyamotoNagaiPotential(units=galactic,
                                  m=1.E11, a=6.5, b=0.26)
    potential = CompositePotential()
    potential['disk'] = p2
    potential['halo'] = p1
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestCComposite(CompositePotentialTestBase):
    p1 = p.LogarithmicPotential(units=galactic,
                                v_c=0.17, r_h=10.,
                                q1=1.2, q2=1., q3=0.8)
    p2 = p.MiyamotoNagaiPotential(units=galactic,
                                  m=1.E11, a=6.5, b=0.26)
    potential = CCompositePotential()
    potential['disk'] = p2
    potential['halo'] = p1
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestKepler3Body(CompositePotentialTestBase):
    """ This implicitly tests the origin shift """
    mu = 1/11.
    x1 = -mu
    m1 = 1-mu
    x2 = 1-mu
    m2 = mu
    potential = CCompositePotential()
    potential['m1'] = p.KeplerPotential(m=m1, origin=[x1, 0, 0.])
    potential['m2'] = p.KeplerPotential(m=m2, origin=[x2, 0, 0.])

    Omega = np.array([0, 0, 1.])
    frame = ConstantRotatingFrame(Omega=Omega)
    w0 = [0.5, 0, 0, 0., 1.05800316, 0.]


@pytest.mark.skipif(not GSL_ENABLED,
                    reason="requires GSL to run this test")
class TestMultipoleInner(CompositePotentialTestBase):
    potential_1 = p.NFWPotential(m=1E12, r_s=15., units=galactic)
    potential = potential_1 + p.MultipolePotential(
        units=galactic, m=1E10, r_s=15., inner=True,
        lmax=2, S10=1., S21=0.5)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    @pytest.mark.skip(reason="Not implemented for multipole potentials")
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason="Not implemented for multipole potentials")
    def test_against_sympy(self):
        pass


@pytest.mark.skipif(not GSL_ENABLED,
                    reason="requires GSL to run this test")
class TestMultipoleOuter(CompositePotentialTestBase):
    potential_1 = p.NFWPotential(m=1E12, r_s=15., units=galactic)
    potential = potential_1 + p.MultipolePotential(
        units=galactic, m=1E10, r_s=15., inner=False,
        lmax=2, S10=1., S21=0.5)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]
    check_finite_at_origin = False

    @pytest.mark.skip(reason="Not implemented for multipole potentials")
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason="Not implemented for multipole potentials")
    def test_against_sympy(self):
        pass


@pytest.mark.skipif(not GSL_ENABLED,
                    reason="requires GSL to run this test")
class TestCylspline(PotentialTestBase):
    check_finite_at_origin = True

    def setup_method(self):
        self.potential = p.CylSplinePotential.from_file(
            get_pkg_data_filename('pot_disk_506151.pot'),
            units=galactic
        )
        vc = self.potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic)
        self.w0 = [19.0, 0.2, -0.9, 0., vc.value[0], 0.]
        super().setup_method()

    @pytest.mark.skip(reason="Not implemented for cylspline potentials")
    def test_density(self):
        pass

    @pytest.mark.skip(reason="Not implemented for cylspline potentials")
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason="Not implemented for cylspline potentials")
    def test_against_sympy(self):
        pass

    def test_against_agama(self):
        agama_tbl = at.QTable.read(get_pkg_data_filename('agama_cylspline_test.fits'))

        gala_ene = self.potential.energy(agama_tbl['xyz'].T)
        gala_acc = self.potential.acceleration(agama_tbl['xyz'].T)

        assert u.allclose(gala_ene, agama_tbl['pot'][:, 0], rtol=1e-3)
        for i in range(3):
            assert u.allclose(gala_acc[i], agama_tbl['acc'][:, i], rtol=1e-2)


class TestBurkert(PotentialTestBase):
    potential = p.BurkertPotential(units=galactic, rho=5e-25 * u.g / u.cm ** 3, r0=12 * u.kpc)
    w0 = [1., 0., 0., 0., 0.1, 0.1]

    check_finite_at_origin = False

    @pytest.mark.skip(reason="Not implemented for Burkert potentials")
    def test_against_sympy(self):
        pass

    @pytest.mark.skip(reason="Hessian not implemented for Burkert potential")
    def test_hessian(self):
        pass

    def test_from_r0(self):
        # Test against values from Zhu+2023
        pot = p.BurkertPotential.from_r0(r0=11.87 * u.kpc, units=galactic)

        rho = pot.parameters['rho'].to(u.g / u.cm ** 3)
        rho_check = 5.93e-25 * u.g / u.cm ** 3

        # Check a 1% tolerance on inferred density against published values
        assert abs(rho - rho_check) / rho_check < 0.01
</file>

<file path="gala/potential/potential/tests/test_composite.py">
# Third party
import astropy.units as u
import pytest
import numpy as np

# This project
from ..core import PotentialBase, CompositePotential
from ...common import PotentialParameter
from ..builtin import (KeplerPotential, HernquistPotential,
                       HenonHeilesPotential)

from ..ccompositepotential import CCompositePotential
from ...hamiltonian import Hamiltonian
from ....integrate import LeapfrogIntegrator, DOPRI853Integrator
from ....units import solarsystem, galactic


class CompositeHelper:

    def setup_method(self):
        self.units = solarsystem
        self.p1 = KeplerPotential(m=1.*u.Msun, units=self.units)
        self.p2 = HernquistPotential(m=0.5*u.Msun, c=0.1*u.au,
                                     units=self.units)

    def test_shit(self):
        potential = self.Cls(one=self.p1, two=self.p2)

        q = np.ascontiguousarray(np.array([[1.1, 0, 0]]).T)
        print("val", potential.energy(q))

        q = np.ascontiguousarray(np.array([[1.1, 0, 0]]).T)
        print("grad", potential.gradient(q))

    def test_composite_create(self):
        potential = self.Cls()

        # Add a point mass with same unit system
        potential["one"] = KeplerPotential(units=self.units, m=1.)

        with pytest.raises(TypeError):
            potential["two"] = "derp"

        assert "one" in potential.parameters
        assert "m" in potential.parameters["one"]
        with pytest.raises(TypeError):
            potential.parameters["m"] = "derp"

    def test_plot_composite(self):
        # TODO: do image comparison or something to compare?

        potential = self.Cls()

        # Add a kepler potential and a harmonic oscillator
        potential["one"] = self.p1
        potential["two"] = self.p2

        grid = np.linspace(-5., 5)
        potential.plot_contours(grid=(grid, 0., 0.))
        # fig.savefig(os.path.join(plot_path, "composite_kepler_sho_1d.png"))

        potential.plot_contours(grid=(grid, grid, 0.))
        # fig.savefig(os.path.join(plot_path, "composite_kepler_sho_2d.png"))

    def test_integrate(self):
        potential = self.Cls()
        potential["one"] = self.p1
        potential["two"] = self.p2

        for Integrator in [DOPRI853Integrator, LeapfrogIntegrator]:
            H = Hamiltonian(potential)
            w_cy = H.integrate_orbit([1., 0, 0, 0, 2*np.pi, 0], dt=0.01,
                                     n_steps=1000,
                                     Integrator=Integrator,
                                     cython_if_possible=True)
            w_py = H.integrate_orbit([1., 0, 0, 0, 2*np.pi, 0], dt=0.01,
                                     n_steps=1000,
                                     Integrator=Integrator,
                                     cython_if_possible=False)

            assert np.allclose(w_cy.xyz.value, w_py.xyz.value)
            assert np.allclose(w_cy.v_xyz.value, w_py.v_xyz.value)

# ------------------------------------------------------------------------


class TestComposite(CompositeHelper):
    Cls = CompositePotential


class TestCComposite(CompositeHelper):
    Cls = CCompositePotential


def test_failures():
    p = CCompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    with pytest.raises(ValueError):
        p['jnsdfn'] = HenonHeilesPotential(units=solarsystem)


def test_lock():
    p = CompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    p.lock = True
    with pytest.raises(ValueError):  # try adding potential after lock
        p['herp'] = KeplerPotential(m=2.*u.Msun, units=solarsystem)

    p = CCompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    p.lock = True
    with pytest.raises(ValueError):  # try adding potential after lock
        p['herp'] = KeplerPotential(m=2.*u.Msun, units=solarsystem)


class MyPotential(PotentialBase):
    m = PotentialParameter('m', physical_type='mass')
    x0 = PotentialParameter('x0', physical_type='length')

    def _energy(self, x, t):
        m = self.parameters['m']
        x0 = self.parameters['x0']
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return -m/r

    def _gradient(self, x, t):
        m = self.parameters['m']
        x0 = self.parameters['x0']
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return m*(x-x0[None])/r**3


def test_add():
    """ Test adding potentials to get a composite """
    p1 = KeplerPotential(units=galactic, m=1*u.Msun)
    p2 = HernquistPotential(units=galactic,
                            m=1.E11, c=0.26)

    comp1 = CompositePotential()
    comp1['0'] = p1
    comp1['1'] = p2

    py_p1 = MyPotential(m=1., x0=[1., 0., 0.], units=galactic)
    py_p2 = MyPotential(m=4., x0=[-1., 0., 0.], units=galactic)

    # python + python
    new_p = py_p1 + py_p2
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # python + python + python
    new_p = py_p1 + py_p2 + py_p2
    assert isinstance(new_p, CompositePotential)
    assert len(new_p.keys()) == 3

    # cython + cython
    new_p = p1 + p2
    assert isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # cython + python
    new_p = py_p1 + p2
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # cython + cython + python
    new_p = p1 + p2 + py_p1
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 3
</file>

<file path="gala/potential/potential/tests/test_core.py">
"""
    Test the core Potential classes
"""

# Third party
import pytest
import numpy as np
from astropy.constants import G
import astropy.units as u
from matplotlib import cm

# This package
from ..core import PotentialBase, CompositePotential
from ...common import PotentialParameter
from ....units import UnitSystem

units = [u.kpc, u.Myr, u.Msun, u.radian]
usys = UnitSystem(u.au, u.yr, u.Msun, u.radian)
G = G.decompose(units)


def test_new_simple():

    class MyPotential(PotentialBase):
        ndim = 1

        def _energy(self, r, t=0.):
            return -1/r

        def _gradient(self, r, t=0.):
            return r**-2

    p = MyPotential()
    assert p(0.5) == -2.
    assert p.energy(0.5) == -2.
    assert p.acceleration(0.5) == -4.

    p(np.arange(0.5, 11.5, 0.5).reshape(1, -1))
    p.energy(np.arange(0.5, 11.5, 0.5).reshape(1, -1))
    p.acceleration(np.arange(0.5, 11.5, 0.5).reshape(1, -1))


class MyPotential(PotentialBase):
    m = PotentialParameter('m', 'mass')
    x0 = PotentialParameter('x0', 'length')

    def _energy(self, x, t):
        m = self.parameters['m'].value
        x0 = self.parameters['x0'].value
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return -m/r

    def _gradient(self, x, t):
        m = self.parameters['m'].value
        x0 = self.parameters['x0'].value
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return m*(x-x0[None])/r**3


def test_init_potential():
    MyPotential(1.5, 1)
    MyPotential(1.5, x0=1)
    MyPotential(m=1.5, x0=1)
    MyPotential(1.5*u.Msun, 1*u.au, units=usys)
    MyPotential(1.5*u.Msun, x0=1*u.au, units=usys)
    MyPotential(m=1.5*u.Msun, x0=1*u.au, units=usys)


def test_repr():
    p = MyPotential(m=1.E10*u.Msun, x0=0., units=usys)
    _repr = p.__repr__()
    assert _repr.startswith("<MyPotential: m=")
    assert "m=1" in _repr
    assert "x0=0" in _repr
    assert _repr.endswith("(AU,yr,solMass,rad)>")
    # assert p.__repr__() == "<MyPotential: m=1.00e+10, x0=0.00e+00 (AU, yr, solMass, rad)>"


def test_plot():
    p = MyPotential(m=1, x0=[1., 3., 0.], units=usys)
    f = p.plot_contours(grid=(np.linspace(-10., 10., 100), 0., 0.),
                        labels=["X"])
    # f.suptitle("slice off from 0., won't have cusp")
    # f.savefig(os.path.join(plot_path, "contour_x.png"))

    f = p.plot_contours(grid=(np.linspace(-10., 10., 100),  # noqa
                              np.linspace(-10., 10., 100),
                              0.),
                        cmap=cm.Blues)
    # f.savefig(os.path.join(plot_path, "contour_xy.png"))

    f = p.plot_contours(grid=(np.linspace(-10., 10., 100), # noqa
                              1.,
                              np.linspace(-10., 10., 100)),
                        cmap=cm.Blues, labels=["X", "Z"])
    # f.savefig(os.path.join(plot_path, "contour_xz.png"))


def test_composite():
    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=usys)

    p = CompositePotential(one=p1, two=p2)
    assert u.allclose(p.energy([0., 0., 0.]), -2*usys['energy']/usys['mass'])
    assert u.allclose(p.acceleration([0., 0., 0.]), 0.*usys['acceleration'])

    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=[u.kpc, u.yr, u.Msun, u.radian])
    with pytest.raises(ValueError):
        p = CompositePotential(one=p1, two=p2)

    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=usys)
    p = CompositePotential(one=p1, two=p2)
    assert u.au in p.units
    assert u.yr in p.units
    assert u.Msun in p.units


def test_replace_units():
    usys1 = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    usys2 = UnitSystem([u.pc, u.Myr, u.Msun, u.degree])

    p = MyPotential(m=1.E10*u.Msun, x0=0., units=usys1)
    assert p.parameters['m'].unit == usys1['mass']

    p2 = p.replace_units(usys2)
    assert p2.parameters['m'].unit == usys2['mass']
    assert p.units == usys1
    assert p2.units == usys2


def test_replicate():
    usys = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    R = np.diag(np.arange(3))
    p1 = MyPotential(m=1.E10*u.Msun, x0=0., units=usys, R=R)
    p2 = p1.replicate(m=2e10*u.Msun, R=None)

    assert p2.R is None
    assert np.isclose(p2.parameters['m'].value, 2e10)
    assert np.isclose(p2.parameters['x0'].value, p1.parameters['x0'].value)
</file>

<file path="gala/potential/potential/tests/test_cpotential.py">
# Third party
import astropy.units as u

# This package
from ..builtin import HernquistPotential
from ....units import UnitSystem


def test_replace_units():
    usys1 = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    usys2 = UnitSystem([u.pc, u.Myr, u.Msun, u.degree])

    p = HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc, units=usys1)
    assert p.parameters['m'].unit == usys1['mass']
    assert p.parameters['c'].unit == usys1['length']

    p2 = p.replace_units(usys2)
    assert p2.parameters['m'].unit == usys2['mass']
    assert p2.parameters['c'].unit == usys2['length']
    assert p.units == usys1
    assert p2.units == usys2
</file>

<file path="gala/potential/potential/tests/test_interop_agama.py">
"""
Test converting the builtin Potential classes to Agama
"""

# Third-party
import astropy.units as u
import numpy as np
import pytest

# This project
from gala.potential import JaffePotential, LogarithmicPotential, MiyamotoNagaiPotential
from gala.tests.optional_deps import HAS_AGAMA
from gala.units import galactic

if HAS_AGAMA:
    from gala.potential.potential.interop import _gala_to_agama


def pytest_generate_tests(metafunc):
    # Some magic, semi-random numbers below!
    gala_pots = []
    other_pots = []

    if not HAS_AGAMA:
        return

    # Test the Gala -> Agama direction
    for Potential in _gala_to_agama.keys():
        init = {}
        len_scale = 1.0
        for k, par in Potential._parameters.items():
            if k == "m":
                val = 1.43e10 * u.Msun
            elif par.physical_type == "length":
                val = 5.12 * u.kpc * len_scale
                len_scale *= 0.5
            elif par.physical_type == "dimensionless":
                val = 1.0
            elif par.physical_type == "speed":
                val = 201.41 * u.km / u.s
            else:
                continue

            init[k] = val

        pot = Potential(**init, units=galactic)
        other_pot = pot.as_interop("agama")

        gala_pots.append(pot)
        other_pots.append(other_pot)

    # Make a composite potential too:
    gala_pots.append(gala_pots[0] + gala_pots[1])
    other_pots.append(gala_pots[-1].as_interop("agama"))

    test_names = [
        f"{g1.__class__.__name__}:{g2.__class__.__name__}"
        for g1, g2 in zip(gala_pots, other_pots)
    ]

    metafunc.parametrize(
        ["gala_pot", "other_pot"], list(zip(gala_pots, other_pots)), ids=test_names
    )


@pytest.mark.skipif(
    not HAS_AGAMA, reason="must have agama installed to run these tests"
)
class TestAgamaInterop:
    def setup_method(self):
        # Test points:
        rng = np.random.default_rng(42)
        ntest = 4

        xyz = rng.uniform(-25, 25, size=(3, ntest)) * u.kpc
        self.xyz = xyz.copy()

    def test_density(self, gala_pot, other_pot):
        gala_val = gala_pot.density(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.density(self.xyz.decompose(gala_pot.units).value.T)
        assert np.allclose(gala_val, other_val)

    def test_energy(self, gala_pot, other_pot):
        if isinstance(gala_pot, LogarithmicPotential):
            # TODO: Agama has an inconsistency with Gala's log potential energy
            pytest.skip()
        gala_val = gala_pot.energy(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.potential(self.xyz.decompose(gala_pot.units).value.T)
        assert np.allclose(gala_val, other_val)

    def test_acc(self, gala_pot, other_pot):
        gala_val = gala_pot.acceleration(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.force(self.xyz.decompose(gala_pot.units).value.T).T
        assert np.allclose(gala_val, other_val)

    def test_Menc(self, gala_pot, other_pot):
        if isinstance(
            gala_pot, (LogarithmicPotential, JaffePotential, MiyamotoNagaiPotential)
        ):
            # TODO: Agama has an inconsistency with Gala's log potential energy
            pytest.skip()

        grid = np.zeros((3, 128))
        grid[0] = np.geomspace(1e-3, 100.0, 128)

        gala_val = gala_pot.mass_enclosed(grid).value
        agama_val = other_pot.enclosedMass(grid[0])
        assert np.allclose(gala_val, agama_val)
</file>

<file path="gala/potential/potential/tests/test_interop_galpy.py">
"""
Test converting the builtin Potential classes to other packages
"""

# Third-party
import astropy.units as u
import numpy as np
import pytest
from astropy.coordinates import CylindricalRepresentation

# This project
import gala.potential as gp
from gala.potential.potential.interop import galpy_to_gala_potential
from gala.tests.optional_deps import HAS_GALPY
from gala.units import galactic

# Set these globally!
ro = 8.122 * u.kpc
vo = 245 * u.km / u.s

if HAS_GALPY:
    import galpy.potential as galpy_gp

    from gala.potential.potential.interop import _gala_to_galpy, _galpy_to_gala


def pytest_generate_tests(metafunc):
    # Some magic, semi-random numbers below!
    gala_pots = []
    galpy_pots = []

    if not HAS_GALPY:
        return

    # Test the Gala -> Galpy direction
    for Potential in _gala_to_galpy.keys():
        init = {}
        len_scale = 1.0
        for k, par in Potential._parameters.items():
            if k == "m":
                val = 1.43e10 * u.Msun
            elif par.physical_type == "length":
                val = 5.12 * u.kpc * len_scale
                len_scale *= 0.5
            elif par.physical_type == "dimensionless":
                val = 1.0
            elif par.physical_type == "speed":
                val = 201.41 * u.km / u.s
            else:
                continue

            init[k] = val

        pot = Potential(**init, units=galactic)
        galpy_pot = pot.as_interop("galpy", ro=ro, vo=vo)

        gala_pots.append(pot)
        galpy_pots.append(galpy_pot)

        # Custom settings in the MN3 potential:
        if isinstance(pot, gp.MN3ExponentialDiskPotential):
            pot = Potential(**init, units=galactic, sech2_z=False)
            galpy_pot = pot.to_galpy_potential(ro=ro, vo=vo)
            gala_pots.append(pot)
            galpy_pots.append(galpy_pot)

    # Make a composite potential too:
    gala_pots.append(gala_pots[0] + gala_pots[1])
    galpy_pots.append([galpy_pots[0], galpy_pots[1]])

    # Test the Galpy -> Gala direction
    for Potential in _galpy_to_gala.keys():
        galpy_pot = Potential(ro=ro, vo=vo)  # use defaults

        if isinstance(galpy_pot, galpy_gp.MN3ExponentialDiskPotential):
            with pytest.warns():
                pot = galpy_to_gala_potential(galpy_pot, ro=ro, vo=vo)
        else:
            pot = galpy_to_gala_potential(galpy_pot, ro=ro, vo=vo)

        gala_pots.append(pot)
        galpy_pots.append(galpy_pot)

    test_names = [
        f"{g1.__class__.__name__}:{g2.__class__.__name__}"
        for g1, g2 in zip(gala_pots, galpy_pots)
    ]

    metafunc.parametrize(
        ["gala_pot", "galpy_pot"], list(zip(gala_pots, galpy_pots)), ids=test_names
    )


@pytest.mark.skipif(
    not HAS_GALPY, reason="must have galpy installed to run these tests"
)
class TestGalpy:
    def setup_method(self):
        # Test points:
        rng = np.random.default_rng(42)
        ntest = 4

        Rs = rng.uniform(1, 15, size=ntest) * u.kpc
        phis = rng.uniform(0, 2 * np.pi, size=ntest) * u.radian
        zs = rng.uniform(1, 15, size=ntest) * u.kpc

        cyl = CylindricalRepresentation(Rs, phis, zs)
        xyz = cyl.to_cartesian().xyz

        self.Rs = Rs.to_value(ro)
        self.phis = phis.to_value(u.rad)
        self.zs = zs.to_value(ro)
        self.Rpz_iter = np.array(list(zip(self.Rs, self.phis, self.zs))).copy()

        self.xyz = xyz.copy()

        Jac = np.zeros((len(cyl), 3, 3))
        Jac[:, 0, 0] = xyz[0] / cyl.rho
        Jac[:, 0, 1] = xyz[1] / cyl.rho
        Jac[:, 1, 0] = (-xyz[1] / cyl.rho**2).to_value(1 / ro)
        Jac[:, 1, 1] = (xyz[0] / cyl.rho**2).to_value(1 / ro)
        Jac[:, 2, 2] = 1.0
        self.Jac = Jac

    def test_density(self, gala_pot, galpy_pot):
        if isinstance(gala_pot, gp.LogarithmicPotential):
            pytest.skip()

        gala_val = gala_pot.density(self.xyz).to_value(u.Msun / u.pc**3)
        galpy_val = np.array(
            [
                galpy_gp.evaluateDensities(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        assert np.allclose(gala_val, galpy_val)

    def test_energy(self, gala_pot, galpy_pot):
        gala_val = gala_pot.energy(self.xyz).to_value(u.km**2 / u.s**2)
        galpy_val = np.array(
            [
                galpy_gp.evaluatePotentials(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )

        if isinstance(gala_pot, gp.LogarithmicPotential):
            # Logarithms are weird
            gala_val -= (
                0.5 * gala_pot.parameters["v_c"] ** 2 * np.log(ro.value**2)
            ).to_value((u.km / u.s) ** 2)

        assert np.allclose(gala_val, galpy_val)

    def test_gradient(self, gala_pot, galpy_pot):
        gala_grad = gala_pot.gradient(self.xyz)
        gala_grad = gala_grad.to_value(u.km / u.s / u.Myr)

        # TODO: Starting with galpy 1.7, this has been failing because of a
        # units issue with dPhi/dphi
        if isinstance(gala_pot, gp.LongMuraliBarPotential):
            pytest.skip()

        galpy_dR = np.array(
            [
                -galpy_gp.evaluateRforces(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dp = np.array(
            [
                -galpy_gp.evaluatephitorques(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dp = (galpy_dp * (u.km / u.s) ** 2).to_value(vo**2)

        galpy_dz = np.array(
            [
                -galpy_gp.evaluatezforces(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dRpz = np.stack((galpy_dR, galpy_dp, galpy_dz), axis=1)

        galpy_grad = np.einsum("nij,ni->nj", self.Jac, galpy_dRpz).T

        assert np.allclose(gala_grad, galpy_grad)

    def test_vcirc(self, gala_pot, galpy_pot):
        tmp = self.xyz.copy()
        tmp[2] = 0.0

        if not hasattr(galpy_pot, "vcirc") or isinstance(
            gala_pot, gp.LongMuraliBarPotential
        ):
            pytest.skip()

        gala_vcirc = gala_pot.circular_velocity(tmp).to_value(u.km / u.s)
        galpy_vcirc = np.array([galpy_pot.vcirc(R=RR) for RR, *_ in self.Rpz_iter])
        assert np.allclose(gala_vcirc, galpy_vcirc)
</file>

<file path="gala/potential/potential/tests/test_io.py">
""" test reading/writing potentials to files """

# Third-party
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# Project
from ..io import load, save
from ..core import CompositePotential
from ..ccompositepotential import CCompositePotential
from ..builtin import IsochronePotential, KeplerPotential
from ..builtin.special import LM10Potential
from ...scf import SCFPotential
from ....units import DimensionlessUnitSystem, galactic
from gala._cconfig import GSL_ENABLED


def test_read_plummer():
    potential = load(get_pkg_data_filename('Plummer.yml'))
    assert np.allclose(potential.parameters['m'].value, 100000000000.)
    assert np.allclose(potential.parameters['b'].value, 0.26)
    assert potential.parameters['b'].unit == u.kpc


def test_read_harmonic_oscillator():
    potential = load(get_pkg_data_filename('HarmonicOscillator1D.yml'))
    assert isinstance(potential.units, DimensionlessUnitSystem)


def test_read_composite():
    potential = load(get_pkg_data_filename('Composite.yml'))
    assert 'halo' in potential.keys()
    assert 'disk' in potential.keys()
    assert str(potential) == "CompositePotential"
    assert potential.units['length'] == u.kpc
    assert potential.units['speed'] == u.km/u.s


def test_read_lm10():
    potential = load(get_pkg_data_filename('lm10.yml'))
    assert 'halo' in potential.keys()
    assert 'disk' in potential.keys()
    assert str(potential) == "LM10Potential"
    assert np.allclose(potential['disk'].parameters['a'].value, 10)
    assert np.allclose(potential['disk'].parameters['b'].value, 0.26)
    assert np.allclose(potential['disk'].parameters['m'].value, 150000.)


def test_write_isochrone(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))

    # try a simple potential
    potential = IsochronePotential(m=1E11, b=0.76, units=galactic)

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_isochrone_units(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))

    # try a simple potential with units
    potential = IsochronePotential(m=1E11*u.Msun, b=0.76*u.kpc, units=galactic)

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_lm10(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))

    # more complex
    potential = LM10Potential(disk=dict(m=5E12*u.Msun))
    potential_default = LM10Potential()
    v1 = potential.energy([4., 0, 0])
    v2 = potential_default.energy([4., 0, 0])

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)
    assert u.allclose(p['disk'].parameters['m'], 5E12*u.Msun)
    assert u.allclose(v1, p.energy([4., 0, 0]))
    assert not u.allclose(v2, p.energy([4., 0, 0]))


def test_write_composite(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))
    print(tmp_filename)

    # composite potential
    potential = CompositePotential(halo=KeplerPotential(m=1E11, units=galactic),
                                   bulge=IsochronePotential(m=1E11, b=0.76, units=galactic))
    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_ccomposite(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))

    # composite potential
    potential = CCompositePotential(halo=KeplerPotential(m=1E11, units=galactic),
                                    bulge=IsochronePotential(m=1E11, b=0.76, units=galactic))
    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_units(tmpdir):
    import astropy.units as u

    tmp_filename = str(tmpdir.join("potential.yml"))

    # try a simple potential
    potential = KeplerPotential(m=1E11, units=[u.kpc, u.Gyr, u.Msun, u.radian])
    save(potential, tmp_filename)
    p = load(tmp_filename)


@pytest.mark.skipif(not GSL_ENABLED,
                    reason="requires GSL to run this test")
def test_read_write_SCF(tmpdir):
    tmp_filename = str(tmpdir.join("potential.yml"))

    # try a basic SCF potential
    potential = SCFPotential(100, 1, np.zeros((4, 3, 2)), np.zeros((4, 3, 2)))
    save(potential, tmp_filename)
    p = load(tmp_filename)
</file>

<file path="gala/potential/potential/tests/test_special.py">
"""
    Test the special potentials...
"""

# Third-party
import astropy.units as u
import pytest

from ...._cconfig import GSL_ENABLED
from ..builtin.special import (
    BovyMWPotential2014,
    LM10Potential,
    MilkyWayPotential,
    MilkyWayPotential2022,
)

# This project
from .helpers import CompositePotentialTestBase


class TestLM10Potential(CompositePotentialTestBase):
    potential = LM10Potential()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestLM10Potential2(CompositePotentialTestBase):
    potential = LM10Potential(disk={"m": 5e10 * u.Msun}, bulge={"m": 5e10 * u.Msun})
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestMilkyWayPotential(CompositePotentialTestBase):
    potential = MilkyWayPotential()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestMilkyWayPotential2022(CompositePotentialTestBase):
    potential = MilkyWayPotential2022()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


@pytest.mark.skipif(not GSL_ENABLED, reason="requires GSL to run this test")
class TestBovyMWPotential2014(CompositePotentialTestBase):
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]
    check_finite_at_origin = False

    def setup_method(self):
        self.potential = BovyMWPotential2014()
        super().setup_method()

    check_finite_at_origin = False
</file>

<file path="gala/potential/potential/tests/test_util.py">
import pytest

# This project
from ..util import from_equation
from .helpers import PotentialTestBase
from gala.tests.optional_deps import HAS_SYMPY


class EquationBase(PotentialTestBase):
    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass

    def test_pickle(self):
        # Skip for now because these are not picklable
        pass

    def test_save_load(self):
        # Skip for now because these can't be written to YAML
        pass


if HAS_SYMPY:
    class TestHarmonicOscillatorFromEquation(EquationBase):
        check_finite_at_origin = False

        Potential = from_equation("1/2*k*x**2", vars="x", pars="k",
                                  name='HarmonicOscillator',
                                  hessian=True)
        potential = Potential(k=1.)
        w0 = [1., 0.]

        def test_derp(self):
            import numpy as np
            self.potential.gradient(np.random.random(size=(1, 13)))

        @pytest.mark.skip(reason="to_sympy() not implemented")
        def test_against_sympy(self):
            pass


# class TestHarmonicOscillatorFromEquationUnits(EquationBase):
#     Potential = from_equation("1/2*k*x**2", vars="x", pars="k",
#                               name='HarmonicOscillator',
#                               hessian=True)
#     potential = Potential(k=1., units=solarsystem)
#     w0 = [1., 0.]

# class TestKeplerFromEquation(EquationBase):
#     Potential = from_equation("-G*M/sqrt(x**2+y**2+z**2)", vars=["x","y","z"],
#                               pars=["G","M"], name='Kepler',
#                               hessian=True)
#     potential = Potential(G=1., M=1., units=solarsystem)
#     w0 = [1., 0., 0., 0., 6.28, 0.]
</file>

<file path="gala/potential/potential/__init__.py">
from .core import *
from .cpotential import *
from .ccompositepotential import *
from .builtin import *
from .io import *
from .util import *


def __getattr__(name):
    # Needed for MultipolePotential save/load
    from . import builtin

    if name in globals():
        return globals()[name]

    elif name.startswith('MultipolePotentialLmax'):
        return getattr(builtin.core, name)

    elif name.startswith('SCF'):
        from .. import scf
        return getattr(scf, name)

    else:
        raise AttributeError("huh")
</file>

<file path="gala/potential/potential/ccompositepotential.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

# Third-party
import numpy as np
cimport numpy as np
np.import_array()
import cython
cimport cython

from libc.stdio cimport printf

# Project
from .core import CompositePotential
from .cpotential import CPotentialBase
from .cpotential cimport CPotentialWrapper, CPotential

__all__ = ['CCompositePotential']

cdef class CCompositePotentialWrapper(CPotentialWrapper):

    def __init__(self, list potentials):
        cdef:
            CPotential cp
            CPotential tmp_cp
            int i
            CPotentialWrapper[::1] _cpotential_arr

        self._potentials = potentials
        _cpotential_arr = np.array(potentials)

        n_components = len(potentials)
        self._n_params = np.zeros(n_components, dtype=np.int32)
        for i in range(n_components):
            self._n_params[i] = _cpotential_arr[i]._n_params[0]

        cp.n_components = n_components
        cp.n_params = &(self._n_params[0])
        cp.n_dim = 0

        for i in range(n_components):
            tmp_cp = _cpotential_arr[i].cpotential
            cp.parameters[i] = &(_cpotential_arr[i]._params[0])
            cp.q0[i] = &(_cpotential_arr[i]._q0[0])
            cp.R[i] = &(_cpotential_arr[i]._R[0])
            cp.value[i] = tmp_cp.value[0]
            cp.density[i] = tmp_cp.density[0]
            cp.gradient[i] = tmp_cp.gradient[0]
            cp.hessian[i] = tmp_cp.hessian[0]

            if cp.n_dim == 0:
                cp.n_dim = tmp_cp.n_dim
            elif cp.n_dim != tmp_cp.n_dim:
                raise ValueError("Input potentials must have same number of coordinate dimensions")

        self.cpotential = cp

    def __reduce__(self):
        return (self.__class__, (list(self._potentials),))


class CCompositePotential(CompositePotential, CPotentialBase):

    def __init__(self, **potentials):
        CompositePotential.__init__(self, **potentials)

    def _reset_c_instance(self):
        self._potential_list = []
        for p in self.values():
            self._potential_list.append(p.c_instance)
        self.G = p.G
        self.c_instance = CCompositePotentialWrapper(self._potential_list)

    def __setitem__(self, *args, **kwargs):
        CompositePotential.__setitem__(self, *args, **kwargs)
        self._reset_c_instance()

    def __setstate__(self, state):
        # when rebuilding from a pickle, temporarily release lock
        self.lock = False
        self._units = None
        for name, potential in state:
            self[name] = potential
        self._reset_c_instance()
        self.lock = True

    def __reduce__(self):
        """ Properly package the object for pickling """
        return self.__class__, (), list(self.items())
</file>

<file path="gala/potential/potential/core.py">
# Standard library
import abc
import copy as pycopy
import uuid
import warnings
from collections import OrderedDict

import astropy.units as u

# Third-party
import numpy as np
from astropy.constants import G
from astropy.utils import isiterable
from astropy.utils.decorators import deprecated

try:
    from scipy.spatial.transform import Rotation
except ImportError as exc:
    raise ImportError(
        "Gala requires scipy>=1.2: make sure you have updated your version of "
        "scipy and try importing gala again."
    ) from exc

# Project
from gala.util import GalaDeprecationWarning

from ...units import DimensionlessUnitSystem
from ...util import ImmutableDict, atleast_2d
from ..common import CommonBase

__all__ = ["PotentialBase", "CompositePotential"]


class PotentialBase(CommonBase, metaclass=abc.ABCMeta):
    """
    A baseclass for defining pure-Python gravitational potentials.

    Subclasses must define (at minimum) a method that evaluates the potential
    energy at a given position ``q`` and time ``t``: ``_energy(q, t)``. For
    integration, the subclasses must also define a method to evaluate the
    gradient, ``_gradient(q, t)``. Optionally, they may also define methods to
    compute the density and hessian: ``_density()``, ``_hessian()``.
    """

    ndim = 3

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        if self._GSL_only:
            from gala._cconfig import GSL_ENABLED

            if not GSL_ENABLED:
                raise ValueError(
                    "Gala was compiled without GSL and so this potential -- "
                    f"{str(self.__class__)} -- will not work.  See the gala "
                    "documentation for more information about installing and "
                    "using GSL with gala: "
                    "http://gala.adrian.pw/en/latest/install.html"
                )

        parameter_values = self._parse_parameter_values(*args, **kwargs)
        self._setup_potential(
            parameters=parameter_values, origin=origin, R=R, units=units
        )

    def _setup_potential(self, parameters, origin=None, R=None, units=None):
        self._units = self._validate_units(units)
        self.parameters = self._prepare_parameters(parameters, self.units)

        try:
            self.G = G.decompose(self.units).value
        except u.UnitConversionError:
            # TODO: this is a convention that and could lead to confusion!
            self.G = 1.0

        if origin is None:
            origin = np.zeros(self.ndim)
        self.origin = self._remove_units(origin)

        if R is not None and self.ndim not in [2, 3]:
            raise NotImplementedError(
                "Gala potentials currently only support "
                "rotations when ndim=2 or ndim=3."
            )

        if R is not None:
            if isinstance(R, Rotation):
                R = R.as_matrix()
            R = np.array(R)

            if R.shape != (self.ndim, self.ndim):
                raise ValueError(
                    "Rotation matrix passed to potential {0} has "
                    "an invalid shape: expected {1}, got {2}".format(
                        self.__class__.__name__, (self.ndim, self.ndim), R.shape
                    )
                )
        self.R = R

    def replicate(self, **kwargs):
        """
        Return a copy of the potential instance with some parameter values
        changed. This always produces copies of any parameter arrays.

        Parameters
        ----------
        **kwargs
            All other keyword arguments are used to overwrite parameter values
            when making the copy.

        Returns
        -------
        replicant : `~gala.potential.PotentialBase` subclass instance
            The replicated potential.
        """
        for k, v in self.parameters.items():
            kwargs.setdefault(k, pycopy.copy(v))

        for k in ["units", "origin", "R"]:
            v = getattr(self, k)
            kwargs.setdefault(k, pycopy.copy(v))

        return self.__class__(**kwargs)

    @classmethod
    def to_sympy(cls):
        """Return a representation of this potential class as a sympy expression

        Returns
        -------
        expr : sympy expression
        vars : dict
            A dictionary of sympy symbols used in the expression.
        """
        raise NotImplementedError(
            "to_sympy() is not implemented for this " f"class {cls}"
        )

    @classmethod
    def to_latex(cls):
        """Return a string LaTeX representation of this potential

        Returns
        -------
        latex_str : str
            The latex expression as a Python string.
        """
        try:
            expr, *_ = cls.to_sympy()
        except NotImplementedError:
            raise NotImplementedError(
                ".to_latex() requires having a .to_sympy() method implemented "
                "on the requesting potential class"
            )

        # testing for this import happens in the sympy method
        import sympy as sy

        return sy.latex(expr)

    ###########################################################################
    # Abstract methods that must be implemented by subclasses
    #
    @abc.abstractmethod
    def _energy(self, q, t=0.0):
        pass

    @abc.abstractmethod
    def _gradient(self, q, t=0.0):
        pass

    def _density(self, q, t=0.0):
        raise NotImplementedError(
            "This Potential has no implemented density " "function."
        )

    def _hessian(self, q, t=0.0):
        raise NotImplementedError("This Potential has no implemented Hessian.")

    ###########################################################################
    # Utility methods
    #
    def _remove_units(self, x):
        """
        Always returns an array. If a Quantity is passed in, it converts to the
        units associated with this object and returns the value.
        """
        if hasattr(x, "unit"):
            x = x.decompose(self.units).value

        else:
            x = np.array(x)

        return x

    def _remove_units_prepare_shape(self, x):
        """
        This is similar to that implemented by
        `gala.potential.common.CommonBase`, but returns just the position if the
        input is a `PhaseSpacePosition`.
        """
        from gala.dynamics import PhaseSpacePosition

        if hasattr(x, "unit"):
            x = x.decompose(self.units).value

        elif isinstance(x, PhaseSpacePosition):
            x = x.cartesian.xyz.decompose(self.units).value

        x = atleast_2d(x, insert_axis=1).astype(np.float64)

        if x.shape[0] != self.ndim:
            raise ValueError(
                f"Input position has ndim={x.shape[0]}, but this potential "
                f"expects an {self.ndim}-dimensional position."
            )

        return x

    ###########################################################################
    # Core methods that use the above implemented functions
    #
    def energy(self, q, t=0.0):
        """
        Compute the potential energy at the given position(s).

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            The position to compute the value of the potential. If the
            input position object has no units (i.e. is an `~numpy.ndarray`),
            it is assumed to be in the same unit system as the potential.

        Returns
        -------
        E : `~astropy.units.Quantity`
            The potential energy per unit mass or value of the potential.
        """
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)
        ret_unit = self.units["energy"] / self.units["mass"]

        return self._energy(q, t=t).T.reshape(orig_shape[1:]) * ret_unit

    def gradient(self, q, t=0.0):
        """
        Compute the gradient of the potential at the given position(s).

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            The position to compute the value of the potential. If the
            input position object has no units (i.e. is an `~numpy.ndarray`),
            it is assumed to be in the same unit system as the potential.

        Returns
        -------
        grad : `~astropy.units.Quantity`
            The gradient of the potential. Will have the same shape as
            the input position.
        """
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)
        ret_unit = self.units["length"] / self.units["time"] ** 2
        uu = self.units["acceleration"]
        return (self._gradient(q, t=t).T.reshape(orig_shape) * ret_unit).to(uu)

    def density(self, q, t=0.0):
        """
        Compute the density value at the given position(s).

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            The position to compute the value of the potential. If the
            input position object has no units (i.e. is an `~numpy.ndarray`),
            it is assumed to be in the same unit system as the potential.

        Returns
        -------
        dens : `~astropy.units.Quantity`
            The potential energy or value of the potential. If the input
            position has shape ``q.shape``, the output energy will have
            shape ``q.shape[1:]``.
        """
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)
        ret_unit = self.units["mass"] / self.units["length"] ** 3
        return (self._density(q, t=t).T * ret_unit).to(self.units["mass density"])

    def hessian(self, q, t=0.0):
        """
        Compute the Hessian of the potential at the given position(s).

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            The position to compute the value of the potential. If the
            input position object has no units (i.e. is an `~numpy.ndarray`),
            it is assumed to be in the same unit system as the potential.

        Returns
        -------
        hess : `~astropy.units.Quantity`
            The Hessian matrix of second derivatives of the potential. If the
            input position has shape ``q.shape``, the output energy will have
            shape ``(q.shape[0],q.shape[0]) + q.shape[1:]``. That is, an
            ``n_dim`` by ``n_dim`` array (matrix) for each position.
        """
        if self.R is not None and not np.allclose(
            np.diag(self.R), 1.0, atol=1e-15, rtol=0
        ):
            raise NotImplementedError(
                "Computing Hessian matrices for rotated "
                "potentials is currently not supported."
            )
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)
        ret_unit = 1 / self.units["time"] ** 2
        hess = np.moveaxis(self._hessian(q, t=t), 0, -1)
        return hess.reshape((orig_shape[0], orig_shape[0]) + orig_shape[1:]) * ret_unit

    ###########################################################################
    # Convenience methods that make use the base methods
    #
    def acceleration(self, q, t=0.0):
        """
        Compute the acceleration due to the potential at the given position(s).

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            Position to compute the acceleration at.

        Returns
        -------
        acc : `~astropy.units.Quantity`
            The acceleration. Will have the same shape as the input
            position array, ``q``.
        """
        return -self.gradient(q, t=t)

    def mass_enclosed(self, q, t=0.0):
        """
        Estimate the mass enclosed within the given position by assuming the potential
        is spherical.

        Parameters
        ----------
        q : `~gala.dynamics.PhaseSpacePosition`, `~astropy.units.Quantity`, array_like
            Position(s) to estimate the enclossed mass.

        Returns
        -------
        menc : `~astropy.units.Quantity`
            Mass enclosed at the given position(s). If the input position
            has shape ``q.shape``, the output energy will have shape
            ``q.shape[1:]``.
        """
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)

        # small step-size in direction of q
        h = 1e-3  # MAGIC NUMBER

        # Radius
        r = np.sqrt(np.sum(q**2, axis=1))

        epsilon = h * q / r[:, np.newaxis]

        dPhi_dr_plus = self._energy(q + epsilon, t=t)
        dPhi_dr_minus = self._energy(q - epsilon, t=t)
        diff = dPhi_dr_plus - dPhi_dr_minus

        if isinstance(self.units, DimensionlessUnitSystem):
            Gee = 1.0
        else:
            Gee = G.decompose(self.units).value

        Menc = np.abs(r * r * diff / Gee / (2.0 * h))
        Menc = Menc.reshape(orig_shape[1:])

        sgn = 1.0
        if "m" in self.parameters and self.parameters["m"] < 0:
            sgn = -1.0

        return sgn * Menc * self.units["mass"]

    def circular_velocity(self, q, t=0.0):
        """
        Estimate the circular velocity at the given position assuming the
        potential is spherical.

        Parameters
        ----------
        q : array_like, numeric
            Position(s) to estimate the circular velocity.

        Returns
        -------
        vcirc : `~astropy.units.Quantity`
            Circular velocity at the given position(s). If the input position
            has shape ``q.shape``, the output energy will have shape
            ``q.shape[1:]``.

        """
        q = self._remove_units_prepare_shape(q)

        # Radius
        r = np.sqrt(np.sum(q**2, axis=0)) * self.units["length"]
        dPhi_dxyz = self.gradient(q, t=t)
        dPhi_dr = np.sum(dPhi_dxyz * q / r.value, axis=0)

        return self.units.decompose(np.sqrt(r * np.abs(dPhi_dr)))

    ###########################################################################
    # Python special methods
    #
    def __call__(self, q):
        return self.energy(q)

    def __add__(self, other):
        if not isinstance(other, PotentialBase):
            raise TypeError(
                f"Cannot add a {self.__class__.__name__} to a "
                f"{other.__class__.__name__}"
            )

        new_pot = CompositePotential()

        if isinstance(self, CompositePotential):
            for k, v in self.items():
                new_pot[k] = v

        else:
            k = str(uuid.uuid4())
            new_pot[k] = self

        if isinstance(other, CompositePotential):
            for k, v in self.items():
                if k in new_pot:
                    raise KeyError(
                        f'Potential component "{k}" already exists '
                        "-- duplicate key provided in potential "
                        "addition"
                    )
                new_pot[k] = v

        else:
            k = str(uuid.uuid4())
            new_pot[k] = other

        return new_pot

    ###########################################################################
    # Convenience methods that do fancy things
    #
    def plot_contours(
        self,
        grid,
        t=0.0,
        filled=True,
        ax=None,
        labels=None,
        subplots_kw=dict(),
        **kwargs,
    ):
        """
        Plot equipotentials contours. Computes the potential energy on a grid
        (specified by the array `grid`).

        .. warning:: Right now the grid input must be arrays and must already
            be in the unit system of the potential. Quantity support is coming...

        Parameters
        ----------
        grid : tuple
            Coordinate grids or slice value for each dimension. Should be a
            tuple of 1D arrays or numbers.
        t : quantity-like (optional)
            The time to evaluate at.
        filled : bool (optional)
            Use :func:`~matplotlib.pyplot.contourf` instead of
            :func:`~matplotlib.pyplot.contour`. Default is ``True``.
        ax : matplotlib.Axes (optional)
        labels : iterable (optional)
            List of axis labels.
        subplots_kw : dict
            kwargs passed to matplotlib's subplots() function if an axes object
            is not specified.
        kwargs : dict
            kwargs passed to either contourf() or plot().

        Returns
        -------
        fig : `~matplotlib.Figure`

        """

        import matplotlib.pyplot as plt
        from matplotlib import cm

        # figure out which elements are iterable, which are numeric
        _grids = []
        _slices = []
        for ii, g in enumerate(grid):
            if isiterable(g):
                _grids.append((ii, g))
            else:
                _slices.append((ii, g))

        # figure out the dimensionality
        ndim = len(_grids)

        # if ndim > 2, don't know how to handle this!
        if ndim > 2:
            raise ValueError(
                "ndim > 2: you can only make contours on a 2D grid. For other "
                "dimensions, you have to specify values to slice."
            )

        if ax is None:
            # default figsize
            fig, ax = plt.subplots(1, 1, **subplots_kw)
        else:
            fig = ax.figure

        if ndim == 1:
            # 1D curve
            x1 = _grids[0][1]
            r = np.zeros((len(_grids) + len(_slices), len(x1)))
            r[_grids[0][0]] = x1

            for ii, slc in _slices:
                r[ii] = slc

            Z = self.energy(r * self.units["length"], t=t).value
            ax.plot(x1, Z, **kwargs)

            if labels is not None:
                ax.set_xlabel(labels[0])
                ax.set_ylabel("potential")
        else:
            # 2D contours
            x1, x2 = np.meshgrid(_grids[0][1], _grids[1][1])
            shp = x1.shape
            x1, x2 = x1.ravel(), x2.ravel()

            r = np.zeros((len(_grids) + len(_slices), len(x1)))
            r[_grids[0][0]] = x1
            r[_grids[1][0]] = x2

            for ii, slc in _slices:
                r[ii] = slc

            Z = self.energy(r * self.units["length"], t=t).value

            # make default colormap not suck
            cmap = kwargs.pop("cmap", cm.Blues)
            if filled:
                ax.contourf(
                    x1.reshape(shp),
                    x2.reshape(shp),
                    Z.reshape(shp),
                    cmap=cmap,
                    **kwargs,
                )
            else:
                ax.contour(
                    x1.reshape(shp),
                    x2.reshape(shp),
                    Z.reshape(shp),
                    cmap=cmap,
                    **kwargs,
                )

            if labels is not None:
                ax.set_xlabel(labels[0])
                ax.set_ylabel(labels[1])

        return fig

    def plot_density_contours(
        self,
        grid,
        t=0.0,
        filled=True,
        ax=None,
        labels=None,
        subplots_kw=dict(),
        **kwargs,
    ):
        """
        Plot density contours. Computes the density on a grid
        (specified by the array `grid`).

        .. warning::

            For now, the grid input must be arrays and must already be in
            the unit system of the potential. Quantity support is coming...

        Parameters
        ----------
        grid : tuple
            Coordinate grids or slice value for each dimension. Should be a
            tuple of 1D arrays or numbers.
        t : quantity-like (optional)
            The time to evaluate at.
        filled : bool (optional)
            Use :func:`~matplotlib.pyplot.contourf` instead of
            :func:`~matplotlib.pyplot.contour`. Default is ``True``.
        ax : matplotlib.Axes (optional)
        labels : iterable (optional)
            List of axis labels.
        subplots_kw : dict
            kwargs passed to matplotlib's subplots() function if an axes object
            is not specified.
        kwargs : dict
            kwargs passed to either contourf() or plot().

        Returns
        -------
        fig : `~matplotlib.Figure`

        """

        import matplotlib.pyplot as plt
        from matplotlib import cm

        # figure out which elements are iterable, which are numeric
        _grids = []
        _slices = []
        for ii, g in enumerate(grid):
            if isiterable(g):
                _grids.append((ii, g))
            else:
                _slices.append((ii, g))

        # figure out the dimensionality
        ndim = len(_grids)

        # if ndim > 2, don't know how to handle this!
        if ndim > 2:
            raise ValueError(
                "ndim > 2: you can only make contours on a 2D grid. For other "
                "dimensions, you have to specify values to slice."
            )

        if ax is None:
            # default figsize
            fig, ax = plt.subplots(1, 1, **subplots_kw)
        else:
            fig = ax.figure

        if ndim == 1:
            # 1D curve
            x1 = _grids[0][1]
            r = np.zeros((len(_grids) + len(_slices), len(x1)))
            r[_grids[0][0]] = x1

            for ii, slc in _slices:
                r[ii] = slc

            Z = self.density(r * self.units["length"], t=t).value
            ax.plot(x1, Z, **kwargs)

            if labels is not None:
                ax.set_xlabel(labels[0])
                ax.set_ylabel("potential")
        else:
            # 2D contours
            x1, x2 = np.meshgrid(_grids[0][1], _grids[1][1])
            shp = x1.shape
            x1, x2 = x1.ravel(), x2.ravel()

            r = np.zeros((len(_grids) + len(_slices), len(x1)))
            r[_grids[0][0]] = x1
            r[_grids[1][0]] = x2

            for ii, slc in _slices:
                r[ii] = slc

            Z = self.density(r * self.units["length"], t=t).value

            # make default colormap not suck
            cmap = kwargs.pop("cmap", cm.Blues)
            if filled:
                ax.contourf(
                    x1.reshape(shp),
                    x2.reshape(shp),
                    Z.reshape(shp),
                    cmap=cmap,
                    **kwargs,
                )
            else:
                ax.contour(
                    x1.reshape(shp),
                    x2.reshape(shp),
                    Z.reshape(shp),
                    cmap=cmap,
                    **kwargs,
                )

            # cs.cmap.set_under('w')
            # cs.cmap.set_over('k')

            if labels is not None:
                ax.set_xlabel(labels[0])
                ax.set_ylabel(labels[1])

        return fig

    def plot_rotation_curve(self, R_grid, t=0.0, ax=None, labels=None, **plot_kwargs):
        """
        Plot the rotation curve or circular velocity curve for this potential on the
        input grid of cylindrical radii.

        Parameters
        ----------
        R_grid : array-like
            A grid of radius values to compute the rotation curve at. This should be a
            one-dimensional grid.
        t : quantity-like (optional)
            The time to evaluate at.
        ax : matplotlib.Axes (optional)
        labels : iterable (optional)
            List of axis labels. Set to False to disable adding labels.
        plot_kwargs : dict
            kwargs passed to plot().

        Returns
        -------
        fig : `~matplotlib.Figure`
        ax : `~matplotlib.Axes`

        """

        if not hasattr(R_grid, "unit"):
            R_grid = R_grid * self.units["length"]

        xyz = np.zeros((3,) + R_grid.shape) * self.units["length"]
        xyz[0] = R_grid

        vcirc = self.circular_velocity(xyz, t=t)

        if labels is None:
            labels = [
                f"$R$ [{self.units['length']:latex_inline}]",
                r"$v_{\rm circ}$ " + f"[{self.units['speed']:latex_inline}]",
            ]

        import matplotlib.pyplot as plt

        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        if labels is not False:
            ax.set_xlabel(labels[0])
            ax.set_ylabel(labels[1])

        plot_kwargs.setdefault("marker", "")
        plot_kwargs.setdefault("linestyle", plot_kwargs.pop("ls", "-"))
        plot_kwargs.setdefault("linewidth", plot_kwargs.pop("lw", 1))

        ax.plot(
            R_grid.to_value(self.units["length"]),
            vcirc.to_value(self.units["speed"]),
            **plot_kwargs,
        )

        return fig, ax

    def integrate_orbit(self, *args, **kwargs):
        """
        Integrate an orbit in the current potential using the integrator class
        provided. Uses same time specification as `Integrator()` -- see
        the documentation for `gala.integrate` for more information.

        Parameters
        ----------
        w0 : `~gala.dynamics.PhaseSpacePosition`, array_like
            Initial conditions.
        Integrator : `~gala.integrate.Integrator` (optional)
            Integrator class to use.
        Integrator_kwargs : dict (optional)
            Any extra keyword argumets to pass to the integrator class
            when initializing. Only works in non-Cython mode.
        cython_if_possible : bool (optional)
            If there is a Cython version of the integrator implemented,
            and the potential object has a C instance, using Cython
            will be *much* faster.
        store_all : bool (optional)
            Controls whether to store the phase-space position at all intermediate
            timesteps. Set to False to store only the final values (i.e. the
            phase-space position(s) at the final timestep). Default is True.
        **time_spec
            Specification of how long to integrate. See documentation
            for `~gala.integrate.parse_time_specification`.

        Returns
        -------
        orbit : `~gala.dynamics.Orbit`

        """
        from ..hamiltonian import Hamiltonian

        return Hamiltonian(self).integrate_orbit(*args, **kwargs)

    def total_energy(self, x, v):
        """
        Compute the total energy (per unit mass) of a point in phase-space
        in this potential. Assumes the last axis of the input position /
        velocity is the dimension axis, e.g., for 100 points in 3-space,
        the arrays should have shape (100, 3).

        Parameters
        ----------
        x : array_like, numeric
            Position.
        v : array_like, numeric
            Velocity.
        """
        warnings.warn(
            "Use the energy methods on Orbit objects instead. In a future "
            "release this will be removed.",
            GalaDeprecationWarning,
        )

        v = atleast_2d(v, insert_axis=1)
        return self.energy(x) + 0.5 * np.sum(v**2, axis=0)

    def save(self, f):
        """
        Save the potential to a text file. See :func:`~gala.potential.save`
        for more information.

        Parameters
        ----------
        f : str, file_like
            A filename or file-like object to write the input potential object to.

        """
        from .io import save

        save(self, f)

    @property
    def units(self):
        return self._units

    def replace_units(self, units, copy=True):
        """Change the unit system of this potential.

        Parameters
        ----------
        units : `~gala.units.UnitSystem`
            Set of non-reducable units that specify (at minimum) the
            length, mass, time, and angle units.
        copy : bool (optional)
            If True, returns a copy, if False, changes this object.
        """
        if copy:
            pot = pycopy.deepcopy(self)
        else:
            pot = self

        # TODO: this is repeated code - see equivalent in cpotential.pyx
        tmp = [
            isinstance(units, DimensionlessUnitSystem),
            isinstance(self.units, DimensionlessUnitSystem),
        ]
        if not all(tmp) and any(tmp):
            raise ValueError(
                "Cannot replace a dimensionless unit system with "
                "a unit system with physical units, or vice versa"
            )

        PotentialBase.__init__(
            pot, origin=self.origin, R=self.R, units=units, **self.parameters
        )

        return pot

    ###########################################################################
    # Deprecated methods
    #
    def _value(self, q, t=0.0):
        warnings.warn("Use `_energy()` instead.", GalaDeprecationWarning)
        return self._energy(q, t=t)

    def value(self, *args, **kwargs):
        __doc__ = self.energy.__doc__  # noqa
        warnings.warn("Use `energy()` instead.", GalaDeprecationWarning)
        return self.energy(*args, **kwargs)

    ###########################################################################
    # Interoperability with other packages
    #
    @deprecated(
        since="v1.8",
        message="This has been replaced by a more general interoperability framework.",
        alternative="interop",
    )
    def to_galpy_potential(self, ro=None, vo=None):
        """Convert a Gala potential to a Galpy potential instance

        Parameters
        ----------
        ro : quantity-like (optional)
        vo : quantity-like (optional)
        """
        return self.as_interop("galpy", ro=ro, vo=vo)

    def as_interop(self, package, **kwargs):
        """Interoperability with other Galactic dynamics packages

        Parameters
        ----------
        package : str
            The package to export the potential to. Currently supported packages are
            ``"galpy"`` and ``"agama"``.
        kwargs
            Any additional keyword arguments are passed to the interop function.
        """
        if package == "galpy":
            from .interop import gala_to_galpy_potential

            kwargs.setdefault("ro", None)
            kwargs.setdefault("vo", None)
            return gala_to_galpy_potential(self, **kwargs)
        elif package == "agama":
            import agama

            from .interop import gala_to_agama_potential

            agama_pot = gala_to_agama_potential(self, **kwargs)
            if not isinstance(agama_pot, agama.Potential):
                agama_pot = agama.Potential(*agama_pot)
            return agama_pot
        else:
            raise ValueError(f"Unsupported package: {package}")


class CompositePotential(PotentialBase, OrderedDict):
    """
    A potential composed of several distinct components. For example,
    two point masses or a galactic disk and halo, each with their own
    potential model.

    A `CompositePotential` is created like a Python dictionary, e.g.::

        >>> p1 = SomePotential(func1) # doctest: +SKIP
        >>> p2 = SomePotential(func2) # doctest: +SKIP
        >>> cp = CompositePotential(component1=p1, component2=p2) # doctest: +SKIP

    This object actually acts like a dictionary, so if you want to
    preserve the order of the potential components, use::

        >>> cp = CompositePotential() # doctest: +SKIP
        >>> cp['component1'] = p1 # doctest: +SKIP
        >>> cp['component2'] = p2 # doctest: +SKIP

    You can also use any of the built-in `Potential` classes as
    components::

        >>> from gala.potential import HernquistPotential
        >>> cp = CompositePotential()
        >>> cp['spheroid'] = HernquistPotential(m=1E11, c=10.,
        ...                                     units=(u.kpc, u.Myr, u.Msun, u.radian))

    """

    def __init__(self, *args, **kwargs):
        self._units = None
        self.ndim = None

        if len(args) > 0 and isinstance(args[0], list):
            for k, v in args[0]:
                kwargs[k] = v
        else:
            for i, v in args:
                kwargs[str(i)] = v

        self.lock = False
        for v in kwargs.values():
            self._check_component(v)

        OrderedDict.__init__(self, **kwargs)

        self.R = None  # TODO: this is a little messy

    def __setitem__(self, key, value):
        self._check_component(value)
        super(CompositePotential, self).__setitem__(key, value)

    def _check_component(self, p):
        if not isinstance(p, PotentialBase):
            raise TypeError(
                "Potential components may only be Potential "
                "objects, not {0}.".format(type(p))
            )

        if self.units is None:
            self._units = p.units
            self.ndim = p.ndim

        else:
            if sorted([str(x) for x in self.units]) != sorted(
                [str(x) for x in p.units]
            ):
                raise ValueError(
                    "Unit system of new potential component must "
                    "match unit systems of other potential "
                    "components."
                )

            if p.ndim != self.ndim:
                raise ValueError(
                    "All potential components must have the same "
                    "number of phase-space dimensions ({} in this "
                    "case)".format(self.ndim)
                )

        if self.lock:
            raise ValueError(
                "Potential object is locked - new components can "
                "only be added to unlocked potentials."
            )

    @property
    def parameters(self):
        params = dict()
        for k, v in self.items():
            params[k] = v.parameters
        return ImmutableDict(**params)

    def replace_units(self, units):
        """Change the unit system of this potential.

        Parameters
        ----------
        units : `~gala.units.UnitSystem`
            Set of non-reducable units that specify (at minimum) the
            length, mass, time, and angle units.
        """
        _lock = self.lock
        pots = self.__class__()

        pots._units = None
        pots.lock = False

        for k, v in self.items():
            pots[k] = v.replace_units(units)

        pots.lock = _lock
        return pots

    def _energy(self, q, t=0.0):
        return np.sum([p._energy(q, t) for p in self.values()], axis=0)

    def _gradient(self, q, t=0.0):
        return np.sum([p._gradient(q, t) for p in self.values()], axis=0)

    def _hessian(self, w, t=0.0):
        return np.sum([p._hessian(w, t) for p in self.values()], axis=0)

    def _density(self, q, t=0.0):
        return np.sum([p._density(q, t) for p in self.values()], axis=0)

    def __repr__(self):
        return "<CompositePotential {}>".format(",".join(self.keys()))

    def replicate(self, **kwargs):
        """
        Return a copy of the potential instance with some parameter values
        changed. This always produces copies of any parameter arrays.

        Parameters
        ----------
        **kwargs
            All other keyword arguments are used to overwrite parameter values
            when making the copy. The keywords passed in should be the same as
            the potential component names, so you can pass in dictionaries to set
            parameters for different subcomponents of this composite potential.

        Returns
        -------
        replicant : `~gala.potential.PotentialBase` subclass instance
            The replicated potential.
        """
        obj = pycopy.copy(self)

        # disable potential lock
        lock = obj.lock
        obj.lock = False

        for k, v in kwargs.items():
            obj[k] = self[k].replicate(**v)

        obj.lock = lock
        return obj


_potential_docstring = """units : `~gala.units.UnitSystem` (optional)
        Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
    origin : `~astropy.units.Quantity` (optional)
        The origin of the potential, the default being 0.
    R : `~scipy.spatial.transform.Rotation`, array_like (optional)
        A Scipy ``Rotation`` object or an array representing a rotation matrix
        that specifies a rotation of the potential. This is applied *after* the
        origin shift. Default is the identity matrix.
"""
</file>

<file path="gala/potential/potential/cpotential.pxd">
# cython: language_level=3

# cdef extern from "potential/src/cpotential.h":
#     ctypedef struct CPotential:
#         pass

cdef extern from "src/funcdefs.h":
    ctypedef double (*densityfunc)(double t, double *pars, double *q) nogil
    ctypedef double (*energyfunc)(double t, double *pars, double *q) nogil
    ctypedef void (*gradientfunc)(double t, double *pars, double *q, double *grad) nogil
    ctypedef void (*hessianfunc)(double t, double *pars, double *q, double *hess) nogil

cdef extern from "potential/src/cpotential.h":
    const int MAX_N_COMPONENTS

    ctypedef struct CPotential:
        int n_components
        int n_dim
        int null
        densityfunc density[MAX_N_COMPONENTS]
        energyfunc value[MAX_N_COMPONENTS]
        gradientfunc gradient[MAX_N_COMPONENTS]
        hessianfunc hessian[MAX_N_COMPONENTS]
        int n_params[MAX_N_COMPONENTS]
        double *parameters[MAX_N_COMPONENTS]
        double *q0[MAX_N_COMPONENTS]
        double *R[MAX_N_COMPONENTS]

    double c_potential(CPotential *p, double t, double *q) nogil
    double c_density(CPotential *p, double t, double *q) nogil
    void c_gradient(CPotential *p, double t, double *q, double *grad) nogil
    void c_hessian(CPotential *p, double t, double *q, double *hess) nogil

    double c_d_dr(CPotential *p, double t, double *q, double *epsilon) nogil
    double c_d2_dr2(CPotential *p, double t, double *q, double *epsilon) nogil
    double c_mass_enclosed(CPotential *p, double t, double *q, double G, double *epsilon) nogil

cpdef _validate_pos_arr(double[:,::1] arr)

cdef class CPotentialWrapper:
    cdef CPotential cpotential
    cdef double[::1] _params
    cdef int[::1] _n_params
    cdef list _potentials # HACK: for CCompositePotentialWrapper
    cdef double[::1] _q0
    cdef double[::1] _R

    cpdef init(self, list parameters, double[::1] q0, double[:, ::1] R,
               int n_dim=?)

    cpdef energy(self, double[:,::1] q, double[::1] t)
    cpdef density(self, double[:,::1] q, double[::1] t)
    cpdef gradient(self, double[:,::1] q, double[::1] t)
    cpdef hessian(self, double[:,::1] q, double[::1] t)

    cpdef d_dr(self, double[:,::1] q, double G, double[::1] t)
    cpdef d2_dr2(self, double[:,::1] q, double G, double[::1] t)
    cpdef mass_enclosed(self, double[:,::1] q, double G, double[::1] t)
</file>

<file path="gala/potential/potential/cpotential.pyx">
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

# Standard library
import copy as pycopy
import sys
import warnings
import uuid

# Third-party
import numpy as np
cimport numpy as np
np.import_array()
import cython
cimport cython

from libc.stdio cimport printf

# Project
from .core import PotentialBase, CompositePotential
from ...util import atleast_2d
from ...units import DimensionlessUnitSystem

cdef extern from "math.h":
    double sqrt(double x) nogil
    double fabs(double x) nogil

__all__ = ['CPotentialBase']

cdef extern from "potential/builtin/builtin_potentials.h":
    double nan_density(double t, double *pars, double *q, int n_dim) nogil
    double nan_value(double t, double *pars, double *q, int n_dim) nogil
    void nan_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil
    void nan_hessian(double t, double *pars, double *q, int n_dim, double *hess) nogil

cpdef _validate_pos_arr(double[:, ::1] arr):
    if arr.ndim != 2:
        raise ValueError("Phase-space coordinate array must have 2 dimensions")
    return arr.shape[0], arr.shape[1]

cdef class CPotentialWrapper:
    """
    Wrapper class for C implementation of potentials. At the C layer, potentials
    are effectively struct's that maintain pointers to functions specific to a
    given potential. This provides a Cython wrapper around this C implementation.
    """

    cpdef init(self, list parameters, double[::1] q0, double[:, ::1] R,
               int n_dim=3):

        # save the array of parameters so it doesn't get garbage-collected
        self._params = np.array(parameters, dtype=np.float64)

        # an array of number of parameter counts for composite potentials
        self._n_params = np.array([len(self._params)], dtype=np.int32)

        # store pointers to the above arrays
        self.cpotential.n_params = &(self._n_params[0])
        self.cpotential.parameters[0] = &(self._params[0])

        # phase-space half-dimensionality of the potential
        self.cpotential.n_dim = n_dim

        # number of components in the potential. for a simple potential, this is
        #   always one - composite potentials override this.
        self.cpotential.n_components = 1

        # by default, don't skip this potential!
        self.cpotential.null = 0

        # set the function pointers to nan defaults
        self.cpotential.value[0] = <energyfunc>(nan_value)
        self.cpotential.density[0] = <densityfunc>(nan_density)
        self.cpotential.gradient[0] = <gradientfunc>(nan_gradient)
        self.cpotential.hessian[0] = <hessianfunc>(nan_hessian)

        # set the origin of the potentials
        self._q0 = np.array(q0)
        assert len(self._q0) == n_dim
        self.cpotential.q0[0] = &(self._q0[0])

        # set the rotation matrix of the potentials
        self._R = np.ascontiguousarray(np.array(R).ravel())
        self.cpotential.R[0] = &(self._R[0])

    cpdef energy(self, double[:, ::1] q, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double [::1] pot = np.zeros(n)

        if len(t) == 1:
            for i in range(n):
                pot[i] = c_potential(&(self.cpotential), t[0], &q[i, 0])
        else:
            for i in range(n):
                pot[i] = c_potential(&(self.cpotential), t[i], &q[i, 0])

        return np.array(pot)

    cpdef density(self, double[:, ::1] q, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double [::1] dens = np.zeros(n)

        if len(t) == 1:
            for i in range(n):
                dens[i] = c_density(&(self.cpotential), t[0], &q[i, 0])
        else:
            for i in range(n):
                dens[i] = c_density(&(self.cpotential), t[i], &q[i, 0])

        return np.array(dens)

    cpdef gradient(self, double[:, ::1] q, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double[:, ::1] grad = np.zeros((n, ndim))

        if len(t) == 1:
            for i in range(n):
                c_gradient(&(self.cpotential), t[0], &q[i, 0], &grad[i, 0])
        else:
            for i in range(n):
                c_gradient(&(self.cpotential), t[i], &q[i, 0], &grad[i, 0])

        return np.array(grad)

    cpdef hessian(self, double[:, ::1] q, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double[:, :, ::1] hess = np.zeros((n, ndim, ndim))

        if len(t) == 1:
            for i in range(n):
                c_hessian(&(self.cpotential), t[0], &q[i, 0], &hess[i, 0, 0])
        else:
            for i in range(n):
                c_hessian(&(self.cpotential), t[i], &q[i, 0], &hess[i, 0, 0])

        return np.array(hess)

    # ------------------------------------------------------------------------
    # Other functionality
    #
    cpdef d_dr(self, double[:, ::1] q, double G, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double [::1] dr = np.zeros(n, dtype=np.float64)
        cdef double [::1] epsilon = np.zeros(ndim, dtype=np.float64)

        if len(t) == 1:
            for i in range(n):
                dr[i] = c_d_dr(&(self.cpotential), t[0], &q[i, 0], &epsilon[0])
        else:
            for i in range(n):
                dr[i] = c_d_dr(&(self.cpotential), t[i], &q[i, 0], &epsilon[0])

        return np.array(dr)

    cpdef d2_dr2(self, double[:, ::1] q, double G, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double [::1] dr2 = np.zeros(n, dtype=np.float64)
        cdef double [::1] epsilon = np.zeros(ndim, dtype=np.float64)

        if len(t) == 1:
            for i in range(n):
                dr2[i] = c_d2_dr2(&(self.cpotential), t[0], &q[i, 0], &epsilon[0])
        else:
            for i in range(n):
                dr2[i] = c_d2_dr2(&(self.cpotential), t[i], &q[i, 0], &epsilon[0])

        return np.array(dr2)

    cpdef mass_enclosed(self, double[:, ::1] q, double G, double[::1] t):
        """
        CAUTION: Interpretation of axes is different here! We need the
        arrays to be C ordered and easy to iterate over, so here the
        axes are (norbits, ndim).
        """
        cdef int n, ndim, i
        n, ndim = _validate_pos_arr(q)

        cdef double [::1] mass = np.zeros(n, dtype=np.float64)
        cdef double [::1] epsilon = np.zeros(ndim, dtype=np.float64)

        if len(t) == 1:
            for i in range(n):
                mass[i] = c_mass_enclosed(&(self.cpotential), t[0], &q[i, 0], G, &epsilon[0])
        else:
            for i in range(n):
                mass[i] = c_mass_enclosed(&(self.cpotential), t[i], &q[i, 0], G, &epsilon[0])

        return np.array(mass)

    # For pickling in Python 2
    def __reduce__(self):
        return (self.__class__,
                (self._params[0], list(self._params[1:]),
                 np.array(self._q0),
                 np.array(self._R).reshape(self.cpotential.n_dim,
                                           self.cpotential.n_dim)))

# ----------------------------------------------------------------------------

# TODO: docstrings are now fucked for energy, gradient, etc.

class CPotentialBase(PotentialBase):
    """
    A baseclass for defining gravitational potentials implemented in C.
    """
    Wrapper = None

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        super().__init__(*args,
                         units=units,
                         origin=origin,
                         R=R,
                         **kwargs)
        self._setup_wrapper()

    def _setup_wrapper(self, c_only_parameters=None):
        if self.Wrapper is None:
            raise ValueError("C potential wrapper class not defined for "
                             f"potential class {self.__class__}")

        if c_only_parameters is None:
            c_only_parameters = {}

        arrs = []
        for k, v in c_only_parameters.items():
            arrs.append(np.atleast_1d(v).ravel())

        # to support array parameters, but they get unraveled
        arrs = arrs + [np.atleast_1d(v.value).ravel()
                       for v in self.parameters.values()]

        if len(arrs) > 0:
            self.c_parameters = np.concatenate(arrs)
        else:
            self.c_parameters = np.array([])

        if self.R is None:
            self._R = np.eye(self.ndim)
        else:
            self._R = self.R
        self.c_instance = self.Wrapper(self.G, self.c_parameters,
                                       q0=self.origin, R=self._R)

    def _energy(self, q, t):
        return self.c_instance.energy(q, t=t)

    def _gradient(self, q, t):
        return self.c_instance.gradient(q, t=t)

    def _density(self, q, t):
        return self.c_instance.density(q, t=t)

    def _hessian(self, q, t):
        return self.c_instance.hessian(q, t=t)

    # ----------------------------------------------------------
    # Overwrite the Python potential method to use Cython method
    def mass_enclosed(self, q, t=0.):
        """
        mass_enclosed(q, t)

        Estimate the mass enclosed within the given position by assuming the potential
        is spherical. This is not so good!

        Parameters
        ----------
        q : array_like, numeric
            Position to compute the mass enclosed.
        """
        q = self._remove_units_prepare_shape(q)
        orig_shape, q = self._get_c_valid_arr(q)
        t = self._validate_prepare_time(t, q)

        sgn = 1.
        if 'm' in self.parameters and self.parameters['m'] < 0:
            sgn = -1.

        try:
            menc = self.c_instance.mass_enclosed(q, self.G, t=t)
        except AttributeError, TypeError:
            raise ValueError("Potential C instance has no defined "
                             "mass_enclosed function")

        return sgn * menc.reshape(orig_shape[1:]) * self.units['mass']

    def __add__(self, other):
        """
        If all components are Cython, return a CCompositePotential.
        Otherwise, return a standard CompositePotential.
        """
        from .ccompositepotential import CCompositePotential

        if not isinstance(other, PotentialBase):
            raise TypeError('Cannot add a {} to a {}'
                            .format(self.__class__.__name__,
                                    other.__class__.__name__))

        components = dict()

        if isinstance(self, CompositePotential):
            for k, v in self.items():
                components[k] = v

        else:
            k = str(uuid.uuid4())
            components[k] = self

        if isinstance(other, CompositePotential):
            for k, v in self.items():
                if k in components:
                    raise KeyError('Potential component "{}" already exists --'
                                   'duplicate key provided in potential '
                                   'addition')
                components[k] = v

        else:
            k = str(uuid.uuid4())
            components[k] = other

        cython_only = True
        for k, pot in components.items():
            if not isinstance(pot, CPotentialBase):
                cython_only = False
                break

        if cython_only:
            new_pot = CCompositePotential()
        else:
            new_pot = CompositePotential()

        for k, pot in components.items():
            new_pot[k] = pot

        return new_pot

    def replace_units(self, units):
        """Change the unit system of this potential.

        Parameters
        ----------
        units : `~gala.units.UnitSystem`
            Set of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.
        """

        # TODO: this is repeated code - see equivalent in core.py
        tmp = [isinstance(units, DimensionlessUnitSystem),
               isinstance(self.units, DimensionlessUnitSystem)]
        if not all(tmp) and any(tmp):
            raise ValueError("Cannot replace a dimensionless unit system with "
                             "a unit system with physical units, or vice versa")

        return self.__class__(**self.parameters, units=units,
                              R=self.R, origin=self.origin)
</file>

<file path="gala/potential/potential/interop.py">
"""Interoperability with other dynamics packages"""

import inspect
import warnings

import astropy.units as u
import numpy as np
from astropy.constants import G

import gala.potential.potential.builtin as gp
from gala.potential.potential.ccompositepotential import CCompositePotential
from gala.potential.potential.core import CompositePotential
from gala.tests.optional_deps import HAS_AGAMA, HAS_GALPY
from gala.units import galactic

__all__ = [
    "gala_to_galpy_potential",
    "galpy_to_gala_potential",
    "gala_to_agama_potential",
]

###############################################################################
# Galpy interoperability
#

if HAS_GALPY:
    import galpy.potential as galpy_gp
    from scipy.special import gamma

    def _powerlaw_amp_to_galpy(pars, ro, vo):
        # I don't really remember why this is like this, but it might be related
        # to the difference between GSL gamma and scipy gamma??
        fac = (
            1
            / (2 * np.pi)
            * pars["r_c"].to_value(ro) ** (pars["alpha"] - 3)
            / (gamma(3 / 2 - pars["alpha"] / 2))
        )
        amp = fac * (G * pars["m"]).to_value(vo**2 * ro)
        return amp

    def _powerlaw_m_from_galpy(pars, ro, vo):
        # See note above!
        fac = (
            1
            / (2 * np.pi)
            * pars["rc"] ** (pars["alpha"] - 3)
            / (gamma(3 / 2 - pars["alpha"] / 2))
        )
        amp = pars["amp"] * vo**2 * ro
        m = amp / G / fac
        return m

    def _mn3_amp_to_galpy(pars, ro, vo):
        num = (G * pars["m"]).to_value(ro * vo**2)
        den = 4 * np.pi * pars["h_R"].to_value(ro) ** 2 * pars["h_z"].to_value(ro)
        return num / den

    # TODO: some potential conversions drop parameters. Might want to add an
    # option for a custom validator function or something to raise warnings?
    _gala_to_galpy = {
        gp.HernquistPotential: (
            galpy_gp.HernquistPotential,
            {
                "a": "c",
                "amp": lambda pars, ro, vo: (G * 2 * pars["m"]).to_value(ro * vo**2),
            },
        ),
        gp.IsochronePotential: (galpy_gp.IsochronePotential, {"b": "b"}),
        gp.JaffePotential: (galpy_gp.JaffePotential, {"a": "c"}),
        gp.KeplerPotential: (galpy_gp.KeplerPotential, {}),
        gp.KuzminPotential: (
            galpy_gp.KuzminDiskPotential,
            {
                "a": "a",
            },
        ),
        gp.LogarithmicPotential: (
            galpy_gp.LogarithmicHaloPotential,
            {
                "amp": lambda pars, ro, vo: pars["v_c"].to_value(vo) ** 2,
                "core": "r_h",
                "q": "q3",
            },
        ),
        gp.LongMuraliBarPotential: (
            galpy_gp.SoftenedNeedleBarPotential,
            {"a": "a", "b": "b", "c": "c", "pa": "alpha"},
        ),
        gp.MiyamotoNagaiPotential: (
            galpy_gp.MiyamotoNagaiPotential,
            {"a": "a", "b": "b"},
        ),
        gp.MN3ExponentialDiskPotential: (
            galpy_gp.MN3ExponentialDiskPotential,
            {
                "amp": _mn3_amp_to_galpy,
                "hr": "h_R",
                "hz": "h_z",
                "posdens": "positive_density",
                "sech": "sech2_z",
            },
        ),
        gp.NFWPotential: (
            galpy_gp.TriaxialNFWPotential,
            {
                "a": "r_s",
                "b": lambda pars, *_: pars["b"] / pars["a"],
                "c": lambda pars, *_: pars["c"] / pars["a"],
            },
        ),
        gp.PlummerPotential: (galpy_gp.PlummerPotential, {"b": "b"}),
        gp.PowerLawCutoffPotential: (
            galpy_gp.PowerSphericalPotentialwCutoff,
            {"amp": _powerlaw_amp_to_galpy, "rc": "r_c", "alpha": "alpha"},
        ),
    }

    _galpy_to_gala = {}
    for gala_cls, (galpy_cls, pars) in _gala_to_galpy.items():
        galpy_pars = {
            v: k
            for k, v in pars.items()
            if isinstance(v, (str, int, float, np.ndarray))
        }
        _galpy_to_gala[galpy_cls] = (gala_cls, galpy_pars)

    # Special cases:
    _galpy_to_gala[galpy_gp.HernquistPotential][1]["m"] = lambda pars, ro, vo: (
        pars["amp"] * ro * vo**2 / G / 2
    )

    _galpy_to_gala[galpy_gp.LogarithmicHaloPotential][1][
        "v_c"
    ] = lambda pars, ro, vo: np.sqrt(pars["amp"] * vo**2)

    _galpy_to_gala[galpy_gp.TriaxialNFWPotential][1]["m"] = lambda pars, ro, vo: (
        pars["amp"] * ro * vo**2 / G * 4 * np.pi * pars["a"] ** 3
    )
    _galpy_to_gala[galpy_gp.TriaxialNFWPotential][1]["a"] = 1.0
    _galpy_to_gala[galpy_gp.TriaxialNFWPotential][1]["b"] = "b"
    _galpy_to_gala[galpy_gp.TriaxialNFWPotential][1]["c"] = "c"

    _galpy_to_gala[galpy_gp.PowerSphericalPotentialwCutoff][1][
        "m"
    ] = _powerlaw_m_from_galpy

    _galpy_to_gala[galpy_gp.NFWPotential] = (
        gp.NFWPotential,
        {
            "r_s": "a",
        },
    )

if HAS_AGAMA:
    # TODO: some potential conversions drop parameters. Might want to add an
    # option for a custom validator function or something to raise warnings?
    _gala_to_agama = {
        gp.HernquistPotential: {
            "type": "dehnen",
            "mass": "m",
            "scaleradius": "c",
            "gamma": 1.0,
        },
        gp.IsochronePotential: {"type": "isochrone", "mass": "m", "scaleradius": "b"},
        gp.JaffePotential: {
            "type": "dehnen",
            "mass": "m",
            "scaleradius": "c",
            "gamma": 2.0,
        },
        # gp.KeplerPotential: {},
        # gp.KuzminPotential: {},
        gp.LogarithmicPotential: {
            "type": "logarithmic",
            "v0": "v_c",
            "scaleradius": "r_h",
            "axisRatioY": "q2",
            "axisRatioZ": "q3",
        },
        # gp.LongMuraliBarPotential: {},
        gp.MiyamotoNagaiPotential: {
            "type": "miyamotonagai",
            "mass": "m",
            "scaleradius": "a",
            "scaleheight": "b",
        },
        # gp.MN3ExponentialDiskPotential: {}, # Special cased below
        gp.NFWPotential: {"type": "nfw", "mass": "m", "scaleradius": "r_s"},
        gp.PlummerPotential: {"type": "plummer", "mass": "m", "scaleradius": "b"},
        # gp.PowerLawCutoffPotential: {}
    }


def _get_ro_vo(ro, vo):
    # If not specified, get the default ro, vo from Galpy
    if ro is None or vo is None:
        from galpy.potential import Force

        f = Force()

        if ro is None:
            ro = f._ro * u.kpc
        if vo is None:
            vo = f._vo * u.km / u.s

    return u.Quantity(ro), u.Quantity(vo)


def gala_to_galpy_potential(potential, ro=None, vo=None):
    if not HAS_GALPY:
        raise ImportError(
            "Failed to import galpy.potential: Converting a potential to a galpy "
            "potential requires galpy to be installed."
        )

    ro, vo = _get_ro_vo(ro, vo)

    if isinstance(potential, CompositePotential):
        pot = []
        for k in potential.keys():
            pot.append(gala_to_galpy_potential(potential[k], ro, vo))

    else:
        if potential.__class__ not in _gala_to_galpy:
            raise TypeError(
                f"Converting potential class {potential.__class__.__name__} "
                "to galpy is currently not supported"
            )

        galpy_cls, converters = _gala_to_galpy[potential.__class__]
        gala_pars = potential.parameters.copy()

        galpy_pars = {}
        if "amp" not in converters and "m" not in gala_pars:
            raise ValueError(
                "Gala potential has no mass parameter, so converting to a Galpy "
                "potential is currently not supported."
            )

        if isinstance(potential, gp.MN3ExponentialDiskPotential):
            gala_pars["positive_density"] = potential.positive_density
            gala_pars["sech2_z"] = potential.sech2_z

        converters.setdefault(
            "amp", lambda pars, ro, vo: (G * pars["m"]).to_value(ro * vo**2)
        )

        for galpy_par_name, conv in converters.items():
            if isinstance(conv, str):
                galpy_pars[galpy_par_name] = gala_pars[conv]
            elif hasattr(conv, "__call__"):
                galpy_pars[galpy_par_name] = conv(gala_pars, ro, vo)
            elif isinstance(conv, (int, float, u.Quantity, np.ndarray)):
                galpy_pars[galpy_par_name] = conv
            else:
                # TODO: invalid parameter??
                print(f"FAIL: {galpy_par_name}, {conv}")

            par = galpy_pars[galpy_par_name]
            if hasattr(par, "unit"):
                if par.unit.physical_type == "length":
                    galpy_pars[galpy_par_name] = par.to_value(ro)
                elif par.unit.physical_type == "speed":
                    galpy_pars[galpy_par_name] = par.to_value(vo)
                elif par.unit.physical_type == "dimensionless":
                    galpy_pars[galpy_par_name] = par.value
                elif par.unit.physical_type == "angle":
                    galpy_pars[galpy_par_name] = par.to_value(u.rad)
                else:
                    warnings.warn(
                        f"Unknown unit physical type '{par.unit.physical_type}'"
                        " - this should have a custom unit converter. Please "
                        "make a GitHub issue!",
                        RuntimeWarning,
                    )
                    galpy_pars[galpy_par_name] = par.value

        pot = galpy_cls(**galpy_pars, ro=ro, vo=vo)

    return pot


def galpy_to_gala_potential(potential, ro=None, vo=None, units=galactic):
    if not HAS_GALPY:
        raise ImportError(
            "Failed to import galpy.potential: Converting a potential to a "
            "gala potential requires galpy to be installed."
        )

    ro, vo = _get_ro_vo(ro, vo)

    if potential._roSet:
        ro = potential._ro * u.kpc
    if potential._voSet:
        vo = potential._vo * u.km / u.s

    if isinstance(potential, list):
        pot = CCompositePotential()
        for i, sub_pot in enumerate(potential):
            pot[str(i)] = galpy_to_gala_potential(sub_pot, ro, vo)

    else:
        if potential.__class__ not in _galpy_to_gala:
            raise TypeError(
                f"Converting galpy potential {potential.__class__.__name__} "
                "to gala is currently not supported"
            )
        elif isinstance(potential, galpy_gp.MN3ExponentialDiskPotential):
            warnings.warn(
                "For the MN3ExponentialDiskPotential, galpy does not store "
                "information to fully reconstruct the potential, so the "
                "default gala choices will be adopted for the "
                "'positive_density' and 'sech2_z' potential arguments",
                RuntimeWarning,
            )

        gala_cls, converters = _galpy_to_gala[potential.__class__]

        exclude = ["self", "normalize", "ro", "vo"]
        spec = inspect.getfullargspec(potential.__class__)
        par_names = [arg for arg in spec.args if arg not in exclude]

        # UGH!
        galpy_pars = {}
        for name in par_names:
            galpy_pars[name] = getattr(
                potential, "_" + name, getattr(potential, name, None)
            )

        if isinstance(potential, galpy_gp.LogarithmicHaloPotential):
            galpy_pars["core"] = np.sqrt(potential._core2)

        elif isinstance(potential, galpy_gp.SoftenedNeedleBarPotential):
            galpy_pars["c"] = np.sqrt(potential._c2)

        if "m" in inspect.getfullargspec(gala_cls).args:
            converters.setdefault(
                "m", lambda pars, ro, vo: pars["amp"] * ro * vo**2 / G
            )

        gala_pars = {}
        for gala_par_name, conv in converters.items():
            if isinstance(conv, str):
                gala_pars[gala_par_name] = galpy_pars[conv]
            elif hasattr(conv, "__call__"):
                gala_pars[gala_par_name] = conv(galpy_pars, ro, vo)
            elif isinstance(conv, (int, float, u.Quantity, np.ndarray)):
                gala_pars[gala_par_name] = conv
            else:
                # TODO: invalid parameter??
                print(f"FAIL: {gala_par_name}, {conv}")

            if hasattr(gala_pars[gala_par_name], "unit"):
                continue

            if gala_par_name not in gala_cls._parameters:
                continue

            gala_par = gala_cls._parameters[gala_par_name]
            if gala_par.physical_type == "mass":
                gala_pars[gala_par_name] = gala_pars[gala_par_name] * u.Msun
            elif gala_par.physical_type == "length":
                gala_pars[gala_par_name] = gala_pars[gala_par_name] * ro
            elif gala_par.physical_type == "speed":
                gala_pars[gala_par_name] = gala_pars[gala_par_name] * vo
            elif gala_par.physical_type == "angle":
                gala_pars[gala_par_name] = gala_pars[gala_par_name] * u.radian
            elif gala_par.physical_type == "dimensionless":
                pass
            else:
                print("TODO")

        pot = gala_cls(**gala_pars, units=units)

    return pot


def gala_to_agama_potential(potential):
    if not HAS_AGAMA:
        raise ImportError(
            "Failed to import agama: Converting a potential to an Agama potential "
            "requires Agama to be installed."
        )

    import agama

    agama.setUnits(**{k: potential.units[k] for k in ["length", "mass", "time"]})

    if isinstance(potential, CompositePotential):
        pot = []
        for k in potential.keys():
            agama_pot = gala_to_agama_potential(potential[k])
            if isinstance(agama_pot, list):
                pot.extend(agama_pot)
            else:
                pot.append(agama_pot)

    elif isinstance(potential, gp.MN3ExponentialDiskPotential):
        pot = []
        for disk in potential.get_three_potentials().values():
            pot.append(gala_to_agama_potential(disk))

    else:
        if potential.__class__ not in _gala_to_agama:
            raise TypeError(
                f"Converting potential class {potential.__class__.__name__} "
                "to agama is currently not supported"
            )

        agama_spec = _gala_to_agama[potential.__class__]
        gala_pars = potential.parameters.copy()

        agama_pars = {"type": agama_spec["type"]}
        for agama_par_name, conv in agama_spec.items():
            if agama_par_name == "type":
                continue
            elif isinstance(conv, str):
                agama_pars[agama_par_name] = gala_pars[conv]
            # elif hasattr(conv, "__call__"):
            #     agama_pars[agama_par_name] = conv(gala_pars)
            elif isinstance(conv, (int, float, u.Quantity, np.ndarray)):
                agama_pars[agama_par_name] = conv
            else:
                # TODO: invalid parameter??
                print(f"FAIL: {agama_par_name}, {conv}")

        for k, v in agama_pars.items():
            if hasattr(v, "unit"):
                agama_pars[k] = v.decompose(potential.units).value

        pot = agama.Potential(**agama_pars)

    return pot
</file>

<file path="gala/potential/potential/io.py">
""" Read and write potentials to text (YAML) files. """

# Standard library
import os

# Third-party
import astropy.units as u
from astropy.utils import isiterable
import numpy as np
import yaml

from gala.units import DimensionlessUnitSystem

__all__ = ["load", "save"]


def _unpack_params(p):
    params = p.copy()
    for key, item in p.items():
        if "_unit" in key:
            continue

        if isiterable(item) and not isinstance(item, str):
            params[key] = np.array(item).astype(float)
        else:
            params[key] = float(item)

        if key + "_unit" in params:
            params[key] = params[key] * u.Unit(params[key + "_unit"])
            del params[key + "_unit"]

    return params


def _parse_component(component, module):
    # need this here for circular import
    from .. import potential as gala_potential

    try:
        class_name = component["class"]
    except KeyError:
        raise KeyError(
            "Potential dictionary must contain a key 'class' for "
            "specifying the name of the Potential class."
        )

    if "units" not in component:
        unitsys = None
    else:
        try:
            unitsys = [u.Unit(unit) for ptype, unit in component["units"].items()]
        except KeyError:
            raise KeyError(
                "Potential dictionary must contain a key 'units' "
                "with a list of strings specifying the unit system."
            )

    params = component.get("parameters", {})

    # need to crawl the dictionary structure and unpack quantities
    params = _unpack_params(params)

    if module is None:
        potential = gala_potential
    else:
        potential = module

    try:
        Potential = getattr(potential, class_name)
    except AttributeError:  # HACK: this might be bad to assume
        Potential = getattr(gala_potential, class_name)

    return Potential(units=unitsys, **params)


def from_dict(d, module=None):
    """
    Convert a dictionary potential specification into a
    :class:`~gala.potential.PotentialBase` subclass object.

    Parameters
    ----------
    d : dict
        Dictionary specification of a potential.
    module : namespace (optional)

    """

    # need this here for circular import issues
    import gala.potential as gala_potential

    if module is None:
        potential = gala_potential
    else:
        potential = module

    if "type" in d and d["type"] == "composite":
        p = getattr(potential, d["class"])()
        for i, component in enumerate(d["components"]):
            c = _parse_component(component, module)
            name = component.get("name", str(i))
            p[name] = c

    elif "type" in d and d["type"] == "custom":
        param_groups = dict()
        for i, component in enumerate(d["components"]):
            c = _parse_component(component, module)

            try:
                name = component["name"]
            except KeyError:
                raise KeyError(
                    "For custom potentials, component specification "
                    "must include the component name (e.g., name: "
                    "'blah')"
                )

            params = component.get("parameters", {})
            params = _unpack_params(params)  # unpack quantities
            param_groups[name] = params
        p = getattr(potential, d["class"])(**param_groups)

    else:
        p = _parse_component(d, module)

    return p


# ----------------------------------------------------------------------------


def _pack_params(p):
    params = p.copy()
    for key, item in p.items():
        if hasattr(item, "unit"):
            params[key] = item.value
            params[key + "_unit"] = str(item.unit)

        if hasattr(params[key], "tolist"):  # convert array to list
            params[key] = params[key].tolist()

    return params


def _to_dict_help(potential):
    d = dict()

    d["class"] = potential.__class__.__name__

    if not isinstance(potential.units, DimensionlessUnitSystem):
        d["units"] = dict(
            [(str(k), str(v)) for k, v in potential.units.to_dict().items()]
        )

    if len(potential.parameters) > 0:
        params = _pack_params(potential.parameters)
        d["parameters"] = params

    return d


def to_dict(potential):
    """
    Turn a potential object into a dictionary that fully specifies the
    state of the object.

    Parameters
    ----------
    potential : :class:`~gala.potential.PotentialBase`
        The instantiated :class:`~gala.potential.PotentialBase` object.

    """
    from .. import potential as gp

    if isinstance(potential, gp.CompositePotential):
        d = dict()
        d["class"] = potential.__class__.__name__
        d["components"] = []
        for k, p in potential.items():
            comp_dict = _to_dict_help(p)
            comp_dict["name"] = k
            d["components"].append(comp_dict)

        if (
            potential.__class__.__name__ == "CompositePotential"
            or potential.__class__.__name__ == "CCompositePotential"
        ):
            d["type"] = "composite"
        else:
            d["type"] = "custom"

    else:
        d = _to_dict_help(potential)

    return d


# ----------------------------------------------------------------------------


def load(f, module=None):
    """
    Read a potential specification file and return a
    :class:`~gala.potential.PotentialBase` object instantiated with parameters
    specified in the spec file.

    Parameters
    ----------
    f : str, file_like
        A block of text, filename, or file-like object to parse and read
        a potential from.
    module : namespace (optional)

    """
    if hasattr(f, "read"):
        p_dict = yaml.load(f.read(), Loader=yaml.Loader)
    else:
        with open(os.path.abspath(f), "r") as fil:
            p_dict = yaml.load(fil.read(), Loader=yaml.Loader)

    return from_dict(p_dict, module=module)


def save(potential, f):
    """
    Write a :class:`~gala.potential.PotentialBase` object out to a text (YAML)
    file.

    Parameters
    ----------
    potential : :class:`~gala.potential.PotentialBase`
        The instantiated :class:`~gala.potential.PotentialBase` object.
    f : str, file_like
        A filename or file-like object to write the input potential object to.

    """
    d = to_dict(potential)

    if hasattr(f, "write"):
        yaml.dump(d, f, default_flow_style=None)
    else:
        with open(f, "w") as f2:
            yaml.dump(d, f2, default_flow_style=None)
</file>

<file path="gala/potential/potential/setup_package.py">
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["include_dirs"].append("gala")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/potential/potential/cpotential.pyx")
    cfg["sources"].append(
        "gala/potential/potential/builtin/builtin_potentials.c"
    )
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    exts.append(Extension("gala.potential.potential.cpotential", **cfg))

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["include_dirs"].append("gala")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/potential/potential/ccompositepotential.pyx")
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    exts.append(
        Extension("gala.potential.potential.ccompositepotential", **cfg)
    )

    cfg = defaultdict(list)
    cfg["include_dirs"].append(np.get_include())
    cfg["include_dirs"].append(mac_incl_path)
    cfg["include_dirs"].append("gala/potential")
    cfg["include_dirs"].append("gala")
    cfg["extra_compile_args"].append("--std=gnu99")
    cfg["sources"].append("gala/potential/potential/builtin/cybuiltin.pyx")
    cfg["sources"].append(
        "gala/potential/potential/builtin/builtin_potentials.c"
    )
    cfg["sources"].append("gala/potential/potential/builtin/multipole.c")
    cfg["sources"].append("gala/potential/potential/src/cpotential.c")
    exts.append(Extension("gala.potential.potential.builtin.cybuiltin", **cfg))

    return exts


def get_package_data():

    return {
        "gala.potential.potential": [
            "*.h",
            "*.pyx",
            "*.pxd",
            "*/*.pyx",
            "*/*.pxd",
            "builtin/builtin_potentials.h",
            "builtin/builtin_potentials.c",
            "src/cpotential.h",
            "src/cpotential.c",
            "tests/*.yml",
            "tests/pot_disk_506151.pot",
            "tests/agama_cylspline_test.fits"
        ]
    }
</file>

<file path="gala/potential/potential/util.py">
""" Utilities for Potential classes """

# Standard library
from functools import wraps

# Third-party
import numpy as np

# Project
from ..common import PotentialParameter
from .core import PotentialBase

__all__ = ['from_equation']
__doctest_requires__ = {('from_equation', ): ['sympy']}


def from_equation(expr, vars, pars, name=None, hessian=False):
    r"""
    Create a potential class from an expression for the potential.

    .. note::

        This utility requires having `Sympy <http://www.sympy.org/>`_ installed.

    .. warning::

        These potentials are *not* pickle-able and cannot be written
        out to YAML files (using `~gala.potential.PotentialBase.save()`)

    Parameters
    ----------
    expr : :class:`sympy.core.expr.Expr`, str
        Either a ``Sympy`` expression, or a string that can be converted to
        a ``Sympy`` expression.
    vars : iterable
        An iterable of variable names in the expression.
    pars : iterable
        An iterable of parameter names in the expression.
    name : str (optional)
        The name of the potential class returned.
    hessian : bool (optional)
        Generate a function to compute the Hessian.

    Returns
    -------
    CustomPotential : `~gala.potential.PotentialBase`
        A potential class that represents the input equation. To instantiate the
        potential, use just like a normal class with parameters.

    Examples
    --------
    Here we'll create a potential class for the harmonic oscillator
    potential, :math:`\Phi(x) = \frac{1}{2}\,k\,x^2`:

        >>> Potential = from_equation("1/2*k*x**2", vars="x", pars="k",
        ...                           name='HarmonicOscillator')
        >>> p1 = Potential(k=1.)
        >>> p1
        <HarmonicOscillatorPotential: k=1.00 (dimensionless)>

    The potential class (and object) is a fully-fledged subclass of
    `~gala.potential.PotentialBase` and therefore has many useful methods.
    For example, to integrate an orbit:

        >>> from gala.potential import Hamiltonian
        >>> H = Hamiltonian(p1)
        >>> orbit = H.integrate_orbit([1., 0], dt=0.01, n_steps=1000)

    """
    try:
        import sympy
        from sympy.utilities.lambdify import lambdify
    except ImportError:
        raise ImportError("sympy is required to use 'from_equation()' "
                          "potential class creation.")

    # convert all input to Sympy objects
    expr = sympy.sympify(expr)
    vars = [sympy.sympify(v) for v in vars]
    var_names = [v.name for v in vars]
    pars = [sympy.sympify(p) for p in pars]
    par_names = [p.name for p in pars]
    ndim = len(vars)

    # Energy / value
    energyfunc = lambdify(vars + pars, expr, dummify=False,
                          modules=['numpy', 'sympy'])

    # Gradient
    gradfuncs = []
    for var in vars:
        gradfuncs.append(lambdify(vars + pars, sympy.diff(expr, var),
                                  dummify=False,
                                  modules=['numpy', 'sympy']))

    parameters = {}
    for _name in par_names:
        parameters[_name] = PotentialParameter(_name,
                                               physical_type='dimensionless')

    class CustomPotential(PotentialBase, parameters=parameters):
        ndim = len(vars)

        def _energy(self, w, t=0.):
            kw = self.parameters.copy()
            for k, v in kw.items():
                kw[k] = v.value

            for i, name in enumerate(var_names):
                kw[name] = w[:, i]

            return np.array(energyfunc(**kw))

        def _gradient(self, w, t=0.):
            kw = self.parameters.copy()
            for k, v in kw.items():
                kw[k] = v.value

            for i, name in enumerate(var_names):
                kw[name] = w[:, i]

            grad = np.vstack([f(**kw)[np.newaxis] for f in gradfuncs])
            return grad.T

    if name is not None:
        # name = _classnamify(name)
        if "potential" not in name.lower():
            name = name + "Potential"
        CustomPotential.__name__ = str(name)

    # Hessian
    if hessian:
        hessfuncs = []
        for var1 in vars:
            for var2 in vars:
                hessfuncs.append(lambdify(vars + pars,
                                          sympy.diff(expr, var1, var2),
                                          dummify=False,
                                          modules=['numpy', 'sympy']))

        def _hessian(self, w, t):
            kw = self.parameters.copy()
            for k, v in kw.items():
                kw[k] = v.value

            for i, name in enumerate(var_names):
                kw[name] = w[:, i]

            # expand = [np.newaxis] * w[i].ndim

            # This ain't pretty, bub
            arrs = []
            for f in hessfuncs:
                hess_arr = np.array(f(**kw))
                if hess_arr.shape != w[:, i].shape:
                    hess_arr = np.tile(hess_arr, reps=w[:, i].shape)
                arrs.append(hess_arr)
            hess = np.vstack(arrs)

            return hess.reshape((ndim, ndim, len(w[:, i])))

        CustomPotential._hessian = _hessian

    CustomPotential.save = None
    return CustomPotential


def format_doc(*args, **kwargs):
    """
    Replaces the docstring of the decorated object and then formats it.

    Modeled after astropy.utils.decorators.format_doc
    """
    def set_docstring(obj):

        # None means: use the objects __doc__
        doc = obj.__doc__
        # Delete documentation in this case so we don't end up with
        # awkwardly self-inserted docs.
        obj.__doc__ = None

        # If the original has a not-empty docstring append it to the format
        # kwargs.
        kwargs['__doc__'] = obj.__doc__ or ''
        obj.__doc__ = doc.format(*args, **kwargs)
        return obj
    return set_docstring


class SympyWrapper:

    @classmethod
    def as_decorator(cls, func=None, **kwargs):
        self = cls(**kwargs)
        if func is not None and not kwargs:
            return self(func)
        else:
            return self

    def __init__(self, func=None, var=None, include_G=True):
        if var is None:
            _var = 'x, y, z'
        else:
            _var = var
        self.var = _var
        self.include_G = include_G

    def __call__(self, wrapped_function):

        @wraps(wrapped_function)
        def wrapper(cls, *func_args, **func_kwargs):
            try:
                import sympy as sy  # noqa
            except ImportError:
                raise ImportError("Converting to a latex expression requires "
                                  "the sympy package to be installed")

            _var = sy.symbols(self.var, seq=True, real=True)
            _var = {v.name: v for v in _var}

            if cls._parameters:
                par = sy.symbols(' '.join(cls._parameters.keys()),
                                 seq=True, real=True)
                par = {v.name: v for v in par}
            else:
                par = {}

            if self.include_G:
                par['G'] = sy.symbols('G')

            return wrapped_function(cls, _var, par)

        return wrapper


sympy_wrap = SympyWrapper.as_decorator
</file>

<file path="gala/potential/scf/src/bfe_helper.c">
#include <stdlib.h>
#include "extra_compile_macros.h"
#include <math.h>
#include "bfe_helper.h"
#if USE_GSL == 1
#include "gsl/gsl_sf_legendre.h"
#include "gsl/gsl_sf_gegenbauer.h"
#include "gsl/gsl_sf_gamma.h"
#endif

#define SQRT_FOURPI 3.544907701811031

#if USE_GSL == 1
double rho_nl(double s, int n, int l) {
    double RR, Knl;
    Knl = 0.5*n*(n+4*l+3) + (l+1)*(2*l+1);
    RR = Knl/(2*M_PI) * pow(s,l) / (s*pow(1+s,2*l+3)) * gsl_sf_gegenpoly_n(n, 2*l + 1.5, (s-1)/(s+1));
    return SQRT_FOURPI*RR;
}
double rho_nlm(double s, double phi, double X, int n, int l, int m) {
    return rho_nl(s, n, l) * gsl_sf_legendre_sphPlm(l, m, X);// / SQRT_FOURPI;
}

double phi_nl(double s, int n, int l) {
    return -SQRT_FOURPI*pow(s,l) * pow(1+s, -2*l-1) * gsl_sf_gegenpoly_n(n, 2*l+1.5, (s-1)/(s+1));
}
double phi_nlm(double s, double phi, double X, int n, int l, int m) {
    return phi_nl(s, n, l) * gsl_sf_legendre_sphPlm(l, m, X); // / SQRT_FOURPI;
}

void sph_grad_phi_nlm(double s, double phi, double X, int n, int l, int m,
                      int lmax, double *sphgrad) {
    double A, dYlm_dtheta;
    double dPhinl_dr, dPhi_dphi, dPhi_dtheta;

    // spherical coord stuff
    double sintheta = sqrt(1-X*X);

    double Phi_nl, Ylm, Plm, Pl1m;
    Phi_nl = phi_nl(s, n, l);

    Ylm = gsl_sf_legendre_sphPlm(l, m, X);

    // Correct: associated Legendre polynomial -- not sphPlm!
    if (m <= l) {
        Plm = gsl_sf_legendre_Plm(l, m, X);
    } else {
        Plm = 0.;
    }

    // copied out of Mathematica
    if (n == 0) {
        dPhinl_dr = SQRT_FOURPI*pow(s,-1 + l)*pow(1 + s,-3 - 2*l)*(1 + s)*(l*(-1 + s) + s);
    } else {
        dPhinl_dr = (SQRT_FOURPI*pow(s,-1 + l)*pow(1 + s,-3 - 2*l)*
                      (-2*(3 + 4*l)*s*gsl_sf_gegenpoly_n(-1 + n, 2.5 + 2*l, (-1 + s)/(1 + s)) +
                      (1 + s)*(l*(-1 + s) + s)*gsl_sf_gegenpoly_n(n, 1.5 + 2*l, (-1 + s)/(1 + s))));
    }
    dPhinl_dr *= Ylm;

    if (l==0) {
        dYlm_dtheta = 0.;
    } else {
        // Correct: associated Legendre polynomial -- not sphPlm!
        if (m <= (l-1)) {
            Pl1m = gsl_sf_legendre_Plm(l-1, m, X);
        } else {
            Pl1m = 0.;
        }

        if (l == m) {
            A = sqrt(2*l+1) / SQRT_FOURPI * sqrt(1. / gsl_sf_gamma(l+m+1.));
        } else {
            A = sqrt(2*l+1) / SQRT_FOURPI * sqrt(gsl_sf_gamma(l-m+1.) / gsl_sf_gamma(l+m+1.));
        }
        dYlm_dtheta = A / sintheta * (l*X*Plm - (l+m)*Pl1m);
    }
    dPhi_dtheta = dYlm_dtheta * Phi_nl / s;

    if (m == 0) {
        dPhi_dphi = 0.;
    } else {
        dPhi_dphi = m;
    }
    dPhi_dphi *= Ylm * Phi_nl;

    sphgrad[0] = dPhinl_dr;
    sphgrad[1] = dPhi_dtheta;
    sphgrad[2] = dPhi_dphi;
}
#endif
</file>

<file path="gala/potential/scf/src/bfe_helper.h">
// #ifndef _BFE_HELPER_
// #define _BFE_HELPER_
extern double rho_nl(double s, int n, int l);
extern double rho_nlm(double s, double phi, double X, int n, int l, int m);

extern double phi_nl(double s, int n, int l);
extern double phi_nlm(double s, double phi, double X, int n, int l, int m);

extern void sph_grad_phi_nlm(double s, double phi, double X, int n, int l, int m, int lmax, double *sphgrad);
// #endif
</file>

<file path="gala/potential/scf/src/bfe.c">
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "bfe_helper.h"
#include "extra_compile_macros.h"

#if USE_GSL == 1
#include "gsl/gsl_math.h"
#include "gsl/gsl_spline.h"
#endif

#if USE_GSL == 1
void scf_density_helper(double *xyz, int K,
                        double M, double r_s,
                        double *Snlm, double *Tnlm,
                        int nmax, int lmax, double *dens) {

    int i,j,k, n,l,m;
    double r, s, X, phi;
    double cosmphi[lmax+1], sinmphi[lmax+1];
    memset(cosmphi, 0, (lmax+1)*sizeof(double));
    memset(sinmphi, 0, (lmax+1)*sizeof(double));
    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r/r_s;
        X = xyz[j+2]/r; // cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m*phi);
            sinmphi[m] = sin(m*phi);
        }

        // i = 0;
        for (n=0; n<(nmax+1); n++) {
            for (l=0; l<(lmax+1); l++) {
                for (m=0; m<(lmax+1); m++) {
                    if (m > l) {
                        // i++;
                        continue;
                    }

                    i = m + (lmax+1) * (l + (lmax+1) * n);
                    if ((Snlm[i] == 0.) & (Tnlm[i] == 0.)) {
                        // i++;
                        continue;
                    }
                    dens[k] += rho_nlm(s, phi, X, n, l, m) * (Snlm[i]*cosmphi[m] +
                                                              Tnlm[i]*sinmphi[m]);
                }
            }
        }
        dens[k] *= M / (r_s*r_s*r_s);
    }
}

void scf_potential_helper(double *xyz, int K,
                          double G, double M, double r_s,
                          double *Snlm, double *Tnlm,
                          int nmax, int lmax, double *val) {

    int i,j,k, n,l,m;
    double r, s, X, phi;
    double cosmphi[lmax+1], sinmphi[lmax+1];
    memset(cosmphi, 0, (lmax+1)*sizeof(double));
    memset(sinmphi, 0, (lmax+1)*sizeof(double));
    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r/r_s;
        X = xyz[j+2]/r; // cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        // HACK: zero out before filling;
        val[k] = 0.;

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m*phi);
            sinmphi[m] = sin(m*phi);
        }

        // TODO: could speed this up by moving call to legendre out of n loop
        // TODO: note, if I do this I need to go from 3D to 1D array in different way...
        // i = 0;
        for (n=0; n<(nmax+1); n++) {
            for (l=0; l<(lmax+1); l++) {
                for (m=0; m<(lmax+1); m++) {
                    if (m > l) {
                        // i++;
                        continue;
                    }

                    i = m + (lmax+1) * (l + (lmax+1) * n);
                    if ((Snlm[i] == 0.) & (Tnlm[i] == 0.)) {
                        // i++;
                        continue;
                    }

                    val[k] += phi_nlm(s, phi, X, n, l, m) * (Snlm[i]*cosmphi[m] +
                                                             Tnlm[i]*sinmphi[m]);
                    // i++;
                }
            }
        }
        val[k] *= G*M/r_s;
    }
}

void scf_gradient_helper(double *xyz, int K,
                         double G, double M, double r_s,
                         double *Snlm, double *Tnlm,
                         int nmax, int lmax, double *grad) {

    int i,j,k, n,l,m;
    double r, s, X, phi;
    double sintheta, cosphi, sinphi, tmp;
    double tmp_grad[3], tmp_grad2[3*K]; // TODO: this might be really inefficient
    double cosmphi[lmax+1], sinmphi[lmax+1];
    memset(cosmphi, 0, (lmax+1)*sizeof(double));
    memset(sinmphi, 0, (lmax+1)*sizeof(double));

    for (k=0; k<K; k++) {
        j = 3*k;
        r = sqrt(xyz[j]*xyz[j] + xyz[j+1]*xyz[j+1] + xyz[j+2]*xyz[j+2]);
        s = r/r_s;
        X = xyz[j+2]/r; // cos(theta)
        phi = atan2(xyz[j+1], xyz[j+0]);

        sintheta = sqrt(1 - X*X);
        cosphi = cos(phi);
        sinphi = sin(phi);

        // precompute all cos(m phi), sin(m phi)
        for (m=0; m<(lmax+1); m++) {
            cosmphi[m] = cos(m*phi);
            sinmphi[m] = sin(m*phi);
        }

        // zero out
        tmp_grad2[j+0] = 0.;
        tmp_grad2[j+1] = 0.;
        tmp_grad2[j+2] = 0.;

        // i = 0;
        for (n=0; n<(nmax+1); n++) {
            // gsl_sf_legendre_deriv_array(GSL_SF_LEGENDRE_SPHARM, lmax, X,
            //                             double result_array[], double result_deriv_array[]);
            for (l=0; l<(lmax+1); l++) {
                for (m=0; m<(lmax+1); m++) {
                    if (m > l) {
                        // i++;
                        continue;
                    }

                    i = m + (lmax+1) * (l + (lmax+1) * n);
                    tmp = (Snlm[i]*cosmphi[m] + Tnlm[i]*sinmphi[m]);
                    if ((Snlm[i] == 0.) & (Tnlm[i] == 0.)) {
                        // i++;
                        continue;
                    }

                    sph_grad_phi_nlm(s, phi, X, n, l, m, lmax, &tmp_grad[0]);
                    tmp_grad2[j+0] += tmp_grad[0] * tmp; // r
                    tmp_grad2[j+1] += tmp_grad[1] * tmp; // theta
                    tmp_grad2[j+2] += tmp_grad[2] * (Tnlm[i]*cosmphi[m] - Snlm[i]*sinmphi[m]) / (s*sintheta); // phi

                    // i++;
                }
            }
        }
        tmp_grad[0] = tmp_grad2[j+0];
        tmp_grad[1] = tmp_grad2[j+1];
        tmp_grad[2] = tmp_grad2[j+2];

        // transform to cartesian
        tmp_grad2[j+0] = sintheta*cosphi*tmp_grad[0] + X*cosphi*tmp_grad[1] - sinphi*tmp_grad[2];
        tmp_grad2[j+1] = sintheta*sinphi*tmp_grad[0] + X*sinphi*tmp_grad[1] + cosphi*tmp_grad[2];
        tmp_grad2[j+2] = X*tmp_grad[0] - sintheta*tmp_grad[1];

        grad[j+0] = grad[j+0] + tmp_grad2[j+0]*G*M/(r_s*r_s);
        grad[j+1] = grad[j+1] + tmp_grad2[j+1]*G*M/(r_s*r_s);
        grad[j+2] = grad[j+2] + tmp_grad2[j+2]*G*M/(r_s*r_s);
    }
}

double scf_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - nmax
        - lmax
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */

    double G = pars[0];
    int nmax = (int)pars[1];
    int lmax = (int)pars[2];
    double M = pars[3];
    double r_s = pars[4];

    double val[1] = {0.};
    double _val;
    int n,l,m;

    int num_coeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                num_coeff++;
            }
        }
    }

    scf_potential_helper(&q[0], 1,
                         G, M, r_s,
                         &pars[5], &pars[5+num_coeff],
                         nmax, lmax, &val[0]);

    _val = val[0];
    return _val;
}

void scf_gradient(double t, double *pars, double *q, int n_dim, double *grad) {
    /*  pars:
        - G (Gravitational constant)
        - nmax
        - lmax
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    double G = pars[0];
    int nmax = (int)pars[1];
    int lmax = (int)pars[2];
    double M = pars[3];
    double r_s = pars[4];

    int n,l,m;

    int num_coeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                num_coeff++;
            }
        }
    }

    scf_gradient_helper(&q[0], 1,
                        G, M, r_s,
                        &pars[5], &pars[5+num_coeff],
                        nmax, lmax, &grad[0]);
}

double scf_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - nmax
        - lmax
        - m (mass scale)
        - r_s (length scale)
        [- sin_coeff, cos_coeff]
    */
    double G = pars[0];
    int nmax = (int)pars[1];
    int lmax = (int)pars[2];
    double M = pars[3];
    double r_s = pars[4];

    double val[1] = {0.};
    double _val;
    int n,l,m;

    int num_coeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                num_coeff++;
            }
        }
    }

    scf_density_helper(&q[0], 1,
                       M, r_s,
                       &pars[5], &pars[5+num_coeff],
                       nmax, lmax, &val[0]);

    _val = val[0];
    return _val;
}

/* Support for interpolation between SCF coefficient snapshots */
void get_bound_idx(double val, double *arr, int narr, int *idx) {
    double dist = fabs(arr[0] - val);
    double newdist;
    int min_i = 0;
    for (int i=0; i<narr; i++) {
        newdist = fabs(arr[i] - val);
        if (newdist < dist) {
            min_i = i;
            dist = newdist;
        }
    }

    if (arr[min_i] == val) {
        idx[0] = min_i;
        idx[1] = min_i;
    } else if (arr[min_i] > val) {
        idx[0] = min_i - 1;
        idx[1] = min_i;
    } else {
        idx[0] = min_i;
        idx[1] = min_i + 1;
    }
}

void interp_helper(double t, double *q, double *pars, int ntimes, int ncoeff,
                   double *interp_pars, double *newq) {
    int i, n;
    for (i=0; i<5; i++) {
        interp_pars[i] = pars[i];
    }

    interp_pars[0] = pars[0];
    interp_pars[1] = pars[1];
    interp_pars[2] = pars[2];
    interp_pars[3] = pars[4]; // skip ntimes
    interp_pars[4] = pars[5];

    // Get the indices in the coefficient time array, tj, that bound the
    // evaluation time, t. pars[6 + 2*ncoeff] is tj!
    int idx[2];
    get_bound_idx(t, &pars[6 + 2*ncoeff*ntimes], ntimes, &idx[0]);

    // Time difference between bounding timesteps
    double t0 = pars[6 + 2*ncoeff*ntimes + idx[0]];
    double dt = pars[6 + 2*ncoeff*ntimes + idx[1]] - t0;
    double slope;

    if (idx[0] == idx[1]) {
        // evaluation time exactly equals one of the coefficient times
        for (n=0; n<ncoeff; n++) {
            // pars[6 + ncoeff*idx[0] + n]
            // pars[6 + ncoeff*idx[0] + ncoeff + n]
            interp_pars[5+n] = pars[6 + ncoeff*idx[0] + n];
            interp_pars[5+n + ncoeff] = pars[6 + ncoeff*ntimes +
                                             ncoeff*idx[0] + n];
        }

        for (i=0; i<3; i++) {
            newq[i] = q[i];
        }

    } else {
        // generic case: we must interpolate!
        for (n=0; n<ncoeff; n++) {
            slope = (pars[6 + ncoeff*idx[1] + n] -
                     pars[6 + ncoeff*idx[0] + n]) / dt;
            interp_pars[5+n] = slope * (t - t0) + pars[6 + ncoeff*idx[0] + n];

            slope = (pars[6 + ncoeff*ntimes + ncoeff*idx[1] + n] -
                     pars[6 + ncoeff*ntimes + ncoeff*idx[0] + n]) / dt;
            interp_pars[5+n + ncoeff] = (slope * (t - t0) +
                pars[6 + ncoeff*ntimes + ncoeff*idx[0] + n]);
        }

        // First, use this variable to compute the interpolated origin. Then, we
        // shift the q's to the new origin:
        for (i=0; i<3; i++) {
            slope = (pars[6 + 2*ncoeff*ntimes + ntimes + 3*idx[1] + i] -
                     pars[6 + 2*ncoeff*ntimes + ntimes + 3*idx[0] + i]) / dt;
            newq[i] = (slope * (t-t0) +
                    pars[6 + 2*ncoeff*ntimes + ntimes + 3*idx[0] + i]);
            newq[i] = q[i] - newq[i];
        }
    }
}

double scf_interp_value(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - nmax
        - lmax
        - ntimes
        - m (mass scale)
        - r_s (length scale)
        - Sjnlm[ntimes,nmax,lmax,lmax]
        - Tjnlm[ntimes,nmax,lmax,lmax]
        - tj[ntimes]
        - originj[ntimes,3]

        Logic:
        - Find index of timestep ahead of and behind time t
        - Linear (or cubic) interpolate coefficients to time t using those steps
        - Center input position on interpolated origin at time t
        - Pass interpolated coefficients, and centered q to scf_*
    */

    int nmax = (int)pars[1];   // TODO: abuse!
    int lmax = (int)pars[2];   // TODO: abuse!
    int ntimes = (int)pars[3]; // TODO: abuse!

    int n, l, m;
    double val;  // return value of the potential

    int ncoeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                ncoeff++;
            }
        }
    }

    double interp_pars[5 + 2*ncoeff];
    double newq[3];  // recentered position
    interp_helper(t, q, &pars[0], ntimes, ncoeff, &interp_pars[0], &newq[0]);

    val = scf_value(t, interp_pars, newq, n_dim);

    return val;
}

double scf_interp_density(double t, double *pars, double *q, int n_dim) {
    /*  pars:
        - G (Gravitational constant)
        - nmax
        - lmax
        - ntimes
        - m (mass scale)
        - r_s (length scale)
        - Sjnlm[ntimes,nmax,lmax,lmax]
        - Tjnlm[ntimes,nmax,lmax,lmax]
        - tj[ntimes]
        - originj[ntimes,3]
    */
    int nmax = (int)pars[1];   // TODO: abuse!
    int lmax = (int)pars[2];   // TODO: abuse!
    int ntimes = (int)pars[3]; // TODO: abuse!

    int n, l, m;
    double val;  // return value of the potential

    int ncoeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                ncoeff++;
            }
        }
    }

    double interp_pars[5 + 2*ncoeff];
    double newq[3];  // recentered position
    interp_helper(t, q, &pars[0], ntimes, ncoeff, &interp_pars[0], &newq[0]);

    val = scf_density(t, interp_pars, newq, n_dim);

    return val;

}

void scf_interp_gradient(double t, double *pars, double *q, int n_dim,
                         double *grad) {
    int nmax = (int)pars[1];   // TODO: abuse!
    int lmax = (int)pars[2];   // TODO: abuse!
    int ntimes = (int)pars[3]; // TODO: abuse!

    int n, l, m;
    double val;  // return value of the potential

    int ncoeff = 0;
    for (n=0; n<(nmax+1); n++) {
        for (l=0; l<(lmax+1); l++) {
            for (m=0; m<(lmax+1); m++) {
                ncoeff++;
            }
        }
    }

    double interp_pars[5 + 2*ncoeff];
    double newq[3];  // recentered position
    interp_helper(t, q, &pars[0], ntimes, ncoeff, &interp_pars[0], &newq[0]);

    scf_gradient(t, interp_pars, newq, n_dim, grad);
}

#endif
</file>

<file path="gala/potential/scf/src/bfe.h">
extern void scf_density_helper(double *xyz, int K, double M, double r_s,
                               double *Snlm, double *Tnlm,
                               int nmax, int lmax, double *dens);

extern void scf_potential_helper(double *xyz, int K,
                                 double G, double M, double r_s,
                                 double *Snlm, double *Tnlm,
                                 int nmax, int lmax, double *val);

extern void scf_gradient_helper(double *xyz, int K,
                                double G, double M, double r_s,
                                double *Snlm, double *Tnlm,
                                int nmax, int lmax, double *grad);

extern double scf_value(double t, double *pars, double *q, int n_dim);
extern void scf_gradient(double t, double *pars, double *q, int n_dim,
                         double *grad);
extern double scf_density(double t, double *pars, double *q, int n_dim);

extern double scf_interp_value(double t, double *pars, double *q, int n_dim);
extern void scf_interp_gradient(double t, double *pars, double *q, int n_dim,
                                double *grad);
extern double scf_interp_density(double t, double *pars, double *q, int n_dim);
</file>

<file path="gala/potential/scf/src/coeff_helper.c">
#include <stdlib.h>
#include "extra_compile_macros.h"
#include <math.h>
#include "coeff_helper.h"
#include "bfe_helper.h"
#include <complex.h>
#if USE_GSL == 1
#include "gsl/gsl_sf_legendre.h"
#include "gsl/gsl_sf_gegenbauer.h"
#include "gsl/gsl_sf_gamma.h"
#endif

#define SQRT_FOURPI 3.544907701811031

#if USE_GSL == 1
double STnlm_integrand_help(double phi, double X, double xsi,
                            double density, int n, int l, int m) {
    /*
    Computes the integrand used to compute the expansion
    coefficients, Snlm, Tnlm. The integral is done over:

        * phi: azimuthal angle
        * X: cos(theta), where theta is the colatitude
            (e.g., from spherical coordinates typical to physicists)
        * xsi: (s-1)/(s+1), a radial coordinate mapped to the interval
            [-1,1] rather than [0,inf].
    */
    double s = (1 + xsi) / (1 - xsi);
    double sinth = sqrt(1 - X*X);

    // temporary variables
    double Knl, Anl_til, krond, numer, denom, ds;

    Knl = 0.5*n*(n + 4*l + 3) + (l + 1)*(2*l + 1);
    if (m == 0) {
        krond = 1.;
    } else {
        krond = 0.;
    }

    numer = gsl_sf_fact(n) * (n + 2*l + 1.5) * pow(gsl_sf_gamma(2*l + 1.5),2);
    denom = gsl_sf_gamma(n + 4*l + 3);
    Anl_til = -(pow(2., 8*l+6) / (4*M_PI*Knl)) * numer / denom;

    ds = s*s*(s+1)*(s+1) / 2; // change of variables ds -> dxsi
    return (2 - krond) * phi_nlm(s, phi, X, n, l, m) * Anl_til * density * ds;

}

double c_Snlm_integrand(double phi, double X, double xsi,
                        double density, int n, int l, int m) {
    return STnlm_integrand_help(phi, X, xsi, density, n, l, m) * cos(m*phi);
}

double c_Tnlm_integrand(double phi, double X, double xsi,
                        double density, int n, int l, int m) {
    return STnlm_integrand_help(phi, X, xsi, density, n, l, m) * sin(m*phi);
}

void c_STnlm_discrete(double *s, double *phi, double *X, double *m_k, int K,
                      int n, int l, int m, double *ST) {
    // temporary variables
    double Knl, Anl_til, krond, numer, denom, coeff, _tmp;

    Knl = 0.5*n*(n + 4*l + 3) + (l + 1)*(2*l + 1);
    if (m == 0) {
        krond = 1.;
    } else {
        krond = 0.;
    }

    numer = gsl_sf_fact(n) * (n + 2*l + 1.5) * pow(gsl_sf_gamma(2*l + 1.5),2);
    denom = gsl_sf_gamma(n + 4*l + 3);
    Anl_til = -(pow(2., 8*l+6) / (4*M_PI*Knl)) * numer / denom;
    coeff = (2 - krond) * Anl_til;

    // zero out coeff storage array
    ST[0] = 0.;
    ST[1] = 0.;
    for (int k=0; k<K; k++) {
        _tmp = coeff * m_k[k] * phi_nlm(s[k], phi[k], X[k], n, l, m);
        ST[0] += _tmp * cos(m*phi[k]); // Snlm
        ST[1] += _tmp * sin(m*phi[k]); // Tnlm
    }
}

void c_STnlm_var_discrete(double *s, double *phi, double *X, double *m_k, int K,
                          int n, int l, int m, double *ST_var) {
    // TODO: I shouldn't have just copy-pasted this code...

    // temporary variables
    double Knl, Anl_til, krond, numer, denom, coeff, _tmp;

    Knl = 0.5*n*(n + 4*l + 3) + (l + 1)*(2*l + 1);
    if (m == 0) {
        krond = 1.;
    } else {
        krond = 0.;
    }

    numer = gsl_sf_fact(n) * (n + 2*l + 1.5) * pow(gsl_sf_gamma(2*l + 1.5),2);
    denom = gsl_sf_gamma(n + 4*l + 3);
    Anl_til = -(pow(2., 8*l+6) / (4*M_PI*Knl)) * numer / denom;
    coeff = (2 - krond) * Anl_til;

    // zero out coeff storage array
    ST_var[0] = 0.;
    ST_var[1] = 0.;
    ST_var[2] = 0.;
    for (int k=0; k<K; k++) {
        _tmp = coeff * m_k[k] * phi_nlm(s[k], phi[k], X[k], n, l, m);
        ST_var[0] += _tmp * _tmp * cos(m*phi[k]) * cos(m*phi[k]); // var(Snlm)
        ST_var[1] += _tmp * _tmp * sin(m*phi[k]) * sin(m*phi[k]); // var(Tnlm)
        ST_var[2] += _tmp * _tmp * sin(m*phi[k]) * cos(m*phi[k]); // covar(Snlm, Tnlm)
    }
}
#endif
</file>

<file path="gala/potential/scf/src/coeff_helper.h">
extern double STnlm_integrand_help(double phi, double X, double xsi,
                                   double density, int n, int l, int m);

extern double c_Snlm_integrand(double phi, double X, double xsi,
                               double density, int n, int l, int m);

extern double c_Tnlm_integrand(double phi, double X, double xsi,
                               double density, int n, int l, int m);

extern void c_STnlm_discrete(double *s, double *phi, double *X, double *m_k, int K,
                             int n, int l, int m, double *ST);

extern void c_STnlm_var_discrete(double *s, double *phi, double *X, double *m_k, int K,
                                 int n, int l, int m, double *ST_var);
</file>

<file path="gala/potential/scf/tests/data/computed-hernquist.coeff">
0           0           0  -1.0057553547018365        0.0000000000000000     
           0           1           0  -1.7891070404864942E-002   0.0000000000000000     
           0           1           1  -1.8193246827105047E-002   1.2184133088114271E-002
           0           2           0  -1.7192742805895292E-002   0.0000000000000000     
           0           2           1  -2.5073288272602995E-002   3.7807577650467765E-002
           0           2           2  -2.1202837742990630E-002  -1.0508646311633467E-003
           0           3           0   2.0473777361908172E-002   0.0000000000000000     
           0           3           1   3.5381236243487990E-002  -1.6007850427367330E-002
           0           3           2   1.3646734692758934E-002  -1.1424109562885700E-002
           0           3           3  -1.1277884062534518E-002  -4.5948554512636793E-003
           0           4           0  -2.0231706914587966E-002   0.0000000000000000     
           0           4           1   8.1652096738516394E-002   2.0657227962459730E-002
           0           4           2  -1.9810283609542314E-002   1.1652714166265466E-002
           0           4           3   6.7708352882058448E-003   8.3868515760214916E-003
           0           4           4  -4.1331948801702689E-003   1.8490422606209577E-003
           0           5           0  -6.6348545287153490E-002   0.0000000000000000     
           0           5           1  0.42864969996238728       0.40133763783451598     
           0           5           2   5.0585368043610336E-002  -1.2900436565368040E-002
           0           5           3  -1.2104702254656523E-002  -8.7357930733069546E-003
           0           5           4   5.0189026379321190E-003   5.3812079297120338E-003
           0           5           5  -4.4777248820398498E-004  -7.6997814353392752E-004
           0           6           0  -2.6888304648622823        0.0000000000000000     
           0           6           1  0.60051877284889754       0.20119706265634710     
           0           6           2  -5.7482914441719372E-002 -0.13661798135726155     
           0           6           3  -7.8861004788618441E-004   6.3050635539543464E-003
           0           6           4   1.6960304517006323E-003  -6.0912249673521976E-003
           0           6           5   1.5945971685501334E-003  -4.2598502856598105E-004
           0           6           6  -1.6813353775817458E-004   1.7131898086264008E-004
           0           7           0   13.811158590988986        0.0000000000000000     
           0           7           1  -1.1718300649335589        3.7618587820778657     
           0           7           2  -7.9878642443716827E-002  -1.5247868649838989E-002
           0           7           3   4.8259239440825136E-002  -1.4781806412261487E-002
           0           7           4   1.0865265692505481E-002   1.3448497858874815E-002
           0           7           5   8.0100404729614347E-004  -1.0318291535058675E-004
           0           7           6  -2.3434578758104338E-004  -4.7798041289893951E-004
           0           7           7  -2.6237861261866509E-005   4.5174558792828142E-005
           0           8           0  -48.811962699770518        0.0000000000000000     
           0           8           1  -4.8237949965299878        11.474688601012739     
           0           8           2  0.90062654457751001       -1.4168043135355182     
           0           8           3  -7.5018083509998890E-002   6.1881601066405334E-002
           0           8           4  -1.0711653133808457E-002   1.5012967267755715E-002
           0           8           5  -5.7446103749590489E-004   1.6301197147289683E-005
           0           8           6  -1.8762723293062425E-004  -7.4211281802233776E-004
           0           8           7  -6.0647790161183450E-005  -5.3955646569360521E-006
           0           8           8  -8.9274717318204841E-006  -3.2270766850726990E-005
           0           9           0   170.06854674078340        0.0000000000000000     
           0           9           1  -3.3376021167955487        15.816471356609323     
           0           9           2  -7.0648393411958776E-002  0.80971781436633361     
           0           9           3  0.29517426257041135       0.16727208740577165     
           0           9           4  -5.5994355721222133E-002   2.9225930754297077E-002
           0           9           5  -5.4371394173587488E-003   2.3523684089365333E-005
           0           9           6   1.1241196032973060E-004   5.4783332842797222E-006
           0           9           7  -4.5215060644693870E-005  -7.7578037137952756E-005
           0           9           8  -8.0171533478772851E-006  -1.4114696065449287E-005
           0           9           9  -2.3107249560628927E-006   8.8045705288970608E-007
           0          10           0  -86.482288675912542        0.0000000000000000     
           0          10           1   15.745929712916613       -85.762723715978211     
           0          10           2   4.3136027486653985        2.8843860925736204     
           0          10           3 -0.10773843842825899       0.61121023658426377     
           0          10           4   3.5440243782785832E-002  -4.2258961197398047E-002
           0          10           5   2.4048719359752806E-003  -2.5429660806883213E-003
           0          10           6  -1.1215794668719180E-003   2.5197472055490356E-005
           0          10           7   3.3672050815111495E-006  -6.5402035884282994E-005
           0          10           8   1.4473630550826083E-005  -1.0136224374235120E-005
           0          10           9  -2.2585995270753232E-006  -1.4126468345673932E-006
           0          10          10  -2.0461024496303656E-007   3.2967844637118868E-007
           1           0           0   2.0054711857580621E-003   0.0000000000000000     
           1           1           0   3.2651312093979951E-003   0.0000000000000000     
           1           1           1  -8.8812604118666053E-003   2.9174891982785820E-003
           1           2           0  -1.7515963250888437E-002   0.0000000000000000     
           1           2           1  -1.1021693869213908E-002   8.8270477777936500E-003
           1           2           2   3.3768589638711521E-003  -1.8858205790655697E-003
           1           3           0  -5.6063128063441679E-002   0.0000000000000000     
           1           3           1   8.0107249419955305E-003   3.4709014205334615E-003
           1           3           2  -6.3671772384033464E-003   5.5327257397455674E-003
           1           3           3   1.2749736715597438E-003   9.7095338926482273E-004
           1           4           0  -6.6067321240772955E-002   0.0000000000000000     
           1           4           1  -1.5054142083380058E-002   7.9644572827133765E-003
           1           4           2   4.6357589946867056E-003   3.1066562666821271E-003
           1           4           3  -1.9738250920108284E-003   1.0299659038830724E-003
           1           4           4   2.6404139035008913E-004  -5.3580151855441450E-004
           1           5           0 -0.21803802034781627        0.0000000000000000     
           1           5           1   1.1612962212665626E-002  -4.1757295841737756E-002
           1           5           2   1.4949830619379737E-002   7.8152496718431243E-003
           1           5           3   1.5945301560227616E-003  -1.3545133905164032E-003
           1           5           4  -4.9125827833410452E-004   4.5229114717772976E-004
           1           5           5  -1.6720144130699858E-004  -1.5081037110252493E-004
           1           6           0 -0.46994288629812392        0.0000000000000000     
           1           6           1   7.6761820851795337E-002  -5.8833853693170735E-002
           1           6           2   2.9924763090051217E-002  -4.3058139729419805E-002
           1           6           3  -4.1654834792538521E-003   9.6339865321948672E-004
           1           6           4   4.1229100743666507E-004   1.2947466414568655E-004
           1           6           5   1.6686385902510924E-004  -1.2032678070367403E-004
           1           6           6  -9.4709711071150235E-005  -6.8413617759212529E-005
           1           7           0 -0.43826532810678842        0.0000000000000000     
           1           7           1  0.50974779178249585        9.7981988204996553E-002
           1           7           2   7.0046490381902027E-002  -5.7056377790759248E-002
           1           7           3   1.9272407363475643E-003   7.5987794160017070E-003
           1           7           4  -3.7681854141665934E-004  -2.3388813136402654E-003
           1           7           5   1.8826316762946892E-006  -2.0660906786478425E-004
           1           7           6   6.8899472851753906E-005   5.5365921223587779E-005
           1           7           7   7.8548450368134490E-006   9.6596381747573360E-006
           1           8           0  -9.0021441051910145        0.0000000000000000     
           1           8           1 -0.70206405574637643       0.53082127933321976     
           1           8           2 -0.12714386266978994       0.12728738278331719     
           1           8           3  -6.2817464468749359E-003  -1.3800630057922628E-002
           1           8           4   3.5024408879010408E-003  -2.1881416210564691E-003
           1           8           5   2.2403005602808824E-004   1.5004622297188966E-004
           1           8           6  -1.7815566872388194E-007   8.6737085619078233E-006
           1           8           7   4.0510891816112585E-006   5.5193283544984126E-007
           1           8           8   1.1417336360595196E-006   2.3696183623569033E-006
           1           9           0   27.963677940030244        0.0000000000000000     
           1           9           1  -5.8235360529465172        3.3148192826988643     
           1           9           2  0.21779484940261662       0.21487059168243516     
           1           9           3  -3.1556754975977763E-002   1.9434069652818305E-002
           1           9           4   8.8438899056521875E-003  -9.0448893433216443E-004
           1           9           5  -8.2652209100941268E-004  -1.2010087207715925E-003
           1           9           6   5.8921667687280397E-005  -7.8771451173018862E-005
           1           9           7   1.4271687970736716E-005   9.0019509848749499E-006
           1           9           8  -7.4214301184645698E-007   4.2783416257247134E-007
           1           9           9  -1.4009816465657095E-007   1.8859135755697387E-007
           1          10           0  -53.695174506634764        0.0000000000000000     
           1          10           1  -13.607333931537276        18.236812211970033     
           1          10           2 -0.10139172900322999       -1.7229622944398342     
           1          10           3  -7.6006358804631843E-002   6.0566167820900553E-002
           1          10           4  -1.1189263735165661E-002   1.5992808432118245E-002
           1          10           5   6.8466540014839911E-004   1.7513129861134711E-003
           1          10           6  -2.0584150589401091E-004  -5.8433178569947160E-005
           1          10           7  -1.7666891117383476E-005   7.1912551688311656E-006
           1          10           8   2.6562410241865357E-007  -6.4116965455996811E-007
           1          10           9   5.2801810300004426E-009   6.8781334072961465E-008
           1          10          10   6.5991717458725683E-009   1.1917094405454564E-007
           2           0           0   5.0826639833751125E-004   0.0000000000000000     
           2           1           0  -1.7618608823290107E-003   0.0000000000000000     
           2           1           1   5.2696242598384811E-003   9.8764484129597015E-004
           2           2           0   1.9586465921677507E-003   0.0000000000000000     
           2           2           1   3.9617878107633727E-003  -1.2034254604959397E-003
           2           2           2   1.0789906991743442E-003   1.1277381631101648E-003
           2           3           0  -8.2316594463186718E-003   0.0000000000000000     
           2           3           1   3.3085859489090049E-003   3.5832231545676256E-003
           2           3           2  -1.7434948826152105E-004  -2.2813221056885904E-003
           2           3           3   3.2024777528269400E-005  -1.6041973251717717E-005
           2           4           0  -5.3593933429141143E-003   0.0000000000000000     
           2           4           1  -8.0020113889600220E-003   7.0540917884718887E-003
           2           4           2  -1.5904739533246853E-003   1.3881617084483785E-003
           2           4           3   7.6083871900559723E-005  -4.2113010138628395E-004
           2           4           4  -7.2568116531472284E-005  -1.5601709730060471E-004
           2           5           0  -8.9575374750130360E-002   0.0000000000000000     
           2           5           1  -2.0431581699054758E-003   1.6106379755626522E-003
           2           5           2  -1.2169158390166151E-003   1.2251561343717460E-003
           2           5           3  -2.5258165857432820E-004   1.4372127421155524E-004
           2           5           4  -5.0240424740963924E-005   8.9299437724705576E-005
           2           5           5   4.7257956328708598E-005   1.3919066961644476E-004
           2           6           0  0.18215637265919721        0.0000000000000000     
           2           6           1  -2.1548394902326011E-002   6.2199305679148366E-002
           2           6           2  -1.2836177747883730E-002   4.9680145732873887E-003
           2           6           3  -7.6918762854353550E-005  -4.4469627433309223E-004
           2           6           4   1.2168495933228140E-005   2.3607381497198719E-004
           2           6           5   5.2636991950403245E-007   3.7504958770271087E-005
           2           6           6   1.7647026545709172E-007  -5.3291582328560799E-006
           2           7           0 -0.64489157143908749        0.0000000000000000     
           2           7           1  -5.6826383495659535E-002 -0.10048145611064689     
           2           7           2   1.1426895059755368E-002   8.9791287462215666E-003
           2           7           3  -4.9799652125295313E-004  -9.0414391356977456E-004
           2           7           4   2.6821371774239850E-004   1.0899781557050416E-004
           2           7           5  -4.7583273954674574E-005   4.1479128043522386E-006
           2           7           6  -3.1527862322264226E-006  -2.0613711661277754E-006
           2           7           7  -2.3251577116424053E-006  -5.0306441075092283E-006
           2           8           0 -0.56394027304910099        0.0000000000000000     
           2           8           1  -3.6147946002741078E-002 -0.18248733060785738     
           2           8           2   9.8061257430459292E-003  -6.0715282876406566E-003
           2           8           3   1.4785157666433102E-003   1.4067893183848286E-003
           2           8           4   2.9259781159429829E-004   2.0034618163933114E-004
           2           8           5   4.6374232357746732E-005   1.4780195135567253E-005
           2           8           6  -1.3961666062827923E-005  -1.1471801443986313E-005
           2           8           7  -2.0906131015735951E-007   2.6182799620578290E-006
           2           8           8  -5.8128469081483722E-007  -4.2082541362486968E-007
           2           9           0  -2.9657097157979018        0.0000000000000000     
           2           9           1  0.22521483260041697      -0.28321269890566836     
           2           9           2  -3.3699872098964308E-002   8.3084283456399018E-003
           2           9           3   5.8810581058659425E-003   5.6236373677824711E-003
           2           9           4  -3.8689161073406840E-004   6.1090472320173708E-005
           2           9           5  -1.1142323238559402E-004   2.2905240897229745E-004
           2           9           6   1.0051233502651782E-005  -2.0307958953151089E-005
           2           9           7   3.2866827245466963E-007   5.8280571022530475E-007
           2           9           8   1.6202160295136399E-007   7.5899188377050548E-007
           2           9           9  -8.1995882679698939E-008  -1.4872099358928328E-007
           2          10           0  -17.019658693457252        0.0000000000000000     
           2          10           1  0.37609595831769205        1.7826514712463488     
           2          10           2  -7.8623896103839231E-003 -0.34048189805577878     
           2          10           3   3.4359242890201050E-002   2.3556509384315982E-002
           2          10           4   2.9085081748791443E-003  -4.2695243782586182E-003
           2          10           5   1.4563405113293611E-004   1.4548720843511687E-005
           2          10           6  -1.1480196541649275E-006  -2.3265777685995576E-005
           2          10           7   1.2677445577890437E-006  -6.0289465041338076E-006
           2          10           8   5.5639056070396330E-007  -5.8278830787630587E-007
           2          10           9  -5.1547906091423617E-008  -6.6189746056487467E-008
           2          10          10  -1.7691847253559642E-008  -5.5577566297297631E-009
           3           0           0  -5.4580468227726593E-004   0.0000000000000000     
           3           1           0   2.0851484890031993E-003   0.0000000000000000     
           3           1           1  -2.4769668393453542E-003   9.4431919689556755E-004
           3           2           0  -3.5623196658449027E-004   0.0000000000000000     
           3           2           1  -6.7758521932777163E-004   5.3395577971478831E-004
           3           2           2  -5.9324373728215094E-004  -1.9885909363590593E-004
           3           3           0   3.8817062272831129E-003   0.0000000000000000     
           3           3           1  -1.4916153884780012E-003   1.9936513227521234E-004
           3           3           2   6.7141240084761045E-005   1.5726170517147979E-004
           3           3           3   1.4289461129553312E-004  -4.7780349136610119E-005
           3           4           0   7.0940264605314348E-003   0.0000000000000000     
           3           4           1  -3.1669446074704837E-003  -2.3360342859557890E-004
           3           4           2   8.1813650169585051E-005   3.1055072425107043E-005
           3           4           3   8.0004496766606517E-006  -1.0943213029433051E-004
           3           4           4   5.6420598531525647E-006   1.0328243809807484E-004
           3           5           0   2.0132532647869107E-002   0.0000000000000000     
           3           5           1  -2.6884528746379931E-003  -3.2314447777165101E-003
           3           5           2   5.7022310743155206E-004  -2.9542079689964882E-004
           3           5           3  -1.0882181742801795E-004  -1.8564432845700316E-004
           3           5           4  -1.5817359000283349E-005  -4.4316625763224042E-005
           3           5           5  -7.9602538386695239E-006  -2.6455901535865390E-005
           3           6           0 -0.12093449207326655        0.0000000000000000     
           3           6           1   9.1520163944444777E-003   6.9812960204934374E-003
           3           6           2  -3.0451188772477497E-004   1.1296051544515951E-003
           3           6           3  -6.4086555838894382E-004  -2.2675315516622332E-004
           3           6           4  -6.5518186503812833E-005  -1.0581704312720306E-004
           3           6           5   2.9381473471085454E-006   5.8973834134786654E-006
           3           6           6  -5.3189453812453547E-007   4.0311294286824424E-006
           3           7           0  0.20768311624105895        0.0000000000000000     
           3           7           1   1.1358112298521727E-002   1.0798749258892867E-002
           3           7           2   5.0546349210895466E-004  -9.2136429680196076E-004
           3           7           3   1.3809335305426415E-004  -1.1279953772012949E-004
           3           7           4  -7.3233435092467136E-005  -2.7975229208120974E-005
           3           7           5   1.5138375734760376E-005   8.9534844770540746E-007
           3           7           6  -7.7429291128525466E-008   6.7582615678225363E-007
           3           7           7   9.7366251617983999E-007  -3.4112900154421662E-007
           3           8           0  -7.1313412426683431E-002   0.0000000000000000     
           3           8           1   1.2973695591204800E-003 -0.10550509033073990     
           3           8           2  -4.3095198837454383E-003  -2.9184686792466242E-003
           3           8           3  -1.0376949859877823E-003  -4.0512659542084209E-004
           3           8           4   6.0481430247696336E-005  -1.9189155140808154E-004
           3           8           5  -8.4017247118607565E-006  -2.3472279040758207E-005
           3           8           6   5.4007083767630478E-007  -3.9467655245126429E-006
           3           8           7   1.0991315796985149E-007   1.3771240022512028E-006
           3           8           8   1.0247610616400785E-007   6.1135106180793120E-008
           3           9           0   1.1361559153066956        0.0000000000000000     
           3           9           1  0.11607312293410108       -1.4482984940178184E-002
           3           9           2   5.2710669167170543E-002  -7.8644390905955944E-003
           3           9           3   1.6218454976482247E-003   8.2970041199874160E-004
           3           9           4   1.1855963286438422E-004   3.1844505234550173E-004
           3           9           5   3.9877860567764718E-005   2.4686938886689525E-005
           3           9           6  -1.0067824300889677E-006   7.1198094369512662E-006
           3           9           7  -8.1524885978321096E-007   9.7195878459420861E-007
           3           9           8  -1.3576834983270660E-007  -8.2198085523178036E-008
           3           9           9  -2.0305478920150071E-008   3.3258620576885339E-008
           3          10           0  0.72729134015939345        0.0000000000000000     
           3          10           1 -0.24859073180775679      -0.40718738574487567     
           3          10           2  -7.3937373493680927E-003  -7.9633474256919461E-004
           3          10           3  -8.4384576955973782E-003   2.0549461243836459E-003
           3          10           4   3.9039382636320107E-006   2.5744749139578642E-004
           3          10           5  -3.5265917428210253E-005   3.6120800717323324E-005
           3          10           6   4.7923746921407991E-006   4.5237648347008324E-006
           3          10           7  -9.7956498765850928E-008   9.7583042433143454E-007
           3          10           8  -1.5706315398945146E-007   5.9968986778745444E-008
           3          10           9  -1.4571042706271957E-008  -2.0327914497898411E-008
           3          10          10   7.2600806281739646E-009   3.9141745276629965E-009
           4           0           0   1.2484587562257353E-004   0.0000000000000000     
           4           1           0  -5.9953528959615998E-004   0.0000000000000000     
           4           1           1   1.1417600927261752E-004  -7.1966090718179030E-004
           4           2           0   3.7915777185961311E-005   0.0000000000000000     
           4           2           1  -3.6355206897553791E-004  -1.5612562009393785E-004
           4           2           2   3.5088022946385508E-005  -1.2921470695334409E-004
           4           3           0  -5.5574038778131031E-004   0.0000000000000000     
           4           3           1   5.5294732133218539E-004   2.5316232407164558E-004
           4           3           2   1.2509271328916559E-004  -6.0944543490224638E-005
           4           3           3  -6.3405822827418160E-005  -6.8860369298490227E-005
           4           4           0  -3.2971523114643994E-004   0.0000000000000000     
           4           4           1   1.9401173071355391E-003  -5.1997863290647098E-004
           4           4           2  -1.2671877207817622E-004  -4.0083894166863161E-005
           4           4           3   2.4965787105451009E-005   1.3952680284077979E-005
           4           4           4  -1.6320734027494639E-005  -5.7237839619370631E-006
           4           5           0  -4.3124158339884791E-004   0.0000000000000000     
           4           5           1  -7.5816752852977390E-004   1.1142424727643423E-003
           4           5           2   3.8737977348453415E-005   4.8979049649685886E-004
           4           5           3   7.7792825247887485E-005  -4.6082776992966973E-005
           4           5           4   1.0323202497169216E-005   8.0348936963051105E-006
           4           5           5   7.9653670278947141E-006   1.2131707217324661E-005
           4           6           0  -9.1041703194686355E-003   0.0000000000000000     
           4           6           1   3.9665569459135189E-003  -1.0631101782605009E-003
           4           6           2   1.6495282780452519E-003   2.6985620844805137E-004
           4           6           3   1.3802922474193916E-004   6.4298433441222923E-005
           4           6           4  -4.1892564729219796E-006   6.8406831998583935E-006
           4           6           5  -1.5426829274407850E-006   2.3962463857197790E-006
           4           6           6   6.9860029657367846E-007  -6.8135418477819329E-007
           4           7           0   1.2646590467261796E-002   0.0000000000000000     
           4           7           1  -1.1574555150840880E-002   7.6526742914657334E-003
           4           7           2  -3.3186356958028008E-004  -7.4198767449075356E-005
           4           7           3   2.8197792031885887E-004   2.8927236201441818E-005
           4           7           4  -1.1894023258596546E-005   6.1977604519384159E-006
           4           7           5  -4.6764340863944565E-006  -2.7871679739323016E-006
           4           7           6  -5.8749614152267271E-008  -8.6886870080538984E-008
           4           7           7  -1.1746337573491274E-007  -5.6034279225728573E-008
           4           8           0  0.10627046672017494        0.0000000000000000     
           4           8           1  -1.1253542775643671E-002   1.0049952725841981E-002
           4           8           2   9.6533251119131124E-004   1.8160493176711417E-003
           4           8           3   4.9080898210381529E-004   4.3889412330409513E-004
           4           8           4  -3.6099158709637569E-005   2.1572776888377915E-005
           4           8           5  -2.8488225679804872E-006  -1.7294278488850445E-006
           4           8           6   2.4173612378482771E-007  -1.0853205222996012E-006
           4           8           7   1.3008624291515734E-007  -2.4671967789922889E-007
           4           8           8  -3.2428478022940911E-009   3.5262983356931029E-008
           4           9           0  0.59375832323625033        0.0000000000000000     
           4           9           1  -6.0547181119962781E-002  -3.7819610821027250E-002
           4           9           2  -3.3488223727392678E-003  -1.5439741624893838E-003
           4           9           3  -7.3709658393858967E-004  -3.0579980503683677E-004
           4           9           4  -4.6458680798684640E-005  -1.0353000889259050E-005
           4           9           5   7.2606279272014335E-006   4.7395252976028061E-006
           4           9           6  -4.5220844992179947E-007  -1.9904115745064303E-006
           4           9           7   1.0684491111402539E-007  -9.6838922277486848E-008
           4           9           8   4.1393050913221936E-008  -1.3152786095509776E-008
           4           9           9  -1.4096894969767243E-008   5.7267000679214719E-009
           4          10           0   1.7925487777522358        0.0000000000000000     
           4          10           1   4.5704516058297152E-002   9.8295685558846380E-002
           4          10           2   2.9647990039205478E-002   1.6698691006334393E-002
           4          10           3   3.7872639443375835E-004  -6.5729195176315999E-004
           4          10           4   2.2492168398342198E-004  -2.0364362279124052E-004
           4          10           5   3.0584786435639623E-005  -8.3459378032250829E-006
           4          10           6   1.6432019821517735E-007  -2.1864624282850920E-006
           4          10           7   1.6238934844727705E-007  -9.6427905473114125E-008
           4          10           8   3.4788486367407247E-008  -2.0288106333694510E-009
           4          10           9   7.4909950077130288E-010   3.4373291718023413E-009
           4          10          10  -3.7530663665197426E-010  -1.4954073110112257E-009
           5           0           0  -4.0822087266337619E-005   0.0000000000000000     
           5           1           0  -1.7022706381283111E-005   0.0000000000000000     
           5           1           1   8.5034850624346025E-005   4.2380244886740736E-004
           5           2           0  -1.6477180497361866E-004   0.0000000000000000     
           5           2           1   6.9173895145727043E-005   1.4304179887470622E-004
           5           2           2   1.0702779312866454E-004  -4.6275914564313868E-005
           5           3           0  -7.7762457450370186E-004   0.0000000000000000     
           5           3           1  -3.8663344552653244E-004   1.6696241585568744E-004
           5           3           2  -2.9788240088983606E-005   5.1309301239127589E-005
           5           3           3   1.9262693016345563E-005  -1.3383464042133870E-006
           5           4           0   6.0212822155173795E-004   0.0000000000000000     
           5           4           1  -1.9344442293847968E-004   1.5700775582389598E-004
           5           4           2   9.7174433034294182E-006   6.0634073523522796E-005
           5           4           3  -4.0219162427522964E-006  -4.5337893329079384E-006
           5           4           4   8.7880352988149045E-006   8.4923495315274290E-006
           5           5           0   1.0884089180952547E-003   0.0000000000000000     
           5           5           1   6.9258760321410330E-005  -8.8219651047894386E-004
           5           5           2   1.6499818742466121E-004  -9.6763590716397830E-005
           5           5           3  -2.6171838359403089E-005   1.8415980360295110E-005
           5           5           4   2.9412463235038723E-006  -8.9192723830518526E-006
           5           5           5  -1.4955563083553196E-006  -1.1872320664493684E-006
           5           6           0  -5.7882602032597284E-003   0.0000000000000000     
           5           6           1  -3.0139556422554476E-003   9.9599252641289896E-004
           5           6           2  -3.5928532570461503E-006  -1.9475233944383583E-004
           5           6           3  -1.5862127314981486E-005   3.7606094261361573E-005
           5           6           4   4.4201003877605552E-006   8.3455750660105550E-006
           5           6           5  -2.6606252427818036E-006  -2.6634823919016786E-007
           5           6           6   1.0339593192788806E-007   5.2174951804671151E-007
           5           7           0  -8.8942785700655267E-004   0.0000000000000000     
           5           7           1   1.6387227379278091E-003  -1.9699648596504171E-003
           5           7           2  -3.1079086242941735E-004   4.3056809886668887E-005
           5           7           3   2.2393516537279953E-005   1.9131332774575786E-005
           5           7           4   1.9739927051232875E-006  -3.3617896428916640E-006
           5           7           5   4.2261507360930524E-007   1.3344674098567231E-006
           5           7           6  -2.9803805367072555E-007   4.5910162644948010E-008
           5           7           7  -6.8229126110466062E-009   8.4337520358242874E-008
           5           8           0  -5.3725852544345740E-002   0.0000000000000000     
           5           8           1   6.9926408344513254E-003  -3.8750156112191830E-004
           5           8           2  -7.3790624778569027E-004  -9.3522581325828171E-004
           5           8           3  -1.8992226424095703E-004  -2.4616920088563451E-006
           5           8           4   1.6033847493752185E-006   3.8628616271540428E-006
           5           8           5   2.2589557966150201E-006  -1.0379474809798478E-006
           5           8           6  -3.5426193852997648E-007  -1.6758475197670842E-007
           5           8           7  -9.6688469185956220E-009   1.0532522358441312E-008
           5           8           8   1.0035574863421382E-008  -8.4514155417755334E-009
           5           9           0 -0.18262716434565840        0.0000000000000000     
           5           9           1   8.1414332359541625E-003   1.1999251910980250E-002
           5           9           2  -3.1472520405238384E-004  -3.2035498642534110E-003
           5           9           3  -2.1787960337332600E-004   1.2420036967097017E-004
           5           9           4   1.3727009380792598E-005   1.9502628461299732E-005
           5           9           5  -1.8472661284934935E-006   4.2642082095340990E-007
           5           9           6   7.2534553103192780E-008  -2.9504773057515799E-007
           5           9           7  -6.3839429218981086E-008  -1.2858715274327965E-008
           5           9           8  -3.3556491767739913E-011   1.0817337458241120E-008
           5           9           9  -1.3774899847048886E-009  -6.6341675984417397E-010
           5          10           0  0.43670934989512555        0.0000000000000000     
           5          10           1  -1.0990165628049109E-002  -7.1182233624273367E-002
           5          10           2  -4.2959107211846337E-003  -3.7489965951406790E-003
           5          10           3  -2.0307872353298695E-004  -4.2022169862355817E-004
           5          10           4  -2.3448298540932588E-006  -7.7920914452012200E-006
           5          10           5   1.2100329851252683E-006   2.3511622008442197E-006
           5          10           6  -1.2781915709441691E-007   7.7066114106515627E-007
           5          10           7   8.1510924570078952E-008   5.2936743937150206E-008
           5          10           8  -1.1985149669543029E-008   5.8761101240044839E-009
           5          10           9  -1.9479305378167728E-010  -7.0488425530132678E-010
           5          10          10   4.5141144889776694E-010   2.6957873997317736E-010
           6           0           0  -1.1205087761690147E-004   0.0000000000000000     
           6           1           0  -6.6644520364487523E-005   0.0000000000000000     
           6           1           1  -5.4817499020080297E-005  -2.5048567031992576E-004
           6           2           0  -6.9854688084005490E-005   0.0000000000000000     
           6           2           1  -1.4503823833560870E-006  -3.6681400214589100E-005
           6           2           2   2.0990042399232726E-005   5.2539951955781204E-005
           6           3           0  -1.1671073243216297E-004   0.0000000000000000     
           6           3           1   1.5060729029466949E-004   1.7878356018287663E-005
           6           3           2   4.1012725990144489E-006  -2.8969254128764802E-005
           6           3           3  -7.3528490257491409E-006   9.0688439741167863E-006
           6           4           0  -2.0971182372846157E-005   0.0000000000000000     
           6           4           1  -1.3014515906096519E-004  -1.6542130201250860E-004
           6           4           2   1.3932016715534271E-005  -4.1382464113943184E-005
           6           4           3  -2.0019647175021900E-006   2.0283329181613351E-006
           6           4           4  -5.0408236378815827E-006  -3.0528957083162369E-006
           6           5           0  -1.0575927646745164E-003   0.0000000000000000     
           6           5           1   1.1417042419065466E-006  -4.5610158933365440E-004
           6           5           2  -6.9939202765174492E-005   6.5537215131353208E-005
           6           5           3  -2.5634574804762235E-006  -3.4162225361537077E-006
           6           5           4  -2.4611581289666683E-006   1.8850094582145002E-006
           6           5           5   1.0589690759346218E-006  -1.0853249653065834E-007
           6           6           0  -3.4187954619490306E-004   0.0000000000000000     
           6           6           1   1.0824244299505073E-003  -6.2595912419067623E-004
           6           6           2  -2.5562710451908272E-005   1.2415966528616360E-004
           6           6           3  -1.2272359898791735E-005  -1.7192546456658749E-005
           6           6           4  -2.3540760755697455E-006  -4.9027159385852368E-006
           6           6           5   7.4819011739109219E-007   6.0742861098265927E-009
           6           6           6   6.8021481218546486E-008  -1.2003549487990960E-007
           6           7           0  -4.3893255413245498E-003   0.0000000000000000     
           6           7           1  -1.1416537296266365E-003   1.7885822253428565E-004
           6           7           2   1.4215214258708067E-004   9.6338306719973067E-005
           6           7           3   1.3725376014190013E-005   5.6094961487703903E-006
           6           7           4  -1.0255266139010924E-007   2.6225958483037281E-006
           6           7           5   5.1450809976841945E-007  -3.4247939692565699E-007
           6           7           6   1.1680475575950724E-007  -3.3892027922781915E-008
           6           7           7  -3.9085558014725729E-008  -2.0937917925292689E-008
           6           8           0   2.0516601790207026E-003   0.0000000000000000     
           6           8           1  -5.9845112768387525E-004  -2.0687911981164095E-003
           6           8           2  -3.6076766897543929E-004   7.7677353344126211E-005
           6           8           3   1.2463080846879336E-005  -2.7215367931731194E-005
           6           8           4  -4.8123822041870360E-006  -4.6257725318198618E-007
           6           8           5  -2.5767415555785668E-007  -3.2668681449782604E-007
           6           8           6  -6.4153769924800805E-008   1.3390285915545545E-007
           6           8           7  -8.1356028900567398E-009   1.2137346929734363E-008
           6           8           8  -2.3493970474138765E-009  -1.2810258589109376E-009
           6           9           0  -2.5078338055646892E-002   0.0000000000000000     
           6           9           1  -6.6088086089733245E-004   1.7762353458403725E-003
           6           9           2   5.3560451431282005E-004   7.0913470350902896E-004
           6           9           3   1.1579192196210454E-004  -8.4483945142419567E-005
           6           9           4   6.9557453289127198E-006  -9.5576022606804223E-006
           6           9           5   1.7279792012539475E-006   1.5162487846783297E-006
           6           9           6   2.4032053334955993E-008   3.0087353144573379E-007
           6           9           7  -6.1579901316244174E-009   1.6145342936009076E-008
           6           9           8  -1.9276446784388169E-009  -1.1081990348128972E-009
           6           9           9   5.2496634186921284E-010   1.1014097468783538E-010
           6          10           0   3.8365251899441753E-002   0.0000000000000000     
           6          10           1  -9.1329661098295788E-003   1.7579462960261619E-003
           6          10           2  -2.5088710699969295E-004   3.3946556168095760E-003
           6          10           3   9.2060054467726617E-005   7.7421560006214553E-005
           6          10           4   3.1633857724347186E-006   8.4733678592361611E-007
           6          10           5  -4.5097165073893203E-007  -2.3628958037565561E-007
           6          10           6   1.0159891487636674E-007   1.5344842581303489E-007
           6          10           7  -6.6340012657443420E-009  -9.6741893884202245E-009
           6          10           8   4.6370116455433031E-009  -2.3825247802518148E-009
           6          10           9  -2.4209412670845549E-010   1.9960591921293462E-010
           6          10          10  -1.9416411521198454E-011  -2.9516366479404090E-010
</file>

<file path="gala/potential/scf/tests/data/multi-hernquist.coeff">
3
0 0 0 1.0 0.0
1 0 0 0.1 0.0
2 0 0 0.05 0.0
</file>

<file path="gala/potential/scf/tests/data/plummer_coeff_nmax10_lmax5.txt">
1.304434625064201658e-01 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.439343900240657457e-03 0.000000000000000000e+00
-3.129058292531008631e-03 6.921619177617611756e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-2.581491437328634238e-03 0.000000000000000000e+00
-6.728266117825634773e-04 2.205723286922194482e-03
8.671023279691653009e-04 7.205922972199911743e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-6.581251343708807711e-03 0.000000000000000000e+00
-1.194330047000859499e-02 8.194561933078515006e-03
1.056532954992223973e-03 -3.120601013877618863e-03
-1.326623579967563596e-02 2.615749198945627445e-03
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
1.376411683319737076e-03 0.000000000000000000e+00
-2.075099702183726483e-02 4.531682575732806466e-03
-2.529479631493424668e-03 -4.659173485126370112e-02
-1.138839020870170606e-03 -3.362298424469774283e-02
1.069240923479596560e-02 1.980674151590648864e-03
0.000000000000000000e+00 0.000000000000000000e+00
-5.532662863400076431e-02 0.000000000000000000e+00
6.372093799154628091e-02 -2.599044394270757022e-02
-5.683778551138042590e-02 4.748118610795373784e-02
2.030992311135371847e-02 1.760347459244713392e-02
1.325859027505918442e-01 -2.813076607673856838e-02
5.165708023981169239e-02 7.390343659543437138e-02
4.109321959164383343e-05 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
3.453261446066403762e-04 0.000000000000000000e+00
-6.285378762138135310e-05 1.230487964726284967e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
4.143831066159271259e-04 0.000000000000000000e+00
1.076667929557620666e-03 -5.626664924611220892e-04
1.183559128303013656e-04 -2.558474312053322561e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.430190394100834886e-03 0.000000000000000000e+00
-2.772765133368108176e-03 2.984217854820448530e-04
6.891782006831674925e-04 1.092871838394224304e-03
-2.134925568561857074e-03 8.330201475862573056e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
2.411276659171514639e-03 0.000000000000000000e+00
7.404986463712261852e-03 -3.821078990167115722e-03
-8.883737075693943792e-04 1.154906799782482460e-03
-5.507932758824355454e-04 8.697917880693108172e-03
-3.981324406349732135e-03 3.845042014490551024e-03
0.000000000000000000e+00 0.000000000000000000e+00
8.694748914922967656e-03 0.000000000000000000e+00
1.821435161325079535e-03 2.462662038380764723e-03
7.626511370216215203e-03 -4.727696746874375695e-03
5.955799208694712889e-03 -1.445856695250371041e-02
-1.174096156720067993e-02 -4.220657022257651506e-03
2.251575951158383757e-02 -2.385716932497319864e-02
-6.245875059439466061e-03 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.099169574658092697e-04 0.000000000000000000e+00
1.575563794648594308e-04 2.478235525590057823e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
7.191357794823988528e-05 0.000000000000000000e+00
7.450705020331181412e-05 7.593530303276212927e-05
-2.131526859309371938e-04 -4.343655579324548813e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
2.202960026198896360e-04 0.000000000000000000e+00
4.762537814177440374e-04 -3.205125574587600447e-04
-2.742572569445001683e-05 1.985689005807942244e-04
9.200698017212266544e-04 3.287825465640080934e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-3.163173695521699939e-04 0.000000000000000000e+00
-9.505475780980315132e-04 -2.432898070976638699e-04
-1.045991431523721508e-03 -1.871375789779506325e-03
8.042458130626786890e-04 -9.963000320803564770e-04
-5.535771480262208135e-04 -1.039816649679743210e-03
0.000000000000000000e+00 0.000000000000000000e+00
-1.764313919970723725e-03 0.000000000000000000e+00
-2.233324198683913145e-03 1.098382965858850325e-03
-9.780876258116232957e-05 9.699105994771298721e-04
1.046341102267151239e-03 2.619020153031520731e-03
-1.014837757442827630e-03 2.729408438002430340e-03
-6.312590895618967529e-04 1.780076542834160662e-03
-4.454336215801040541e-05 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-6.856854572295220107e-06 0.000000000000000000e+00
-7.841864373574215492e-05 -1.118868504363355118e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
1.648074688432395437e-05 0.000000000000000000e+00
-2.111308967918107805e-04 -1.955046164326432355e-05
-8.720136009562520069e-05 4.062569648161322383e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
1.485155448360843400e-04 0.000000000000000000e+00
2.256761180958199466e-04 -3.773856407221754764e-05
-2.422064639250435278e-04 7.131298046645498444e-05
2.296504805054935503e-06 -2.012723169486858366e-04
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.560827879165303475e-04 0.000000000000000000e+00
-1.340284633957868695e-04 -2.376341934360842097e-05
-1.660793710070972162e-04 3.752853428834111672e-04
1.459164561972175653e-04 -5.051899816343666380e-04
1.963115986488453782e-04 -4.116822002319337013e-04
0.000000000000000000e+00 0.000000000000000000e+00
2.473673083235440693e-05 0.000000000000000000e+00
1.977325985589657622e-04 1.127307839841890612e-03
-3.552722618387055666e-04 -4.929479669471027725e-04
-1.575309329347667300e-04 -7.916674383866514919e-05
1.291188421747252978e-03 -1.721871618326903657e-04
-4.733772649175980763e-05 -4.670395506495363699e-04
5.755437594244592735e-04 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-4.889266108270894070e-06 0.000000000000000000e+00
-7.821785713684144663e-06 1.680676013803841188e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-3.100890063341312229e-05 0.000000000000000000e+00
6.106111790867447273e-05 7.054877160525870394e-06
8.337320877263439632e-05 2.011667006758752151e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-7.342190911282240381e-05 0.000000000000000000e+00
1.741140349733171435e-05 4.017675997724581702e-05
-5.098109137226668506e-05 2.458562235145258157e-05
-6.619064261263156587e-05 -7.670903444430240121e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
9.724383878580921900e-05 0.000000000000000000e+00
9.625279301384229570e-05 6.412162812899151968e-05
1.913757931187845724e-04 1.846020727879679608e-06
-9.975246150484625037e-05 2.440484138439270824e-04
1.800910683028545569e-05 5.832548946715759559e-05
0.000000000000000000e+00 0.000000000000000000e+00
1.281818068932058139e-04 0.000000000000000000e+00
-2.555544093995338727e-04 -1.960499860662581935e-04
2.245617041150458032e-04 5.437662795816716136e-04
-2.481942501044721557e-04 1.804202481731724799e-04
-7.650816800662619600e-05 -2.832006022871280814e-05
9.909353599822405751e-05 -4.639549114871540611e-05
9.970659052252758234e-06 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
2.884349749719073380e-06 0.000000000000000000e+00
2.441468367608399081e-05 -1.435239622880282575e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
3.724114221485872788e-06 0.000000000000000000e+00
1.998678071995217922e-05 8.125301894157419631e-06
5.235955655655371523e-06 1.738220063145758801e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.785108392427998652e-05 0.000000000000000000e+00
-6.328092691343508921e-05 8.429906211832557304e-06
5.842576038526473285e-05 -4.186353254978873435e-05
1.214082292188408249e-05 2.451183796238299775e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.284868933836862448e-06 0.000000000000000000e+00
-1.561398234923812230e-05 1.490184826282580221e-05
1.254168362373678326e-06 -6.126656578853878802e-05
-2.055826660164001093e-05 -3.846529541565431261e-05
6.517538434031610572e-06 7.745055744442566061e-05
0.000000000000000000e+00 0.000000000000000000e+00
1.478262728721372941e-05 0.000000000000000000e+00
1.603274481682154549e-05 4.491598841742159935e-06
-1.118816857914054294e-04 1.060385802643919359e-05
-5.303188573825791321e-05 -2.243687971532007391e-05
5.009818679269007391e-05 3.548723736967405442e-05
3.778487721358077570e-05 5.638954419405082310e-05
-5.840656296845502557e-05 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
6.736775884001822605e-06 0.000000000000000000e+00
7.962947215209853564e-06 1.191689697190123280e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
9.501224706322899361e-06 0.000000000000000000e+00
-9.020936496553465448e-06 6.425005961385313195e-07
-5.529032467452674796e-06 -1.019282588364806918e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
2.096773858577811634e-05 0.000000000000000000e+00
3.979078054903180175e-06 -1.438064572388084900e-05
5.713301919354310361e-06 7.192415200602913848e-06
2.128097141410034959e-05 1.028332952774682338e-05
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-2.815911568980001748e-05 0.000000000000000000e+00
2.665653443698168117e-06 -1.472841581686814786e-05
-2.732278121390535359e-05 1.260433087507474647e-05
3.142504824508865409e-05 -1.836120349401925923e-06
-2.990151112953675033e-05 -1.167879053341489046e-05
0.000000000000000000e+00 0.000000000000000000e+00
-1.866437815431127331e-05 0.000000000000000000e+00
7.419736482629750310e-05 4.609228098551572357e-05
4.230752571316732100e-05 -1.228895957492147936e-04
7.496075538629683546e-05 2.185597116295610098e-05
2.241233724416355583e-05 8.541059024044979849e-06
-1.494248126537928758e-05 2.705383729513708332e-05
4.270991754891668838e-06 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
1.819641380601381200e-06 0.000000000000000000e+00
-5.872475378451113167e-06 1.259263866052971703e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-3.450830730295567427e-06 0.000000000000000000e+00
2.597868841564937610e-06 -5.326483180411220231e-06
-5.088308032168992359e-07 1.036704021745175158e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-2.543451499281563293e-06 0.000000000000000000e+00
9.728674506409675296e-06 6.025696310445161686e-06
-4.974526004525086173e-06 2.720649861617755288e-06
-4.201055070709284495e-07 -4.228514798910577297e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
8.928525175557225382e-06 0.000000000000000000e+00
-3.918642445174474147e-06 -6.572256963260701923e-06
5.335607889462749693e-06 1.354810964882532624e-05
-2.656485543359852701e-06 3.256283528027096609e-07
-1.620450673005140737e-06 -2.045104502152567351e-07
0.000000000000000000e+00 0.000000000000000000e+00
-8.850174239400176721e-07 0.000000000000000000e+00
-1.838828553200937011e-05 8.445115665831431670e-06
-4.336060735184760177e-06 9.951827892384611522e-06
-2.600245588896701827e-05 -1.507662643774671361e-05
-3.492376380855933323e-05 -3.366016210112201477e-05
-5.739764471032531206e-06 1.548849254065660434e-05
-9.795793045089899370e-06 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-3.351925983618716022e-06 0.000000000000000000e+00
-6.987149996304767616e-07 -3.561158892310595392e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.831224835567532322e-06 0.000000000000000000e+00
-2.365143208424990369e-06 3.860790931880018931e-07
-3.783959268088811988e-07 4.006856678565868190e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-2.399017350079396918e-06 0.000000000000000000e+00
1.490538858865357756e-06 -2.150452307748374249e-06
-3.003997099557287875e-07 -3.479902394262972312e-07
-2.163979077885408800e-06 -7.437277877562604192e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
2.314187012574232976e-06 0.000000000000000000e+00
6.081796667252602831e-06 3.616008105480609300e-06
-1.377776292899372955e-06 -6.900097470965827353e-06
-6.647638855868451568e-06 -2.200801587743863170e-06
1.163266562071029116e-05 -7.119645962329327105e-07
0.000000000000000000e+00 0.000000000000000000e+00
3.054825732269478577e-06 0.000000000000000000e+00
6.971335229183869107e-06 -1.719540610739949627e-05
-1.168034586322194109e-05 1.349780252864542939e-05
1.104292154768494567e-05 -6.984058118109886942e-06
4.060497827638037072e-06 1.492975444771517132e-05
8.956469895688857471e-06 -1.417838660118450628e-06
-1.878085410125813063e-06 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-2.561513314710346999e-06 0.000000000000000000e+00
3.998126944512776706e-07 2.235979141154641425e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
8.403045257038042587e-07 0.000000000000000000e+00
9.929490824847277457e-07 2.103276618519428488e-06
2.380943348849475002e-07 -2.557907068286337071e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.121952800263125177e-06 0.000000000000000000e+00
-2.373644160211889600e-07 2.243386172560191973e-07
5.056657584927242192e-07 -1.442883552704267060e-06
2.634560833471630544e-07 -2.560289521348768220e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
-1.460611267514909573e-06 0.000000000000000000e+00
1.796197982199792562e-06 -4.790405338991362705e-06
-2.199175422988432862e-06 -1.541535876302072589e-06
2.377002400121986390e-06 2.999554539870974747e-06
-4.993919215867527423e-06 2.135618803853240912e-06
0.000000000000000000e+00 0.000000000000000000e+00
-1.799745988768611524e-07 0.000000000000000000e+00
1.083625156687995180e-06 1.877616546750391271e-06
7.233392723400661863e-06 -9.803864710390580817e-07
-9.251346992246597385e-07 1.782842415241592558e-06
4.376861547887300820e-06 1.988059187996584017e-07
1.426259014464856113e-06 -5.415999458248678548e-06
1.398660187900680145e-05 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
1.873995580893917312e-06 0.000000000000000000e+00
-4.981638440253702015e-07 1.044526142252208167e-06
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
6.133030417146916056e-07 0.000000000000000000e+00
-5.495810682008039152e-07 -6.761617378116299236e-07
9.618987677065846455e-07 7.040639900698219721e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
3.911629150463877622e-07 0.000000000000000000e+00
-1.721740466233316291e-06 4.267469919835734111e-07
-1.567724336201443722e-06 -1.229409022945579084e-07
-6.317731785752117489e-07 -2.645467196340974731e-07
0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00
7.144547697102718910e-07 0.000000000000000000e+00
-2.990794295510930245e-06 1.002727849520059236e-06
2.099794565567973999e-06 6.859935555064075368e-07
9.155676712583608323e-07 -2.094584098099119314e-06
-4.253270067044640701e-07 -2.661566770531764332e-06
0.000000000000000000e+00 0.000000000000000000e+00
-6.599705024862042910e-07 0.000000000000000000e+00
-4.074638633640298232e-06 3.305215111875517394e-06
3.783987706205318015e-06 -1.041936237348737632e-06
-1.249215811181738234e-06 2.027647620083294914e-06
-1.849298779812065456e-07 1.303782405880884547e-06
-1.519779329623025048e-06 1.692601264332519547e-06
</file>

<file path="gala/potential/scf/tests/data/plummer_coeff_var_nmax10_lmax5.txt">
1.955542420667336910e-06 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.501694738331875903e-06 0.000000000000000000e+00 0.000000000000000000e+00
3.069974360420259202e-06 3.058244723598650198e-06 8.259305429235818083e-09
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
5.151475760715934999e-06 0.000000000000000000e+00 0.000000000000000000e+00
1.038563355002337311e-05 1.035077180930233886e-05 -1.589996923167818011e-07
1.058534066643928995e-05 1.043526748767122636e-05 -1.129025988375223285e-08
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.902924507841970914e-05 0.000000000000000000e+00 0.000000000000000000e+00
5.720866869013867338e-05 5.676538685279609712e-05 -4.399557984988813699e-07
5.874248691105214172e-05 5.753466544441846934e-05 2.529302209277357381e-07
5.930885644358156294e-05 5.781732253073513031e-05 3.265804064070954633e-07
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.073773228526394694e-04 0.000000000000000000e+00 0.000000000000000000e+00
4.129940370202110850e-04 4.031100235969758624e-04 -5.404526211741658649e-06
4.068099631203810291e-04 4.122789531152861570e-04 3.458183832150718069e-06
4.168211653823444287e-04 4.169496562075238749e-04 -6.709829757764032992e-06
4.162940666034420497e-04 4.211183084448069159e-04 -5.012489664447216521e-07
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.750464741414420929e-03 0.000000000000000000e+00 0.000000000000000000e+00
3.365212565029881628e-03 3.357546932682020906e-03 -3.913630922346395224e-05
3.367548043722668437e-03 3.464627647149332024e-03 7.015539873152493997e-06
3.429006899756932222e-03 3.412635078887994028e-03 -1.458127332528042313e-05
3.457991023531225682e-03 3.499182327842530020e-03 -1.244260515000052001e-06
3.511213062423861227e-03 3.466013425050964904e-03 -1.835077914063982228e-05
6.154249653618050666e-08 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.292690044024561206e-08 0.000000000000000000e+00 0.000000000000000000e+00
1.279286089304920707e-07 1.291034671431923107e-07 2.694255353134101858e-10
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.996501579758773836e-07 0.000000000000000000e+00 0.000000000000000000e+00
3.987160054579043966e-07 4.101032541954881082e-07 -1.294555217018412604e-08
4.066324252119791976e-07 4.050754495337268223e-07 -4.210152820923436036e-09
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.013671287198434257e-06 0.000000000000000000e+00 0.000000000000000000e+00
1.958515702176806657e-06 1.995554363946965203e-06 -4.637858321334611655e-08
2.043820831120128426e-06 2.021575982631594098e-06 1.473407114508798328e-08
2.055743341201720956e-06 1.962191442597902465e-06 1.374838256550107891e-08
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.392246238862768901e-06 0.000000000000000000e+00 0.000000000000000000e+00
1.271015911567457694e-05 1.292825328955402627e-05 -3.887426971875215156e-07
1.258116908611657525e-05 1.284891344270544819e-05 1.919640170527257559e-07
1.317195963089071501e-05 1.290636031074247607e-05 -2.542102831953534507e-07
1.279788639832947623e-05 1.273508661884189125e-05 2.263529674166630785e-07
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
4.827952819300896677e-05 0.000000000000000000e+00 0.000000000000000000e+00
9.424190585875452469e-05 9.619748794811842116e-05 -1.830597753594446977e-06
9.409720482618970448e-05 9.798929279871706165e-05 1.440832166805832670e-07
9.712011382941124768e-05 9.479951262107583492e-05 -1.296922239481954883e-06
9.708587573072389532e-05 9.833972372083668579e-05 7.190463629596031577e-07
9.420745442128132616e-05 9.632840047672453973e-05 1.053309449877799526e-06
1.225482878202881586e-08 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
7.464117858255532386e-09 0.000000000000000000e+00 0.000000000000000000e+00
1.603756650060489091e-08 1.528404488601745721e-08 5.127699473812801457e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.813605025125152232e-08 0.000000000000000000e+00 0.000000000000000000e+00
3.665643979662440699e-08 3.537502726315677454e-08 -8.117927148333732987e-10
3.761204488745535171e-08 3.752925586629598854e-08 -1.748863531942093784e-10
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
7.553257701569056366e-08 0.000000000000000000e+00 0.000000000000000000e+00
1.444364176537227846e-07 1.454893275729833864e-07 -1.610931415441400672e-09
1.492092997719821444e-07 1.480794624014914403e-07 1.534429683566218053e-09
1.552101904976523698e-07 1.505843079498609427e-07 1.229818546584380122e-09
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
4.069010689945093577e-07 0.000000000000000000e+00 0.000000000000000000e+00
8.104525375393547929e-07 8.177744814249472170e-07 -2.042535350388787241e-08
7.916456651401325181e-07 7.906252794534128260e-07 1.088058102364256104e-08
8.291716668581216286e-07 8.189756966554863425e-07 -7.926230074630115705e-09
8.359641930885894215e-07 8.281664412304361511e-07 -1.143199183504787219e-09
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.720014684206167938e-06 0.000000000000000000e+00 0.000000000000000000e+00
5.259830469348248607e-06 5.373791015996052541e-06 -7.166972530140828425e-08
5.311951661239744218e-06 5.359586231834790811e-06 9.287061415112108138e-08
5.325149562224412970e-06 5.189122260897168688e-06 -3.367734267982601723e-08
5.399269834420611753e-06 5.566331353916384709e-06 4.322966253025839644e-08
5.447959635802507371e-06 5.446707065103944059e-06 1.005112378086796415e-08
3.224844499646951859e-09 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.477318053130910693e-09 0.000000000000000000e+00 0.000000000000000000e+00
3.034163581499809991e-09 2.942623390103944677e-09 -4.475096631152589526e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.663159752296150455e-09 0.000000000000000000e+00 0.000000000000000000e+00
5.561794821162051498e-09 5.484476140118572450e-09 -1.201807257515811292e-10
5.464795865159360144e-09 5.615521558762375658e-09 -9.638926171029957453e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
8.852014042347463434e-09 0.000000000000000000e+00 0.000000000000000000e+00
1.789763909375238255e-08 1.759074511200920497e-08 3.213564720807068699e-10
1.798536469551458735e-08 1.817932743751014468e-08 1.088831753081169398e-10
1.886128435679916301e-08 1.770158012412863226e-08 1.268207436401327458e-10
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
4.072058647044656389e-08 0.000000000000000000e+00 0.000000000000000000e+00
8.273370562157914736e-08 8.005955215778657427e-08 1.431993723210857483e-10
7.979543411745320842e-08 8.150617083116538310e-08 -6.489307147848282612e-12
8.486192562844999565e-08 8.114880315855176395e-08 -3.776808503460354424e-10
8.495415567469645829e-08 8.312417679734297727e-08 -7.424138699462392538e-10
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.344545693382513998e-07 0.000000000000000000e+00 0.000000000000000000e+00
4.645145219072512296e-07 4.605438601691486079e-07 -3.231510145114265867e-10
4.506339352411797537e-07 4.671678403189288886e-07 -3.219675785686195465e-09
4.773555754415972091e-07 4.409186091709433092e-07 2.407548285263202807e-11
4.765006121275016015e-07 4.749775451811467544e-07 8.796519695288754818e-09
4.798858185213348706e-07 4.781573564714084898e-07 1.133659542996676267e-08
1.124878401910943608e-09 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.499637068527346058e-10 0.000000000000000000e+00 0.000000000000000000e+00
7.259939440283042018e-10 7.084754464518281134e-10 -1.033141806227861822e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
5.139642031541438449e-10 0.000000000000000000e+00 0.000000000000000000e+00
1.053513443368176093e-09 1.053352657525335080e-09 -4.926029840905539569e-11
1.089173683146579052e-09 1.036255587192240977e-09 -2.260323240570193669e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.401027176183919621e-09 0.000000000000000000e+00 0.000000000000000000e+00
2.798842608211604154e-09 2.945904068341456618e-09 -2.999853474555550255e-11
2.878814370328683252e-09 2.951698753547726017e-09 5.780384667095386705e-11
2.937295171752520237e-09 2.873970351902024333e-09 6.348939411611532766e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
5.389602361998939282e-09 0.000000000000000000e+00 0.000000000000000000e+00
1.120343210643673065e-08 1.126594910784988289e-08 -2.074619025339290647e-11
1.074881864447610285e-08 1.155057449524051064e-08 1.962591651562543713e-10
1.137010920167736542e-08 1.131825725644974821e-08 7.956810518373705519e-12
1.144768871452673022e-08 1.115278310891438586e-08 -4.127562578486695071e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.690972075872912806e-08 0.000000000000000000e+00 0.000000000000000000e+00
5.446150025742075829e-08 5.511094062951710029e-08 2.689585392497582786e-10
5.298199956252860320e-08 5.648092829024149550e-08 -3.786914345043207495e-10
5.612943494589317206e-08 5.380058054339198258e-08 2.737082136164978462e-11
5.546975580455735950e-08 5.591385722116058478e-08 5.836243659309952976e-10
5.587690770640462459e-08 5.564491980827620397e-08 1.757929740399571071e-09
5.049647647648927402e-10 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.061924382871060242e-10 0.000000000000000000e+00 0.000000000000000000e+00
2.202656389670875193e-10 2.106697541155129628e-10 -4.413176821609211320e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.201460836114832518e-10 0.000000000000000000e+00 0.000000000000000000e+00
2.454730115040905277e-10 2.340576983038293002e-10 -1.033954966706560048e-11
2.521398284896769111e-10 2.421442605616351184e-10 -1.149839393469590103e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.742972736334709864e-10 0.000000000000000000e+00 0.000000000000000000e+00
5.539717593307005421e-10 5.490408639609299650e-10 4.017250574855704644e-13
5.678437518365972118e-10 5.559881062740458057e-10 -6.118837899306465003e-12
5.819912614734698550e-10 5.557215121533186650e-10 -1.464407152092444426e-12
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
8.925003964493838748e-10 0.000000000000000000e+00 0.000000000000000000e+00
1.916282514485573543e-09 1.887376723637087531e-09 1.311207454393070694e-11
1.825882227947816716e-09 1.869303291148545783e-09 -7.383151625741304712e-13
1.939911329336631862e-09 1.898131738699123073e-09 -3.521008268199570280e-11
1.913775970645862643e-09 1.900661973865388344e-09 -1.679196658763610760e-11
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.850345845898911280e-09 0.000000000000000000e+00 0.000000000000000000e+00
8.189737273755337455e-09 8.063950071614595091e-09 2.070132683972923640e-11
7.946804899553253617e-09 8.298969277178271070e-09 -3.915996254960506300e-11
8.124636962946553703e-09 7.785341442156637416e-09 7.112366543801725829e-11
8.257077076209882429e-09 8.444717679195313920e-09 1.814522649539691177e-10
8.195625700143349606e-09 8.230589444527513729e-09 1.619366564449920151e-10
2.418440340438496756e-10 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.853946281892877164e-11 0.000000000000000000e+00 0.000000000000000000e+00
7.749455342225214758e-11 7.591778670447883394e-11 -1.595241057777848666e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.296120646087236366e-11 0.000000000000000000e+00 0.000000000000000000e+00
6.637196675454028342e-11 6.532890753648263445e-11 -3.280896230597016365e-12
6.805380605123305986e-11 6.576405636206745189e-11 -9.373654831394700376e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.111103762906620979e-11 0.000000000000000000e+00 0.000000000000000000e+00
1.240450011539199367e-10 1.264372621388873612e-10 -2.145624207165082390e-12
1.250493371430281574e-10 1.246950236368058953e-10 -3.200876667763571251e-12
1.291256047539483158e-10 1.254185842184306650e-10 -3.299242081843928883e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.787803859218156691e-10 0.000000000000000000e+00 0.000000000000000000e+00
3.596382069019199190e-10 3.621612221764095659e-10 2.734766022671124478e-12
3.683229885692087969e-10 3.692806219911911473e-10 -1.175316110186545283e-11
3.679745095442539873e-10 3.661686361561307558e-10 -7.334670494422035345e-12
3.755491774054564274e-10 3.647889129635244117e-10 -8.242797102648938796e-12
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.660129830895630122e-10 0.000000000000000000e+00 0.000000000000000000e+00
1.376999553686192842e-09 1.402526839466798447e-09 5.687726226270321907e-12
1.382187607858145117e-09 1.390017261759421558e-09 1.340689623476634822e-12
1.432141988881250787e-09 1.370850577344738421e-09 -2.253456629926024008e-11
1.387959185737627580e-09 1.432532819308312155e-09 2.830125350507720713e-11
1.400134613246773099e-09 1.397094231850021292e-09 7.196996999012667057e-12
1.259120822309661796e-10 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.518549224437385860e-11 0.000000000000000000e+00 0.000000000000000000e+00
3.109752967129153372e-11 2.995735260977583622e-11 -5.021268050847311868e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.044168775802168580e-11 0.000000000000000000e+00 0.000000000000000000e+00
2.133702479429557412e-11 2.055186697805852174e-11 -5.880587737822933244e-13
2.176826907389185543e-11 2.068825501328848133e-11 5.919261427115326027e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.609538189193252476e-11 0.000000000000000000e+00 0.000000000000000000e+00
3.204046599460035641e-11 3.129653320785798314e-11 -8.002329319651215602e-13
3.261500288032126370e-11 3.194270132866781855e-11 -6.670217957958855340e-14
3.352821642687519244e-11 3.248948207336120152e-11 -3.579545010593330895e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.939493462142988876e-11 0.000000000000000000e+00 0.000000000000000000e+00
8.178919267177747509e-11 8.051482762589722519e-11 -2.132360708453290293e-12
7.960144653802840713e-11 8.114934776985525454e-11 -2.611256696134488503e-12
8.129725688281082125e-11 8.177738902902640040e-11 -2.193438898293965193e-12
8.311344968938896150e-11 8.393711648569390736e-11 -1.616759258241948097e-12
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.360914351894146666e-10 0.000000000000000000e+00 0.000000000000000000e+00
2.706571628014560990e-10 2.714226141836222067e-10 -4.101180278645566972e-12
2.807191035455768412e-10 2.800392922027231254e-10 -6.118936124149278224e-12
2.828487596243198652e-10 2.692714469617568613e-10 -1.965016092001095432e-12
2.746342702394422227e-10 2.847442996958909425e-10 4.434316936981717911e-12
2.839704297491786294e-10 2.853709348383055217e-10 -3.679545754687407942e-12
7.257516113734235602e-11 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.414371180194103076e-12 0.000000000000000000e+00 0.000000000000000000e+00
1.292933997057751632e-11 1.281238704237722088e-11 -1.222947336053036776e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
3.697643558010748261e-12 0.000000000000000000e+00 0.000000000000000000e+00
7.440125192668666101e-12 7.384652258235513706e-12 -1.467793408998789279e-13
7.414087305790444449e-12 7.354657935416706961e-12 -3.837019598264792612e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
4.643201965202050264e-12 0.000000000000000000e+00 0.000000000000000000e+00
9.072748424965415114e-12 9.364197440883862357e-12 -2.163322814118304625e-14
9.515510064102467504e-12 9.308591503557812947e-12 1.385481804370315919e-13
9.630696188464663816e-12 9.149701117953892902e-12 1.801777596568665196e-15
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
9.625473414226720678e-12 0.000000000000000000e+00 0.000000000000000000e+00
1.920938687796980439e-11 1.964193294296897346e-11 -7.944715897830023893e-13
1.946955762275289352e-11 1.919021493905150214e-11 -2.564881469669617856e-13
1.958134976408083770e-11 2.007053177840841298e-11 -5.337038081684425876e-13
1.960489616991941994e-11 2.003224099146012803e-11 -4.204662735566095595e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.866142505134648015e-11 0.000000000000000000e+00 0.000000000000000000e+00
5.960474927275288191e-11 5.791676133341629378e-11 -2.948445467813419937e-12
5.869494353063501558e-11 5.761075430241717798e-11 -5.770019628797047667e-13
5.944393939418903974e-11 5.745008898350029844e-11 -1.098049362846760925e-12
5.778707813648108667e-11 6.097470543722549861e-11 1.471001149611219205e-12
5.837025614734168256e-11 6.085131357497173529e-11 -1.415376828445966535e-12
4.501367653221281796e-11 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.879723013095073545e-12 0.000000000000000000e+00 0.000000000000000000e+00
6.005589734960714160e-12 5.807875507024871252e-12 -3.384304678425237182e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.414827838134706533e-12 0.000000000000000000e+00 0.000000000000000000e+00
2.827744507478850109e-12 2.715020659858806908e-12 -1.481541516910848357e-13
2.802171334217860349e-12 2.834420703841962688e-12 -4.933000573596051965e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.540302248378772545e-12 0.000000000000000000e+00 0.000000000000000000e+00
3.102629603205183762e-12 3.064876429318944762e-12 1.366498511007262618e-14
3.093540536407955661e-12 3.091816970364022553e-12 3.035514861683012543e-14
3.213954369297482847e-12 3.069007715178577995e-12 1.295675091167728591e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
2.678449523858159449e-12 0.000000000000000000e+00 0.000000000000000000e+00
5.376501897039607272e-12 5.630460807581595272e-12 -7.794148235691610774e-14
5.479867831084443026e-12 5.543074399175339949e-12 -1.166814819540805070e-13
5.558575700683859324e-12 5.631417382803890843e-12 -1.146969784210942868e-13
5.537579562204165869e-12 5.791105675134707127e-12 -1.396598322436072022e-13
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
6.763237181525172007e-12 0.000000000000000000e+00 0.000000000000000000e+00
1.359877961096404003e-11 1.427603693907594070e-11 -7.233844217419753033e-13
1.434099417026095166e-11 1.379845031490931562e-11 1.221601513717413345e-13
1.423916729156160569e-11 1.392517729983021179e-11 2.285057232434158715e-15
1.403952118610047282e-11 1.482586145374840371e-11 2.646262301132666319e-13
1.471450145462063977e-11 1.425540239321531578e-11 -3.076431219061037627e-13
2.849924298051221704e-11 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.432531197995135573e-12 0.000000000000000000e+00 0.000000000000000000e+00
2.917284682603617198e-12 2.906574253268154485e-12 -1.107881030944939383e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
5.441594528428117194e-13 0.000000000000000000e+00 0.000000000000000000e+00
1.106453366219980978e-12 1.056440839874971620e-12 -5.252696255480552352e-14
1.101112737372159504e-12 1.062271231245146958e-12 8.179579220452581752e-15
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
5.354390102361499700e-13 0.000000000000000000e+00 0.000000000000000000e+00
1.050487753929663483e-12 9.995161815694140799e-13 -3.399226189887866295e-15
1.056835692359001597e-12 1.031727799749988527e-12 9.923729247828882196e-15
1.059835430860786120e-12 1.023130194393242195e-12 8.857353859005130775e-15
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
8.445311268195063201e-13 0.000000000000000000e+00 0.000000000000000000e+00
1.685180387686050324e-12 1.659205673773709066e-12 1.763787827722718989e-14
1.700807246390284102e-12 1.654762176302202158e-12 -5.901338318468332747e-14
1.699962744413702306e-12 1.649128697730139577e-12 -7.847139167715137061e-15
1.684567203696272682e-12 1.709404519996951499e-12 -3.838224963655591701e-14
0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00
1.851130298038994461e-12 0.000000000000000000e+00 0.000000000000000000e+00
3.802799954469440909e-12 3.802157332356086186e-12 -1.027128282347662240e-13
3.763144091432152882e-12 3.755241270995029359e-12 -5.669537216790900043e-14
3.814444647999950293e-12 3.746095484842269683e-12 3.839181416162380646e-14
3.798840557685720703e-12 3.955183814026824247e-12 1.008864113329574717e-13
3.847875242614496537e-12 3.872101308912856533e-12 -1.215065079270114607e-13
</file>

<file path="gala/potential/scf/tests/data/random.coeff">
40
0 0 0 -0.250920 0.000000
0 1 0 0.901429 0.000000
0 1 1 0.463988 0.000000
0 2 0 0.197317 0.000000
0 2 1 -0.687963 0.000000
0 2 2 -0.688011 0.000000
0 3 0 -0.883833 0.000000
0 3 1 0.732352 0.000000
0 3 2 0.202230 0.000000
0 3 3 0.416145 0.000000
1 0 0 -0.958831 0.000000
1 1 0 0.939820 0.000000
1 1 1 0.664885 0.000000
1 2 0 -0.575322 0.000000
1 2 1 -0.636350 0.000000
1 2 2 -0.633191 0.000000
1 3 0 -0.391516 0.000000
1 3 1 0.049513 0.000000
1 3 2 -0.136110 0.000000
1 3 3 -0.417542 0.000000
2 0 0 0.223706 0.000000
2 1 0 -0.721012 0.000000
2 1 1 -0.415711 0.000000
2 2 0 -0.267276 0.000000
2 2 1 -0.087860 0.000000
2 2 2 0.570352 0.000000
2 3 0 -0.600652 0.000000
2 3 1 0.028469 0.000000
2 3 2 0.184829 0.000000
2 3 3 -0.907099 0.000000
3 0 0 0.215090 0.000000
3 1 0 -0.658952 0.000000
3 1 1 -0.869897 0.000000
3 2 0 0.897771 0.000000
3 2 1 0.931264 0.000000
3 2 2 0.616795 0.000000
3 3 0 -0.390772 0.000000
3 3 1 -0.804656 0.000000
3 3 2 0.368466 0.000000
3 3 3 -0.119695 0.000000
</file>

<file path="gala/potential/scf/tests/data/README.md">
Note: the data in here was generated using the scripts in https://github.com/adrn/biff
</file>

<file path="gala/potential/scf/tests/data/simple-hernquist.coeff">
1
0 0 0 1.0 0.0
</file>

<file path="gala/potential/scf/tests/data/simple-nonsph.coeff">
1
0 1 1 1.0 0.0
</file>

<file path="gala/potential/scf/tests/data/Snlm-mathematica.csv">
0.9152366869235695,0.,-0.09450062158550537,-3.1190158821107065e-16,0.030783603783174643,8.124049411618912e-15,-0.013512420689246692,-4.207875466038105e-14,0.006866337559153507
-0.0052054990653439175,0.,-0.004684744344628895,-1.354913191125643e-19,0.0019258260006106988,-7.229431168944954e-17,-0.0008690870281076569,3.031290510878991e-16,0.0004298172601139982
0.00006499178959724264,0.,-0.002490842172896697,-8.323318468706546e-18,0.0008289440253978623,1.9605436738499557e-16,-0.00033152902434216295,-8.779248689882321e-16,0.0001506309722314064
-1.0406645452567241e-6,0.,-0.00032581037837221117,-4.1016303404253453e-20,0.0001283047314703666,-4.57452351412777e-18,-0.00005208441081737473,2.8566531035235203e-18,0.000023039206232664963
1.886362542347212e-8,0.,-0.0002276107685616673,-6.951838679377756e-19,0.00006617213180033839,1.3641697007917025e-17,-0.000023116467882576172,-5.1595217795682355e-17,9.262680411260551e-6
-3.6836564726891204e-10,0.,-0.00004346235840999843,-3.560144788169866e-22,0.000014715145724316492,-5.610687144071785e-19,-5.188336919654948e-6,1.916669654861419e-18,2.0233170742521486e-6
7.559881132455772e-12,0.,-0.00003599412558254942,-1.0190039079360521e-19,8.630590080754665e-6,1.6604494844060874e-18,-2.5787743997281766e-6,-4.25916783378157e-18,9.037464998463334e-7
-1.6076033814313124e-13,0.,-8.516447924267826e-6,5.193050170763415e-21,2.374852909637775e-6,-6.780704184205336e-20,-7.151022836804109e-7,1.8484678338454885e-19,2.4396862431845174e-7
3.5096996742605785e-15,0.,-7.929167154701838e-6,-1.1898967976889553e-20,1.534413588121971e-6,2.432706965765482e-19,-3.8833806578106424e-7,-6.995743173477491e-19,1.1852338716667918e-7
</file>

<file path="gala/potential/scf/tests/data/wang-zhao.coeff">
20
0 0 0 1.509000 0.000000
1 0 0 -0.086000 0.000000
2 0 0 -0.033000 0.000000
3 0 0 -0.020000 0.000000
0 2 0 -2.606000 0.000000
1 2 0 -0.221000 0.000000
2 2 0 -0.001000 0.000000
0 2 2 0.665000 0.000000
1 2 2 0.129000 0.000000
2 2 2 0.006000 0.000000
0 4 0 6.406000 0.000000
1 4 0 1.295000 0.000000
0 4 2 -0.660000 0.000000
1 4 2 -0.140000 0.000000
0 4 4 0.044000 0.000000
1 4 4 -0.012000 0.000000
0 6 0 -5.859000 0.000000
0 6 2 0.984000 0.000000
0 6 4 -0.030000 0.000000
0 6 6 0.001000 0.000000
</file>

<file path="gala/potential/scf/tests/test_accp_fortran.py">
# coding: utf-8

# Standard library
import os
from math import factorial as _factorial

# Third-party
from astropy.constants import G as _G
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# Project
from gala.units import galactic
from gala._cconfig import GSL_ENABLED
from .._bfe import density, potential, gradient

G = _G.decompose(galactic).value

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)


def factorial(x):
    return _factorial(int(x))


@pytest.mark.parametrize("basename", [
    'simple-hernquist', 'multi-hernquist', 'simple-nonsph', 'random', 'wang-zhao',
])
def test_density(basename):
    pos_path = os.path.abspath(get_pkg_data_filename('data/positions.dat.gz'))
    coeff_path = os.path.abspath(
        get_pkg_data_filename(f'data/{basename}.coeff'))
    accp_path = os.path.abspath(
        get_pkg_data_filename(f'data/{basename}-accp.dat.gz'))

    xyz = np.ascontiguousarray(np.loadtxt(pos_path, skiprows=1).T)
    coeff = np.atleast_2d(np.loadtxt(coeff_path, skiprows=1))

    nmax = coeff[:, 0].astype(int).max()
    lmax = coeff[:, 1].astype(int).max()

    cos_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    sin_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    for row in coeff:
        n, l, m, cc, sc = row

        # transform from H&O 1992 coefficients to Lowing 2011 coefficients
        if l != 0:
            fac = np.sqrt(4*np.pi) * np.sqrt((2*l+1) / (4*np.pi) * factorial(l-m) / factorial(l+m))
            cc /= fac
            sc /= fac

        cos_coeff[int(n), int(l), int(m)] = cc
        sin_coeff[int(n), int(l), int(m)] = sc

    dens = density(xyz, M=1., r_s=1.,
                   Snlm=cos_coeff, Tnlm=sin_coeff)

    # TODO: nothing to compare this to....
    # just test that it runs...


@pytest.mark.parametrize("basename", [
    'simple-hernquist', 'multi-hernquist', 'simple-nonsph', 'random', 'wang-zhao',
])
def test_potential(basename):
    coeff_path = os.path.abspath(get_pkg_data_filename(f'data/{basename}.coeff'))
    accp_path = os.path.abspath(get_pkg_data_filename(f'data/{basename}-accp.dat.gz'))

    coeff = np.atleast_2d(np.loadtxt(coeff_path, skiprows=1))
    accp = np.loadtxt(accp_path)

    pos_path = os.path.abspath(get_pkg_data_filename('data/positions.dat.gz'))
    xyz = np.loadtxt(pos_path, skiprows=1)

    nmax = coeff[:, 0].astype(int).max()
    lmax = coeff[:, 1].astype(int).max()

    cos_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    sin_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    for row in coeff:
        n, l, m, cc, sc = row

        # transform from H&O 1992 coefficients to Lowing 2011 coefficients
        if l != 0:
            fac = np.sqrt(4*np.pi) * np.sqrt((2*l+1) / (4*np.pi) * factorial(l-m) / factorial(l+m))
            cc /= fac
            sc /= fac

        cos_coeff[int(n), int(l), int(m)] = cc
        sin_coeff[int(n), int(l), int(m)] = sc

    potv = potential(xyz, G=1., M=1., r_s=1.,
                     Snlm=cos_coeff, Tnlm=sin_coeff)

    # for some reason, SCF potential is -potential
    scf_potv = -accp[:, -1]
    np.testing.assert_allclose(potv, scf_potv, rtol=1E-6)


@pytest.mark.parametrize("basename", [
    'simple-hernquist', 'multi-hernquist', 'simple-nonsph', 'random', 'wang-zhao',
])
def test_gradient(basename):
    pos_path = os.path.abspath(get_pkg_data_filename('data/positions.dat.gz'))
    coeff_path = os.path.abspath(get_pkg_data_filename(f'data/{basename}.coeff'))
    accp_path = os.path.abspath(get_pkg_data_filename(f'data/{basename}-accp.dat.gz'))

    xyz = np.loadtxt(pos_path, skiprows=1)
    coeff = np.atleast_2d(np.loadtxt(coeff_path, skiprows=1))
    accp = np.loadtxt(accp_path)

    nmax = coeff[:, 0].astype(int).max()
    lmax = coeff[:, 1].astype(int).max()

    cos_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    sin_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    for row in coeff:
        n, l, m, cc, sc = row

        # transform from H&O 1992 coefficients to Lowing 2011 coefficients
        if l != 0:
            fac = np.sqrt(4*np.pi) * np.sqrt((2*l+1) / (4*np.pi) * factorial(l-m) / factorial(l+m))
            cc /= fac
            sc /= fac

        cos_coeff[int(n), int(l), int(m)] = cc
        sin_coeff[int(n), int(l), int(m)] = sc

    grad = gradient(xyz, G=1., M=1., r_s=1.,
                    Snlm=cos_coeff, Tnlm=sin_coeff)

    # I output the acceleration from SCF when I make the files
    #   so I have no idea why I don't need a minus sign here...
    scf_grad = accp[:, :3]
    np.testing.assert_allclose(grad, scf_grad, rtol=1E-6)
</file>

<file path="gala/potential/scf/tests/test_bfe_interp.py">
# coding: utf-8

# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from gala.units import galactic
from gala.potential.scf import SCFPotential, SCFInterpolatedPotential

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)


@pytest.mark.parametrize('func_name', ['energy', 'density', 'gradient'])
def test_simple_compare_noninterp(func_name):
    """
    Compare the interpolated to time-invariant versions for a trivial case
    """
    rng = np.random.default_rng(42)
    nmax = 5
    lmax = 3

    Snlm = rng.uniform(size=(nmax+1, lmax+1, lmax+1))
    Tnlm = np.zeros_like(Snlm)

    tj = np.linspace(0, 1000, 16)
    Sjnlm = np.repeat(Snlm[None], len(tj), axis=0)
    Tjnlm = np.repeat(Tnlm[None], len(tj), axis=0)

    m = 1e9
    r_s = 10.

    pot_static = SCFPotential(m=m, r_s=r_s, Snlm=Snlm, Tnlm=Tnlm, units=galactic)
    pot_t = SCFInterpolatedPotential(
        m=m, r_s=r_s, tj=tj, Sjnlm=Sjnlm, Tjnlm=Tjnlm, units=galactic,
        com_xj=np.zeros((3, len(tj))), com_vj=np.zeros((3, len(tj)))
    )

    test_xyz = rng.uniform(-10, 10, size=(3, 10))
    test_t = rng.uniform(0, 1000, size=16)
    for t in test_t:
        t_val = getattr(pot_t, func_name)(test_xyz, t=t)
        static_val = getattr(pot_static, func_name)(test_xyz, t=t)
        assert u.allclose(t_val, static_val)
</file>

<file path="gala/potential/scf/tests/test_bfe.py">
# coding: utf-8

# Third-party
import astropy.units as u
from astropy.constants import G as _G
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from gala.units import galactic
from .._bfe import density, potential, gradient

G = _G.decompose(galactic).value

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)


# Check that we get A000=1. for putting in hernquist density
def hernquist_density(xyz, M, r_s):
    r = np.sqrt(np.sum(xyz**2, axis=0))
    return M/(2*np.pi) * r_s / (r * (r+r_s)**3)


def hernquist_potential(xyz, M, r_s):
    r = np.sqrt(np.sum(xyz**2, axis=0))
    return -G*M / (r + r_s)


def hernquist_gradient(xyz, M, r_s):
    import gala.potential as gp
    p = gp.HernquistPotential(m=M, c=r_s,
                              units=[u.kpc, u.Myr, u.Msun, u.radian])
    return p.gradient(xyz).value


def test_hernquist():
    nmax = 6
    lmax = 2

    Snlm = np.zeros((nmax+1, lmax+1, lmax+1))
    Tnlm = np.zeros((nmax+1, lmax+1, lmax+1))
    Snlm[0, 0, 0] = 1.

    M = 1E10
    r_s = 3.5

    nbins = 128
    rr = np.linspace(0.1, 10., nbins)
    xyz = np.zeros((nbins, 3))
    xyz[:, 0] = rr * np.cos(np.pi/4.) * np.sin(np.pi/4.)
    xyz[:, 1] = rr * np.sin(np.pi/4.) * np.sin(np.pi/4.)
    xyz[:, 2] = rr * np.cos(np.pi/4.)

    bfe_dens = density(xyz, Snlm, Tnlm, M=M, r_s=r_s)
    true_dens = hernquist_density(xyz.T, M, r_s)
    np.testing.assert_allclose(bfe_dens, true_dens)

    bfe_pot = potential(xyz, Snlm, Tnlm, G=G, M=M, r_s=r_s)
    true_pot = hernquist_potential(xyz.T, M, r_s)
    np.testing.assert_allclose(bfe_pot, true_pot)

    bfe_grad = gradient(xyz, Snlm, Tnlm, G=G, M=M, r_s=r_s)
    true_grad = hernquist_gradient(xyz.T, M, r_s)
    np.testing.assert_allclose(bfe_grad.T, true_grad)


def pure_py(xyz, Snlm, Tnlm, nmax, lmax):
    from scipy.special import lpmv, gegenbauer, eval_gegenbauer, gamma
    from math import factorial as f

    def Plm(l, m, costh):
        return lpmv(m, l, costh)

    def Ylmth(l, m, costh):
        return np.sqrt((2*l+1)/(4 * np.pi) * f(l-m)/f(l+m)) * Plm(l, m, costh)

    twopi = 2*np.pi
    sqrtpi = np.sqrt(np.pi)
    sqrt4pi = np.sqrt(4*np.pi)

    r = np.sqrt(np.sum(xyz**2, axis=0))
    X = xyz[2] / r  # cos(theta)
    sinth = np.sqrt(1 - X**2)
    phi = np.arctan2(xyz[1], xyz[0])
    xsi = (r - 1) / (r + 1)

    density = 0
    potenti = 0
    gradien = np.zeros_like(xyz)
    sph_gradien = np.zeros_like(xyz)
    for l in range(lmax+1):
        r_term1 = r**l / (r*(1+r)**(2*l+3))
        r_term2 = r**l / (1+r)**(2*l+1)
        for m in range(l+1):
            for n in range(nmax+1):
                Cn = gegenbauer(n, 2*l+3/2)
                Knl = 0.5 * n * (n+4*l+3) + (l+1)*(2*l+1)
                rho_nl = Knl / twopi * sqrt4pi * r_term1 * Cn(xsi)
                phi_nl = -sqrt4pi * r_term2 * Cn(xsi)

                density += rho_nl * Ylmth(l, m, X) * (Snlm[n, l, m]*np.cos(m*phi) +
                                                      Tnlm[n, l, m]*np.sin(m*phi))
                potenti += phi_nl * Ylmth(l, m, X) * (Snlm[n, l, m]*np.cos(m*phi) +
                                                      Tnlm[n, l, m]*np.sin(m*phi))

                # derivatives
                dphinl_dr = (
                    2*sqrtpi*np.power(r, -1 + l)*np.power(1 + r, -3 - 2*l) *
                    (-2*(3 + 4*l)*r*eval_gegenbauer(-1 + n, 2.5 + 2*l, (-1 + r)/(1 + r)) +
                     (1 + r)*(l*(-1 + r) + r)*eval_gegenbauer(n, 1.5 + 2*l, (-1 + r)/(1 + r))))
                sph_gradien[0] += dphinl_dr * Ylmth(l, m, X) * (Snlm[n, l, m]*np.cos(m*phi) +
                                                                Tnlm[n, l, m]*np.sin(m*phi))

                A = np.sqrt((2*l+1) / (4*np.pi)) * np.sqrt(gamma(l-m+1) / gamma(l+m+1))
                dYlm_dth = A / sinth * (l*X*Plm(l, m, X) - (l+m)*Plm(l-1, m, X))
                sph_gradien[1] += (1/r) * dYlm_dth * phi_nl * (Snlm[n, l, m]*np.cos(m*phi) +
                                                               Tnlm[n, l, m]*np.sin(m*phi))

                sph_gradien[2] += (m/(r*sinth)) * phi_nl * Ylmth(l, m, X) * (
                    -Snlm[n, l, m]*np.sin(m*phi) + Tnlm[n, l, m]*np.cos(m*phi))

    cosphi = np.cos(phi)
    sinphi = np.sin(phi)
    gradien[0] = sinth*cosphi*sph_gradien[0] + X*cosphi*sph_gradien[1] - sinphi*sph_gradien[2]
    gradien[1] = sinth*sinphi*sph_gradien[0] + X*sinphi*sph_gradien[1] + cosphi*sph_gradien[2]
    gradien[2] = X*sph_gradien[0] - sinth*sph_gradien[1]

    return density, potenti, gradien


def test_pure_py():

    nmax = 6
    lmax = 4

    # xyz = np.array([[1., 0., 1.],
    #                 [1., 1., 0.],
    #                 [0., 1., 1.]])
    xyz = np.random.uniform(-2., 2., size=(128, 3))

    # first try spherical:
    Snlm = np.zeros((nmax+1, lmax+1, lmax+1))
    Snlm[:, 0, 0] = np.logspace(0., -4, nmax+1)
    Tnlm = np.zeros_like(Snlm)

    py_den, py_pot, py_grd = pure_py(xyz.T, Snlm, Tnlm, nmax, lmax)

    cy_den = density(xyz, Snlm, Tnlm, M=1., r_s=1.)
    cy_pot = potential(xyz, Snlm, Tnlm, G=1., M=1., r_s=1.)
    cy_grd = gradient(xyz, Snlm, Tnlm, G=1., M=1., r_s=1.).T

    assert np.allclose(py_den, cy_den)
    assert np.allclose(py_pot, cy_pot)
    assert np.allclose(py_grd, cy_grd)

    # non-spherical:
    Snlm = np.random.uniform(-1, 1, size=(nmax+1, lmax+1, lmax+1))
    Tnlm = np.zeros_like(Snlm)

    py_den, py_pot, py_grd = pure_py(xyz.T, Snlm, Tnlm, nmax, lmax)

    cy_den = density(xyz, Snlm, Tnlm, M=1., r_s=1.)
    cy_pot = potential(xyz, Snlm, Tnlm, G=1., M=1., r_s=1.)
    cy_grd = gradient(xyz, Snlm, Tnlm, G=1., M=1., r_s=1.).T

    assert np.allclose(py_den, cy_den)
    assert np.allclose(py_pot, cy_pot)
    assert np.allclose(py_grd, cy_grd)
</file>

<file path="gala/potential/scf/tests/test_class.py">
# coding: utf-8

# Third-party
import astropy.units as u
from astropy.constants import G as _G
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from gala.units import galactic
import gala.potential as gp
from gala.potential.potential.tests.helpers import PotentialTestBase
from gala.potential.potential.io import load
from .. import _bfe_class

G = _G.decompose(galactic).value

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)


def test_hernquist():
    nmax = 6
    lmax = 2

    M = 1E10
    r_s = 3.5

    cos_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    sin_coeff = np.zeros((nmax+1, lmax+1, lmax+1))
    cos_coeff[0, 0, 0] = 1.
    scf_potential = _bfe_class.SCFPotential(m=M, r_s=r_s,
                                            Snlm=cos_coeff, Tnlm=sin_coeff,
                                            units=galactic)
    # scf_potential = HackPotential(m=10., units=galactic)

    nbins = 128
    rr = np.linspace(0.1, 10., nbins)
    xyz = np.zeros((3, nbins))
    xyz[0] = rr * np.cos(np.pi/4.) * np.sin(np.pi/4.)
    xyz[1] = rr * np.sin(np.pi/4.) * np.sin(np.pi/4.)
    xyz[2] = rr * np.cos(np.pi/4.)

    hernquist = gp.HernquistPotential(m=M, c=r_s, units=galactic)

    bfe_pot = scf_potential.energy(xyz).value
    true_pot = hernquist.energy(xyz).value
    np.testing.assert_allclose(bfe_pot, true_pot)

    bfe_grad = scf_potential.gradient(xyz).value
    true_grad = hernquist.gradient(xyz).value
    np.testing.assert_allclose(bfe_grad, true_grad)


class TestSCFPotential(PotentialTestBase):
    nmax = 6
    lmax = 2
    Snlm = np.zeros((nmax+1, lmax+1, lmax+1))
    Tnlm = np.zeros((nmax+1, lmax+1, lmax+1))
    Snlm[0, 0, 0] = 1.
    Snlm[2, 0, 0] = 0.5
    Snlm[4, 0, 0] = 0.25

    potential = _bfe_class.SCFPotential(m=1E11*u.Msun, r_s=10*u.kpc,
                                        Snlm=Snlm, Tnlm=Tnlm, units=galactic)
    w0 = [4.0, 0.7, -0.9, 0.0352238, 0.1579493, 0.02]

    def test_save_load(self, tmpdir):
        fn = str(tmpdir.join("{}.yml".format(self.name)))
        self.potential.save(fn)
        p = load(fn, module=_bfe_class)
        p.energy(self.w0[:self.w0.size//2])

    @pytest.mark.skipif(True, reason='no hessian implemented')
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason="to_sympy() not implemented yet")
    def test_against_sympy(self):
        pass

    def test_compare(self):
        # skip if composite potentials
        if len(self.potential.parameters) == 0:
            return

        other = self.potential.__class__(units=self.potential.units, **self.potential.parameters)
        assert other == self.potential

        pars = self.potential.parameters.copy()
        for k in pars.keys():
            if k != 0:
                pars[k] = 1.1 * pars[k]

        other = self.potential.__class__(units=self.potential.units, **pars)
        assert other != self.potential

    def test_replace_units(self):
        H = gp.Hamiltonian(self.potential)
        H2 = gp.Hamiltonian(self.potential.replace_units(self.potential.units))

        ww = [20., 10, 10, 0, 0.2, 0]
        w1 = H.integrate_orbit(ww, t=np.array([0, 1.]))[-1].w(galactic).T
        w2 = H2.integrate_orbit(ww, t=np.array([0, 1.]))[-1].w(galactic).T

        assert np.allclose(w1, w2)
</file>

<file path="gala/potential/scf/tests/test_computecoeff_discrete.py">
# coding: utf-8

import multiprocessing
import os

# Third-party
import numpy as np
import pytest
from astropy.constants import G
from astropy.utils.data import get_pkg_data_filename

# Project
import gala.potential as gp
from gala._cconfig import GSL_ENABLED
from gala.units import galactic

from .._bfe import potential
from ..core import compute_coeffs_discrete

_G = G.decompose(galactic).value

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL", allow_module_level=True)


def test_plummer():
    pos_path = os.path.abspath(get_pkg_data_filename("data/plummer-pos.dat.gz"))

    scfbi = scfbi = np.loadtxt(pos_path)
    m_k = scfbi[:, 0] * 10  # masses sum to 0.1
    xyz = scfbi[:, 1:4]

    G = 1.0
    r_s = 1.0
    M = m_k.sum()
    pot = gp.PlummerPotential(m=1 / _G, b=r_s, units=galactic)

    nmax = 10
    lmax = 0

    Snlm, Tnlm = compute_coeffs_discrete(xyz, m_k, nmax=nmax, lmax=lmax, r_s=r_s)

    x = np.logspace(-2, 1, 512)
    xyz = np.zeros((len(x), 3))
    xyz[:, 0] = x

    # plot discrete vs. analytic potential
    true_pot = pot.energy(xyz.T).value
    bfe_pot = potential(xyz, Snlm, Tnlm, G, M, r_s)

    assert np.allclose(true_pot, bfe_pot, rtol=1e-2)


@pytest.mark.parametrize("pool", [None, multiprocessing.Pool(2)])
def test_coefficients(pool):
    pos_path = os.path.abspath(get_pkg_data_filename("data/plummer-pos.dat.gz"))
    coeff_path = os.path.abspath(
        get_pkg_data_filename("data/plummer_coeff_nmax10_lmax5.txt")
    )
    scfbi = np.loadtxt(pos_path)
    m_k = scfbi[:, 0]  # masses sum to 0.1
    xyz = scfbi[:, 1:4]

    scfcoeff = np.loadtxt(coeff_path)
    Snlm_true = scfcoeff[:, 0]
    Tnlm_true = scfcoeff[:, 1]

    r_s = 1.0
    nmax = 10
    lmax = 5

    Snlm, Tnlm = compute_coeffs_discrete(
        xyz, m_k, nmax=nmax, lmax=lmax, r_s=r_s, pool=pool
    )

    assert np.allclose(Snlm_true, Snlm.flatten(), rtol=1e-3)
    assert np.allclose(Tnlm_true, Tnlm.flatten(), rtol=1e-3)


@pytest.mark.parametrize("pool", [None, multiprocessing.Pool(2)])
def test_coeff_variances(pool):
    pos_path = os.path.abspath(get_pkg_data_filename("data/plummer-pos.dat.gz"))
    coeff_path = os.path.abspath(
        get_pkg_data_filename("data/plummer_coeff_var_nmax10_lmax5.txt")
    )
    scfbi = np.loadtxt(pos_path)
    m_k = scfbi[:, 0]  # masses sum to 0.1
    xyz = scfbi[:, 1:4]

    scfcoeff = np.loadtxt(coeff_path)
    Snlm_var_true = scfcoeff[:, 0]
    Tnlm_var_true = scfcoeff[:, 1]
    STnlm_var_true = scfcoeff[:, 2]

    r_s = 1.0
    nmax = 10
    lmax = 5

    *_, STnlm_Cov = compute_coeffs_discrete(
        xyz, m_k, nmax=nmax, lmax=lmax, r_s=r_s, compute_var=True, pool=pool
    )
    assert np.allclose(Snlm_var_true, STnlm_Cov[0, 0].flatten(), rtol=1e-3)
    assert np.allclose(Tnlm_var_true, STnlm_Cov[1, 1].flatten(), rtol=1e-3)
    assert np.allclose(STnlm_var_true, STnlm_Cov[0, 1].flatten(), rtol=1e-3)
</file>

<file path="gala/potential/scf/tests/test_computecoeff_fortran.py">
# coding: utf-8

# Standard library
import os
from math import factorial as _factorial

# Third-party
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from ..core import compute_coeffs_discrete

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)

# Compare coefficients computed with Fortran to Biff


def factorial(x):
    return _factorial(int(x))


@pytest.mark.parametrize("basename", [
    'hernquist'
])
def test_coeff(basename):
    nmax = 6
    lmax = 10  # HACK: these are hard-set in Fortran

    pos_path = os.path.abspath(get_pkg_data_filename('data/{}-samples.dat.gz'.format(basename)))
    coeff_path = os.path.abspath(get_pkg_data_filename('data/computed-{0}.coeff'.format(basename)))
    coeff = np.atleast_2d(np.loadtxt(coeff_path))

    xyz = np.ascontiguousarray(np.loadtxt(pos_path, skiprows=1))
    S, T = compute_coeffs_discrete(xyz, mass=np.zeros(xyz.shape[0])+1./xyz.shape[0],
                                   nmax=nmax, lmax=lmax, r_s=1.)

    S_f77 = np.zeros((nmax+1, lmax+1, lmax+1))
    T_f77 = np.zeros((nmax+1, lmax+1, lmax+1))
    for row in coeff:
        n, l, m, cc, sc = row

        # transform from H&O 1992 coefficients to Lowing 2011 coefficients
        if l != 0:
            fac = np.sqrt(4*np.pi) * np.sqrt((2*l+1) / (4*np.pi) * factorial(l-m) / factorial(l+m))
            cc /= fac
            sc /= fac

        S_f77[int(n), int(l), int(m)] = -cc
        T_f77[int(n), int(l), int(m)] = -sc

    assert np.allclose(S_f77, S)
</file>

<file path="gala/potential/scf/tests/test_computecoeff.py">
# coding: utf-8

import os

# Third-party
from astropy.utils.data import get_pkg_data_filename
from astropy.constants import G as _G
import matplotlib as mpl
import matplotlib.pyplot as pl
import numpy as np
from scipy.integrate import quad
import pytest

# Project
import gala.potential as gp
from gala.units import galactic
from gala._cconfig import GSL_ENABLED
from ..core import compute_coeffs
from .._bfe import potential, density, gradient

G = _G.decompose(galactic).value

if not GSL_ENABLED:
    pytest.skip("skipping SCF tests: they depend on GSL",
                allow_module_level=True)


# Check that we get A000=1. for putting in hernquist density
def hernquist_density(x, y, z, M, r_s):
    r = np.sqrt(x**2 + y**2 + z**2)
    return M/(2*np.pi) * r_s / (r * (r+r_s)**3)


def test_hernquist():
    for M in [1E5, 1E10]:
        for r_s in np.logspace(-1, 2, 4):
            (S, Serr), (T, Terr) = compute_coeffs(hernquist_density, nmax=0, lmax=0,
                                                  M=M, r_s=r_s, args=(M, r_s))

            np.testing.assert_allclose(S, 1.)
            np.testing.assert_allclose(Serr, 0., atol=1E-10)

            np.testing.assert_allclose(T, 0.)
            np.testing.assert_allclose(Terr, 0., atol=1E-10)


def test_hernquist_spherical():
    (S, Serr), (T, Terr) = compute_coeffs(hernquist_density, nmax=8, lmax=8,
                                          M=1., r_s=1., args=(1., 1.), skip_m=True)

    np.testing.assert_allclose(S[0, 0, 0], 1., atol=1E-13)
    np.testing.assert_allclose(S[1:, :, :], 0., atol=1E-13)
    np.testing.assert_allclose(Serr, 0., atol=1E-10)

    np.testing.assert_allclose(T, 0., atol=1E-13)
    np.testing.assert_allclose(Terr, 0., atol=1E-10)

# ----------------------------------------------------------------------------


def _plummer_density(x, y, z, M, r_s):
    r2 = x*x + y*y + z*z
    return (3*M / (4*np.pi*r_s**3)) * (1 + r2/r_s**2)**(-5/2.)


def test_plummer():
    true_M = 1/G
    true_r_s = 1.

    x = np.logspace(-2, 1, 512)
    xyz = np.zeros((len(x), 3))
    xyz[:, 0] = x

    pot = gp.PlummerPotential(m=true_M, b=true_r_s, units=galactic)
    true_pot = pot.energy(xyz.T).value
    true_dens = pot.density(xyz.T).value
    true_grad = pot.gradient(xyz.T).value.T

    nmax = 16
    lmax = 0

    (S, S_err), (T, T_err) = compute_coeffs(_plummer_density, nmax=nmax, lmax=lmax,
                                            M=true_M, r_s=true_r_s, args=(true_M, true_r_s),
                                            epsrel=1E-9)

    bfe_dens = density(xyz, S, T, true_M, true_r_s)
    bfe_pot = potential(xyz, S, T, G, true_M, true_r_s)
    bfe_grad = gradient(xyz, S, T, G, true_M, true_r_s)

    # fig, axes = pl.subplots(3, 1, figsize=(6, 12), sharex=True)

    # axes[0].loglog(x, true_dens)
    # axes[0].loglog(x, bfe_dens)

    # axes[1].semilogx(x, true_pot)
    # axes[1].semilogx(x, bfe_pot)

    # axes[2].semilogx(x, true_grad[:, 0])
    # axes[2].semilogx(x, bfe_grad[:, 0])

    # pl.show()

    assert np.allclose(true_dens, bfe_dens, rtol=2E-3)
    assert np.allclose(true_pot, bfe_pot, rtol=1E-6)
    assert np.allclose(true_grad[:, 0], bfe_grad[:, 0], rtol=5E-3)
    # print(np.abs((bfe_dens - true_dens) / true_dens).max())
    # print(np.abs((bfe_pot - true_pot) / true_pot).max())
    # print(np.abs((bfe_grad[:, 0] - true_grad[:, 0]) / true_grad[:, 0]).max())


# ----------------------------------------------------------------------------
# Non-spherical, axisymmetric

def flattened_hernquist_density_s(s, M, a, q):
    return M*a / (2*np.pi) / (s * (a + s)**3)


def flattened_hernquist_density(x, y, z, M, a, q):
    s = np.sqrt(x*x + y*y + z*z/(q*q))
    return flattened_hernquist_density_s(s, M, a, q)


def _integrand_helper(tau, xyz, M, a, q):
    x, y, z = xyz
    m = a*np.sqrt((x*x + y*y) / (a*a + tau) + z*z / (q*q + tau))
    return flattened_hernquist_density_s(m, M, a, q) / ((tau+a*a)*np.sqrt(tau+q*q))


def integrand(tau, i, xyz, M, a, q):
    if i in [0, 1]:
        denom = tau + a*a
    elif i == 2:
        denom = tau + q*q
    else:
        raise ValueError("WTF")

    return _integrand_helper(tau, xyz, M, a, q) * xyz[i] / denom


def flattened_hernquist_gradient(x, y, z, G, M, a, q):
    A = 2*np.pi*G*a**2*q
    gx = A * quad(integrand, 0, np.inf, args=(0, (x, y, z), M, a, q), limit=1000)[0]
    gy = A * quad(integrand, 0, np.inf, args=(1, (x, y, z), M, a, q))[0]
    gz = A * quad(integrand, 0, np.inf, args=(2, (x, y, z), M, a, q))[0]

    return np.array([gx, gy, gz])


def test_flattened_hernquist():
    """
    This test compares the coefficients against some computed in the mathematica
    notebook 'flattened-hernquist.nb'. nmax and lmax here must match nmax and lmax
    in that notebook.
    """

    coeff_path = os.path.abspath(get_pkg_data_filename('data/Snlm-mathematica.csv'))

    G = 1.
    M = 1
    a = 1.
    q = 0.9

    # Note: this must be the same as in the mathematica notebook
    nmax = 8
    lmax = 8

    (Snlm, Serr), (Tnlm, Terr) = compute_coeffs(flattened_hernquist_density,
                                                nmax=nmax, lmax=lmax, skip_odd=True, skip_m=True,
                                                M=M, r_s=a, args=(M, a, q))

    for l in range(1, lmax+1, 2):
        for m in range(lmax+1):
            assert Snlm[0, l, m] == 0.

    m_Snl0 = np.loadtxt(coeff_path, delimiter=',')
    m_Snl0 = m_Snl0[:, ::2]  # every other l

    assert np.allclose(Snlm[0, ::2, 0], m_Snl0[0])

    # check that random points match in gradient and density
    np.random.seed(42)
    n_test = 1024
    r = 10.*np.cbrt(np.random.uniform(0.1**3, 1, size=n_test))  # 1 to 10
    t = np.arccos(2*np.random.uniform(size=n_test) - 1)
    ph = np.random.uniform(0, 2*np.pi, size=n_test)
    x = r*np.cos(ph)*np.sin(t)
    y = r*np.sin(ph)*np.sin(t)
    z = r*np.cos(t)
    xyz = np.vstack((x, y, z))

    # confirmed by testing...
    tru_dens = flattened_hernquist_density(xyz[0], xyz[1], xyz[2], M, a, q)
    bfe_dens = density(np.ascontiguousarray(xyz.T), Snlm, Tnlm, M, a)
    assert np.all((np.abs(bfe_dens - tru_dens) / tru_dens) < 0.05)  # <5%

    tru_grad = np.array([flattened_hernquist_gradient(xyz[0, i], xyz[1, i], xyz[2, i], G, M, a, q)
                        for i in range(xyz.shape[1])]).T
    bfe_grad = gradient(np.ascontiguousarray(xyz.T), Snlm, Tnlm, G, M, a).T

    # check what typical errors are
    # for j in range(3):
    #     pl.hist(np.abs((bfe_grad[j]-tru_grad[j])/tru_grad[j]))

    for j in range(3):
        assert np.all(np.abs((bfe_grad[j]-tru_grad[j])/tru_grad[j]) < 0.005)  # 0.5%

    return

    # ------------------------------------------------------------------------
    # plots:

    # coefficients
    fig, ax = pl.subplots(1, 1, figsize=(10, 8))
    n, l = np.mgrid[:nmax+1, :lmax+1]
    c = ax.scatter(n.ravel(), l.ravel(), c=Snlm[:, :, 0].ravel(), s=64,
                   norm=mpl.colors.SymLogNorm(1E-5), cmap='RdBu_r',
                   vmin=-100, vmax=100, linewidths=1., edgecolors='#666666')

    ax.xaxis.set_ticks(np.arange(0, nmax+1, 1))
    ax.yaxis.set_ticks(np.arange(0, lmax+1, 1))

    ax.set_xlim(-0.5, nmax+0.5)
    ax.set_ylim(-0.5, lmax+0.5)

    ax.set_xlabel('$n$')
    ax.set_ylabel('$l$')

    tickloc = np.concatenate((-10.**np.arange(2, -5-1, -1),
                              10.**np.arange(-5, 2+1, 1)))
    fig.colorbar(c, ticks=tickloc, format='%.0e')
    fig.tight_layout()

    # contour plot in r, t at ph=0

    rgrid = np.logspace(-1, 1., 128)
    tgrid = np.linspace(0, np.pi, 128)

    r, t = np.meshgrid(rgrid, tgrid)
    x = r*np.sin(t)
    z = r*np.cos(t)

    _xyz = np.vstack((x.ravel(), np.zeros_like(x.ravel()), z.ravel()))
    bfe_dens = density(np.ascontiguousarray(_xyz.T), Snlm, Tnlm, M, a)
    true_dens = flattened_hernquist_density(_xyz[0], _xyz[1], _xyz[2], M, a, q)

    fig, ax = pl.subplots(1, 1, figsize=(8, 8))

    levels = 10**np.linspace(-4.5, 1, 16)
    ax.contour(np.log10(r), t, true_dens.reshape(x.shape),
               levels=levels, colors='k',
               locator=mpl.ticker.LogLocator(), label='True')
    ax.contour(np.log10(r), t, bfe_dens.reshape(x.shape),
               levels=levels, colors='r',
               locator=mpl.ticker.LogLocator(), label='BFE')

    ax.legend()
    fig.tight_layout()

    pl.show()
</file>

<file path="gala/potential/scf/__init__.py">
"""
Implementation of the Self-Consistent Field (SCF) expansion method.
"""

from .core import compute_coeffs, compute_coeffs_discrete
from ._bfe_class import SCFPotential, SCFInterpolatedPotential
</file>

<file path="gala/potential/scf/bfe_class.pyx">
# coding: utf-8
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: language_level=3

# Standard library
from libc.math cimport M_PI

# Third party
from astropy.constants import G
import numpy as np
cimport numpy as np
np.import_array()
import cython
cimport cython

# Gala
from gala.units import galactic
from gala.potential.common import PotentialParameter
from gala.potential import PotentialBase
from gala.potential.potential.cpotential cimport (CPotentialWrapper,
                                                  MAX_N_COMPONENTS, CPotential)
from gala.potential.potential.cpotential import CPotentialBase

cdef extern from "extra_compile_macros.h":
    int USE_GSL

cdef extern from "src/funcdefs.h":
    ctypedef double (*densityfunc)(double t, double *pars, double *q, int n_dim) nogil
    ctypedef double (*energyfunc)(double t, double *pars, double *q, int n_dim) nogil
    ctypedef void (*gradientfunc)(double t, double *pars, double *q, int n_dim, double *grad) nogil

cdef extern from "scf/src/bfe.h":
    double scf_value(double t, double *pars, double *q, int n_dim) nogil
    double scf_density(double t, double *pars, double *q, int n_dim) nogil
    void scf_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil

    double scf_interp_value(double t, double *pars, double *q, int n_dim) nogil
    double scf_interp_density(double t, double *pars, double *q, int n_dim) nogil
    void scf_interp_gradient(double t, double *pars, double *q, int n_dim, double *grad) nogil

__all__ = ['SCFPotential', 'InterpolatedSCFPotential']


gsl_err_msg = ("Gala was compiled without GSL and so the {classname} class "
               "will not work.  See the gala documentation for more "
               "information about installing and using GSL with gala: "
               "http://gala.adrian.pw/en/latest/install.html")


cdef class SCFWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        if USE_GSL == 1:
            self.cpotential.value[0] = <energyfunc>(scf_value)
            self.cpotential.density[0] = <densityfunc>(scf_density)
            self.cpotential.gradient[0] = <gradientfunc>(scf_gradient)

class SCFPotential(CPotentialBase, GSL_only=True):
    r"""
    SCFPotential(m, r_s, Snlm, Tnlm, units=None, origin=None, R=None)

    A gravitational potential represented as a basis function expansion.  This
    uses the self-consistent field (SCF) method of Hernquist & Ostriker (1992)
    and Lowing et al. (2011), and represents all coefficients as real
    quantities.

    Parameters
    ----------
    m : numeric
        Scale mass.
    r_s : numeric
        Scale length.
    Snlm : array_like
        Array of coefficients for the cos() terms of the expansion.
        This should be a 3D array with shape `(nmax+1, lmax+1, lmax+1)`,
        where `nmax` is the number of radial expansion terms and `lmax`
        is the number of spherical harmonic `l` terms.
    Tnlm : array_like
        Array of coefficients for the sin() terms of the expansion.
        This should be a 3D array with shape `(nmax+1, lmax+1, lmax+1)`,
        where `nmax` is the number of radial expansion terms and `lmax`
        is the number of spherical harmonic `l` terms.
    units : iterable
        Unique list of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.

    """
    m = PotentialParameter('m', physical_type='mass')
    r_s = PotentialParameter('r_s', physical_type='length')
    Snlm = PotentialParameter('Snlm', physical_type='dimensionless')
    Tnlm = PotentialParameter('Tnlm', physical_type='dimensionless')

    Wrapper = SCFWrapper

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        PotentialBase.__init__(
            self,
            *args,
            units=units,
            origin=origin,
            R=R,
            **kwargs)

        shp1 = self.parameters['Snlm'].shape
        shp2 = self.parameters['Tnlm'].shape
        if shp1 != shp2:
            raise ValueError(
                "The input coefficient arrays Snlm and Tnlm must have the same "
                f"shape! Received: {shp1} and {shp2}")

        # extra parameters
        nmax = self.parameters['Snlm'].shape[0] - 1
        lmax = self.parameters['Snlm'].shape[1] - 1

        self._setup_wrapper({'nmax': nmax, 'lmax': lmax})


cdef class InterpolatedSCFWrapper(CPotentialWrapper):

    def __init__(self, G, parameters, q0, R):
        self.init([G] + list(parameters),
                  np.ascontiguousarray(q0),
                  np.ascontiguousarray(R))
        if USE_GSL == 1:
            self.cpotential.value[0] = <energyfunc>(scf_interp_value)
            self.cpotential.density[0] = <densityfunc>(scf_interp_density)
            self.cpotential.gradient[0] = <gradientfunc>(scf_interp_gradient)


class SCFInterpolatedPotential(CPotentialBase, GSL_only=True):
    r"""
    SCFInterpolatedPotential(m, r_s, Sjnlm, Tjnlm, tj, com_xj, com_vj, units=None, origin=None, R=None)

    A gravitational potential represented as a basis function expansion with the
    Hernquist basis, but where the coefficients are interpolated with linear
    interpolation to compute the density, potential, or acceleration at a given time.
    This uses the self-consistent field (SCF) method of Hernquist & Ostriker (1992) and
    Lowing et al. (2011), and represents all coefficients as real quantities.

    Parameters
    ----------
    m : numeric
        Scale mass.
    r_s : numeric
        Scale length.
    Sjnlm : array_like
        Array of coefficients for the cos() terms of the expansion. The 0th axis should
        contain the coefficients at a given time (specified by the ``tj`` argument).
        This should be a 4D array with shape `(len(tj), nmax+1, lmax+1, lmax+1)`, where
        `tj` is the array of times that the input coefficients are stored at, `nmax` is
        the number of radial expansion terms and `lmax` is the number of spherical
        harmonic `l` terms.
    Tjnlm : array_like
        Same as `Sjnlm`, but for the sin() terms of the expansion.
    tj : array_like
        The array of times that the input coefficients are specified at.
    com_xj : array_like
        The position of the expansion center as a function of time, evaluated at the
        same times as the input time array `tj`.
    com_vj : array_like
        The velocity of the expansion center as a function of time, evaluated at the
        same times as the input time array `tj`.
    units : iterable
        Unique list of non-reducable units that specify (at minimum) the
        length, mass, time, and angle units.

    """
    m = PotentialParameter('m', physical_type='mass')
    r_s = PotentialParameter('r_s', physical_type='length')
    Sjnlm = PotentialParameter('Sjnlm', physical_type='dimensionless')
    Tjnlm = PotentialParameter('Tjnlm', physical_type='dimensionless')
    tj = PotentialParameter('tj', physical_type='time')
    com_xj = PotentialParameter('com_xj', physical_type='length')
    com_vj = PotentialParameter('com_vj', physical_type='speed')

    Wrapper = InterpolatedSCFWrapper

    def __init__(self, *args, units=None, origin=None, R=None, **kwargs):
        PotentialBase.__init__(
            self,
            *args,
            units=units,
            origin=origin,
            R=R,
            **kwargs)

        shp1 = self.parameters['Sjnlm'].shape
        shp2 = self.parameters['Tjnlm'].shape
        if shp1 != shp2:
            raise ValueError(
                "The input coefficient arrays must have the same shape! Received: "
                f"{shp1} and {shp2}"
            )

        # extra parameters
        ntimes = shp1[0]
        nmax = shp1[1] - 1
        lmax = shp1[2] - 1

        self._setup_wrapper({'nmax': nmax, 'lmax': lmax, 'ntimes': ntimes})
</file>

<file path="gala/potential/scf/bfe.pyx">
# coding: utf-8
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: language_level=3

# Standard library
from libc.math cimport M_PI

# Third party
from astropy.constants import G
import numpy as np
cimport numpy as np
np.import_array()
import cython
cimport cython

cdef extern from "extra_compile_macros.h":
    int USE_GSL

cdef extern from "scf/src/bfe_helper.h":
    double rho_nlm(double s, double phi, double X, int n, int l, int m) nogil
    double phi_nlm(double s, double phi, double X, int n, int l, int m) nogil
    double sph_grad_phi_nlm(double s, double phi, double X, int n, int l, int m, double *grad) nogil

cdef extern from "scf/src/bfe.h":
    void scf_density_helper(double *xyz, int K, double M, double r_s,
                            double *Snlm, double *Tnlm,
                            int nmax, int lmax, double *dens) nogil
    void scf_potential_helper(double *xyz, int K, double G, double M, double r_s,
                              double *Snlm, double *Tnlm,
                              int nmax, int lmax, double *potv) nogil
    void scf_gradient_helper(double *xyz, int K, double G, double M, double r_s,
                             double *Snlm, double *Tnlm,
                             int nmax, int lmax, double *grad) nogil

__all__ = ['density', 'potential', 'gradient']

cpdef density(double[:, ::1] xyz,
              double[:, :, ::1] Snlm, double[:, :, ::1] Tnlm,
              double M=1., double r_s=1.):
    """
    density(xyz, Snlm, Tnlm, M=1, r_s=1)

    Compute the density of the basis function expansion
    at a set of positions given the expansion coefficients.

    Parameters
    ----------
    xyz : `~numpy.ndarray`
        A 2D array of positions where ``axis=0`` are multiple positions
        and ``axis=1`` are the coordinate dimensions (x, y, z).
    Snlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the cosine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    Tnlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the sine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    M : numeric (optional)
        Mass scale. Leave unset for dimensionless units.
    r_s : numeric (optional)
        Length scale. Leave unset for dimensionless units.

    Returns
    -------
    dens : `~numpy.ndarray`
        A 1D array of the density at each input position.
        Will have the same length as the input position array, ``xyz``.

    """

    cdef:
        int ncoords = xyz.shape[0]
        double[::1] dens = np.zeros(ncoords)

        int nmax = Snlm.shape[0]-1
        int lmax = Snlm.shape[1]-1

    if USE_GSL == 1:
        scf_density_helper(&xyz[0, 0], ncoords, M, r_s,
                           &Snlm[0, 0, 0], &Tnlm[0, 0, 0],
                           nmax, lmax, &dens[0])

    return np.array(dens)

cpdef potential(double[:, ::1] xyz,
                double[:, :, ::1] Snlm, double[:, :, ::1] Tnlm,
                double G=1., double M=1., double r_s=1.):
    """
    potential(xyz, Snlm, Tnlm, G=1, M=1, r_s=1)

    Compute the gravitational potential of the basis function expansion
    at a set of positions given the expansion coefficients.

    Parameters
    ----------
    xyz : `~numpy.ndarray`
        A 2D array of positions where ``axis=0`` are multiple positions
        and ``axis=1`` are the coordinate dimensions (x, y, z).
    Snlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the cosine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    Tnlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the sine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    G : numeric (optional)
        Gravitational constant. Leave unset for dimensionless units.
    M : numeric (optional)
        Mass scale. Leave unset for dimensionless units.
    r_s : numeric (optional)
        Length scale. Leave unset for dimensionless units.

    Returns
    -------
    pot : `~numpy.ndarray`
        A 1D array of the value of the potential at each input position.
        Will have the same length as the input position array, ``xyz``.

    """
    cdef:
        int ncoords = xyz.shape[0]
        double[::1] potv = np.zeros(ncoords)

        int nmax = Snlm.shape[0]-1
        int lmax = Snlm.shape[1]-1

    if USE_GSL == 1:
        scf_potential_helper(&xyz[0, 0], ncoords, G, M, r_s,
                             &Snlm[0, 0, 0], &Tnlm[0, 0, 0],
                             nmax, lmax, &potv[0])

    return np.array(potv)

cpdef gradient(double[:, ::1] xyz,
               double[:, :, ::1] Snlm, double[:, :, ::1] Tnlm,
               double G=1, double M=1, double r_s=1):
    """
    gradient(xyz, Snlm, Tnlm, G=1, M=1, r_s=1)

    Compute the gradient of the gravitational potential of the
    basis function expansion at a set of positions given the
    expansion coefficients.

    Parameters
    ----------
    xyz : `~numpy.ndarray`
        A 2D array of positions where ``axis=0`` are multiple positions
        and ``axis=1`` are the coordinate dimensions (x, y, z).
    Snlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the cosine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    Tnlm : `~numpy.ndarray`
        A 3D array of expansion coefficients for the sine terms
        of the expansion. This notation follows Lowing et al. (2011).
        The array should have shape ``(nmax+1, lmax+1, lmax+1)`` and any
        invalid terms (e.g., when m > l) will be ignored.
    G : numeric (optional)
        Gravitational constant. Leave unset for dimensionless units.
    M : numeric (optional)
        Mass scale. Leave unset for dimensionless units.
    r_s : numeric (optional)
        Length scale. Leave unset for dimensionless units.

    Returns
    -------
    grad : `~numpy.ndarray`
        A 2D array of the gradient of the potential at each input position.
        Will have the same shape as the input position array, ``xyz``.

    """
    cdef:
        int ncoords = xyz.shape[0]
        double[:, ::1] grad = np.zeros((ncoords, 3))

        int nmax = Snlm.shape[0]-1
        int lmax = Snlm.shape[1]-1

    if USE_GSL == 1:
        scf_gradient_helper(&xyz[0, 0], ncoords, G, M, r_s,
                            &Snlm[0, 0, 0], &Tnlm[0, 0, 0],
                            nmax, lmax, &grad[0, 0])

    return np.array(grad)
</file>

<file path="gala/potential/scf/computecoeff.pyx">
# coding: utf-8
# cython: boundscheck=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

""" THIS IS A THIN WRAPPER AROUND THE FUNCTIONS IN coeff_helper.c """

import numpy as np
cimport numpy as np
from libc.math cimport M_PI

cdef extern from "extra_compile_macros.h":
    int USE_GSL

cdef extern from "math.h":
    double sqrt(double x) nogil
    double cos(double x) nogil
    double sin(double x) nogil

cdef extern from "scf/src/coeff_helper.h":
    double c_Snlm_integrand(double phi, double X, double xsi, double density, int n, int l, int m)
    double c_Tnlm_integrand(double phi, double X, double xsi, double density, int n, int l, int m)
    void c_STnlm_discrete(double *s, double *phi, double *X, double *m_k, int K, int n, int l, int m, double *ST)
    void c_STnlm_var_discrete(double *s, double *phi, double *X, double *m_k, int K, int n, int l, int m, double *ST_var)

__all__ = ['Snlm_integrand', 'Tnlm_integrand']

cpdef Snlm_integrand(double phi, double X, double xsi,
                     density_func,
                     int n, int l, int m,
                     double M, double r_s, args):
    cdef:
        double s = (1 + xsi) / (1 - xsi)
        double r = s * r_s
        double x = r * cos(phi) * sqrt(1-X*X)
        double y = r * sin(phi) * sqrt(1-X*X)
        double z = r * X
        double val = 0.

    if USE_GSL == 1:
        val = c_Snlm_integrand(phi, X, xsi,
                               density_func(x, y, z, *args) / M * r_s*r_s*r_s,
                               n, l, m)
    return val

cpdef Tnlm_integrand(double phi, double X, double xsi,
                     density_func,
                     int n, int l, int m,
                     double M, double r_s, args):
    cdef:
        double s = (1 + xsi) / (1 - xsi)
        double r = s * r_s
        double x = r * cos(phi) * sqrt(1-X*X)
        double y = r * sin(phi) * sqrt(1-X*X)
        double z = r * X
        double val = 0.

    if USE_GSL == 1:
        val = c_Tnlm_integrand(phi, X, xsi,
                               density_func(x, y, z, *args) / M * r_s*r_s*r_s,
                               n, l, m)
    return val

cpdef STnlm_discrete(double[::1] s, double[::1] phi, double[::1] X,
                     double[::1] m_k,
                     int n, int l, int m):
    cdef:
        double[::1] ST = np.zeros(2)
        int K = s.size

    if USE_GSL == 1:
        c_STnlm_discrete(&s[0], &phi[0], &X[0],
                         &m_k[0], K, n, l, m, &ST[0])
    return ST

cpdef STnlm_var_discrete(double[::1] s, double[::1] phi, double[::1] X,
                         double[::1] m_k,
                         int n, int l, int m):
    cdef:
        double[::1] ST_var = np.zeros(3)
        int K = s.size

    if USE_GSL == 1:
        c_STnlm_var_discrete(&s[0], &phi[0], &X[0],
                             &m_k[0], K, n, l, m, &ST_var[0])
    return ST_var
</file>

<file path="gala/potential/scf/core.py">
# coding: utf-8

# Third-party
import numpy as np
import scipy.integrate as si

# Project
from ._computecoeff import (
    Snlm_integrand,
    STnlm_discrete,
    STnlm_var_discrete,
    Tnlm_integrand,
)

__all__ = ["compute_coeffs", "compute_coeffs_discrete"]


def compute_coeffs(
    density_func,
    nmax,
    lmax,
    M,
    r_s,
    args=(),
    skip_odd=False,
    skip_even=False,
    skip_m=False,
    S_only=False,
    progress=False,
    **nquad_opts,
):
    """
    Compute the expansion coefficients for representing the input density
    function using a basis function expansion.

    Computing the coefficients involves computing triple integrals which are
    computationally expensive.

    .. warning::

        GSL is required for this function, see the
        `Installation instructions <http://gala.adrian.pw/en/latest/install.html>`_ for more details

    Parameters
    ----------
    density_func : function, callable
        A function or callable object that evaluates the density at a given
        position. The call format must be of the form: ``density_func(x, y, z,
        M, r_s, args)`` where ``x, y, z`` are cartesian coordinates, ``M`` is a
        scale mass, ``r_s`` a scale radius, and ``args`` is an iterable
        containing any other arguments needed by the density function.
    nmax : int
        Maximum value of ``n`` for the radial expansion.
    lmax : int
        Maximum value of ``l`` for the spherical harmonics.
    M : numeric
        Scale mass.
    r_s : numeric
        Scale radius.
    args : iterable (optional)
        A list or iterable of any other arguments needed by the density
        function.
    skip_odd : bool (optional)
        Skip the odd terms in the angular portion of the expansion. For example,
        only take :math:`l=0, 2, 4, ...`
    skip_even : bool (optional)
        Skip the even terms in the angular portion of the expansion. For
        example, only take :math:`l=1, 3, 5, ...`
    skip_m : bool (optional)
        Ignore terms with :math:`m > 0`.
    S_only : bool (optional)
        Only compute the S coefficients.
    progress : bool (optional)
        If ``tqdm`` is installed, display a progress bar.
    **nquad_opts
        Any additional keyword arguments are passed through to
        `~scipy.integrate.nquad` as options, `opts`.

    Returns
    -------
    Snlm : float, `~numpy.ndarray`
        The value of the cosine expansion coefficient.
    Snlm_err : , `~numpy.ndarray`
        An estimate of the uncertainty in the coefficient value (from `~scipy.integrate.nquad`).
    Tnlm : , `~numpy.ndarray`
        The value of the sine expansion coefficient.
    Tnlm_err : , `~numpy.ndarray`
        An estimate of the uncertainty in the coefficient value. (from `~scipy.integrate.nquad`).

    """
    from gala._cconfig import GSL_ENABLED

    if not GSL_ENABLED:
        raise ValueError(
            "Gala was compiled without GSL and so this function "
            "will not work.  See the gala documentation for more "
            "information about installing and using GSL with "
            "gala: http://gala.adrian.pw/en/latest/install.html"
        )

    lmin = 0
    lstride = 1

    if skip_odd or skip_even:
        lstride = 2

    if skip_even:
        lmin = 1

    Snlm = np.zeros((nmax + 1, lmax + 1, lmax + 1))
    Snlm_e = np.zeros((nmax + 1, lmax + 1, lmax + 1))
    Tnlm = np.zeros((nmax + 1, lmax + 1, lmax + 1))
    Tnlm_e = np.zeros((nmax + 1, lmax + 1, lmax + 1))

    nquad_opts.setdefault("limit", 256)
    nquad_opts.setdefault("epsrel", 1e-10)

    limits = [
        [0, 2 * np.pi],  # phi
        [-1, 1.0],  # X (cos(theta))
        [-1, 1.0],
    ]  # xsi

    nlms = []
    for n in range(nmax + 1):
        for l in range(lmin, lmax + 1, lstride):
            for m in range(l + 1):
                if skip_m and m > 0:
                    continue

                nlms.append((n, l, m))

    if progress:
        try:
            from tqdm import tqdm
        except ImportError as e:
            raise ImportError(
                "tqdm is not installed - you can install it "
                "with `pip install tqdm`.\n" + str(e)
            )
        iterfunc = tqdm
    else:
        iterfunc = lambda x: x  # noqa

    for n, l, m in iterfunc(nlms):
        Snlm[n, l, m], Snlm_e[n, l, m] = si.nquad(
            Snlm_integrand,
            ranges=limits,
            args=(density_func, n, l, m, M, r_s, args),
            opts=nquad_opts,
        )

        if not S_only:
            Tnlm[n, l, m], Tnlm_e[n, l, m] = si.nquad(
                Tnlm_integrand,
                ranges=limits,
                args=(density_func, n, l, m, M, r_s, args),
                opts=nquad_opts,
            )

    return (Snlm, Snlm_e), (Tnlm, Tnlm_e)


def _discrete_worker(task):
    (n, l, m), compute_var, *args = task
    # args = s, phi, X, mass

    S, T = STnlm_discrete(*args, n, l, m)

    if compute_var:
        (S_var, T_var, co_var) = STnlm_var_discrete(*args, n, l, m)
        cov = np.array([[S_var, co_var], [co_var, T_var]])
    else:
        cov = None

    return (n, l, m), (S, T), cov


def compute_coeffs_discrete(
    xyz,
    mass,
    nmax,
    lmax,
    r_s,
    skip_odd=False,
    skip_even=False,
    skip_m=False,
    compute_var=False,
    pool=None,
):
    """
    Compute the expansion coefficients for representing the density distribution
    of input points as a basis function expansion. The points, ``xyz``, are
    assumed to be samples from the density distribution.

    .. warning::

        GSL is required for this function, see the
        `Installation instructions <http://gala.adrian.pw/en/latest/install.html>`_ for more details

    Parameters
    ----------
    xyz : array_like
        Samples from the density distribution. Should have shape ``(n_samples,
        3)``.
    mass : array_like
        Mass of each sample. Should have shape ``(n_samples,)``.
    nmax : int
        Maximum value of ``n`` for the radial expansion.
    lmax : int
        Maximum value of ``l`` for the spherical harmonics.
    r_s : numeric
        Scale radius.
    skip_odd : bool (optional)
        Skip the odd terms in the angular portion of the expansion. For example,
        only take :math:`l=0, 2, 4, ...`
    skip_even : bool (optional)
        Skip the even terms in the angular portion of the expansion. For
        example, only take :math:`l=1, 3, 5, ...`
    skip_m : bool (optional)
        Ignore terms with :math:`m > 0`.
    compute_var : bool (optional)
        Also compute the variances (and covariances) of the coefficients.
    pool : `~multiprocessing.Pool`, `schwimmbad.BasePool` (optional)
        A multi-processing or other parallel processing pool to use to distribute the
        tasks of computing the coefficients for each n,l,m term. The pool instance must
        have a `.map()` method.

    Returns
    -------
    Snlm : `~numpy.ndarray`
        The value of the cosine expansion coefficient.
    Tnlm : `~numpy.ndarray`
        The value of the sine expansion coefficient.
    STcovar : `~numpy.ndarray`, optional
        If ``compute_var==True``, this also computes and returns the covariance
        matrix of the coefficients.

    """
    from gala._cconfig import GSL_ENABLED

    if not GSL_ENABLED:
        raise ValueError(
            "Gala was compiled without GSL and so this function "
            "will not work.  See the gala documentation for more "
            "information about installing and using GSL with "
            "gala: http://gala.adrian.pw/en/latest/install.html"
        )

    if pool is None:
        _map = map
    else:
        _map = pool.map

    lmin = 0
    lstride = 1

    if skip_odd or skip_even:
        lstride = 2

    if skip_even:
        lmin = 1

    Snlm = np.zeros((nmax + 1, lmax + 1, lmax + 1))
    Tnlm = np.zeros((nmax + 1, lmax + 1, lmax + 1))

    # positions and masses of point masses
    xyz = np.ascontiguousarray(np.atleast_2d(xyz))
    mass = np.ascontiguousarray(np.atleast_1d(mass))

    r = np.sqrt(np.sum(xyz**2, axis=-1))
    s = r / r_s
    phi = np.arctan2(xyz[:, 1], xyz[:, 0])
    X = xyz[:, 2] / r

    nlms = []
    for n in range(nmax + 1):
        for l in range(lmin, lmax + 1, lstride):
            for m in range(l + 1):
                if skip_m and m > 0:
                    continue

                nlms.append((n, l, m))

    tasks = [(nlm, compute_var, s, phi, X, mass) for nlm in nlms]
    ST_cov = np.zeros((2, 2) + Snlm.shape)
    for (n, l, m), ST_nlm, ST_cov_nlm in _map(_discrete_worker, tasks):
        Snlm[n, l, m], Tnlm[n, l, m] = ST_nlm
        if compute_var:
            ST_cov[:, :, n, l, m] = ST_cov_nlm

    if compute_var:
        return Snlm, Tnlm, ST_cov
    else:
        return Snlm, Tnlm
</file>

<file path="gala/potential/scf/setup_package.py">
# Licensed under a 3-clause BSD style license - see PYFITS.rst

import sys
from os import path
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    import numpy as np

    exts = []

    # malloc
    mac_incl_path = "/usr/include/malloc"

    # Some READTHEDOCS hacks - see
    # https://github.com/pyFFTW/pyFFTW/pull/161/files
    # https://github.com/pyFFTW/pyFFTW/pull/162/files
    include_dirs = [path.join(sys.prefix, 'include')]
    library_dirs = [path.join(sys.prefix, 'lib')]

    # all need these:
    include_dirs.extend([np.get_include(), mac_incl_path,
                         'gala', 'gala/potential'])

    cfg = defaultdict(list)
    cfg['include_dirs'].extend(include_dirs)
    cfg['library_dirs'].extend(library_dirs)
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/scf/computecoeff.pyx')
    cfg['sources'].append('gala/potential/scf/src/bfe_helper.c')
    cfg['sources'].append('gala/potential/scf/src/coeff_helper.c')
    exts.append(Extension('gala.potential.scf._computecoeff', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].extend(include_dirs)
    cfg['library_dirs'].extend(library_dirs)
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/potential/src/cpotential.c')
    cfg['sources'].append('gala/potential/potential/builtin/builtin_potentials.c')
    cfg['sources'].append('gala/potential/scf/bfe.pyx')
    cfg['sources'].append('gala/potential/scf/src/bfe.c')
    cfg['sources'].append('gala/potential/scf/src/bfe_helper.c')
    exts.append(Extension('gala.potential.scf._bfe', **cfg))

    cfg = defaultdict(list)
    cfg['include_dirs'].extend(include_dirs)
    cfg['library_dirs'].extend(library_dirs)
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/potential/scf/bfe_class.pyx')
    cfg['sources'].append('gala/potential/scf/src/bfe.c')
    cfg['sources'].append('gala/potential/scf/src/bfe_helper.c')
    exts.append(Extension('gala.potential.scf._bfe_class', **cfg))

    return exts


def get_package_data():
    return {'gala.potential.scf': ['*.pyx',
                                   'tests/data/*',
                                   'tests/data/*.csv',
                                   'tests/data/*.dat.gz',
                                   'tests/data/*.coeff',
                                   '*.h', '*.pyx', '*.pxd',
                                   'src/*.c', 'src/*.h']}
</file>

<file path="gala/potential/src/funcdefs.h">
#ifndef _FUNCS_
#define _FUNCS_
    typedef double (*densityfunc)(double t, double *pars, double *q, int n_dim);
    typedef double (*energyfunc)(double t, double *pars, double *q, int n_dim);
    typedef void (*gradientfunc)(double t, double *pars, double *q, int n_dim, double *grad);
    typedef void (*hessianfunc)(double t, double *pars, double *q, int n_dim, double *hess);
#endif
</file>

<file path="gala/potential/__init__.py">
from .potential import *
from .hamiltonian import *
from .frame import *
from .scf import SCFPotential
from .common import PotentialParameter
</file>

<file path="gala/potential/common.py">
# Standard library
import inspect

# Third-party
import astropy.units as u
from astropy.utils import isiterable
import numpy as np

# Project
from ..util import atleast_2d
from ..units import UnitSystem, DimensionlessUnitSystem


class PotentialParameter:
    """A class for defining parameters needed by the potential classes

    Parameters
    ----------
    name : str
        The name of the parameter. For example, "m" for mass.
    physical_type : str (optional)
        The physical type (as defined by `astropy.units`) of the expected
        physical units that this parameter is in. For example, "mass" for a mass
        parameter.
    default : numeric, str, array (optional)
        The default value of the parameter.
    equivalencies : `astropy.units.equivalencies.Equivalency` (optional)
        Any equivalencies required for the parameter.
    """

    def __init__(self, name, physical_type="dimensionless", default=None,
                 equivalencies=None):
        # TODO: could add a "shape" argument?
        # TODO: need better sanitization and validation here

        self.name = str(name)
        self.physical_type = str(physical_type)
        self.default = default
        self.equivalencies = equivalencies

    def __repr__(self):
        return f"<PotentialParameter: {self.name} [{self.physical_type}]>"


class CommonBase:

    def __init_subclass__(cls, GSL_only=False, **kwargs):

        # Read the default call signature for the init
        sig = inspect.signature(cls.__init__)

        # Collect all potential parameters defined on the class:
        cls._parameters = dict()
        sig_parameters = []

        # Also allow passing parameters in to subclassing:
        subcls_params = kwargs.pop('parameters', {})
        subcls_params.update(cls.__dict__)

        for k, v in subcls_params.items():
            if not isinstance(v, PotentialParameter):
                continue

            cls._parameters[k] = v

            if v.default is None:
                default = inspect.Parameter.empty
            else:
                default = v.default

            sig_parameters.append(inspect.Parameter(
                k, inspect.Parameter.POSITIONAL_OR_KEYWORD, default=default))

        for k, param in sig.parameters.items():
            if k == 'self' or param.kind == param.VAR_POSITIONAL:
                continue
            sig_parameters.append(param)
        sig_parameters = sorted(sig_parameters, key=lambda x: int(x.kind))

        # Define a new init signature based on the potential parameters:
        newsig = sig.replace(parameters=tuple(sig_parameters))
        cls.__signature__ = newsig

        super().__init_subclass__(**kwargs)

        cls._GSL_only = GSL_only

    def _validate_units(self, units):

        # make sure the units specified are a UnitSystem instance
        if units is not None and not isinstance(units, UnitSystem):
            units = UnitSystem(*units)

        elif units is None:
            units = DimensionlessUnitSystem()

        return units

    def _parse_parameter_values(self, *args, **kwargs):
        expected_parameter_keys = list(self._parameters.keys())

        if len(args) > len(expected_parameter_keys):
            raise ValueError(
                "Too many positional arguments passed in to "
                f"{self.__class__.__name__}: Potential and Frame classes only "
                "accept parameters as positional arguments, all other "
                "arguments (e.g., units) must now be passed in as keyword "
                "argument.")

        parameter_values = dict()

        # Get any parameters passed as positional arguments
        i = 0

        if args:
            for i in range(len(args)):
                parameter_values[expected_parameter_keys[i]] = args[i]
            i += 1

        # Get parameters passed in as keyword arguments:
        for k in expected_parameter_keys[i:]:
            val = kwargs.pop(k, self._parameters[k].default)
            parameter_values[k] = val

        if len(kwargs):
            raise ValueError(f"{self.__class__} received unexpected keyword "
                             f"argument(s): {list(kwargs.keys())}")

        return parameter_values

    @classmethod
    def _prepare_parameters(cls, parameters, units):

        pars = dict()
        for k, v in parameters.items():
            expected_ptype = cls._parameters[k].physical_type
            expected_unit = units[expected_ptype]
            equiv = cls._parameters[k].equivalencies

            if hasattr(v, 'unit'):
                if (not isinstance(units, DimensionlessUnitSystem) and
                        not v.unit.is_equivalent(expected_unit, equiv)):
                    msg = (f"Parameter {k} has physical type "
                           f"'{v.unit.physical_type}', but we expected a "
                           f"physical type '{expected_ptype}'")
                    if equiv is not None:
                        msg = (msg +
                               f" or something equivalent via the {equiv} "
                               "equivalency.")

                    raise ValueError(msg)

                # NOTE: this can lead to some comparison issues in __eq__, which
                # tests for strong equality between parameter values. Here, the
                # .to() could cause small rounding issues in comparisons
                if v.unit.physical_type != expected_ptype:
                    v = v.to(expected_unit, equiv)

            elif expected_ptype is not None:
                # this is false for empty ptype: treat empty string as u.one
                # (i.e. this goes to the else clause)

                # TODO: remove when fix potentials that ask for scale velocity!
                if expected_ptype == 'speed':
                    v = v * units['length'] / units['time']
                else:
                    v = v * units[expected_ptype]

            else:
                v = v * u.one

            pars[k] = v.decompose(units)

        return pars

    def _remove_units_prepare_shape(self, x):
        from gala.dynamics import PhaseSpacePosition

        if hasattr(x, 'unit'):
            x = x.decompose(self.units).value

        elif isinstance(x, PhaseSpacePosition):
            x = x.w(self.units)

        x = atleast_2d(x, insert_axis=1).astype(np.float64)
        return x

    def _get_c_valid_arr(self, x):
        """
        Warning! Interpretation of axes is different for C code.
        """
        orig_shape = x.shape
        x = np.ascontiguousarray(x.reshape(orig_shape[0], -1).T)
        return orig_shape, x

    def _validate_prepare_time(self, t, pos_c):
        """
        Make sure that t is a 1D array and compatible with the C position array.
        """
        if hasattr(t, 'unit'):
            t = t.decompose(self.units).value

        if not isiterable(t):
            t = np.atleast_1d(t)

        t = np.ascontiguousarray(t.ravel())

        if len(t) > 1:
            if len(t) != pos_c.shape[0]:
                raise ValueError("If passing in an array of times, it must have a shape "
                                 "compatible with the input position(s).")

        return t

    # For comparison operations
    def __eq__(self, other):
        if other is None or not hasattr(other, 'parameters'):
            return False

        # the funkiness in the below is in case there are array parameters:
        par_bool = [
            (k1 == k2) and np.all(self.parameters[k1] == other.parameters[k2])
            for k1, k2 in zip(self.parameters.keys(), other.parameters.keys())]
        return np.all(par_bool) and (str(self) == str(other)) and (self.units == other.units)

    # String representations:
    def __repr__(self):
        pars = []

        keys = self.parameters.keys()
        for k in keys:
            v = self.parameters[k].value
            post = ""

            if hasattr(v, 'unit'):
                post = f" {v.unit}"
                v = v.value

            if isinstance(v, float):
                if v == 0:
                    par = f"{v:.0f}"
                elif np.log10(np.abs(v)) < -2 or np.log10(np.abs(v)) > 5:
                    par = f"{v:.2e}"
                else:
                    par = f"{v:.2f}"

            elif isinstance(v, int) and np.log10(np.abs(v)) > 5:
                par = f"{v:.2e}"

            else:
                par = str(v)

            pars.append(f"{k}={par}{post}")

        par_str = ", ".join(pars)

        if isinstance(self.units, DimensionlessUnitSystem):
            return f"<{self.__class__.__name__}: {par_str} (dimensionless)>"
        else:
            core_units_str = ",".join(map(str, self.units._core_units))
            return f"<{self.__class__.__name__}: {par_str} ({core_units_str})>"

    def __str__(self):
        return self.__class__.__name__
</file>

<file path="gala/tests/optional_deps.py">
"""Checks for optional dependencies using lazy import from
`PEP 562 <https://www.python.org/dev/peps/pep-0562/>`_.
"""
import importlib
import io
from collections.abc import Sequence
from contextlib import redirect_stdout

# First, the top-level packages:
# TODO: This list is a duplicate of the dependencies in setup.cfg "all", but
# some of the package names are different from the pip-install name (e.g.,
# beautifulsoup4 -> bs4).
_optional_deps = ["h5py", "sympy", "tqdm", "twobody", "agama"]
_deps = {k.upper(): k for k in _optional_deps}

# Any subpackages that have different import behavior:
_deps["MATPLOTLIB"] = ("matplotlib", "matplotlib.pyplot")
_deps["GALPY"] = ("galpy", "galpy.orbit", "galpy.potential")

__all__ = [f"HAS_{pkg}" for pkg in _deps]


def __getattr__(name):
    if name in __all__:
        module_name = name[4:]
        modules = _deps[module_name]

        if not isinstance(modules, Sequence) or isinstance(modules, str):
            modules = [modules]

        for module in modules:
            try:
                with redirect_stdout(io.StringIO()):
                    importlib.import_module(module)
            except (ImportError, ModuleNotFoundError):
                return False
            return True

    raise AttributeError(f"Module {__name__!r} has no attribute {name!r}.")
</file>

<file path="gala/tests/setup_package.py">
def get_package_data():
    return {'gala.tests': ['coveragerc']}
</file>

<file path="gala/tests/test_units.py">
"""
    Test the unit system.
"""

import itertools
import pickle

import astropy.units as u
import numpy as np
import pytest
from astropy.constants import G, c

from ..units import DimensionlessUnitSystem, SimulationUnitSystem, UnitSystem


def test_create():
    # dumb
    usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun)

    with pytest.raises(ValueError):
        UnitSystem(u.kpc, u.Myr, u.radian)  # no mass

    with pytest.raises(ValueError):
        UnitSystem(u.kpc, u.Myr, u.Msun)

    with pytest.raises(ValueError):
        UnitSystem(u.kpc, u.radian, u.Msun)

    with pytest.raises(ValueError):
        UnitSystem(u.Myr, u.radian, u.Msun)

    usys = UnitSystem((u.kpc, u.Myr, u.radian, u.Msun))
    usys = UnitSystem(usys)


def test_constants():
    usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun)
    assert np.allclose(
        usys.get_constant("G"), G.decompose([u.kpc, u.Myr, u.radian, u.Msun]).value
    )
    assert np.allclose(
        usys.get_constant("c"), c.decompose([u.kpc, u.Myr, u.radian, u.Msun]).value
    )


def test_decompose():
    usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun, u.km / u.s)
    q = 15.0 * u.km / u.s
    assert q.decompose(usys).unit == u.kpc / u.Myr  # uses the core units
    assert usys.decompose(q).unit == u.km / u.s


def test_dimensionless():
    usys = DimensionlessUnitSystem()
    assert usys["dimensionless"] == u.one
    assert usys["length"] == u.one

    with pytest.raises(ValueError):
        (15 * u.kpc).decompose(usys)

    with pytest.raises(ValueError):
        usys.decompose(15 * u.kpc)


@pytest.mark.parametrize(
    "nu1, nu2",
    itertools.combinations(
        {
            "length": 15 * u.kpc,
            "mass": 1e6 * u.Msun,
            "time": 5e2 * u.Myr,
            "velocity": 150 * u.km / u.s,
        }.items(),
        2,
    ),
)
def test_simulation(nu1, nu2):
    print(nu1, nu2)
    name1, unit1 = nu1
    name2, unit2 = nu2
    SimulationUnitSystem(**{name1: unit1, name2: unit2})


def test_compare():
    usys1 = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun, u.mas / u.yr)
    usys1_clone = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun, u.mas / u.yr)

    usys2 = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun, u.kiloarcsecond / u.yr)
    usys3 = UnitSystem(u.kpc, u.Myr, u.radian, u.kg, u.mas / u.yr)

    assert usys1 == usys1_clone
    assert usys1_clone == usys1

    assert usys1 != usys2
    assert usys2 != usys1

    assert usys1 != usys3
    assert usys3 != usys1


def test_pickle(tmpdir):
    usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun)

    with open(tmpdir / "test.pkl", "wb") as f:
        pickle.dump(usys, f)

    with open(tmpdir / "test.pkl", "rb") as f:
        usys2 = pickle.load(f)


def test_quantity_units():
    usys = UnitSystem(5 * u.kpc, 50 * u.Myr, 1e5 * u.Msun, u.rad)

    assert np.isclose((8 * u.Myr).decompose(usys).value, 8 / 50)
    usys.get_constant("G")
</file>

<file path="gala/tests/test_util.py">
# Third-party
import pytest

# Project
from ..util import ImmutableDict


def test_immutabledict():
    a = dict(a=5, c=6)
    b = ImmutableDict(**a)

    with pytest.raises(TypeError):
        b['test'] = 5
</file>

<file path="gala/__init__.py">
"""
Gala.
"""

import sys

__author__ = "adrn <adrianmpw@gmail.com>"

from ._version import version as __version__
</file>

<file path="gala/_compat_utils.py">
import numpy as np
from packaging.version import Version

# See: https://github.com/astropy/astropy/pull/16181
NUMPY_LT_2_0 = Version(np.__version__) < Version("2.0.0")
COPY_IF_NEEDED = False if NUMPY_LT_2_0 else None
</file>

<file path="gala/cconfig.pyx">
# cython: language_level=3

cdef extern from "extra_compile_macros.h":
    int USE_GSL

if USE_GSL == 1:
    GSL_ENABLED = True
else:
    GSL_ENABLED = False
</file>

<file path="gala/conftest.py">
import os

from pytest_astropy_header.display import (
    PYTEST_HEADER_MODULES,
    TESTED_VERSIONS,)


def pytest_configure(config):

    config.option.astropy_header = True

    # Customize the following lines to add/remove entries from the list of
    # packages for which version numbers are displayed when running the tests.
    PYTEST_HEADER_MODULES.pop('Pandas', None)
    PYTEST_HEADER_MODULES['scikit-image'] = 'skimage'

    from . import __version__
    packagename = os.path.basename(os.path.dirname(__file__))
    TESTED_VERSIONS[packagename] = __version__


def pytest_report_header(config):
    from gala._cconfig import GSL_ENABLED

    if GSL_ENABLED:
        hdr = " +++ Gala compiled with GSL +++"
    else:
        hdr = " --- Gala compiled without GSL ---"

    return hdr + "\n"
</file>

<file path="gala/io.py">
# Third-party
import astropy.units as u


def quantity_from_hdf5(dset):
    """
    Return an Astropy Quantity object from a key in an HDF5 file,
    group, or dataset. This checks to see if the input file/group/dataset
    contains a ``'unit'`` attribute (e.g., in `f.attrs`).

    Parameters
    ----------
    dset : :class:`h5py.DataSet`

    Returns
    -------
    q : `astropy.units.Quantity`, `numpy.ndarray`
        If a unit attribute exists, this returns a Quantity. Otherwise, it
        returns a numpy array.
    """
    if 'unit' in dset.attrs and dset.attrs['unit'] is not None:
        unit = u.Unit(dset.attrs['unit'])
    else:
        unit = 1.

    return dset[:] * unit


def quantity_to_hdf5(f, key, q):
    """
    Turn an Astropy Quantity object into something we can write out to
    an HDF5 file.

    Parameters
    ----------
    f : :class:`h5py.File`, :class:`h5py.Group`, :class:`h5py.DataSet`
    key : str
        The name.
    q : float, `astropy.units.Quantity`
        The quantity.

    """

    if hasattr(q, 'unit'):
        f[key] = q.value
        f[key].attrs['unit'] = str(q.unit)

    else:
        f[key] = q
        f[key].attrs['unit'] = ""
</file>

<file path="gala/logging.py">
# Standard library
import logging
import sys


class CustomStreamHandler(logging.StreamHandler):
    def emit(self, record):
        record.origin = 'gala'

        if record.levelno <= logging.INFO:
            stream = sys.stdout
        else:
            stream = sys.stderr

        self.setStream(stream)
        super().emit(record)


class Logger(logging.getLoggerClass()):
    def _set_defaults(self):
        """Reset logger to its initial state"""

        # Remove all previous handlers
        for handler in self.handlers:
            self.removeHandler(handler)

        # Set default level
        self.setLevel(logging.INFO)

        # Set up the custom handler
        sh = CustomStreamHandler()

        # create formatter
        formatter = logging.Formatter('[%(origin)s] %(levelname)s: %(message)s')

        # add formatter to ch
        sh.setFormatter(formatter)

        self.addHandler(sh)


logging.setLoggerClass(Logger)
logger = logging.getLogger('gala')
logger._set_defaults()
</file>

<file path="gala/setup_package.py">
from distutils.core import Extension
from collections import defaultdict


def get_extensions():
    exts = []

    cfg = defaultdict(list)
    cfg['include_dirs'].append('gala')
    cfg['extra_compile_args'].append('--std=gnu99')
    cfg['sources'].append('gala/cconfig.pyx')
    exts.append(Extension('gala._cconfig', **cfg))

    return exts
</file>

<file path="gala/units.py">
__all__ = [
    "UnitSystem",
    "DimensionlessUnitSystem",
    "SimulationUnitSystem",
    "galactic",
    "dimensionless",
    "solarsystem",
]

import astropy.constants as const
import astropy.units as u
import numpy as np
from astropy.units.physical import _physical_unit_mapping

_greek_letters = [
    "alpha",
    "beta",
    "gamma",
    "delta",
    "epsilon",
    "zeta",
    "eta",
    "theta",
    "iota",
    "kappa",
    "lambda",
    "mu",
    "nu",
    "xi",
    "pi",
    "o",
    "rho",
    "sigma",
    "tau",
    "upsilon",
    "phi",
    "chi",
    "psi",
    "omega",
]


class UnitSystem:
    _required_physical_types = [
        u.get_physical_type("length"),
        u.get_physical_type("time"),
        u.get_physical_type("mass"),
        u.get_physical_type("angle"),
    ]

    def __init__(self, units, *args):
        """
        Represents a system of units.

        At minimum, this consists of a set of length, time, mass, and angle
        units, but may also contain preferred representations for composite
        units. For example, the base unit system could be ``{kpc, Myr, Msun,
        radian}``, but you can also specify a preferred velocity unit, such as
        ``km/s``.

        This class behaves like a dictionary with keys set by physical types. If
        a unit for a particular physical type is not specified on creation, a
        composite unit will be created with the base units. See the examples
        below for some demonstrations.

        Parameters
        ----------
        *units
            The units that define the unit system. At minimum, this must
            contain length, time, mass, and angle units.

        Examples
        --------
        If only base units are specified, any physical type specified as a key
        to this object will be composed out of the base units::

            >>> usys = UnitSystem(u.m, u.s, u.kg, u.radian)
            >>> usys['energy']  # doctest: +SKIP
            Unit("kg m2 / s2")

        However, custom representations for composite units can also be
        specified when initializing::

            >>> usys = UnitSystem(u.m, u.s, u.kg, u.radian, u.erg)
            >>> usys['energy']
            Unit("erg")

        This is useful for Galactic dynamics where lengths and times are usually
        given in terms of ``kpc`` and ``Myr``, but velocities are given in
        ``km/s``::

            >>> usys = UnitSystem(u.kpc, u.Myr, u.Msun, u.radian, u.km/u.s)
            >>> usys['velocity']
            Unit("km / s")

        """

        self._core_units = []

        if isinstance(units, UnitSystem):
            self._registry = units._registry.copy()
            self._core_units = units._core_units
            return

        if len(args) > 0:
            units = (units,) + tuple(args)

        self._registry = dict()
        for unit in units:
            if not isinstance(unit, u.UnitBase):  # hopefully a quantity
                q = unit
                new_unit = u.def_unit(f"{q!s}", q)
                unit = new_unit

            typ = unit.decompose().physical_type
            if typ in self._registry:
                raise ValueError(f"Multiple units passed in with type '{typ}'")
            self._registry[typ] = unit

        for phys_type in self._required_physical_types:
            if phys_type not in self._registry:
                raise ValueError(
                    "You must specify a unit for the physical type" f"'{phys_type}'"
                )
            self._core_units.append(self._registry[phys_type])

    def __getitem__(self, key):
        key = u.get_physical_type(key)

        if key in self._registry:
            return self._registry[key]

        else:
            unit = None
            for k, v in _physical_unit_mapping.items():
                if v == key:
                    unit = u.Unit(" ".join([f"{x}**{y}" for x, y in k]))
                    break

            if unit is None:
                raise ValueError(
                    f"Physical type '{key}' doesn't exist in unit " "registry."
                )

            unit = unit.decompose(self._core_units)
            unit._scale = 1.0
            return unit

    def __len__(self):
        return len(self._core_units)

    def __iter__(self):
        for uu in self._core_units:
            yield uu

    def __str__(self):
        core_units = ", ".join([str(uu) for uu in self._core_units])
        return f"UnitSystem ({core_units})"

    def __repr__(self):
        return f"<{self.__str__()}>"

    def __eq__(self, other):
        for k in self._registry:
            if not self[k] == other[k]:
                return False

        for k in other._registry:
            if not self[k] == other[k]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def to_dict(self):
        """
        Return a dictionary representation of the unit system with keys
        set by the physical types and values set by the unit objects.
        """
        return self._registry.copy()

    def decompose(self, q):
        """
        A thin wrapper around :meth:`astropy.units.Quantity.decompose` that
        knows how to handle Quantities with physical types with non-default
        representations.

        Parameters
        ----------
        q : :class:`~astropy.units.Quantity`
            An instance of an astropy Quantity object.

        Returns
        -------
        q : :class:`~astropy.units.Quantity`
            A new quantity, decomposed to represented in this unit system.
        """
        try:
            ptype = q.unit.physical_type
        except AttributeError:
            raise TypeError(
                "Object must be an astropy.units.Quantity, not "
                f"a '{q.__class__.__name__}'."
            )

        if ptype in self._registry:
            return q.to(self._registry[ptype])
        else:
            return q.decompose(self)

    def get_constant(self, name):
        """
        Retrieve a constant with specified name in this unit system.

        Parameters
        ----------
        name : str
            The name of the constant, e.g., G.

        Returns
        -------
        const : float
            The value of the constant represented in this unit system.

        Examples
        --------

            >>> usys = UnitSystem(u.kpc, u.Myr, u.radian, u.Msun)
            >>> usys.get_constant('c')  # doctest: +SKIP
            306.6013937855506

        """
        try:
            c = getattr(const, name)
        except AttributeError:
            raise ValueError(
                f"Constant name '{name}' doesn't exist in " "astropy.constants"
            )

        return c.decompose(self._core_units).value


class DimensionlessUnitSystem(UnitSystem):
    _required_physical_types = []

    def __init__(self):
        self._core_units = [u.one]
        self._registry = {"dimensionless": u.one}

    def __getitem__(self, key):
        return u.one

    def __str__(self):
        return "UnitSystem (dimensionless)"

    def to_dict(self):
        raise ValueError("Cannot represent dimensionless unit system as dict!")

    def get_constant(self, name):
        raise ValueError("Cannot get constant in dimensionless units!")


l_pt = u.get_physical_type("length")
m_pt = u.get_physical_type("mass")
t_pt = u.get_physical_type("time")
v_pt = u.get_physical_type("velocity")
a_pt = u.get_physical_type("angle")


class SimulationUnitSystem(UnitSystem):
    def __init__(
        self,
        length: u.Unit | u.Quantity[l_pt] = None,
        mass: u.Unit | u.Quantity[m_pt] = None,
        time: u.Unit | u.Quantity[t_pt] = None,
        velocity: u.Unit | u.Quantity[v_pt] = None,
        G: float | u.Quantity = 1.0,
        angle: u.Unit | u.Quantity[a_pt] = u.radian,
    ):
        """
        Represents a system of units for a (dynamical) simulation.

        A common assumption is that G=1. If this is the case, then you only have to
        specify two of the three fundamental unit types (length, mass, time) and the
        rest will be derived from these. You may also optionally specify a velocity with
        one of the base unit types (length, mass, time).

        Examples
        --------
        To convert simulation positions and velocities to physical units, you can
        use this unit system::

            usys = SimulationUnitSystem(length=10 * u.kpc, time=50 * u.Myr)
            (sim_pos * usys["length"]).to(u.kpc)
            (sim_vel * usys["velocity"]).to(u.km/u.s)

        Or, to convert positions and velocities from physical units to simulation
        units::

            (100 * u.kpc).to(usys["length"])

        """
        G = G * const.G.unit

        if length is not None and mass is not None:
            time = 1 / np.sqrt(G * mass / length**3)
        elif length is not None and time is not None:
            mass = 1 / G * length**3 / time**2
        elif length is not None and velocity is not None:
            time = length / velocity
            mass = velocity**2 / G * length
        elif mass is not None and time is not None:
            length = np.cbrt(G * mass * time**2)
        elif mass is not None and velocity is not None:
            length = G * mass / velocity**2
            time = length / velocity
        elif time is not None and velocity is not None:
            mass = 1 / G * velocity**3 * time
            length = G * mass / velocity**2
        else:
            msg = (
                "You must specify at least two of the three fundamental unit types "
                "(length, mass, time) or a velocity unit."
            )
            raise ValueError(msg)

        super().__init__(length, mass, time, angle)


# define galactic unit system
galactic = UnitSystem(u.kpc, u.Myr, u.Msun, u.radian, u.km / u.s)

# solar system units
solarsystem = UnitSystem(u.au, u.M_sun, u.yr, u.radian)

# dimensionless
dimensionless = DimensionlessUnitSystem()
</file>

<file path="gala/util.py">
""" General utilities. """

# Standard library
from collections.abc import Mapping

# Third-party
import numpy as np

__all__ = ["rolling_window", "atleast_2d", "assert_angles_allclose"]


class ImmutableDict(Mapping):

    @classmethod
    def from_dict(cls, somedict):
        return cls(**somedict)

    def __init__(self, **kwargs):
        self._dict = kwargs
        self._hash = None

    def __getitem__(self, key):
        return self._dict[key]

    def __len__(self):
        return len(self._dict)

    def __iter__(self):
        return iter(self._dict)

    def __hash__(self):
        if self._hash is None:
            self._hash = hash(frozenset(self._dict.items()))
        return self._hash

    def __eq__(self, other):
        return self._dict == other._dict

    def __repr__(self):
        return f"<ImmutableDict {self._dict.__repr__()}>"

    def __str__(self):
        return self._dict.__str__()

    def copy(self):
        import copy

        return copy.deepcopy(self._dict)


def rolling_window(arr, window_size, stride=1, return_idx=False):
    """
    There is an example of an iterator for pure-Python objects in:
    http://stackoverflow.com/questions/6822725/rolling-or-sliding-window-iterator-in-python
    This is a rolling-window iterator Numpy arrays, with window size and
    stride control. See examples below for demos.

    Parameters
    ----------
    arr : array_like
        Input numpy array.
    window_size : int
        Width of the window.
    stride : int (optional)
        Number of indices to advance the window each iteration step.
    return_idx : bool (optional)
        Whether to return the slice indices alone with the array segment.

    Examples
    --------
    >>> a = np.array([1, 2, 3, 4, 5, 6])
    >>> for x in rolling_window(a, 3):
    ...     print(x)
    [1 2 3]
    [2 3 4]
    [3 4 5]
    [4 5 6]
    >>> for x in rolling_window(a, 2, stride=2):
    ...     print(x)
    [1 2]
    [3 4]
    [5 6]
    >>> for (i1, i2), x in rolling_window(a, 2, stride=2, return_idx=True): # doctest: +SKIP
    ...     print(i1, i2, x)
    (0, 2, array([1, 2]))
    (2, 4, array([3, 4]))
    (4, 6, array([5, 6]))

    """

    window_size = int(window_size)
    stride = int(stride)

    if window_size < 0 or stride < 1:
        raise ValueError

    arr_len = len(arr)
    if arr_len < window_size:
        if return_idx:
            yield (0, arr_len), arr
        else:
            yield arr

    ix1 = 0
    while ix1 < arr_len:
        ix2 = ix1 + window_size
        result = arr[ix1:ix2]
        if return_idx:
            yield (ix1, ix2), result
        else:
            yield result
        if len(result) < window_size or ix2 >= arr_len:
            break
        ix1 += stride


def atleast_2d(*arys, **kwargs):
    """
    View inputs as arrays with at least two dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted
        to arrays.  Arrays that already have two or more dimensions are
        preserved.
    insert_axis : int (optional)
        Where to create a new axis if input array(s) have <2 dim.

    Returns
    -------
    res, res2, ... : ndarray
        An array, or tuple of arrays, each with ``a.ndim >= 2``.
        Copies are avoided where possible, and views with two or more
        dimensions are returned.

    Examples
    --------
    >>> atleast_2d(3.0) # doctest: +FLOAT_CMP
    array([[3.]])

    >>> x = np.arange(3.0)
    >>> atleast_2d(x) # doctest: +FLOAT_CMP
    array([[0., 1., 2.]])
    >>> atleast_2d(x, insert_axis=-1) # doctest: +FLOAT_CMP
    array([[0.],
           [1.],
           [2.]])
    >>> atleast_2d(x).base is x
    True

    >>> atleast_2d(1, [1, 2], [[1, 2]])
    [array([[1]]), array([[1, 2]]), array([[1, 2]])]

    """
    insert_axis = kwargs.pop("insert_axis", 0)
    slc = [slice(None)] * 2
    slc[insert_axis] = None
    slc = tuple(slc)

    res = []
    for ary in arys:
        ary = np.asanyarray(ary)
        if len(ary.shape) == 0:
            result = ary.reshape(1, 1)
        elif len(ary.shape) == 1:
            result = ary[slc]
        else:
            result = ary
        res.append(result)
    if len(res) == 1:
        return res[0]
    else:
        return res


def assert_angles_allclose(x, y, **kwargs):
    """
    Like numpy's assert_allclose, but for angles (in radians).
    """
    c2 = (np.sin(x) - np.sin(y)) ** 2 + (np.cos(x) - np.cos(y)) ** 2
    diff = np.arccos((2.0 - c2) / 2.0)  # a = b = 1
    assert np.allclose(diff, 0.0, **kwargs)


class GalaDeprecationWarning(DeprecationWarning):
    """
    A warning class to indicate a deprecated feature.
    """
</file>

<file path="paper/paper.bib">
@article{Pearson:2017,
	Adsnote = {Provided by the SAO/NASA Astrophysics Data System},
	Adsurl = {http://adsabs.harvard.edu/abs/2017arXiv170304627P},
	Archiveprefix = {arXiv},
	Author = {{Pearson}, S. and {Price-Whelan}, A.~M. and {Johnston}, K.~V.},
	Eprint = {1703.04627},
	Journal = {ArXiv e-prints},
	Keywords = {Astrophysics - Astrophysics of Galaxies},
	Month = mar,
	Title = {{Gaps in Globular Cluster Streams: Pal 5 and the Galactic Bar}},
	Year = 2017}

@book{Binney:2008,
	Adsnote = {Provided by the SAO/NASA Astrophysics Data System},
	Adsurl = {http://adsabs.harvard.edu/abs/2008gady.book.....B},
	Author = {{Binney}, J. and {Tremaine}, S.},
	Booktitle = {Galactic Dynamics: Second Edition, by James Binney and Scott Tremaine.~ISBN 978-0-691-13026-2 (HB).~Published by Princeton University Press, Princeton, NJ USA, 2008.},
	Publisher = {Princeton University Press},
	Title = {{Galactic Dynamics: Second Edition}},
	Year = 2008}

@article{zenodo,
	Abstractnote = {<p>Gala is a Python package for Galactic astronomy and gravitational dynamics. The bulk of the package centers around implementations of gravitational potentials, numerical integration, and nonlinear dynamics.</p>},
	Author = {Adrian Price-Whelan and Brigitta Sipocz and Syrtis Major and Semyeong Oh},
	Date-Modified = {2017-08-13 14:14:18 +0000},
	Doi = {10.5281/zenodo.833339},
	Month = {Jul},
	Publisher = {Zenodo},
	Title = {adrn/gala: v0.2.1},
	Year = {2017},
	Bdsk-Url-1 = {http://dx.doi.org/10.5281/zenodo.833339}}

@ARTICLE{gaia,
   author = {{Gaia Collaboration} and {Prusti}, T. and {de Bruijne}, J.~H.~J. and
	{Brown}, A.~G.~A. and {Vallenari}, A. and {Babusiaux}, C. and
	{Bailer-Jones}, C.~A.~L. and {Bastian}, U. and {Biermann}, M. and
	{Evans}, D.~W. and et al.},
    title = "{The Gaia mission}",
  journal = {\aap},
archivePrefix = "arXiv",
   eprint = {1609.04153},
 primaryClass = "astro-ph.IM",
 keywords = {space vehicles: instruments, Galaxy: structure, astrometry, parallaxes, proper motions, telescopes},
     year = 2016,
    month = nov,
   volume = 595,
      eid = {A1},
    pages = {A1},
      doi = {10.1051/0004-6361/201629272},
   adsurl = {http://adsabs.harvard.edu/abs/2016A%26A...595A...1G},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@ARTICLE{astropy,
   author = {{Astropy Collaboration} and {Robitaille}, T.~P. and {Tollerud}, E.~J. and
	{Greenfield}, P. and {Droettboom}, M. and {Bray}, E. and {Aldcroft}, T. and
	{Davis}, M. and {Ginsburg}, A. and {Price-Whelan}, A.~M. and
	{Kerzendorf}, W.~E. and {Conley}, A. and {Crighton}, N. and
	{Barbary}, K. and {Muna}, D. and {Ferguson}, H. and {Grollier}, F. and
	{Parikh}, M.~M. and {Nair}, P.~H. and {Unther}, H.~M. and {Deil}, C. and
	{Woillez}, J. and {Conseil}, S. and {Kramer}, R. and {Turner}, J.~E.~H. and
	{Singer}, L. and {Fox}, R. and {Weaver}, B.~A. and {Zabalza}, V. and
	{Edwards}, Z.~I. and {Azalee Bostroem}, K. and {Burke}, D.~J. and
	{Casey}, A.~R. and {Crawford}, S.~M. and {Dencheva}, N. and
	{Ely}, J. and {Jenness}, T. and {Labrie}, K. and {Lim}, P.~L. and
	{Pierfederici}, F. and {Pontzen}, A. and {Ptak}, A. and {Refsdal}, B. and
	{Servillat}, M. and {Streicher}, O.},
    title = "{Astropy: A community Python package for astronomy}",
  journal = {\aap},
archivePrefix = "arXiv",
   eprint = {1307.6212},
 primaryClass = "astro-ph.IM",
 keywords = {methods: data analysis, methods: miscellaneous, virtual observatory tools},
     year = 2013,
    month = oct,
   volume = 558,
      eid = {A33},
    pages = {A33},
      doi = {10.1051/0004-6361/201322068},
   adsurl = {http://adsabs.harvard.edu/abs/2013A%26A...558A..33A},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}
</file>

<file path="paper/paper.md">
---
title: 'Gala: A Python package for galactic dynamics'
tags:
  - Python
  - astronomy
  - dynamics
  - galactic dynamics
  - milky way
authors:
  - name: Adrian M. Price-Whelan
    orcid: 0000-0003-0872-7098
    affiliation: 1
affiliations:
 - name: Lyman Spitzer, Jr. Fellow, Princeton University
   index: 1
date: 13 August 2017
bibliography: paper.bib
---

# Summary

The forces on stars, galaxies, and dark matter under external gravitational
fields lead to the dynamical evolution of structures in the universe. The orbits
of these bodies are therefore key to understanding the formation, history, and
future state of galaxies. The field of "galactic dynamics," which aims to model
the gravitating components of galaxies to study their structure and evolution,
is now well-established, commonly taught, and frequently used in astronomy.
Aside from toy problems and demonstrations, the majority of problems require
efficient numerical tools, many of which require the same base code (e.g., for
performing numerical orbit integration).

``Gala`` is an Astropy-affiliated Python package for galactic dynamics. Python
enables wrapping low-level languages (e.g., C) for speed without losing
flexibility or ease-of-use in the user-interface. The API for ``Gala`` was
designed to provide a class-based and user-friendly interface to fast (C or
Cython-optimized) implementations of common operations such as gravitational
potential and force evaluation, orbit integration, dynamical transformations,
and chaos indicators for nonlinear dynamics. ``Gala`` also relies heavily on and
interfaces well with the implementations of physical units and astronomical
coordinate systems in the ``Astropy`` package [@astropy] (``astropy.units`` and
``astropy.coordinates``).

``Gala`` was designed to be used by both astronomical researchers and by
students in courses on gravitational dynamics or astronomy. It has already been
used in a number of scientific publications [@Pearson:2017] and has also been
used in graduate courses on Galactic dynamics to, e.g., provide interactive
visualizations of textbook material [@Binney:2008]. The combination of speed,
design, and support for Astropy functionality in ``Gala`` will enable exciting
scientific explorations of forthcoming data releases from the *Gaia* mission
[@gaia] by students and experts alike. The source code for ``Gala`` has been
archived to Zenodo with the linked DOI: [@zenodo]

# Acknowledgements

We acknowledge contributions from Brigitta Sipocz, Syrtis Major, and Semyeong
Oh, and support from Kathryn Johnston during the genesis of this project.

# References
</file>

<file path=".gitignore">
# Compiled files
*.py[co]
*.a
*.o
*.so
__pycache__

# Ignore .c files by default to avoid including generated code. If you want to
# add a non-generated .c extension, use `git add -f filename.c`.
# *.c
gala/_compiler.c
gala/dynamics/lyapunov/dop853_lyapunov.c
gala/dynamics/mockstream/_coord.c
gala/dynamics/mockstream/mockstream.c
gala/dynamics/mockstream/df.c
gala/integrate/cyintegrators/dop853.c
gala/integrate/cyintegrators/leapfrog.c
gala/integrate/cyintegrators/ruth4.c
gala/potential/frame/builtin/frames.c
gala/potential/frame/cframe.c
gala/potential/hamiltonian/chamiltonian.c
gala/potential/potential/builtin/cybuiltin.c
gala/potential/potential/ccompositepotential.c
gala/potential/potential/cpotential.c
gala/potential/scf/bfe_class.c
gala/potential/scf/computecoeff.c
gala/potential/scf/bfe.c
gala/extra_compile_macros.h
gala/cconfig.c
gala/dynamics/nbody/nbody.c

# Other generated files
*/_version.py
htmlcov
.coverage
MANIFEST

# Sphinx
docs/api
docs/_build
docs/*/_*

# Eclipse editor project files
.project
.pydevproject
.settings

# Pycharm editor project files
.idea

# Packages/installer info
*.egg
*.egg-info
dist
build
eggs
.eggs
parts
bin
var
sdist
develop-eggs
.installed.cfg
distribute-*.tar.gz
pip-wheel-metadata/

# Other
.*.swp
*~

# Mac OSX
.DS_Store

# Custom
notebooks
plots
scripts
.hypothesis

gala_env
</file>

<file path=".readthedocs.yml">
version: 2

build:
  os: ubuntu-22.04
  tools:
    python: "mambaforge-4.10"
  jobs:
    post_checkout:
        # Use `git log` to check if the latest commit contains "skip ci",
        # in that case exit the command with 183 to cancel the build
        - (git --no-pager log --pretty="tformat:%s -- %b" -1 | grep -viq "skip docs") || exit 183


conda:
  environment: .rtd-environment.yml

python:
  install:
    - method: pip
      path: .
      extra_requirements:
        - docs

sphinx:
  configuration: docs/conf.py

formats: []
</file>

<file path=".rtd-environment.yml">
dependencies:
  - python=3.11
  - gsl
  - pip
  - pip:
    - -e .[docs]
</file>

<file path="AUTHORS.rst">
**Main author:** Adrian Price-Whelan (`@adrn <https://github.com/adrn>`_)

All contributors (alphabetical last name):

* Bill Chen (@ybillchen)
* Dan Foreman-Mackey (@dfm)
* Nico Garavito-Camargo (@jngaravitoc)
* Johnny Greco (@johnnygreco)
* Akeem Hart (@akeemlh)
* Sergey Koposov (@segasai)
* Alex Kurek (@AlexKurek)
* Daniel Lenz (@DanielLenz)
* Zhaozhou Li (@syrte)
* Sophia Lilleengen (@sophialilleengen)
* Pey Lian Lim (@pllim)
* Semyeong Oh (@smoh)
* Clément Robert (@neutrinoceros)
* Brigitta Sipőcz (@bsipocz)
* Harrison Souchereau (@HSouch)
* Nathaniel Starkman (@nstarman)
* Tom Wagg (@tomwagg)
</file>

<file path="CHANGES.rst">
1.9.2 (unreleased)
==================

New Features
------------

- Added a new ``SimulationUnitSystem`` class for handling unit systems in
  simulations, especially for N-body simulations.

Bug fixes
---------

API changes
-----------


1.9.1 (2024-08-26)
==================

- This release fixes the wheel builds for linux and mac and no new features or bug fixes
  are included.


1.9.0 (2024-08-22)
==================

New Features
------------

- Added an option to specify a multiprocessing or parallel processing pool when
  computing basis function coefficients for the SCF potential from discrete particles.

- Added the Burkert potential as a built-in cpotential.

- Added a method to generate the Burkert potential with just r0 as an input

- Added new particle spray method by Chen et al. (2024).

Bug fixes
---------

- Fixed the parameter values in the ``FardalStreamDF`` class to be consistent with
  the values used in Fardal et al. (2015). Added an option ``gala_modified`` to the
  class to enable using the new (correct) parameter values, but the default will
  continue to use the Gala modified values (for backwards compatibility).

- Improved internal efficiency of ``DirectNBody``.

- Fixed a bug in which passing a ``DirectNBody`` instance to the ``MockStreamGenerator.
  run()`` would fail if ``save_all=False`` in the nbody instance.

- Fixed an incompatibility with Astropy v6.1 and above where ``_make_getter`` was
  removed.


API changes
-----------

- Deprecated ``gala.integrate.Integrator.run`` for
  ``gala.integrate.Integrator.__call__``. The old method will raise a warning
  and will be removed in a future release.


1.8.1 (2023-12-31)
==================

- New release to fix upload to PyPI from GitHub Actions and invalid pin in pyia
  dependency.


1.8 (2023-12-23)
================

New Features
------------

- Added a ``.guiding_center()`` method to ``PhaseSpacePosition`` and ``Orbit`` to
  compute the guiding center radius.

- Added a way to convert Gala potential instances to Agama potential instances.

Bug fixes
---------

- Fixed a bug with the ``plot_contours()`` and ``plot_density_contours()`` methods so
  that times specified are now passed through correctly to the potential methods.

- Fixed the YAML output to use ``default_flow_style=None`` for serializing potential
  objects, which leads to a more efficient array output.

- ``scf.compute_coeffs_discrete`` now raises an error if GSL is not enabled rather than
  silently returning zeros

- ``SCFPotential`` will now work with IO functions (``save`` & ``load``)

- Fixes compatibility with Astropy v6.0

API changes
-----------

- Changed the way potential interoperability is done with other Galactic dynamics
  packages (Agama, galpy, etc.). It is now handled by the ``Potential.as_interop()``
  method on all potential class instances.


1.7.1 (2023-08-05)
==================

- Switched build system to use pyproject.toml instead of setup.cfg

1.7 (2023-08-05)
================

New Features
------------

- Added a method to export the internal components of an
  ``MN3ExponentialDiskPotential()`` to three ``MiyamotoNagaiPotential`` instances.

- Added a new Milky Way potential model: ``MilkyWayPotential2022``, which is based on
  updated measurements of the disk structure and circular velocity curve of the disk.

- Added the ability to use leapfrog integration within the ``DirectNBody`` integrator.

- Added a new coordinate frame for the Vasiliev+2021 Sagittarius stream coordinate
  system, ``SagittariusVasiliev21``.

Bug fixes
---------

- Fixed a bug with the ``OrphanKoposov19()`` coordinate frame that caused the wrong
  rotation matrix to be returned.

- Fixed an ``AstropyDeprecationWarning`` resulting from the use of ``override__dir__``.

- Fixed a bug in ``Orbit.estimate_period()`` that would cause the method to fail with a
  ``UnitsError`` if one orbit returned a nan value for the period.

- Fixed a bug when compiling the ``dop853`` integrator.

API changes
-----------

- Refactored the way ``GreatCircleICRSFrame()`` works to be more consistent and
  unambiguous with coordinate frame definitions. The frame now requires an input pole
  and origin, but can be initialized in old ways using the ``from_*()`` class methods
  (e.g., with ``pole`` and ``ra0`` values).


1.6.1 (2022-11-07)
==================

Bug fixes
---------

- Properly incorporate commits related to ``SCFInterpolatedPotential``.


1.6 (2022-11-07)
================

New Features
------------

- Added a ``.replicate()`` method to Potential classes to enable copying
  potential objects but modifying some parameter values.

- Added a new potential class ``MN3ExponentialDiskPotential`` based on Smith et
  al. (2015): an approximation of the potential generated by a double
  exponential disk using a sum of three Miyamoto-Nagai disks.

- The ``Orbit.estimate_period()`` method now returns period estimates in all
  phase-space components instead of just the radial period.

- Added a ``store_all`` flag to the integrators to control whether to save
  phase-space information for all timesteps or only the final timestep.

- Added a ``plot_rotation_curve()`` method to all potential objects to make a 1D plot
  of the circular velocity curve.

- Added a new potential for representing multipole expansions ``MultipolePotential``.

- Added a new potential ``CylSplinePotential`` for flexible representation of
  axisymmetric potentials by allowing passing in grids of potential values
  evaluated grids of R, z values (like the ``CylSpline`` potential in Agama).

- Added a ``show_time`` flag to ``Orbit.animate()`` to control whether to show the
  current timestep.

- Changed ``Orbit.animate()`` to allow for different ``marker_style`` and
  ``segment_style`` options for individual orbits by passing a list of dicts instead
  of just a dict.

- Added an experimental new class ``SCFInterpolatedPotential`` that accepts a time
  series of coefficients and interpolates the coefficient values to any evaluation time.

Bug fixes
---------

- Fixed a bug where the ``NFWPotential`` energy was nan when evaluating at the
  origin, and added tests for all potentials to check for a finite value of the
  potential at the origin (when expected).

- Fixed a bug in ``NFWPotential.from_M200_c()`` where the incorrect scale radius
  was computed (Cython does not always use Python 3 division rules for dividing
  integers!).

- Fixed a bug in the (C-level/internal) estimation of the 2nd derivative of the
  potential, used to generate mock streams, that affects non-conservative force
  fields.

API changes
-----------

- The ``Orbit.estimate_period()`` method now returns period estimates in all
  phase-space components instead of just the radial period.


1.5 (2022-03-03)
================

New Features
------------

- Implemented a basic progress bar for integrating orbits and mock streams. Pass
  ``progress=True`` with ``Integrator_kwargs`` when calling
  ``.integrate_orbit()``, or pass ``progress=True`` to
  ``MockStreamGenerator.run()``.

- Added a new symplectic integrator: The Ruth 4th-order integrator, implemented
  with the class ``Ruth4Integrator``.

- Added a ``Orbit.animate()`` method to make ``matplotlib`` animations of
  orbits.

- Modified ``Orbit._max_helper()`` to use a parabola instead of interpolation

- Added functionality to transform from action-angle coordinates to Cartesian
  position velocity coordinates in the Isochrone potential:
  ``gala.dynamics.actionangle.isochrone_aa_to_xv()``.

- Added a new method on ``DirectNBody`` to enable computing the instantaneous,
  mutual, N-body acceleration vectors ``DirectNBody.acceleration()``.

Bug fixes
---------

- Fixed ``find_actions()`` to accept an ``Orbit`` instance with multiple orbits.

- Fixed a bug that appeared when trying to release all mock stream particles at
  the same timestep (e.g., pericenter).

- Fixed a bug where time arrays returned from ``parse_time_specification``
  could come back with a non-float64 dtype.

- Fixed a bug with ``DirectNBody`` with composite potentials where only the
  first potential component would move as a body / particle.

- Fixed a bug with the Python implementation of Leapfrog integration
  ``LeapfrogIntegrator`` that led to incorrect orbits for non-conservative
  systems that were integrated backwards (i.e. with ``dt<<0``).

- Fixed a bug with the ``FlattenedNFW`` potential class in which the energy and
  gradient functions were not using the inputted flattening (``c`` value) and
  were instead defaulting to the spherical NFW model.

- Enabled pickling ``Frame`` instances and therefore now ``Hamiltonian``
  instances.

- Fixed a bug with ``autolim=True`` during Orbit plotting where the axes limits
  were only dependent on the most recent Orbit rather than all that were present
  on the axis

API changes
-----------

- Renamed ``gala.dynamics.actionangle.isochrone_to_aa()`` to
  ``gala.dynamics.actionangle.isochrone_xv_to_aa()``

- Renamed ``gala.dynamics.actionangle.find_actions()`` to
  ``gala.dynamics.actionangle.find_actions_o2gf()``


1.4.1 (2021-07-01)
==================

- Fixed a RST bug that caused the README to fail to render.


1.4 (2021-07-01)
================

New Features
------------

- ``UnitSystem`` objects can now be created with custom units passed in as
  Astropy ``Quantity`` objects.

- Added functionality to convert Gala potential objects to Galpy potential
  objects, or to create Gala potential objects from a pre-existing Galpy
  potential.

- Added a ``plot_3d()`` method for ``Orbit`` objects to make 3D plots of the
  orbital trajectories.

Bug fixes
---------

- Fixed a bug when calling ``orbit.norbits`` when the representation is not
  cartesian.

- Fixed a bug with ``GreatCircleICRSFrame.from_endpoints()`` that caused an
  error when the input coordinates had associated velocity data.

- Fixed a bug with the ``JaffePotential`` density evaluation, which was too low
  by a factor of two.

- Implemented a density function for ``LogarithmicPotential``, which was
  missing previously.

- The analytic action-angle and ``find_actions()`` utilities now correctly
  return frequencies with angular frequency units rather than frequency.

API changes
-----------

- Removed the deprecated ``gala.coordinates.get_galactocentric2019()`` function.


1.3 (2020-10-27)
================

New Features
------------

- Added a new ``.to_sympy()`` classmethod for the ``Potential`` classes to
  return a sympy expression and variables.

- Added a method, ``.to_galpy_orbit()``, to convert Gala ``Orbit`` instances to
  Galpy ``Orbit`` objects.

- The ``NFWPotential`` can now be instantiated via a new classmethod:
  ``NFWPotential.from_M200_c()``, which accepts a virial mass and a
  concentration.

- Added a fast way of computing the Staeckel focal length, ``Delta``, using
  Gala potential classes, ``gala.dynamics.get_staeckel_fudge_delta``

Bug fixes
---------

- Fixed a bug with ``Potential`` classes ``.replace_units()`` so that classes
  with dimensionless unit systems cannot be replaced with physical unit systems,
  and vice versa.

- Implemented Hessian functions for most potentials.

- Fixed ``.to_latex()`` to properly return a latex representation of the
  potential. This uses the new ``.to_sympy()`` method under the hood.

- Potential classes now validate that input positions have dimensionality that
  matches what is expected for each potential.

API changes
-----------

- Changed the way new ``Potential`` classes are defined: they now rely on
  defining class-level ``PotentialParameter`` objects, which reduces a
  significant amount of boilerplate code in the built-in potentials.


1.2 (2020-07-13)
================

- Gala now builds on Windows!

New Features
------------

- Added a coordinate frame for the Pal 13 stream, ``Pal13Shipp20``.

Bug fixes
---------

- Fixed a bug with the mock stream machinery in which the stream would not
  integrate for the specified number of timesteps if an array of
  ``n_particles`` was passed in with 0's near the end of the array.


1.1 (2020-03-08)
================

New Features
------------
- Potential objects now support replacing the unit system with the
  ``.replace_units()`` method, or by updating the ``.units`` attribute on an
  existing instance.
- Added a ``DirectNBody`` class that supports direct N-body orbit integration in
  (optional) external background potentials.
- Added a coordinate frame for the Jhelum stream, ``JhelumBonaca19``.
- Added a function for retrieving a more modern Galactocentric reference frame,
  ``gala.coordinates.get_galactocentric2019()``.
- Added a classmethod to allow initializing a ``GreatCircleICRSFrame`` from a
  rotation matrix that specifies the transformation from ``ICRS`` to the great
  circle frame.

Bug fixes
---------
- Fixed an issue that led to incorrect ``GreatCircleICRSFrame`` transformations
  when no ``ra0`` was provided.
- Fixed a bug in the ``OrphanKoposov19`` transformation.

API changes
-----------
- Overhauled the mock stellar stream generation methodology to allow for more
  general stream generation. See ``MockStreamGenerator`` and the stream
  distribution function classes, e.g., ``FardalStreamDF``.
- Removed deprecated ``CartesianPhaseSpacePosition`` class.
- Removed long deprecated ``Quaternion`` class.


1.0 (2019-04-12)
================

New Features
------------
- Added a new coordinate frame for great circle coordinate systems defined by a
  pole. This frame can be created with a pole and origin, a pole and longitude
  zero point, by two points along a great circle, or by specifying the cartesian
  basis vectors of the new frame.
- Added a function to transform a proper motion covariance matrix to a new
  coordinate frame.
- Added support for compiling Gala with or without the GNU Scientific Library
  (GSL), which is needed for the new potential classes indicated below.
- Added a new ``PowerLawCutoffPotential`` class for a power-law density
  distribution with an exponential cutoff *(requires GSL)*.
- Added an implementation of the ``MWPotential2014`` from ``galpy`` (called
  ``BovyMWPotential2014`` in ``gala``) *(requires GSL)*.
- Added an implementation of the Self-Consistent Field (SCF) basis function
  expansion method for representing potential-density pairs *(requires GSL)*.
- Most Potential classes now support rotations and origin shifts through the
  ``R`` and ``origin`` arguments.
- Added a ``progress`` argument to the Python integrators to display a progress
  bar when stepping the integrators.
- When generating mock stellar streams and storing snapshots (rather than just
  the final phase-space positions of the particles) now supports specifying the
  snapshot frequency with the ``output_every`` argument.

Bug fixes
---------
- Stream frames now properly wrap the longitude (``phi1``) components to the
  range (-180, 180) deg.

API changes
-----------
- Stream classes have been renamed to reflect the author that defined them.
- Proper motion and coordinate velocity transformations have now been removed in
  favor of the implementations in Astropy.
- Added a ``.data`` attribute to ``PhaseSpacePosition`` objects that returns a
  ``Representation`` or ``NDRepresentation`` instance with velocity data
  (differentials) attached.

0.3 (2018-04-23)
================

New Features
------------

- Added a ``NullPotential`` class that has 0 mass and serves as a placeholder.
- Added a new ``zmax()`` method on the ``Orbit`` class to compute the maximum z
  heights and times, or the mean maximum z height. Similar to ``apocenter()``
  and ``pericenter()``.
- Added a new generator method on the ``Orbit`` class for easy iteration over
  orbits.

Bug fixes
---------

- ``Orbit.norbits`` now works...oops.
- ``apocenter()`` and ``pericenter()`` now work when more than one orbit is
  stored in an ``Orbit`` class.

0.2.2 (2017-10-07)
==================

New features
------------
- Added a new coordinate frame aligned with the Palomar 5 stream.
- Added a function ``gala.dynamics.combine`` to combine ``PhaseSpacePosition``
  or ``Orbit`` objects.

Bug fixes
---------
- Added a density function for the Kepler potential.
- Added a density function for the Long & Murali bar potential

Other changes
-------------
- Added JOSS paper.
- Cleaned up some tests and documentation to use the ``Hamiltonian`` object.

0.2.1 (2017-07-19)
==================

Bug fixes
---------
- Array parameters are now numpy.ravel'd before being passed to the
  ``CPotentialWrapper`` class methods.
- Added attribution to Bovy 2015 for disk potential in MilkyWayPotential

0.2 (2017-07-15)
================

New Features
------------
- Added a new potential class for the Satoh density (Satoh 1980).
- Added support for Leapfrog integration when generating mock stellar streams.
- Added new colormaps and defaults for the matplotlib style.
- Added support for non-inertial reference frames and implemented a constant
  rotating reference frame.
- Added a new class - ``Hamiltonian`` - for storing potentials with reference
  frames. This should be used for easy orbit integration instead of the
  potential classes.
- Added a new argument to the mock stream generation functions t output orbits
  of all of the mock stream star particles to an HDF5 file.
- Cleaned up and simplified the process of subclassing a C-implemented
  gravitational potential.
- Gravitational potential class instances can now be composed by just adding the
  instances.
- Added a ``MilkyWayPotential`` class.

API-breaking changes
--------------------
- ``CartesianPhaseSpacePosition`` and ``CartesianOrbit`` are deprecated. Use
  ``PhaseSpacePosition`` and ``Orbit`` with a Cartesian representation instead.
- Overhauled the storage of position and velocity information on
  ``PhaseSpacePosition`` and ``Orbit`` classes. This uses new features in
  Astropy 2.0 that allow attaching "differential" classes to representation
  classes for storing velocity information. ``.pos`` and ``.vel`` no longer
  point to arrays of Cartesian coordinates, but now instead point to
  astropy.coordinates representation and differential objects, respectively.

0.1.1 (2016-05-20)
==================

- Removed debug statement.
- Added 'Why' page to documentation.

0.1.0 (2016-05-19)
==================

- Initial release.
</file>

<file path="CODE_OF_CONDUCT.md">
All ``gala`` community members are expected to abide by the [Astropy Project
Code of Conduct](http://www.astropy.org/code_of_conduct.html).
</file>

<file path="codemeta.json">
{
    "@context": "https://doi.org/10.5063/schema/codemeta-2.0",
    "@type": "SoftwareSourceCode",
    "name": "Gala: Galactic astronomy and gravitational dynamics",
    "description": "Gala is an Astropy-affiliated Python package for galactic dynamics. Python enables wrapping low-level languages (e.g., C) for speed without losing flexibility or ease-of-use in the user-interface. The API for Gala was designed to provide a class-based and user-friendly interface to fast (C or Cython-optimized) implementations of common operations such as gravitational potential and force evaluation, orbit integration, dynamical transformations, and chaos indicators for nonlinear dynamics. Gala also relies heavily on and interfaces well with the implementations of physical units and astronomical coordinate systems in the Astropy package (astropy.units and astropy.coordinates).",
    "identifier": "https://dx.doi.org/10.21105/joss.00388",
    "author": [
        {
            "@type": "Person",
            "givenName": "Adrian",
            "familyName": "Price-Whelan",
            "@id": "http://orcid.org/0000-0003-0872-7098"
        }
    ],
    "citation": "https://ui.adsabs.harvard.edu/abs/2017JOSS....2..388P/abstract",
    "relatedLink": [
        "https://gala.adrian.pw/",
        "https://zenodo.org/record/4159870"
    ],
    "codeRepository": [
        "https://github.com/adrn/gala"
    ],
    "version": "v1.3",
    "license": "https://github.com/adrn/gala/blob/main/LICENSE"
}
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2012-2024 Adrian M. Price-Whelan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="pyproject.toml">
[project]
name = "gala"
authors = [
    {name = "Adrian Price-Whelan", email = "adrianmpw@gmail.com"},
]
description = "Galactic dynamics in Python"
readme = "README.rst"
requires-python = ">=3.10"
keywords = ["astronomy", "dynamics"]
license = {file = "LICENSE"}
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python",
    "Topic :: Scientific/Engineering :: Astronomy"
]
dependencies = [
    "numpy>=1.24.4",
    "scipy>=1.8",
    "astropy>=5.0",
    "pyyaml",
    "cython>=0.29"
]
dynamic = ["version"]

[tool.setuptools.dynamic]
version = {attr = "gala.__version__"}

[project.urls]
Documentation = "https://gala.adrian.pw"
Repository = "https://github.com/adrn/gala.git"

[project.optional-dependencies]
shared = [
    "matplotlib",
    "numexpr",
    "h5py",
    "tqdm",
]
test = [
    "gala[shared]",
    "pytest",
    "pytest-astropy",
]
extra = [
    "galpy",
    "sympy",
    "twobody",
]
docs = [
    "gala[shared,extra]",
    "numpydoc",
    "IPython",
    "nbsphinx",
    "ipython_genutils",
    "pydata_sphinx_theme",
    "sphinx",
    "sphinxcontrib-bibtex",
    "sphinx-astrorefs",
    "sphinx_automodapi",
    "sphinx_astropy",
    "rtds_action",
    "requests"
]
tutorials = [
    "gala[shared,extra]",
    "IPython",
    "nbconvert",
    "ipython_genutils",
    "jupyter_client",
    "ipykernel",
    "jupytext",
    "pyia>=1.4",
    "astroquery"
]

[build-system]
requires = [
    "setuptools>=42",
    "wheel",
    "setuptools_scm",
    "extension-helpers==1.*",
    "numpy>=2.0",
    "cython"
]
build-backend = "setuptools.build_meta"

[tool.setuptools.packages.find]
where = ["."]
include = ["gala", "gala.*"]

[tool.setuptools.package-data]
"*" = ["*.c"]
"gala" = ["extra_compile_macros.h", "cconfig.pyx", "*.c"]
"gala.coordinates.tests" = ["*.txt", "*.npy", "SgrCoord_data", "*.csv"]
"gala.dynamics" = ["*/*.pyx", "*/*.pxd", "*/*.h", "nbody/nbody_helper.h"]
"gala.integrate" = [
    "*/*.pyx",
    "*/*.pxd",
    "cyintegrators/*.c",
    "cyintegrators/dopri/*.c",
    "cyintegrators/dopri/*.h"
]
"gala.potential" = [
    "src/funcdefs.h",
    "potential/src/cpotential.h",
    "frame/src/cframe.h",
    "*/*.pyx",
    "*/*.pxd",
    "scf/tests/data/*",
    "potential/tests/*.yml",
    "potential/tests/*.pot",
    "potential/tests/*.fits"
]

[tool.setuptools_scm]
version_file = "gala/_version.py"
local_scheme = "no-local-version"  # So that uploads to test.pypi.org work

[tool.pytest]
testpaths = ["gala", "docs"]
astropy_header = true
doctest_plus = "enabled"
text_file_format = "rst"
addopts = ["--doctest-rst"]
norecursedirs = [
    "docs/tutorials/*",
    "docs/_*"
]
doctest_norecursedirs = [
    "docs/tutorials/*",
    "docs/_*"
]

[tool.coverage.run]
omit = [
    "gala/_astropy_init*",
    "gala/conftest*",
    "gala/cython_version*",
    "gala/setup_package*",
    "gala/*/setup_package*",
    "gala/*/*/setup_package*",
    "gala/tests/*",
    "gala/*/tests/*",
    "gala/*/*/tests/*",
    "gala/version*",
    "gala/dynamics/_genfunc/*",
    "gala/coordinates/poincarepolar.py",
    "gala/coordinates/velocity_frame_transforms.py",
    "*/gala/_astropy_init*",
    "*/gala/conftest*",
    "*/gala/cython_version*",
    "*/gala/setup_package*",
    "*/gala/*/setup_package*",
    "*/gala/*/*/setup_package*",
    "*/gala/tests/*",
    "*/gala/*/tests/*",
    "*/gala/*/*/tests/*",
    "*/gala/version*",
    "*/gala/dynamics/_genfunc/*",
    "*/gala/coordinates/poincarepolar.py",
    "*/gala/coordinates/velocity_frame_transforms.py",
]

[tool.coverage.report]
exclude_lines = [
    # Have to re-enable the standard pragma
    "pragma: no cover",
    # Don't complain about packages we have installed
    "except ImportError",
    # Don't complain if tests don't hit assertions
    "raise AssertionError",
    "raise NotImplementedError",
    # Don't complain about script hooks
    "def main\\(.*\\):",
    # Ignore branches that don't pertain to this version of Python
    "pragma: py{ignore_python_version}",
    # Don't complain about IPython completion helper
    "def _ipython_key_completions_"
]

[tool.black]
line-length = 88
target-version = ["py310"]

[tool.isort]
profile = "black"
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 88

[tool.ruff]
line-length = 88
select = ["E", "F"]
force-exclude = true

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401", "F403"]
"test*.py" = ["F841"]
"docs/tutorials/*" = ["E703"]
</file>

<file path="README.rst">
|logo|

Gala is a Python package for Galactic and gravitational dynamics.

|Affiliated package| |Coverage Status| |Build status|

Documentation
-------------

|Documentation Status|

The documentation for ``Gala`` is hosted on `Read the docs
<http://gala.adrian.pw>`__.

Installation and Dependencies
-----------------------------

|conda| |PyPI|

The easiest way to get Gala is to install with pip or conda.

The recommended install method is to use ``pip``::

   pip install gala

If you are on Linux or Mac, you can also install ``gala`` with conda using the
conda-forge channel::

    conda install gala --channel conda-forge

See the `installation
instructions <http://gala.adrian.pw/en/latest/install.html>`_ in the
`documentation <http://gala.adrian.pw>`__ for more information.

Attribution
-----------

|JOSS| |DOI|

If you make use of this code, please cite the `JOSS <http://joss.theoj.org>`_
paper::

    @article{gala,
      doi = {10.21105/joss.00388},
      url = {https://doi.org/10.21105%2Fjoss.00388},
      year = 2017,
      month = {oct},
      publisher = {The Open Journal},
      volume = {2},
      number = {18},
      author = {Adrian M. Price-Whelan},
      title = {Gala: A Python package for galactic dynamics},
      journal = {The Journal of Open Source Software}
    }

Please also cite the Zenodo DOI |DOI| as a software citation - see the
`documentation
<http://gala.adrian.pw/en/latest/index.html#citation-and-attribution>`_ for up
to date citation information.

License
-------

|License|

Copyright 2013-2024 Adrian Price-Whelan and contributors.

``Gala`` is free software made available under the MIT License. For details see
the `LICENSE <https://github.com/adrn/gala/blob/main/LICENSE>`_ file.

.. |Coverage Status| image:: https://codecov.io/gh/adrn/gala/branch/main/graph/badge.svg
   :target: https://codecov.io/gh/adrn/gala
.. |Build status| image:: https://github.com/adrn/gala/actions/workflows/tests.yml/badge.svg
   :target: https://github.com/adrn/gala/actions/workflows/tests.yml
.. |License| image:: http://img.shields.io/badge/license-MIT-blue.svg?style=flat
   :target: https://github.com/adrn/gala/blob/main/LICENSE
.. |PyPI| image:: https://badge.fury.io/py/gala.svg
   :target: https://badge.fury.io/py/gala
.. |conda| image:: https://anaconda.org/conda-forge/gala/badges/version.svg
   :target: https://anaconda.org/conda-forge/gala
.. |Documentation Status| image:: https://readthedocs.org/projects/gala-astro/badge/?version=latest
   :target: http://gala-astro.readthedocs.io/en/latest/?badge=latest
.. |Affiliated package| image:: https://img.shields.io/badge/astropy-affiliated%20package-orange.svg
   :target: http://astropy.org/affiliated
.. |JOSS| image:: http://joss.theoj.org/papers/10.21105/joss.00388/status.svg
   :target: http://joss.theoj.org/papers/10.21105/joss.00388
.. |DOI| image:: https://zenodo.org/badge/17577779.svg
   :target: https://zenodo.org/badge/latestdoi/17577779
.. |ASCL| image:: https://img.shields.io/badge/ascl-1707.006-blue.svg?colorB=262255
   :target: http://ascl.net/1707.006
.. |logo| image:: https://gala.adrian.pw/en/latest/_static/Gala_Logo_RGB.png
   :target: https://github.com/adrn/gala
   :width: 400

Contributors
------------

See the `AUTHORS.rst <https://github.com/adrn/gala/blob/main/AUTHORS.rst>`_
file for a complete list of contributors to the project.
</file>

<file path="setup.py">
#!/usr/bin/env python
# Licensed under an MIT license - see LICENSE

# NOTE: The configuration for the package, including the name, version, and
# other information are set in the setup.cfg file.

import os
import sys

from setuptools import setup

from extension_helpers import get_extensions


# First provide helpful messages if contributors try and run legacy commands
# for tests or docs.

TEST_HELP = """
Note: running tests is no longer done using 'python setup.py test'. Instead
you will need to run:

    tox -e test

If you don't already have tox installed, you can install it with:

    pip install tox

If you only want to run part of the test suite, you can also use pytest
directly with::

    pip install -e .[test]
    pytest

For more information, see:

  http://docs.astropy.org/en/latest/development/testguide.html#running-tests
"""

if 'test' in sys.argv:
    print(TEST_HELP)
    sys.exit(1)

DOCS_HELP = """
Note: building the documentation is no longer done using
'python setup.py build_docs'. Instead you will need to run:

    tox -e build_docs

If you don't already have tox installed, you can install it with:

    pip install tox

You can also build the documentation with Sphinx directly using::

    pip install -e .[docs]
    cd docs
    make html

For more information, see:

  http://docs.astropy.org/en/latest/install.html#builddocs
"""

if 'build_docs' in sys.argv or 'build_sphinx' in sys.argv:
    print(DOCS_HELP)
    sys.exit(1)

VERSION_TEMPLATE = """
# Note that we need to fall back to the hard-coded version if either
# setuptools_scm can't be imported or setuptools_scm can't determine the
# version, so we catch the generic 'Exception'.
try:
    from setuptools_scm import get_version
    version = get_version(root='..', relative_to=__file__)
except Exception:
    version = '{version}'
""".lstrip()

# ----------------------------------------------------------------------------
# GSL support
#
from subprocess import check_output, CalledProcessError

extra_compile_macros_file = 'gala/extra_compile_macros.h'

# Note: on RTD, they now support conda environments, but don't activate the
# conda environment that gets created, and so the C stuff installed with GSL
# aren't picked up. This is my attempt to hack around that!
on_rtd = os.environ.get('READTHEDOCS') == 'True'
if on_rtd:
    PATH = '/home/docs/checkouts/readthedocs.org/user_builds/gala-astro/conda/latest/bin/'
    env = os.environ.copy()
    env['PATH'] = env.get('PATH', "") + ":" + PATH
else:
    env = None

# First, see if the user wants to install without GSL:
nogsl = bool(int(os.environ.get('GALA_NOGSL', 0)))
gsl_version = os.environ.get('GALA_GSL_VERSION', None)
gsl_prefix = os.environ.get('GALA_GSL_PREFIX', None)

# Auto-detect whether GSL is installed
if (not nogsl or nogsl is None) and gsl_version is None: # GSL support enabled
    cmd = ['gsl-config', '--version']
    try:
        gsl_version = check_output(cmd, env=env).decode('utf-8')
    except (OSError, CalledProcessError):
        gsl_version = None

if gsl_version is not None:
    gsl_version = gsl_version.strip().split('.')

# If the hacky macros file already exists, read from that what to do.
# This means people experimenting might need to run "git clean" to remove all
# temp. build products if they want to switch between installing with GSL and
# no GSL support.
# if os.path.exists(extra_compile_macros_file):
#     with open(extra_compile_macros_file, "r") as f:
#         line = f.read().strip()

#     if line.endswith('0'):
#         gsl_version = None
#         nogsl = True

print("-" * 79)
_see_msg = ("See the gala documentation 'installation' page for more "
            "information about GSL support and installing GSL: "
            "http://gala.adrian.pw/en/latest/install.html")
if gsl_version is None:
    if nogsl:
        print('Installing without GSL support.')
    else:
        print('GSL not found: installing without GSL support. ' + _see_msg)

elif gsl_version < ['1', '14']:
    print('Warning: GSL version ({0}) is below the minimum required version '
          '(1.16). Installing without GSL support. '
          .format('.'.join(gsl_version)) + _see_msg)
    gsl_version = None

else:
    print("GSL version {0} found: installing with GSL support"
          .format('.'.join(gsl_version)))

    if gsl_prefix is None:
        # Now get the gsl install location
        cmd = ['gsl-config', '--prefix']
        try:
            gsl_prefix = check_output(cmd, encoding='utf-8')
        except:
            gsl_prefix = str(check_output(cmd, shell=shell))

    gsl_prefix = os.path.normpath(gsl_prefix.strip())

print("-" * 79)

extensions = get_extensions()
for ext in extensions:
    if 'potential.potential' in ext.name or 'scf' in ext.name:
        if gsl_version is not None:
            if 'gsl' not in ext.libraries:
                ext.libraries.append('gsl')
                ext.library_dirs.append(os.path.join(gsl_prefix, 'lib'))
                ext.include_dirs.append(os.path.join(gsl_prefix, 'include'))

            if 'gslcblas' not in ext.libraries:
                ext.libraries.append('gslcblas')

with open(extra_compile_macros_file, 'w') as f:
    if gsl_version is not None:
        f.writelines(['#define USE_GSL 1'])
    else:
        f.writelines(['#define USE_GSL 0'])


setup(use_scm_version={'write_to': os.path.join('gala', 'version.py'),
                       'write_to_template': VERSION_TEMPLATE},
      ext_modules=extensions)
</file>

</repository_files>
