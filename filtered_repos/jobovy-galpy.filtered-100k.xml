<?xml version="1.0" ?>
<compressed_repository total_tokens="99583">
  <file_summary>
    
This section contains a summary of this file.


    <purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>
    


    <file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>
    


    <usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>
    


    <notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>
    


    <additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>
    


  </file_summary>
  <repository_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    config.yml
    feature_request.md
  workflows/
    build_pyodide_wheels.yml
    build_windows.yml
    build.yml
    stale.yml
    wheels.yml
  conda-build-environment-macos-latest.yml
  conda-build-environment-windows-latest.yml
  dependabot.yml
doc/
  source/
    _static/
      clipboard.min.js
      clippy.svg
      copycode.js
      custom.css
      gallery.css
      papers-gallery.js
      try-galpy.js
    _templates/
      layout.html
    examples/
      dierickx_eccentricities.py
      dierickx-edist.py
      galpyrc
      sellwood-jrjp.py
    reference/
      aa.rst
      aaactionsfreqs.rst
      aaactionsfreqsangles.rst
      aaadiabatic.rst
      aaadiabaticgrid.rst
      aacall.rst
      aaecczmaxrperirap.rst
      aaharmonic.rst
      aaharmonicinverse.rst
      aaisochrone.rst
      aaisochroneapprox.rst
      aaisochroneinverse.rst
      aaspherical.rst
      aastaeckel.rst
      aastaeckelgrid.rst
      aatcall.rst
      aatfreqs.rst
      aathessianfreqs.rst
      aatorus.rst
      aaturnphysicaloff.rst
      aaturnphysicalon.rst
      aatxvfreqs.rst
      aatxvjacobianfreqs.rst
      aavertical.rst
      aaverticalinverse.rst
      ars.rst
      config.rst
      configsetro.rst
      configsetvo.rst
      conversion.rst
      conversiondens_in_criticaldens.rst
      conversiondens_in_gevcc.rst
      conversiondens_in_meanmatterdens.rst
      conversiondens_in_msolpc3.rst
      conversionextractphysicalkwargs.rst
      conversionforce_in_10m13kms2.rst
      conversionforce_in_2piGmsolpc2.rst
      conversionforce_in_kmsMyr.rst
      conversionforce_in_pcMyr2.rst
      conversionfreq_in_Gyr.rst
      conversionfreq_in_kmskpc.rst
      conversiongetphysical.rst
      conversionmass_in_1010msol.rst
      conversionmass_in_msol.rst
      conversionphysicalcompatible.rst
      conversionphysicaloutput.rst
      conversionsurfdens_in_msolpc2.rst
      conversiontime_in_Gyr.rst
      conversionvelocity_in_kpcGyr.rst
      coords.rst
      coordscovdvrpmllbbtovxyz.rst
      coordscovgalcenrectgalcencyl.rst
      coordscovpmrapmdectopmllpmbb.rst
      coordscovvxyztogalcencyl.rst
      coordscovvxyztogalcenrect.rst
      coordscustomtopmrapmdec.rst
      coordscustomtoradec.rst
      coordscyltorect.rst
      coordscyltorectvec.rst
      coordscyltospher.rst
      coordscyltosphervec.rst
      coordsdltorphi2d.rst
      coordsgalcencyltovxvyvz.rst
      coordsgalcencyltoxyz.rst
      coordsgalcenrecttovxvyvz.rst
      coordsgalcenrecttoxyz.rst
      coordslbdtoxyz.rst
      coordslbtoradec.rst
      coordspmllpmbbtopmrapmdec.rst
      coordspmrapmdectocustom.rst
      coordspmrapmdectopmllpmbb.rst
      coordspupvtovRvz.rst
      coordsradectocustom.rst
      coordsradectolb.rst
      coordsrectgaltosphergal.rst
      coordsrecttocyl.rst
      coordsrecttocylvec.rst
      coordsrphitodl2d.rst
      coordsRztocoshucosv.rst
      coordsRztouv.rst
      coordssphergaltorectgal.rst
      coordssphertocyl.rst
      coordssphertocylvec.rst
      coordsuvtoRz.rst
      coordsvrpmllpmbbtovxvyvz.rst
      coordsvRvztopupv.rst
      coordsvxvyvztogalcencyl.rst
      coordsvxvyvztogalcenrect.rst
      coordsvxvyvztovrpmllpmbb.rst
      coordsxyztogalcencyl.rst
      coordsxyztogalcenrect.rst
      coordsxyztolbd.rst
      df.rst
      dfconstantbeta.rst
      dfdehnen.rst
      dfeddington.rst
      dfhernquist.rst
      dfhernquistconstantbeta.rst
      dfhernquistosipkov.rst
      dfjeanssigmalos.rst
      dfjeanssigmar.rst
      dfking.rst
      dfnfw.rst
      dfnfwosipkov.rst
      dfosipkovmerritt.rst
      dfplummer.rst
      dfquasiisothermal.rst
      dfschwarzschild.rst
      dfshu.rst
      dfturnphysicaloff.rst
      dfturnphysicalon.rst
      diskdfasymmetricdrift.rst
      diskdfcall.rst
      diskdfkurtosisvR.rst
      diskdfkurtosisvT.rst
      diskdfmeanvR.rst
      diskdfmeanvT.rst
      diskdfoortA.rst
      diskdfoortB.rst
      diskdfoortC.rst
      diskdfoortK.rst
      diskdfsample.rst
      diskdfsampledSurfacemassLOS.rst
      diskdfsampleLOS.rst
      diskdfsampleVRVT.rst
      diskdfsigma2.rst
      diskdfsigma2surfacemass.rst
      diskdfsigmaR2.rst
      diskdfsigmaT2.rst
      diskdfskewvR.rst
      diskdfskewvT.rst
      diskdfsurfacemass.rst
      diskdfsurfacemassLOS.rst
      diskdftargetSigma2.rst
      diskdftargetSurfacemass.rst
      diskdftargetSurfacemassLOS.rst
      diskdfvmomentsurfacemass.rst
      edf.rst
      edfcall.rst
      edfmeanvr.rst
      edfmeanvt.rst
      edfoorta.rst
      edfoortb.rst
      edfoortc.rst
      edfoortk.rst
      edfsigmar2.rst
      edfsigmart.rst
      edfsigmat2.rst
      edfvertexdev.rst
      edfvmomentsurfacemass.rst
      impulse_deltav_general_curvedstream.rst
      impulse_deltav_general_fullplummerintegration.rst
      impulse_deltav_general_orbitintegration.rst
      impulse_deltav_general.rst
      impulse_deltav_hernquist_curvedstream.rst
      impulse_deltav_hernquist.rst
      impulse_deltav_plummer_curvedstream.rst
      impulse_deltav_plummer.rst
      orbit.rst
      orbitanimate.rst
      orbitanimate3d.rst
      orbitbb.rst
      orbitbrutesos.rst
      orbitcall.rst
      orbitdec.rst
      orbitdim.rst
      orbitdist.rst
      orbitE.rst
      orbitecc.rst
      orbitER.rst
      orbitEz.rst
      orbitflip.rst
      orbitfromfit.rst
      orbitfromname.rst
      orbitgetitem.rst
      orbitgetorbit.rst
      orbitgetorbitdxdv.rst
      orbitheliox.rst
      orbithelioy.rst
      orbithelioz.rst
      orbitinit.rst
      orbitint.rst
      orbitintdxdv.rst
      orbitintsos.rst
      orbitJacobi.rst
      orbitjp.rst
      orbitjr.rst
      orbitjz.rst
      orbitl.rst
      orbitlce.rst
      orbitll.rst
      orbitlz.rst
      orbitop.rst
      orbitor.rst
      orbitoz.rst
      orbitphasedim.rst
      orbitphi.rst
      orbitplot.rst
      orbitplot3d.rst
      orbitplotbrutesos.rst
      orbitplotsos.rst
      orbitpmbb.rst
      orbitpmdec.rst
      orbitpmll.rst
      orbitpmra.rst
      orbitr.rst
      orbitra.rst
      orbitrap.rst
      orbitre.rst
      orbitreshape.rst
      orbitrguiding.rst
      orbitrperi.rst
      orbitskycoord.rst
      orbitsos.rst
      orbitsphr.rst
      orbitsphvr.rst
      orbittheta.rst
      orbittime.rst
      orbittolinear.rst
      orbittoplanar.rst
      orbittp.rst
      orbittr.rst
      orbittrtp.rst
      orbitturnphysicaloff.rst
      orbitturnphysicalon.rst
      orbittz.rst
      orbitu.rst
      orbitv.rst
      orbitvbb.rst
      orbitvdec.rst
      orbitvll.rst
      orbitvlos.rst
      orbitvphi.rst
      orbitvr.rst
      orbitvra.rst
      orbitvt.rst
      orbitvtheta.rst
      orbitvx.rst
      orbitvy.rst
      orbitvz.rst
      orbitw.rst
      orbitwp.rst
      orbitwr.rst
      orbitwz.rst
      orbitx.rst
      orbity.rst
      orbitz.rst
      orbitzmax.rst
      plot.rst
      plotdens2d.rst
      plotendprint.rst
      plothist.rst
      plotplot.rst
      plotstartprint.rst
      plottext.rst
      potential.rst
      potential1dadd.rst
      potential1dcall.rst
      potential1devaluate.rst
      potential1dforce.rst
      potential1dforces.rst
      potential1dmul.rst
      potential1dplot.rst
      potential1dplots.rst
      potential1dRZtolinear.rst
      potential1dtolinear.rst
      potential1dturnphysicaloff.rst
      potential1dturnphysicalon.rst
      potential2dadd.rst
      potential2dcall.rst
      potential2depifreq.rst
      potential2devaluate.rst
      potential2dlindbladR.rst
      potential2dlinshureductionfactor.rst
      potential2dmul.rst
      potential2domegac.rst
      potential2dphitorque.rst
      potential2dphitorques.rst
      potential2dplot.rst
      potential2dplotescapecurve.rst
      potential2dplotrotcurve.rst
      potential2dplots.rst
      potential2dr2derivs.rst
      potential2drforce.rst
      potential2drforces.rst
      potential2dRZtoplanar.rst
      potential2dtoplanar.rst
      potential2dturnphysicaloff.rst
      potential2dturnphysicalon.rst
      potential2dvcirc.rst
      potential2dvesc.rst
      potential3mn.rst
      potentialadd.rst
      potentialadiabaticcontractwrapper.rst
      potentialanyaxirazorthin.rst
      potentialanyspherical.rst
      potentialburkert.rst
      potentialcall.rst
      potentialchandrasekhardynfric.rst
      potentialconc.rst
      potentialcoredehnen.rst
      potentialcorotwrapper.rst
      potentialcosmphidisk.rst
      potentialdehnen.rst
      potentialdehnenbar.rst
      potentialdehnensmoothwrapper.rst
      potentialdens.rst
      potentialdensities.rst
      potentialdiskscf.rst
      potentialdoubleexp.rst
      potentialdoublepowerspher.rst
      potentialdoublepowertriaxial.rst
      potentialdvcircdr.rst
      potentialdvcircdrs.rst
      potentialellipsoidal.rst
      potentialellipticaldisk.rst
      potentialepifreq.rst
      potentialepifreqs.rst
      potentialevaluate.rst
      potentialferrers.rst
      potentialflatten.rst
      potentialflattenedpower.rst
      potentialflattening.rst
      potentialflattenings.rst
      potentialgaussampwrapper.rst
      potentialhenonheiles.rst
      potentialhernquist.rst
      potentialhomogsphere.rst
      potentialinterprz.rst
      potentialinterpsnapshotrzpotential.rst
      potentialinterpsphere.rst
      potentialisochrone.rst
      potentialisodisk.rst
      potentialjaffe.rst
      potentialkepler.rst
      potentialkg.rst
      potentialking.rst
      potentialkuzmindisk.rst
      potentialkuzminkutuzov.rst
      potentialkuzminlikewrapper.rst
      potentiallce.rst
      potentiallces.rst
      potentiallindbladR.rst
      potentiallindbladRs.rst
      potentialloghalo.rst
      potentiallopsideddisk.rst
      potentialmass.rst
      potentialmasses.rst
      potentialmiyamoto.rst
      potentialmovingobj.rst
      potentialmul.rst
      potentialmvir.rst
      potentialnemoaccname.rst
      potentialnemoaccnames.rst
      potentialnemoaccpars.rst
      potentialnemoaccparss.rst
      potentialnfw.rst
      potentialnoninertialframe.rst
      potentialnull.rst
      potentialnumericalpotentialderivsmixin.rst
      potentialomegac.rst
      potentialomegacs.rst
      potentialperfectellipsoid.rst
      potentialphi2deriv.rst
      potentialphi2derivs.rst
      potentialphitorque.rst
      potentialphitorques.rst
      potentialphizderiv.rst
      potentialphizderivs.rst
      potentialplot.rst
      potentialplotdensities.rst
      potentialplotdensity.rst
      potentialplotescapecurve.rst
      potentialplotescapecurves.rst
      potentialplotrotcurve.rst
      potentialplotrotcurves.rst
      potentialplots.rst
      potentialplotsurfacedensities.rst
      potentialplotsurfacedensity.rst
      potentialplummer.rst
      potentialpowerspher.rst
      potentialpowerspherwcut.rst
      potentialpowertriax.rst
      potentialpseudoiso.rst
      potentialr2deriv.rst
      potentialr2derivs.rst
      potentialrazorexp.rst
      potentialre.rst
      potentialres.rst
      potentialrforce.rst
      potentialrforces.rst
      potentialrhalf.rst
      potentialrhalfs.rst
      potentialring.rst
      potentialrl.rst
      potentialrls.rst
      potentialrmax.rst
      potentialrotateandtiltwrapper.rst
      potentialrphideriv.rst
      potentialrphiderivs.rst
      potentialrtide.rst
      potentialrtides.rst
      potentialrvir.rst
      potentialrzderiv.rst
      potentialrzderivs.rst
      potentialscf.rst
      potentialscfcompute.rst
      potentialscfcomputeaxi.rst
      potentialscfcomputeaxinbody.rst
      potentialscfcomputenbody.rst
      potentialscfcomputesphere.rst
      potentialscfcomputespherenbody.rst
      potentialsnapshotrzpotential.rst
      potentialsoftenedneedle.rst
      potentialsolidbodyrotationwrapper.rst
      potentialspherical.rst
      potentialsphericalshell.rst
      potentialsphr2deriv.rst
      potentialsphr2derivs.rst
      potentialsphrforce.rst
      potentialsphrforces.rst
      potentialspiralarms.rst
      potentialsteadylogspiral.rst
      potentialsurfdens.rst
      potentialsurfdensities.rst
      potentialtdyn.rst
      potentialtdyns.rst
      potentialtimedependentamplitude.rst
      potentialtoamuses.rst
      potentialtoplanar.rst
      potentialtovertical.rst
      potentialtransientlogspiral.rst
      potentialtriaxialgaussian.rst
      potentialtriaxialhernquist.rst
      potentialtriaxialjaffe.rst
      potentialtriaxialnfw.rst
      potentialttensor.rst
      potentialttensors.rst
      potentialturnphysicaloff.rst
      potentialturnphysicaloffs.rst
      potentialturnphysicalon.rst
      potentialturnphysicalons.rst
      potentialvcirc.rst
      potentialvcircs.rst
      potentialverticalfreq.rst
      potentialverticalfreqs.rst
      potentialvesc.rst
      potentialvescs.rst
      potentialvmax.rst
      potentialvterm.rst
      potentialvterms.rst
      potentialz2deriv.rst
      potentialz2derivs.rst
      potentialzforce.rst
      potentialzforces.rst
      potentialzvc.rst
      potentialzvcrange.rst
      potentialzvcranges.rst
      potentialzvcs.rst
      quasidfcall.rst
      quasidfdensity.rst
      quasidfestimatehr.rst
      quasidfestimatehsr.rst
      quasidfestimatehsz.rst
      quasidfestimatehz.rst
      quasidfjmomentdensity.rst
      quasidfmeanjr.rst
      quasidfmeanjz.rst
      quasidfmeanlz.rst
      quasidfmeanvr.rst
      quasidfmeanvt.rst
      quasidfmeanvz.rst
      quasidfpvr.rst
      quasidfpvrvt.rst
      quasidfpvrvz.rst
      quasidfpvt.rst
      quasidfpvtvz.rst
      quasidfpvz.rst
      quasidfsamplev.rst
      quasidfsamplevinterpolate.rst
      quasidfsigmar2.rst
      quasidfsigmarz.rst
      quasidfsigmat2.rst
      quasidfsigmaz2.rst
      quasidfsurfacemass_z.rst
      quasidftilt.rst
      quasidfvmomentdensity.rst
      scatterplot.rst
      sphericaldfbeta.rst
      sphericaldfcall.rst
      sphericaldfdmde.rst
      sphericaldfsample.rst
      sphericaldfsigmar.rst
      sphericaldfsigmat.rst
      sphericaldfvmomentdensity.rst
      streamdf.rst
      streamdfcalcstreamlb.rst
      streamdfcall.rst
      streamdfcallmarg.rst
      streamdfdenspar.rst
      streamdfestimatetdisrupt.rst
      streamdffindclosesttrackpoint.rst
      streamdffindclosesttrackpointlb.rst
      streamdffreqeigvalratio.rst
      streamdfgaussapprox.rst
      streamdflength.rst
      streamdfmeanangledangle.rst
      streamdfmeanomega.rst
      streamdfmeantdangle.rst
      streamdfmisalignment.rst
      streamdfpangledangle.rst
      streamdfplotcomparetrackaamodel.rst
      streamdfplotprogenitor.rst
      streamdfplottrack.rst
      streamdfpoparapar.rst
      streamdfptdangle.rst
      streamdfsample.rst
      streamdfsigangledangle.rst
      streamdfsigomega.rst
      streamdfsigtdangle.rst
      streamdfsubhaloencounters.rst
      streamgapdf.rst
      streamspraydfchen24.rst
      streamspraydffardal15.rst
      streamspraydfsample.rst
      util.rst
    actionAngle.rst
    basic_df.rst
    conf.py
    diskdf.rst
    getting_started.rst
    index.rst
    installation.rst
    orbit.rst
    orbitanim.html
    orbitanim2proj.html
    orbitanim3d.html
    orbitsun.html
    potential.rst
    streamdf.rst
    whatsnew.rst
  Makefile
galpy/
  actionAngle/
    actionAngle_c_ext/
      actionAngle.h
      actionAngleAdiabatic.c
      actionAngleStaeckel.c
    actionAngleTorus_c_ext/
      actionAngleTorus.cc
      galpyPot.cc
      galpyPot.h
    __init__.py
    actionAngle.py
    actionAngleAdiabatic_c.py
    actionAngleAdiabatic.py
    actionAngleAdiabaticGrid.py
    actionAngleHarmonic.py
    actionAngleHarmonicInverse.py
    actionAngleInverse.py
    actionAngleIsochrone.py
    actionAngleIsochroneApprox.py
    actionAngleIsochroneInverse.py
    actionAngleSpherical.py
    actionAngleStaeckel_c.py
    actionAngleStaeckel.py
    actionAngleStaeckelGrid.py
    actionAngleTorus_c.py
    actionAngleTorus.py
    actionAngleVertical.py
    actionAngleVerticalInverse.py
  df/
    __init__.py
    constantbetadf.py
    constantbetaHernquistdf.py
    df.py
    diskdf.py
    eddingtondf.py
    evolveddiskdf.py
    isotropicHernquistdf.py
    isotropicNFWdf.py
    isotropicPlummerdf.py
    jeans.py
    kingdf.py
    osipkovmerrittdf.py
    osipkovmerrittHernquistdf.py
    osipkovmerrittNFWdf.py
    quasiisothermaldf.py
    sphericaldf.py
    streamdf.py
    streamgapdf.py
    streamspraydf.py
    surfaceSigmaProfile.py
  orbit/
    orbit_c_ext/
      integrateFullOrbit.c
      integrateFullOrbit.h
      integrateLinearOrbit.c
      integratePlanarOrbit.c
    __init__.py
    integrateFullOrbit.py
    integrateLinearOrbit.py
    integratePlanarOrbit.py
    named_objects.json
    Orbits.py
  potential/
    interppotential_c_ext/
      interppotential_calc_potential.c
    potential_c_ext/
      BurkertPotential.c
      ChandrasekharDynamicalFrictionForce.c
      CorotatingRotationWrapperPotential.c
      CosmphiDiskPotential.c
      DehnenBarPotential.c
      DehnenCorePotential.c
      DehnenPotential.c
      DehnenSmoothWrapperPotential.c
      DiskSCFPotential.c
      DoubleExponentialDiskPotential.c
      EllipsoidalPotential.c
      EllipticalDiskPotential.c
      FlattenedPowerPotential.c
      galpy_potentials.c
      galpy_potentials.h
      GaussianAmplitudeWrapperPotential.c
      HenonHeilesPotential.c
      HernquistPotential.c
      HomogeneousSpherePotential.c
      interpRZPotential.c
      interpSphericalPotential.c
      IsochronePotential.c
      IsothermalDiskPotential.c
      JaffePotential.c
      KGPotential.c
      KuzminDiskPotential.c
      KuzminKutuzovStaeckelPotential.c
      KuzminLikeWrapperPotential.c
      LogarithmicHaloPotential.c
      LopsidedDiskPotential.c
      Makefile
      MiyamotoNagaiPotential.c
      MovingObjectPotential.c
      NFWPotential.c
      NonInertialFrameForce.c
      PerfectEllipsoidPotential.c
      PlummerPotential.c
      PowerSphericalPotential.c
      PowerSphericalPotentialwCutoff.c
      PowerTriaxialPotential.c
      PseudoIsothermalPotential.c
      RotateAndTiltWrapperPotential.c
      SCFPotential.c
      SoftenedNeedleBarPotential.c
      SolidBodyRotationWrapperPotential.c
      SphericalPotential.c
      SpiralArmsPotential.c
      SteadyLogSpiralPotential.c
      TimeDependentAmplitudeWrapperPotential.c
      TransientLogSpiralPotential.c
      TriaxialGaussianPotential.c
      TwoPowerTriaxialPotential.c
      verticalPotential.c
      ZeroPotential.c
    __init__.py
    AdiabaticContractionWrapperPotential.py
    amuse.py
    AnyAxisymmetricRazorThinDiskPotential.py
    AnySphericalPotential.py
    BurkertPotential.py
    Cautun20.py
    ChandrasekharDynamicalFrictionForce.py
    CorotatingRotationWrapperPotential.py
    CosmphiDiskPotential.py
    DehnenBarPotential.py
    DehnenBinney98.py
    DehnenSmoothWrapperPotential.py
    DiskSCFPotential.py
    DissipativeForce.py
    DoubleExponentialDiskPotential.py
    EllipsoidalPotential.py
    EllipticalDiskPotential.py
    FerrersPotential.py
    FlattenedPowerPotential.py
    Force.py
    GaussianAmplitudeWrapperPotential.py
    HenonHeilesPotential.py
    HomogeneousSpherePotential.py
    interpRZPotential.py
    interpSphericalPotential.py
    Irrgang13.py
    IsochronePotential.py
    IsothermalDiskPotential.py
    KGPotential.py
    KingPotential.py
    KuzminDiskPotential.py
    KuzminKutuzovStaeckelPotential.py
    KuzminLikeWrapperPotential.py
    linearPotential.py
    LogarithmicHaloPotential.py
    McMillan17.py
    MiyamotoNagaiPotential.py
    MN3ExponentialDiskPotential.py
    MovingObjectPotential.py
    mwpot_helpers.py
    mwpotentials.py
    NonInertialFrameForce.py
    NullPotential.py
    NumericalPotentialDerivativesMixin.py
    PerfectEllipsoidPotential.py
    planarDissipativeForce.py
    planarForce.py
    planarPotential.py
    plotEscapecurve.py
    plotRotcurve.py
    PlummerPotential.py
    Potential.py
    PowerSphericalPotential.py
    PowerSphericalPotentialwCutoff.py
    PowerTriaxialPotential.py
    PseudoIsothermalPotential.py
    RazorThinExponentialDiskPotential.py
    RingPotential.py
    RotateAndTiltWrapperPotential.py
    SCFPotential.py
    SnapshotRZPotential.py
    SoftenedNeedleBarPotential.py
    SolidBodyRotationWrapperPotential.py
    SphericalPotential.py
    SphericalShellPotential.py
    SpiralArmsPotential.py
    SteadyLogSpiralPotential.py
    TimeDependentAmplitudeWrapperPotential.py
    TransientLogSpiralPotential.py
    TriaxialGaussianPotential.py
    TwoPowerSphericalPotential.py
    TwoPowerTriaxialPotential.py
    verticalPotential.py
    WrapperPotential.py
  snapshot/
    __init__.py
    directnbody.py
    GadgetSnapshot.py
    nemo_util.py
    Snapshot.py
    snapshotMovies.py
  util/
    interp_2d/
      cubic_bspline_2d_coeffs.c
      cubic_bspline_2d_coeffs.h
      cubic_bspline_2d_interpol.c
      cubic_bspline_2d_interpol.h
      interp_2d.c
      interp_2d.h
      README
    __init__.py
    _load_extension_libs.py
    _optional_deps.py
    ars.py
    bovy_coords.c
    bovy_coords.h
    bovy_rk.c
    bovy_rk.h
    bovy_symplecticode.c
    bovy_symplecticode.h
    config.py
    conversion.py
    coords.py
    leung_dop853.c
    leung_dop853.h
    leung_dop853.py
    multi.py
    plot.py
    quadpack.py
    symplecticode.py
    wez_ias15.c
    wez_ias15.h
  __init__.py
nemo/
  Makefile
  PowSphwCut.cc
tests/
  conftest.py
  orbitint4sigint.py
  test_actionAngle.py
  test_actionAngleTorus.py
  test_amuse.py
  test_conversion.py
  test_coords.py
  test_diskdf.py
  test_dynamfric.py
  test_evolveddiskdf.py
  test_galpypaper.py
  test_import.py
  test_interp_potential.py
  test_jeans.py
  test_kuzminkutuzov.py
  test_nemo.py
  test_noninertial.py
  test_orbit.py
  test_orbits.py
  test_potential.py
  test_pv2qdf.py
  test_qdf.py
  test_quantity.py
  test_scf.py
  test_snapshotpotential.py
  test_sphericaldf.py
  test_SpiralArmsPotential.py
  test_streamdf.py
  test_streamgapdf_impulse.py
  test_streamgapdf.py
  test_streamspraydf.py
  test_util.py
.appveyor.yml_deprecated
.bumpversion.cfg
.coveragerc
.generate_lcov.sh
.git-blame-ignore-revs
.gitignore
.pre-commit-config.yaml
.readthedocs.yaml
AUTHORS.txt
CITATION.cff
CONTRIBUTING.md
create_galpy_wheels.sh
gsl-config.bat
HISTORY.txt
LICENSE
MANIFEST.in
pyproject.toml
README.dev
README.md
README.nemo
RELEASE_CHECKLIST.md
setup.py
</repository_structure>
  <repository_files>
    <file path=".github/workflows/wheels.yml">
name: Wheel builder and uploader

# Update on every push and PR to main, and upon release creation
on:
  push:
    branches:
      - main
    paths:
      - '**'
      - '!*'
      - '*.py'
      - '!tests/**'
      - '!doc/**'
      - '!.github/**'
      - '.github/workflows/wheels.yml'
  pull_request:
    branches:
      - main
    paths-ignore:
      - 'doc/**'
  release:
    types: [created]

jobs:
  build_wheels:
    name: Build wheel for ${{ matrix.python[0] }}-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    strategy:
      # Ensure that a wheel builder finishes even if another fails
      fail-fast: false
      matrix:
        # Following numpy's setup
        buildplat:
        - [ubuntu-22.04, manylinux, x86_64]
        - [macos-13, macosx, x86_64]
        - [macos-14, macosx, arm64]
        - [windows-2019, win, amd64]
        python:
        - [&quot;cp38&quot;,&quot;3.8&quot;]
        - [&quot;cp39&quot;,&quot;3.9&quot;]
        - [&quot;cp310&quot;,&quot;3.10&quot;]
        - [&quot;cp311&quot;,&quot;3.11&quot;]
        - [&quot;cp312&quot;,&quot;3.12&quot;]
        - [&quot;cp313&quot;,&quot;3.13&quot;]
    steps:
      - uses: actions/checkout@v4
      - name: Install GSL (Windows / Mac OS x86_64)
        uses: mamba-org/setup-micromamba@v2
        if: matrix.buildplat[1] == 'win' || matrix.buildplat[1] == 'macosx'
        with:
          environment-name: gsl
          condarc: |
            channels:
              - conda-forge
          create-args: gsl
          cache-environment: true
          cache-environment-key: gsl-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}-${{ hashFiles('.github/workflows/wheels.yml') }}
      - name: Set GSL environment variables (Windows)
        if: matrix.buildplat[1] == 'win'
        shell: bash -l {0}
        run: |
          echo &quot;INCLUDE=$CONDA_PREFIX\\Library\\include&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;LIB=$CONDA_PREFIX\\Library\\lib&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;LIBPATH=$CONDA_PREFIX\\Library\\lib&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;$CONDA_PREFIX\\Library\\bin&quot; &gt;&gt; $GITHUB_PATH # necessary when we don't activate the environment
      - name: Set GSL environment variables (Mac OS)
        if: matrix.buildplat[1] == 'macosx'
        shell: bash -l {0}
        run: |
          echo &quot;CFLAGS=-I$CONDA_PREFIX/include&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;LDFLAGS=-L$CONDA_PREFIX/lib&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;REPAIR_LIBRARY_PATH=$CONDA_PREFIX/lib&quot; &gt;&gt; $GITHUB_ENV # https://github.com/pypa/cibuildwheel/issues/816#issuecomment-916197079
          echo &quot;$CONDA_PREFIX/bin&quot; &gt;&gt; $GITHUB_PATH # necessary when we don't activate the environment
      - name: Build wheels
        uses: pypa/cibuildwheel@v2.22
        env:
          CIBW_BUILD: ${{ matrix.python[0] }}-${{ matrix.buildplat[1] }}_${{ matrix.buildplat[2] }}
          CIBW_BUILD_VERBOSITY: 1
          CIBW_BEFORE_BUILD_LINUX: yum -y install gsl-devel
          CIBW_ARCHS_MACOS: ${{ matrix.buildplat[2] }}
          CIBW_ENVIRONMENT_MACOS: &quot;MACOSX_DEPLOYMENT_TARGET=10.13&quot;
          CIBW_REPAIR_WHEEL_COMMAND_MACOS: &gt;
            DYLD_LIBRARY_PATH=$REPAIR_LIBRARY_PATH delocate-listdeps {wheel} &amp;&amp;
            DYLD_LIBRARY_PATH=$REPAIR_LIBRARY_PATH delocate-wheel -v --require-archs {delocate_archs} -w {dest_dir} {wheel}
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.python[0] }}-${{ matrix.buildplat[1] }}_${{ matrix.buildplat[2] }}
          path: ./wheelhouse/*.whl
  test_wheels:
    name: Test Python ${{ matrix.python[1] }} wheels on ${{ matrix.buildplat[2] }} ${{ matrix.buildplat[0] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: build_wheels
    strategy:
        # Ensure that tests finish even if another fails
        fail-fast: false
        matrix:
          buildplat:
            - [ubuntu-22.04, manylinux, x86_64]
            - [macos-13, macosx, x86_64]
            - [macos-14, macosx, arm64]
            - [windows-2019, win, amd64]
          python:
            - [&quot;cp38&quot;,&quot;3.8&quot;]
            - [&quot;cp39&quot;,&quot;3.9&quot;]
            - [&quot;cp310&quot;,&quot;3.10&quot;]
            - [&quot;cp311&quot;,&quot;3.11&quot;]
            - [&quot;cp312&quot;,&quot;3.12&quot;]
            - [&quot;cp313&quot;,&quot;3.13&quot;]
    steps:
      - uses: actions/checkout@v4
      - run: mkdir wheelhouse
      - uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.python[0] }}-${{ matrix.buildplat[1] }}_${{ matrix.buildplat[2] }}
          path: wheelhouse/
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python[1] }}
          allow-prereleases: true
      - name: Install GSL (Windows)
        uses: mamba-org/setup-micromamba@v2
        if: matrix.buildplat[1] == 'win'
        with:
          environment-name: gsl
          condarc: |
            channels:
              - conda-forge
          create-args: gsl
          cache-environment: true
          cache-environment-key: gsl-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}-${{ hashFiles('.github/workflows/wheels.yml') }}
      - name: Set GSL environment variables (Windows)
        if: matrix.buildplat[1] == 'win'
        shell: bash -l {0}
        run: |
          micromamba activate gsl
          echo &quot;LIBPATH=$CONDA_PREFIX\\Library\\lib&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;$CONDA_PREFIX\\Library\\bin&quot; &gt;&gt; $GITHUB_PATH # necessary when we don't activate the environment
      - name: Install wheel
        shell: bash
        run: python -m pip install `ls -d &quot;$(pwd)&quot;/wheelhouse/*.whl`
      - name: Test built wheel in non-conda environment
        shell: bash
        working-directory: ${{ runner.temp }}
        run: |
          pip install astropy pytest
          pytest -v $GITHUB_WORKSPACE/tests/test_orbit.py -k &quot;test_energy_jacobi_conservation and NFW&quot;
      # Test that built wheels also work in a conda environment, setup environment, install wheel, and run test
      - name: Setup test conda environment (Linux / Mac OS)
        if: matrix.buildplat[1] != 'win'
        uses: mamba-org/setup-micromamba@v2
        with:
          environment-name: test-wheel-conda
          condarc: |
            channels:
              - conda-forge
          create-args: python=${{ matrix.python[1] }} numpy scipy matplotlib astropy pytest
          cache-environment: true
          cache-environment-key: test-wheel-conda-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}-${{ hashFiles('.github/workflows/wheels.yml') }}
      - name: Setup test conda environment (Windows)
        if: matrix.buildplat[1] == 'win'
        shell: bash -l {0}
        run: |
          micromamba create -n test-wheel-conda -c conda-forge python=${{ matrix.python[1] }} numpy scipy matplotlib astropy pytest gsl
          micromamba activate test-wheel-conda
          echo &quot;LIBPATH=$CONDA_PREFIX\\Library\\lib&quot; &gt;&gt; $GITHUB_ENV
      - name: Install built wheel in conda environment
        shell: bash -l {0}
        run: |
          micromamba activate test-wheel-conda
          python -m pip install `ls -d &quot;$(pwd)&quot;/wheelhouse/*.whl`
      - name: Test built wheel in conda environment
        shell: bash -l {0}
        working-directory: ${{ runner.temp }}
        run: |
          micromamba activate test-wheel-conda
          pytest -v $GITHUB_WORKSPACE/tests/test_orbit.py -k &quot;test_energy_jacobi_conservation and NFW&quot;
  build_sdist:
    name: Build source directory for release
    if: github.event_name == 'release' &amp;&amp; github.event.action == 'created'
    runs-on: ubuntu-latest
    steps:
      # check-out this repository
      - uses: actions/checkout@v4
      # Setup python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.x
      # Install the GSL (necessary to properly include the C files)
      - name: Install GSL
        run: sudo apt-get install -y libgsl0-dev
      - name: Build sdist
        run: |
          pip install build
          python -m build --sdist
      - uses: actions/upload-artifact@v4
        with:
          name: sdist
          path: ./dist/*.tar.gz
# Deploy wheels and sdist to PyPI (upon release creation)
  deploy_pypi:
    name: Deploy to PyPI
    needs: [build_wheels, test_wheels, build_sdist]
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing
    if: github.event_name == 'release' &amp;&amp; github.event.action == 'created'
    steps:
      - uses: actions/checkout@v4
      - run: |
          mkdir tmp_wheelhouse
          mkdir wheelhouse
      - uses: actions/download-artifact@v4
        with:
          path: tmp_wheelhouse/
      - run: find tmp_wheelhouse/ -mindepth 2 -type f -exec mv -i '{}' wheelhouse/ ';'
      - name: Publish distribution to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages_dir: wheelhouse/
# Deploy wheels and sdist to AWS S3 (main)
  deploy_s3:
    name: Deploy to AWS S3
    needs: [build_wheels, test_wheels]
    runs-on: ubuntu-latest
    if: github.event_name != 'release' &amp;&amp; github.event_name != 'pull_request' &amp;&amp; github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - run: |
          mkdir tmp_wheelhouse
          mkdir wheelhouse
      - uses: actions/download-artifact@v4
        with:
          path: tmp_wheelhouse/
      - run: find tmp_wheelhouse/ -mindepth 2 -type f -exec mv -i '{}' wheelhouse/ ';'
      - name: Rename wheel to 'latest' version for AWS S3
        run: |
          GALPY_VERSION=&quot;$(awk '/^current_version/{print $NF}' .bumpversion.cfg)&quot;
          for f in wheelhouse/*$GALPY_VERSION*.whl; do mv -i -- &quot;$f&quot; &quot;${f//$GALPY_VERSION/latest}&quot;; done
      - name: Upload to AWS S3
        uses: jakejarvis/s3-sync-action@v0.5.1
        with:
          args: --acl public-read --follow-symlinks --delete --exclude &quot;*emscripten*&quot;
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: 'us-east-2'
          SOURCE_DIR: wheelhouse
          DEST_DIR: wheelhouse
</file>
    <file path=".github/conda-build-environment-macos-latest.yml">
name: galpywheels
channels:
  - conda-forge
dependencies:
  - numpy
  - scipy
  - matplotlib
  - setuptools
  - conda-forge::gsl
  - conda-forge::compilers
  - conda-forge::llvm-openmp
</file>
    <file path=".github/conda-build-environment-windows-latest.yml">
name: galpywheels
channels:
  - anaconda
  - conda-forge
dependencies:
  - numpy
  - scipy
  - matplotlib
  - setuptools
  - gsl
  - anaconda::intel-openmp
</file>
    <file path="doc/source/examples/dierickx_eccentricities.py">
import os
import os.path
import pickle
import shutil
import subprocess
import sys
import tempfile
from ftplib import FTP
from optparse import OptionParser

import matplotlib.pyplot as plt
import numpy
import numpy as np
from astropy import units
from astropy.io import ascii, fits
from tqdm import tqdm

from galpy.actionAngle import UnboundError, actionAngleStaeckel, estimateDeltaStaeckel
from galpy.orbit import Orbit
from galpy.potential import LogarithmicHaloPotential
from galpy.potential import evaluatePotentials as evalPot
from galpy.util import coords

_ERASESTR = (
    &quot;                                                                                &quot;
)


def calc_eccentricity(args, options):
    table = os.path.join(args[0], &quot;table2.dat&quot;)
    readme = os.path.join(args[0], &quot;ReadMe&quot;)
    dierickx = ascii.read(table, readme=readme)
    vxvv = np.dstack(
        [
            dierickx[&quot;RAdeg&quot;],
            dierickx[&quot;DEdeg&quot;],
            dierickx[&quot;Dist&quot;] / 1e3,
            dierickx[&quot;pmRA&quot;],
            dierickx[&quot;pmDE&quot;],
            dierickx[&quot;HRV&quot;],
        ]
    )[0]
    ro, vo, zo = 8.0, 220.0, 0.025
    orbits = Orbit(vxvv, radec=True, ro=ro, vo=vo, zo=zo, solarmotion=&quot;hogg&quot;)
    # do the integration and individual analytic estimate for each object
    lp = LogarithmicHaloPotential(normalize=1.0)
    e_ana = orbits.e(analytic=True, pot=lp, delta=1e-6)
    ts = np.linspace(0.0, 20.0, 10000)
    orbits.integrate(ts, lp)
    e_int = orbits.e()
    # Now plot everything
    fig = plt.figure()
    plt.scatter(e_int, e_ana, s=1, color=&quot;Black&quot;, lw=0.0)
    plt.xlabel(r&quot;$\mathrm{galpy\ integrated}\ e$&quot;)
    plt.ylabel(r&quot;$\mathrm{galpy\ analytic}\ e$&quot;)
    plt.xlim(0.0, 1.0)
    plt.ylim(0.0, 1.0)
    fig.tight_layout()
    plt.savefig(
        os.path.join(args[0], &quot;dierickx-integratedeanalytice.png&quot;),
        format=&quot;png&quot;,
        dpi=200,
    )
    fig = plt.figure()
    plt.hist(e_int, bins=30)
    plt.xlim(0.0, 1.0)
    plt.xlabel(r&quot;$\mathrm{galpy}\ e$&quot;)
    fig.tight_layout()
    plt.savefig(
        os.path.join(args[0], &quot;dierickx-integratedehist.png&quot;), format=&quot;png&quot;, dpi=200
    )
    fig = plt.figure()
    plt.scatter(dierickx[&quot;e&quot;], e_int, s=1, color=&quot;Black&quot;, lw=0.0)
    plt.xlabel(r&quot;$\mathrm{Dierickx\ et\ al.}\ e$&quot;)
    plt.ylabel(r&quot;$\mathrm{galpy\ integrated}\ e$&quot;)
    plt.xlim(0.0, 1.0)
    plt.ylim(0.0, 1.0)
    fig.tight_layout()
    plt.savefig(
        os.path.join(args[0], &quot;dierickx-integratedee.png&quot;), format=&quot;png&quot;, dpi=200
    )
    fig = plt.figure()
    plt.scatter(dierickx[&quot;e&quot;], e_ana, s=1, color=&quot;Black&quot;, lw=0.0)
    plt.xlabel(r&quot;$\mathrm{Dierickx\ et\ al.}\ e$&quot;)
    plt.ylabel(r&quot;$\mathrm{galpy\ estimated}\ e$&quot;)
    plt.xlim(0.0, 1.0)
    plt.ylim(0.0, 1.0)
    fig.tight_layout()
    plt.savefig(os.path.join(args[0], &quot;dierickx-analyticee.png&quot;), format=&quot;png&quot;, dpi=200)
    arr = numpy.recarray(
        len(e_ana), dtype=[(&quot;analytic_e&quot;, float), (&quot;integrated_e&quot;, float)]
    )
    arr[&quot;analytic_e&quot;] = e_ana
    arr[&quot;integrated_e&quot;] = e_int
    with open(os.path.join(args[0], &quot;eccentricities.dat&quot;), &quot;w&quot;) as file:
        pickle.dump(arr, file)
        file.close()


def get_table(args, options):
    cat = &quot;J/ApJ/725/L186/&quot;
    tab2name = &quot;table2.dat.gz&quot;
    tab2readme = &quot;ReadMe&quot;
    out = args[0]
    ensure_dir(os.path.join(out, tab2name))
    vizier(
        cat,
        os.path.join(out, tab2name),
        os.path.join(out, tab2readme),
        catalogname=tab2name,
        readmename=tab2readme,
    )
    subprocess.call([&quot;gunzip&quot;, os.path.join(out, tab2name)])


def vizier(cat, filePath, ReadMePath, catalogname=&quot;catalog.dat&quot;, readmename=&quot;ReadMe&quot;):
    &quot;&quot;&quot;
    NAME:
       vizier
    PURPOSE:
       download a catalog and its associated ReadMe from Vizier
    INPUT:
       cat - name of the catalog (e.g., 'III/272' for RAVE, or J/A+A/... for journal-specific catalogs)
       filePath - path of the file where you want to store the catalog (note: you need to keep the name of the file the same as the catalogname to be able to read the file with astropy.io.ascii)
       ReadMePath - path of the file where you want to store the ReadMe file
       catalogname= (catalog.dat) name of the catalog on the Vizier server
       readmename= (ReadMe) name of the ReadMe file on the Vizier server
    OUTPUT:
       (nothing, just downloads)
    HISTORY:
       2016-09-12 - Written - Bovy (UofT)
    &quot;&quot;&quot;
    _download_file_vizier(cat, filePath, catalogname=catalogname)
    _download_file_vizier(cat, ReadMePath, catalogname=readmename)
    return None


def _download_file_vizier(cat, filePath, catalogname=&quot;catalog.dat&quot;):
    &quot;&quot;&quot;
    Stolen from Jo Bovy's gaia_tools package!
    &quot;&quot;&quot;
    sys.stdout.write(&quot;\r&quot; + &quot;Downloading file %s ...\r&quot; % (os.path.basename(filePath)))
    sys.stdout.flush()
    try:
        # make all intermediate directories
        os.makedirs(os.path.dirname(filePath))
    except OSError:
        pass
    # Safe way of downloading
    downloading = True
    interrupted = False
    file, tmp_savefilename = tempfile.mkstemp()
    os.close(file)  # Easier this way
    ntries = 1
    while downloading:
        try:
            ftp = FTP(&quot;cdsarc.u-strasbg.fr&quot;)
            ftp.login(&quot;anonymous&quot;, &quot;test&quot;)
            ftp.cwd(os.path.join(&quot;pub&quot;, &quot;cats&quot;, cat))
            with open(tmp_savefilename, &quot;wb&quot;) as savefile:
                ftp.retrbinary(&quot;RETR %s&quot; % catalogname, savefile.write)
            shutil.move(tmp_savefilename, filePath)
            downloading = False
            if interrupted:
                raise KeyboardInterrupt
        except:
            raise
            if not downloading:  # Assume KeyboardInterrupt
                raise
            elif ntries &gt; _MAX_NTRIES:
                raise OSError(
                    &quot;File %s does not appear to exist on the server ...&quot;
                    % (os.path.basename(filePath))
                )
        finally:
            if os.path.exists(tmp_savefilename):
                os.remove(tmp_savefilename)
        ntries += 1
    sys.stdout.write(&quot;\r&quot; + _ERASESTR + &quot;\r&quot;)
    sys.stdout.flush()
    return None


def ensure_dir(f):
    &quot;&quot;&quot;Ensure a a file exists and if not make the relevant path&quot;&quot;&quot;
    d = os.path.dirname(f)
    if not os.path.exists(d):
        os.makedirs(d)


def get_options():
    # no options yet - probably none needed?
    usage = &quot;usage: %prog [options] &lt;outpath&gt;&quot;
    parser = OptionParser(usage=usage)
    return parser


if __name__ == &quot;__main__&quot;:
    parser = get_options()
    options, args = parser.parse_args()
    get_table(args, options)
    calc_eccentricity(args, options)
</file>
    <file path="doc/source/examples/dierickx-edist.py">
import csv
import os
import os.path

import cPickle as pickle
import numpy as nu

from galpy.orbit import Orbit
from galpy.potential import (
    HernquistPotential,
    LogarithmicHaloPotential,
    MiyamotoNagaiPotential,
    NFWPotential,
)
from galpy.util import plot

_degtorad = nu.pi / 180.0


def calc_es():
    savefilename = &quot;myes.sav&quot;
    if os.path.exists(savefilename):
        savefile = open(savefilename, &quot;rb&quot;)
        mye = pickle.load(savefile)
        e = pickle.load(savefile)
        savefile.close()
    else:
        # Read data
        dialect = csv.excel
        dialect.skipinitialspace = True
        reader = csv.reader(
            open(&quot;../data/Dierickx-etal-tab2.txt&quot;), delimiter=&quot; &quot;, dialect=dialect
        )
        vxvs = []
        es = []
        vphis = []
        vxs = []
        vys = []
        vzs = []
        ls = []
        for row in reader:
            thisra = float(row[3])
            thisdec = float(row[4])
            thisd = float(row[17]) / 1000.0
            thispmra = float(row[13])
            thispmdec = float(row[15])
            thisvlos = float(row[11])
            thise = float(row[26])
            vxvs.append([thisra, thisdec, thisd, thispmra, thispmdec, thisvlos])
            es.append(thise)
            vphis.append(float(row[25]))
            vxs.append(float(row[19]))
            vys.append(float(row[21]))
            vzs.append(float(row[23]))
            ls.append(float(row[5]))
        vxvv = nu.array(vxvs)
        e = nu.array(es)
        vphi = nu.array(vphis)
        vx = nu.array(vxs)
        vy = nu.array(vys)
        vz = nu.array(vzs)
        l = nu.array(ls)

        # Define potential
        lp = LogarithmicHaloPotential(normalize=1.0)
        mp = MiyamotoNagaiPotential(a=0.5, b=0.0375, amp=1.0, normalize=0.6)
        np = NFWPotential(a=4.5, normalize=0.35)
        hp = HernquistPotential(a=0.6 / 8, normalize=0.05)
        ts = nu.linspace(0.0, 20.0, 10000)

        mye = nu.zeros(len(e))
        for ii in range(len(e)):
            # Integrate the orbit
            o = Orbit(vxvv[ii, :], radec=True, vo=220.0, ro=8.0)
            o.integrate(ts, lp)
            mye[ii] = o.e()

        # Save
        savefile = open(savefilename, &quot;wb&quot;)
        pickle.dump(mye, savefile)
        pickle.dump(e, savefile)
        savefile.close()

    # plot
    plot.print()
    plot.plot(
        nu.array([0.0, 1.0]),
        nu.array([0.0, 1.0]),
        &quot;k-&quot;,
        xlabel=r&quot;$\mathrm{Dierickx\ et\ al.}\ e$&quot;,
        ylabel=r&quot;$\mathrm{galpy}\ e$&quot;,
    )
    plot.plot(e, mye, &quot;k,&quot;, overplot=True)
    plot.end_print(&quot;myee.png&quot;)

    plot.print()
    plot.hist(e, bins=30, xlabel=r&quot;$\mathrm{Dierickx\ et\ al.}\ e$&quot;)
    plot.end_print(&quot;ehist.png&quot;)

    plot.print()
    plot.hist(mye, bins=30, xlabel=r&quot;$\mathrm{galpy}\ e$&quot;)
    plot.end_print(&quot;myehist.png&quot;)


if __name__ == &quot;__main__&quot;:
    calc_es()
</file>
    <file path="doc/source/examples/galpyrc">
[normalization]
ro = 8.
vo = 220.

[plot]
seaborn-bovy-defaults = True

[astropy]
astropy-units = False
astropy-coords = True

[warnings]
verbose= False
</file>
    <file path="doc/source/examples/sellwood-jrjp.py">
import csv
import os
import os.path
import re
import sys

import cPickle as pickle
import numpy as nu

from galpy.orbit import Orbit
from galpy.potential import LogarithmicHaloPotential, PowerSphericalPotential
from galpy.util import plot

_degtorad = nu.pi / 180.0


def hms_to_rad(ra):
    spl = re.split(r&quot; &quot;, ra)
    return (
        float(spl[0]) * 15.0 + float(spl[1]) * 0.25 + float(spl[1]) * 0.25 / 60.0
    ) * _degtorad


def dms_to_rad(dec):
    spl = re.split(r&quot; &quot;, dec)
    return (
        float(spl[0]) + float(spl[1]) / 60.0 + float(spl[2]) / 60.0 / 60.0
    ) * _degtorad


def read_float(f):
    if f == &quot;&quot;:
        return -9999
    else:
        return float(f)


def calcj(rotcurve):
    if rotcurve == &quot;flat&quot;:
        savefilename = &quot;myjs.sav&quot;
    elif rotcurve == &quot;power&quot;:
        savefilename = &quot;myjs_power.sav&quot;
    if os.path.exists(savefilename):
        savefile = open(savefilename, &quot;rb&quot;)
        myjr = pickle.load(savefile)
        myjp = pickle.load(savefile)
        mye = pickle.load(savefile)
        myzmax = pickle.load(savefile)
        e = pickle.load(savefile)
        zmax = pickle.load(savefile)
        savefile.close()
    else:
        dialect = csv.excel
        dialect.skipinitialspace = True
        reader = csv.reader(open(&quot;../data/gcs.tsv&quot;), delimiter=&quot;|&quot;, dialect=dialect)
        vxvs = []
        es = []
        zmaxs = []
        for row in reader:
            if row[0][0] == &quot;#&quot;:
                continue
            thisra = row[0]
            thisdec = row[1]
            thisd = read_float(row[2]) / 1000.0
            if thisd &gt; 0.2:
                continue
            thisu = read_float(row[3])
            thisv = read_float(row[4])
            thisw = read_float(row[5])
            thise = read_float(row[6])
            thiszmax = read_float(row[7])
            if thisd == -9999 or thisu == -9999 or thisv == -9999 or thisw == -9999:
                continue
            vxvs.append(
                [hms_to_rad(thisra), dms_to_rad(thisdec), thisd, thisu, thisv, thisw]
            )
            es.append(thise)
            zmaxs.append(thiszmax)
        vxvv = nu.array(vxvs)
        e = nu.array(es)
        zmax = nu.array(zmaxs)

        # Define potential
        lp = LogarithmicHaloPotential(normalize=1.0)
        pp = PowerSphericalPotential(normalize=1.0, alpha=-2.0)
        ts = nu.linspace(0.0, 100.0, 10000)

        myjr = nu.zeros(len(e))
        myjp = nu.zeros(len(e))
        mye = nu.zeros(len(e))
        myzmax = nu.zeros(len(e))
        for ii in range(len(e)):
            # Integrate the orbit
            o = Orbit(vxvv[ii, :], radec=True, uvw=True, vo=220.0, ro=8.0)
            if rotcurve == &quot;flat&quot;:
                o.integrate(ts, lp)
                mye[ii] = o.e()
                myzmax[ii] = o.zmax() * 8.0
                print(e[ii], mye[ii], zmax[ii], myzmax[ii])
                myjr[ii] = o.jr(lp)
            else:
                myjr[ii] = o.jr(pp)
            myjp[ii] = o.jp()

        # Save
        savefile = open(savefilename, &quot;wb&quot;)
        pickle.dump(myjr, savefile)
        pickle.dump(myjp, savefile)
        pickle.dump(mye, savefile)
        pickle.dump(myzmax, savefile)
        pickle.dump(e, savefile)
        pickle.dump(zmax, savefile)
        savefile.close()

    # plot
    if rotcurve == &quot;flat&quot;:
        plot.print()
        plot.plot(
            nu.array([0.0, 1.0]),
            nu.array([0.0, 1.0]),
            &quot;k-&quot;,
            xlabel=r&quot;$\mathrm{Holmberg\ et\ al.}\ e$&quot;,
            ylabel=r&quot;$\mathrm{galpy}\ e$&quot;,
        )
        plot.plot(e, mye, &quot;k,&quot;, overplot=True)
        plot.end_print(&quot;myee.png&quot;)

        plot.print()
        plot.plot(
            nu.array([0.0, 2.5]),
            nu.array([0.0, 2.5]),
            &quot;k-&quot;,
            xlabel=r&quot;$\mathrm{Holmberg\ et\ al.}\ z_{\mathrm{max}}$&quot;,
            ylabel=r&quot;$\mathrm{galpy}\ z_{\mathrm{max}}$&quot;,
        )
        plot.plot(zmax, myzmax, &quot;k,&quot;, overplot=True)
        plot.end_print(&quot;myzmaxzmax.png&quot;)

    plot.print()
    plot.plot(
        myjp,
        myjr,
        &quot;k.&quot;,
        ms=2.0,
        xlabel=r&quot;$J_{\phi}$&quot;,
        ylabel=r&quot;$J_R$&quot;,
        xrange=[0.7, 1.3],
        yrange=[0.0, 0.05],
    )
    if rotcurve == &quot;flat&quot;:
        plot.end_print(&quot;jrjp.png&quot;)
    else:
        plot.end_print(&quot;jrjp_power.png&quot;)


if __name__ == &quot;__main__&quot;:
    if len(sys.argv) &gt; 1:
        calcj(sys.argv[1])
    else:
        calcj(&quot;flat&quot;)
</file>
    <file path="doc/source/reference/diskdfsample.rst">
galpy.df.diskdf.sample
=======================

.. automethod:: galpy.df.diskdf.sample
</file>
    <file path="doc/source/reference/diskdfsampledSurfacemassLOS.rst">
galpy.df.diskdf.sampledSurfacemassLOS
=========================================

.. automethod:: galpy.df.diskdf.sampledSurfacemassLOS
</file>
    <file path="doc/source/reference/diskdfsampleLOS.rst">
hhgalpy.df.diskdf.sampleLOS
===========================

.. automethod:: galpy.df.diskdf.sampleLOS
</file>
    <file path="doc/source/reference/diskdfsampleVRVT.rst">
galpy.df.diskdf.sampleVRVT
===========================

.. automethod:: galpy.df.diskdf.sampleVRVT
</file>
    <file path="doc/source/reference/quasidfsamplev.rst">
galpy.df.quasiisothermaldf.sampleV
========================================

.. automethod:: galpy.df.quasiisothermaldf.sampleV
</file>
    <file path="doc/source/reference/quasidfsamplevinterpolate.rst">
galpy.df.quasiisothermaldf.sampleV_interpolate
==============================================

.. automethod:: galpy.df.quasiisothermaldf.sampleV_interpolate
</file>
    <file path="doc/source/reference/sphericaldfsample.rst">
galpy.df.sphericaldf.sample
===========================

.. automethod:: galpy.df.sphericaldf.sample
</file>
    <file path="doc/source/reference/streamdfsample.rst">
galpy.df.streamdf.sample
==========================================

.. automethod:: galpy.df.streamdf.sample
</file>
    <file path="doc/source/reference/streamspraydfsample.rst">
galpy.df.streamspraydf.sample
=============================

.. automethod:: galpy.df.streamspraydf.sample
</file>
    <file path="galpy/df/constantbetadf.py">
# Class that implements DFs of the form f(E,L) = L^{-2\beta} f(E) with constant
# beta anisotropy parameter

import numpy
from scipy import integrate, interpolate, special

from ..potential import interpSphericalPotential
from ..potential.Potential import _evaluatePotentials
from ..util import conversion, quadpack
from ..util._optional_deps import _JAX_LOADED
from .sphericaldf import anisotropicsphericaldf, sphericaldf

if _JAX_LOADED:
    from jax import grad, vmap


# This is the general constantbeta superclass, implementation of general
# formula can be found following this class
class _constantbetadf(anisotropicsphericaldf):
    &quot;&quot;&quot;Class that implements DFs of the form f(E,L) = L^{-2\beta} f(E) with constant beta anisotropy parameter&quot;&quot;&quot;

    def __init__(
        self, pot=None, denspot=None, beta=None, rmax=None, scale=None, ro=None, vo=None
    ):
        &quot;&quot;&quot;
        Initialize a spherical DF with constant anisotropy parameter.

        Parameters
        ----------
        pot : Potential or list of Potential instances, optional
            Spherical potential which determines the DF.
        denspot : Potential or list of Potential instances, optional
            Potential instance or list thereof that represent the density of the tracers (assumed to be spherical; if None, set equal to pot).
        beta : float, optional
            Anisotropy parameter. Default is None.
        rmax : float or Quantity, optional
            Maximum radius to consider; DF is cut off at E = Phi(rmax). Default is None.
        scale : float or Quantity, optional
            Characteristic scale radius to aid sampling calculations. Not necessary, and will also be overridden by value from pot if available. Default is None.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        &quot;&quot;&quot;
        anisotropicsphericaldf.__init__(
            self, pot=pot, denspot=denspot, rmax=rmax, scale=scale, ro=ro, vo=vo
        )
        self._beta = beta

    def _call_internal(self, *args):
        &quot;&quot;&quot;
        Evaluate the DF for a constant anisotropy Hernquist.

        Parameters
        ----------
        E : float
            The energy.
        L : float
            The angular momentum.

        Returns
        -------
        float
            The value of the DF.

        Notes
        -----
        - 2020-07-22 - Written - Lane (UofT)

        &quot;&quot;&quot;
        E, L, _ = args
        return L ** (-2 * self._beta) * self.fE(E)

    def _dMdE(self, E):
        if not hasattr(self, &quot;_rphi&quot;):
            self._rphi = self._setup_rphi_interpolator()
        fE = self.fE(E)
        out = numpy.zeros_like(E)
        out[fE &gt; 0.0] = (
            (2.0 * numpy.pi) ** 2.5
            * special.gamma(1.0 - self._beta)
            / 2.0 ** (self._beta - 1.0)
            / special.gamma(1.5 - self._beta)
            * fE[fE &gt; 0.0]
            * numpy.array(
                [
                    integrate.quad(
                        lambda r: r ** (2.0 - 2.0 * self._beta)
                        * (tE - _evaluatePotentials(self._pot, r, 0.0))
                        ** (0.5 - self._beta),
                        0.0,
                        self._rphi(tE),
                    )[0]
                    for ii, tE in enumerate(E)
                    if fE[ii] &gt; 0.0
                ]
            )
        )
        return out

    def _sample_eta(self, r, n=1):
        &quot;&quot;&quot;Sample the angle eta which defines radial vs tangential velocities&quot;&quot;&quot;
        if not hasattr(self, &quot;_coseta_icmf_interp&quot;):
            # Cumulative dist for cos(eta) =
            # 0.5 + x 2F1(0.5,beta,1.5,x^2)/sqrt(pi)/Gamma(1-beta)*Gamma(1.5-beta)
            cosetas = numpy.linspace(-1.0, 1.0, 20001)
            coseta_cmf = (
                cosetas
                * special.hyp2f1(0.5, self._beta, 1.5, cosetas**2.0)
                / numpy.sqrt(numpy.pi)
                / special.gamma(1.0 - self._beta)
                * special.gamma(1.5 - self._beta)
                + 0.5
            )
            self._coseta_icmf_interp = interpolate.interp1d(
                coseta_cmf, cosetas, bounds_error=False, fill_value=&quot;extrapolate&quot;
            )
        return numpy.arccos(self._coseta_icmf_interp(numpy.random.uniform(size=n)))

    def _p_v_at_r(self, v, r):
        if hasattr(self, &quot;_fE_interp&quot;):
            return self._fE_interp(
                _evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0
            ) * v ** (2.0 - 2.0 * self._beta)
        else:
            return self.fE(_evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0) * v ** (
                2.0 - 2.0 * self._beta
            )

    def _vmomentdensity(self, r, n, m):
        if m % 2 == 1 or n % 2 == 1:
            return 0.0
        return (
            2.0
            * numpy.pi
            * r ** (-2.0 * self._beta)
            * integrate.quad(
                lambda v: v ** (2.0 - 2.0 * self._beta + m + n)
                * self.fE(_evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0),
                0.0,
                self._vmax_at_r(self._pot, r),
            )[0]
            * special.gamma(m / 2.0 - self._beta + 1.0)
            * special.gamma((n + 1) / 2.0)
            / special.gamma(0.5 * (m + n - 2.0 * self._beta + 3.0))
        )


class constantbetadf(_constantbetadf):
    &quot;&quot;&quot;Class that implements DFs of the form :math:`f(E,L) = L^{-2\\beta} f_1(E)` with constant :math:`\\beta` anisotropy parameter for a given density profile&quot;&quot;&quot;

    def __init__(
        self,
        pot=None,
        denspot=None,
        beta=0.0,
        twobeta=None,
        rmax=None,
        scale=None,
        ro=None,
        vo=None,
    ):
        &quot;&quot;&quot;
        Initialize a spherical DF with constant anisotropy parameter

        Parameters
        ----------
        pot : Potential instance or list thereof, optional
            Potential instance or list thereof
        denspot : Potential instance or list thereof, optional
            Potential instance or list thereof that represent the density of the tracers (assumed to be spherical; if None, set equal to pot)
        beta : float, optional
            anisotropy parameter
        twobeta : float, optional
            twice the anisotropy parameter (useful for \beta = half-integer, which is a special case); has priority over beta
        rmax : float or Quantity, optional
            maximum radius to consider; DF is cut off at E = Phi(rmax)
        scale : float or Quantity, optional
            Characteristic scale radius to aid sampling calculations. Optional and will also be overridden by value from pot if available.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2021-02-14 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        if not _JAX_LOADED:  # pragma: no cover
            raise ImportError(&quot;galpy.df.constantbetadf requires the google/jax library&quot;)
        # Parse twobeta
        if not twobeta is None:
            beta = twobeta / 2.0
        else:
            twobeta = 2.0 * beta
        if (
            isinstance(pot, interpSphericalPotential) and beta &lt; -0.5
        ):  # pragma: no cover
            raise RuntimeError(
                &quot;constantbetadf with beta &lt; -0.5 is not supported for use with interpSphericalPotential.&quot;
            )
        _constantbetadf.__init__(
            self,
            pot=pot,
            denspot=denspot,
            beta=beta,
            rmax=rmax,
            scale=scale,
            ro=ro,
            vo=vo,
        )
        self._twobeta = twobeta
        self._halfint = False
        if isinstance(self._twobeta, int) and self._twobeta % 2 == 1:
            self._halfint = True
            self._m = (3 - self._twobeta) // 2
            ii = self._m - 1
            # Compute d^m (dens x r^2beta) / d Psi^m as successive
            # d / dr ( ...) / F_r
            func = lambda r: self._denspot._ddenstwobetadr(
                r, beta=self._beta
            ) / self._pot._rforce_jax(r)
            while ii &gt; 0:
                func = lambda r, func=func: grad(func)(r) / self._pot._rforce_jax(r)
                ii -= 1
        else:
            self._m = int(numpy.floor(1.5 - self._beta))
            self._alpha = 1.5 - self._beta - self._m
            self._fE_prefactor = (
                2.0**self._beta
                / (2.0 * numpy.pi) ** 1.5
                / special.gamma(1.0 - self._alpha)
                / special.gamma(1.0 - self._beta)
            )
            ii = self._m
            # Similar d^m (dens x r^2beta) / d Psi^m as above,
            # but because integral necessary now is over psi, we can omit
            # the final 1/Fr to do the integral over r
            if ii == 0:
                func = lambda r: self._denspot._ddenstwobetadr(r, beta=self._beta)
            else:
                func = lambda r: self._denspot._ddenstwobetadr(
                    r, beta=self._beta
                ) / self._pot._rforce_jax(r)
            while ii &gt; 0:
                if ii == 1:
                    func = lambda r, func=func: grad(func)(r)
                else:
                    func = lambda r, func=func: grad(func)(r) / self._pot._rforce_jax(r)
                ii -= 1
        self._gradfunc = vmap(func)
        # Min and max energy
        self._potInf = _evaluatePotentials(self._pot, self._rmax, 0)
        self._Emin = _evaluatePotentials(self._pot, 0.0, 0)
        # Build interpolator r(pot)
        self._rphi = self._setup_rphi_interpolator()
        # Build interpolator for the lower limit of the integration (near the
        # 1/(Phi-E)^alpha divergence; at the end, we slightly adjust it up
        # to be sure to be above the point where things go haywire...
        if not self._halfint:
            Es = numpy.linspace(
                self._Emin, self._potInf + 1e-3 * (self._Emin - self._potInf), 51
            )
            guesspow = -17
            guesst = 10.0 ** (guesspow * (1.0 - self._alpha))
            startt = numpy.ones_like(Es) * guesst
            startval = numpy.zeros_like(Es)
            while numpy.any(startval == 0.0):
                guesspow += 1
                guesst = 10.0 ** (guesspow * (1.0 - self._alpha))
                indx = startval == 0.0
                startt[indx] = guesst
                startval[indx] = _fEintegrand_smallr(
                    startt[indx],
                    self._pot,
                    Es[indx],
                    self._gradfunc,
                    self._alpha,
                    self._rphi(Es[indx]),
                )
            self._logstartt = interpolate.InterpolatedUnivariateSpline(
                Es, numpy.log10(startt) + 10.0 / 3.0 * (1.0 - self._alpha), k=3
            )

    def sample(self, R=None, z=None, phi=None, n=1, return_orbit=True, rmin=0.0):
        # Slight over-write of superclass method to first build f(E) interp
        # No docstring so superclass' is used
        if not hasattr(self, &quot;_fE_interp&quot;):
            Es4interp = numpy.hstack(
                (
                    numpy.geomspace(1e-8, 0.5, 101, endpoint=False),
                    sorted(1.0 - numpy.geomspace(1e-4, 0.5, 101)),
                )
            )
            Es4interp = (Es4interp * (self._Emin - self._potInf) + self._potInf)[::-1]
            fE4interp = self.fE(Es4interp)
            iindx = numpy.isfinite(fE4interp)
            self._fE_interp = interpolate.InterpolatedUnivariateSpline(
                Es4interp[iindx], fE4interp[iindx], k=3, ext=3
            )
        return sphericaldf.sample(
            self, R=R, z=z, phi=phi, n=n, return_orbit=return_orbit, rmin=rmin
        )

    def fE(self, E):
        &quot;&quot;&quot;
        Calculate the energy portion of a constant-beta distribution function

        Parameters
        ----------
        E : float, numpy.ndarray, or Quantity
            The energy.

        Returns
        -------
        numpy.ndarray
            The value of the energy portion of the DF

        Notes
        -----
        - 2021-02-14 - Written - Bovy (UofT)
        &quot;&quot;&quot;
        Eint = numpy.atleast_1d(conversion.parse_energy(E, vo=self._vo))
        out = numpy.zeros_like(Eint)
        indx = (Eint &lt; self._potInf) * (Eint &gt;= self._Emin)
        if self._halfint:
            # fE is simply given by the relevant derivative
            out[indx] = self._gradfunc(self._rphi(Eint[indx]))
            return out.reshape(E.shape) / (
                2.0
                * numpy.pi**1.5
                * 2 ** (0.5 - self._beta)
                * special.gamma(1.0 - self._beta)
            )
        else:
            # Now need to integrate to get fE
            # Split integral at twice the lower limit to deal with divergence
            # at the lower end and infinity at the upper end
            out[indx] = numpy.array(
                [
                    quadpack.quadrature(
                        lambda t: _fEintegrand_smallr(
                            t,
                            self._pot,
                            tE,
                            self._gradfunc,
                            self._alpha,
                            self._rphi(tE),
                        ),
                        10.0 ** self._logstartt(tE),
                        self._rphi(tE) ** (1.0 - self._alpha),
                    )[0]
                    for tE in Eint[indx]
                ]
            )
            # Add constant part at the beginning
            out[indx] += 10.0 ** self._logstartt(Eint[indx]) * _fEintegrand_smallr(
                10.0 ** self._logstartt(Eint[indx]),
                self._pot,
                Eint[indx],
                self._gradfunc,
                self._alpha,
                self._rphi(Eint[indx]),
            )
            # 2nd half of the integral
            out[indx] += numpy.array(
                [
                    quadpack.quadrature(
                        lambda t: _fEintegrand_larger(
                            t, self._pot, tE, self._gradfunc, self._alpha
                        ),
                        0.0,
                        0.5 / self._rphi(tE),
                    )[0]
                    for tE in Eint[indx]
                ]
            )
            return -out.reshape(E.shape) * self._fE_prefactor


def _fEintegrand_raw(r, pot, E, dmp1nudrmp1, alpha):
    # The 'raw', i.e., direct integrand in the constant-beta inversion
    out = numpy.zeros_like(r)  # Avoid JAX item assignment issues
    # print(&quot;r&quot;,r,dmp1nudrmp1(r),(_evaluatePotentials(pot,r,0)-E))
    out[:] = dmp1nudrmp1(r) / (_evaluatePotentials(pot, r, 0) - E) ** alpha
    out[True ^ numpy.isfinite(out)] = (
        0.0  # assume these are where denom is slightly neg.
    )
    return out


def _fEintegrand_smallr(t, pot, E, dmp1nudrmp1, alpha, rmin):
    # The integrand at small r, using transformation to deal with divergence
    # print(&quot;t&quot;,t,rmin,t**(1./(1.-alpha))+rmin)
    return (
        1.0
        / (1.0 - alpha)
        * t ** (alpha / (1.0 - alpha))
        * _fEintegrand_raw(
            t ** (1.0 / (1.0 - alpha)) + rmin, pot, E, dmp1nudrmp1, alpha
        )
    )


def _fEintegrand_larger(t, pot, E, dmp1nudrmp1, alpha):
    # The integrand at large r, using transformation to deal with infinity
    return 1.0 / t**2 * _fEintegrand_raw(1.0 / t, pot, E, dmp1nudrmp1, alpha)
</file>
    <file path="galpy/df/diskdf.py">
###############################################################################
#   diskdf.py: module that interprets (E,Lz) pairs in terms of a
#              distribution function (following Dehnen 1999)
#
#   This module contains the following classes:
#
#      diskdf - top-level class that represents a distribution function
#      dehnendf - inherits from diskdf, implements Dehnen's 'new' DF
#      shudf - inherits from diskdf, implements Shu's DF
#      DFcorrection - class that represents corrections to the input Sigma(R)
#                     and sigma_R(R) to get closer to the targets
###############################################################################
_EPSREL = 10.0**-14.0
_NSIGMA = 4.0
_INTERPDEGREE = 3
_RMIN = 10.0**-10.0
_MAXD_REJECTLOS = 4.0
_PROFILE = False
import copy
import os
import os.path
import pickle

import numpy
import scipy

numpylog = numpy.lib.scimath.log  # somehow, this code produces log(negative), which scipy (now numpy.lib.scimath.log) implements as log(|negative|) + i pi while numpy gives NaN and we want the scipy behavior; not sure where the log(negative) comes from though! I think it's for sigma=0 DFs (this test fails with numpy.log) where the DF eval has a log(~zero) that can be slightly negative because of numerical precision issues
from scipy import integrate, interpolate, optimize, stats

from ..actionAngle import actionAngleAdiabatic
from ..orbit import Orbit
from ..potential import PowerSphericalPotential
from ..util import conversion, quadpack, save_pickles
from ..util.ars import ars
from ..util.conversion import (
    _APY_LOADED,
    _APY_UNITS,
    physical_conversion,
    potential_physical_input,
    surfdens_in_msolpc2,
)
from .df import df
from .surfaceSigmaProfile import expSurfaceSigmaProfile, surfaceSigmaProfile

if _APY_LOADED:
    from astropy import units
# scipy version
from packaging.version import parse as parse_version

_SCIPY_VERSION = parse_version(scipy.__version__)
_SCIPY_VERSION_BREAK = parse_version(&quot;0.9&quot;)
_CORRECTIONSDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), &quot;data&quot;)
_DEGTORAD = numpy.pi / 180.0


class diskdf(df):
    &quot;&quot;&quot;Class that represents a disk DF&quot;&quot;&quot;

    def __init__(
        self,
        dftype=&quot;dehnen&quot;,
        surfaceSigma=expSurfaceSigmaProfile,
        profileParams=(1.0 / 3.0, 1.0, 0.2),
        correct=False,
        beta=0.0,
        ro=None,
        vo=None,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Initialize a DF

        Parameters
        ----------
        dftype : str, optional
            'dehnen' or 'corrected-dehnen', 'shu' or 'corrected-shu'
        surfaceSigma : instance or class name of the target surface density and sigma_R profile, optional
            (default: both exponential)
        profileParams : tuple, optional
            parameters of the surface and sigma_R profile: (xD,xS,Sro) where
              * xD - disk surface mass scalelength / Ro
              * xS - disk velocity dispersion scalelength / Ro
              * Sro - disk velocity dispersion at Ro (/vo)
            Directly given to the 'surfaceSigmaProfile class, so could be anything that class takes
        beta : float, optional
            power-law index of the rotation curve
        correct : bool, optional
            correct the DF (i.e., DFcorrection kwargs are also given)
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        **kwargs : dict, optional
            DFcorrection kwargs (except for those already specified)

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        df.__init__(self, ro=ro, vo=vo)
        self._dftype = dftype
        if isinstance(surfaceSigma, surfaceSigmaProfile):
            self._surfaceSigmaProfile = surfaceSigma
        else:
            if _APY_LOADED and isinstance(profileParams[0], units.Quantity):
                newprofileParams = (
                    conversion.parse_length(profileParams[0], ro=self._ro),
                    conversion.parse_length(profileParams[1], ro=self._ro),
                    conversion.parse_velocity(profileParams[2], vo=self._vo),
                )
                self._roSet = True
                self._voSet = True
                profileParams = newprofileParams
            self._surfaceSigmaProfile = surfaceSigma(profileParams)
        self._beta = beta
        self._gamma = numpy.sqrt(2.0 / (1.0 + self._beta))
        if (
            correct
            or &quot;corrections&quot; in kwargs
            or &quot;rmax&quot; in kwargs
            or &quot;niter&quot; in kwargs
            or &quot;npoints&quot; in kwargs
        ):
            self._correct = True
            # Load corrections
            self._corr = DFcorrection(
                dftype=self.__class__,
                surfaceSigmaProfile=self._surfaceSigmaProfile,
                beta=beta,
                **kwargs,
            )
        else:
            self._correct = False
        self._psp = PowerSphericalPotential(
            normalize=1.0, alpha=2.0 - 2.0 * self._beta
        ).toPlanar()
        # Setup aA objects for frequency and rap,rperi calculation
        self._aA = actionAngleAdiabatic(pot=self._psp, gamma=0.0)
        return None

    @physical_conversion(&quot;phasespacedensity2d&quot;, pop=True)
    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Evaluate the distribution function

        Parameters
        ----------
        *args : tuple
            Either:
                1) Orbit instance or list:
                    a) Orbit instance alone: use initial condition
                    b) Orbit instance + t: call the Orbit instance (for list, each instance is called at t)
                2) E,L - energy (/vo^2; or can be Quantity) and angular momentun (/ro/vo; or can be Quantity)
                3) array vxvv [3/4,nt] [must be in natural units /vo,/ro; use Orbit interface for physical-unit input]
        marginalizeVperp : bool, optional
            marginalize over perpendicular velocity (only supported with 1a) for single orbits above)
        marginalizeVlos : bool, optional
            marginalize over line-of-sight velocity (only supported with 1a) for single orbits above)
        nsigma : float, optional
            number of sigma to integrate over when marginalizing
        **kwargs: dict, optional
            scipy.integrate.quad keywords

        Returns
        -------
        float or numpy.ndarray
            value of DF

        Notes
        -----
        - 2010-07-10 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        if isinstance(args[0], Orbit):
            if len(args[0]) &gt; 1:
                raise RuntimeError(
                    &quot;Only single-object Orbit instances can be passed to DF instances at this point&quot;
                )  # pragma: no cover
            if len(args) == 1:
                if kwargs.pop(&quot;marginalizeVperp&quot;, False):
                    return self._call_marginalizevperp(args[0], **kwargs)
                elif kwargs.pop(&quot;marginalizeVlos&quot;, False):
                    return self._call_marginalizevlos(args[0], **kwargs)
                else:
                    return numpy.real(
                        self.eval(
                            *vRvTRToEL(
                                args[0].vR(use_physical=False),
                                args[0].vT(use_physical=False),
                                args[0].R(use_physical=False),
                                self._beta,
                                self._dftype,
                            )
                        )
                    )
            else:
                no = args[0](args[1])
                return numpy.real(
                    self.eval(
                        *vRvTRToEL(
                            no.vR(use_physical=False),
                            no.vT(use_physical=False),
                            no.R(use_physical=False),
                            self._beta,
                            self._dftype,
                        )
                    )
                )
        elif isinstance(args[0], list) and isinstance(args[0][0], Orbit):
            if numpy.any([len(no) &gt; 1 for no in args[0]]):
                raise RuntimeError(
                    &quot;Only single-object Orbit instances can be passed to DF instances at this point&quot;
                )  # pragma: no cover
            # Grab all of the vR, vT, and R
            vR = numpy.array([o.vR(use_physical=False) for o in args[0]])
            vT = numpy.array([o.vT(use_physical=False) for o in args[0]])
            R = numpy.array([o.R(use_physical=False) for o in args[0]])
            return numpy.real(
                self.eval(*vRvTRToEL(vR, vT, R, self._beta, self._dftype))
            )
        elif isinstance(args[0], numpy.ndarray) and not (
            hasattr(args[0], &quot;isscalar&quot;) and args[0].isscalar
        ):
            # Grab all of the vR, vT, and R
            vR = args[0][1]
            vT = args[0][2]
            R = args[0][0]
            return numpy.real(
                self.eval(*vRvTRToEL(vR, vT, R, self._beta, self._dftype))
            )
        else:
            return numpy.real(self.eval(*args))

    def _call_marginalizevperp(self, o, **kwargs):
        &quot;&quot;&quot;Call the DF, marginalizing over perpendicular velocity&quot;&quot;&quot;
        # Get l, vlos
        l = o.ll(obs=[1.0, 0.0, 0.0], ro=1.0) * _DEGTORAD
        vlos = o.vlos(ro=1.0, vo=1.0, obs=[1.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        R = o.R(use_physical=False)
        phi = o.phi(use_physical=False)
        # Get local circular velocity, projected onto the los
        vcirc = R**self._beta
        vcirclos = vcirc * numpy.sin(phi + l)
        # Marginalize
        alphalos = phi + l
        if not &quot;nsigma&quot; in kwargs or (&quot;nsigma&quot; in kwargs and kwargs[&quot;nsigma&quot;] is None):
            nsigma = _NSIGMA
        else:
            nsigma = kwargs[&quot;nsigma&quot;]
        kwargs.pop(&quot;nsigma&quot;, None)
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        sigmaR1 = numpy.sqrt(sigmaR2)
        # Use the asymmetric drift equation to estimate va
        va = (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if numpy.fabs(numpy.sin(alphalos)) &lt; numpy.sqrt(1.0 / 2.0):
            cosalphalos = numpy.cos(alphalos)
            tanalphalos = numpy.tan(alphalos)
            return (
                integrate.quad(
                    _marginalizeVperpIntegrandSinAlphaSmall,
                    -self._gamma * va / sigmaR1 - nsigma,
                    -self._gamma * va / sigmaR1 + nsigma,
                    args=(
                        self,
                        R,
                        cosalphalos,
                        tanalphalos,
                        vlos - vcirclos,
                        vcirc,
                        sigmaR1 / self._gamma,
                    ),
                    **kwargs,
                )[0]
                / numpy.fabs(cosalphalos)
                * sigmaR1
                / self._gamma
            )
        else:
            sinalphalos = numpy.sin(alphalos)
            cotalphalos = 1.0 / numpy.tan(alphalos)
            return (
                integrate.quad(
                    _marginalizeVperpIntegrandSinAlphaLarge,
                    -nsigma,
                    nsigma,
                    args=(
                        self,
                        R,
                        sinalphalos,
                        cotalphalos,
                        vlos - vcirclos,
                        vcirc,
                        sigmaR1,
                    ),
                    **kwargs,
                )[0]
                / numpy.fabs(sinalphalos)
                * sigmaR1
            )

    def _call_marginalizevlos(self, o, **kwargs):
        &quot;&quot;&quot;Call the DF, marginalizing over line-of-sight velocity&quot;&quot;&quot;
        # Get d, l, vperp
        l = o.ll(obs=[1.0, 0.0, 0.0], ro=1.0) * _DEGTORAD
        vperp = o.vll(ro=1.0, vo=1.0, obs=[1.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        R = o.R(use_physical=False)
        phi = o.phi(use_physical=False)
        # Get local circular velocity, projected onto the perpendicular
        # direction
        vcirc = R**self._beta
        vcircperp = vcirc * numpy.cos(phi + l)
        # Marginalize
        alphaperp = numpy.pi / 2.0 + phi + l
        if not &quot;nsigma&quot; in kwargs or (&quot;nsigma&quot; in kwargs and kwargs[&quot;nsigma&quot;] is None):
            nsigma = _NSIGMA
        else:
            nsigma = kwargs[&quot;nsigma&quot;]
        kwargs.pop(&quot;nsigma&quot;, None)
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        sigmaR1 = numpy.sqrt(sigmaR2)
        # Use the asymmetric drift equation to estimate va
        va = (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if numpy.fabs(numpy.sin(alphaperp)) &lt; numpy.sqrt(1.0 / 2.0):
            cosalphaperp = numpy.cos(alphaperp)
            tanalphaperp = numpy.tan(alphaperp)
            # we can reuse the VperpIntegrand, since it is just another angle
            return (
                integrate.quad(
                    _marginalizeVperpIntegrandSinAlphaSmall,
                    -self._gamma * va / sigmaR1 - nsigma,
                    -self._gamma * va / sigmaR1 + nsigma,
                    args=(
                        self,
                        R,
                        cosalphaperp,
                        tanalphaperp,
                        vperp - vcircperp,
                        vcirc,
                        sigmaR1 / self._gamma,
                    ),
                    **kwargs,
                )[0]
                / numpy.fabs(cosalphaperp)
                * sigmaR1
                / self._gamma
            )
        else:
            sinalphaperp = numpy.sin(alphaperp)
            cotalphaperp = 1.0 / numpy.tan(alphaperp)
            # we can reuse the VperpIntegrand, since it is just another angle
            return (
                integrate.quad(
                    _marginalizeVperpIntegrandSinAlphaLarge,
                    -nsigma,
                    nsigma,
                    args=(
                        self,
                        R,
                        sinalphaperp,
                        cotalphaperp,
                        vperp - vcircperp,
                        vcirc,
                        sigmaR1,
                    ),
                    **kwargs,
                )[0]
                / numpy.fabs(sinalphaperp)
                * sigmaR1
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def targetSigma2(self, R, log=False):
        &quot;&quot;&quot;
        Evaluate the target Sigma_R^2(R)

        Parameters
        ----------
        R : float or Quantity
            Radius at which to evaluate.
        log : bool, optional
            If True, return the log (default: False).

        Returns
        -------
        float
            Target Sigma_R^2(R).

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        return self._surfaceSigmaProfile.sigma2(R, log=log)

    @potential_physical_input
    @physical_conversion(&quot;surfacedensity&quot;, pop=True)
    def targetSurfacemass(self, R, log=False):
        &quot;&quot;&quot;
        Evaluate the target surface mass at R.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to evaluate.
        log : bool, optional
            If True, return the log (default: False).

        Returns
        -------
        float or Quantity
            Target surface mass at R.

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        return self._surfaceSigmaProfile.surfacemass(R, log=log)

    @physical_conversion(&quot;surfacedensitydistance&quot;, pop=True)
    def targetSurfacemassLOS(self, d, l, log=False, deg=True):
        &quot;&quot;&quot;
        Evaluate the target surface mass along the line of sight given Galactic longitude and distance.

        Parameters
        ----------
        d : float or Quantity
            Distance along the line of sight.
        l : float or Quantity
            Galactic longitude in degrees, unless deg=False.
        deg : bool, optional
            If False, l is in radians. Default is True.
        log : bool, optional
            If True, return the logarithm of the surface mass. Default is False.

        Returns
        -------
        float or Quantity
            Surface mass times distance.

        Notes
        -----
        - 2011-03-23 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # Calculate R and phi
        if _APY_LOADED and isinstance(l, units.Quantity):
            lrad = conversion.parse_angle(l)
        elif deg:
            lrad = l * _DEGTORAD
        else:
            lrad = l
        d = conversion.parse_length(d, ro=self._ro)
        R, phi = _dlToRphi(d, lrad)
        if log:
            return self._surfaceSigmaProfile.surfacemass(R, log=log) + numpylog(d)
        else:
            return self._surfaceSigmaProfile.surfacemass(R, log=log) * d

    @physical_conversion(&quot;surfacedensitydistance&quot;, pop=True)
    def surfacemassLOS(
        self, d, l, deg=True, target=True, romberg=False, nsigma=None, relative=None
    ):
        &quot;&quot;&quot;
        Evaluate the surface mass along the line of sight (LOS) given Galactic longitude and distance.

        Parameters
        ----------
        d : float or Quantity
            Distance along the line of sight.
        l : float or Quantity
            Galactic longitude (in deg, unless deg=False).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        target : bool, optional
            If True, use target surfacemass (default).
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        deg : bool, optional
            If False, l is in radians.
        relative : bool, optional
            If True, return d.

        Returns
        -------
        float
            Sigma(d,l) x d

        Notes
        -----
        - 2011-03-24 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # Calculate R and phi
        if _APY_LOADED and isinstance(l, units.Quantity):
            lrad = conversion.parse_angle(l)
        elif deg:
            lrad = l * _DEGTORAD
        else:
            lrad = l
        d = conversion.parse_length(d, ro=self._ro)
        R, phi = _dlToRphi(d, lrad)
        if target:
            if relative:
                return d
            else:
                return self.targetSurfacemass(R, use_physical=False) * d
        else:
            return (
                self.surfacemass(
                    R,
                    romberg=romberg,
                    nsigma=nsigma,
                    relative=relative,
                    use_physical=False,
                )
                * d
            )

    @physical_conversion(&quot;position&quot;, pop=True)
    def sampledSurfacemassLOS(self, l, n=1, maxd=None, target=True):
        &quot;&quot;&quot;
        Sample a distance along the line of sight

        Parameters
        ----------
        l : float or Quantity
            Galactic longitude.
        n : int, optional
            Number of distances to sample.
        maxd : float or Quantity, optional
            Maximum distance to consider (for the rejection sampling).
        target : bool, optional
            If True, sample from the 'target' surface mass density, rather than the actual surface mass density (default=True).

        Returns
        -------
        list
            List of samples.

        Notes
        -----
        - 2011-03-24 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        # First calculate where the maximum is
        if target:
            minR = optimize.fmin_bfgs(
                lambda x: -self.targetSurfacemassLOS(
                    x, l, use_physical=False, deg=False
                ),
                0.0,
                disp=False,
            )[0]
            maxSM = self.targetSurfacemassLOS(minR, l, deg=False, use_physical=False)
        else:
            minR = optimize.fmin_bfgs(
                lambda x: -self.surfacemassLOS(x, l, deg=False, use_physical=False),
                0.0,
                disp=False,
            )[0]
            maxSM = self.surfacemassLOS(minR, l, deg=False, use_physical=False)
        # Now rejection-sample
        l = conversion.parse_angle(l)
        maxd = conversion.parse_length(maxd, ro=self._ro)
        if maxd is None:
            maxd = _MAXD_REJECTLOS
        out = []
        while len(out) &lt; n:
            # sample
            prop = numpy.random.random() * maxd
            if target:
                surfmassatprop = self.targetSurfacemassLOS(
                    prop, l, deg=False, use_physical=False
                )
            else:
                surfmassatprop = self.surfacemassLOS(
                    prop, l, deg=False, use_physical=False
                )
            if surfmassatprop / maxSM &gt; numpy.random.random():  # accept
                out.append(prop)
        return numpy.array(out)

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def sampleVRVT(self, R, n=1, nsigma=None, target=True):
        &quot;&quot;&quot;
        Sample a radial and azimuthal velocity at R

        Parameters
        ----------
        R : float or Quantity
            Galactocentric distance.
        n : int, optional
            Number of distances to sample.
        nsigma : float, optional
            Number of sigma to rejection-sample on.
        target : bool, optional
            If True, sample using the 'target' sigma_R rather than the actual sigma_R (default=True).

        Returns
        -------
        list
            List of samples.

        Notes
        -----
        - 2011-03-24 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # Determine where the max of the v-distribution is using asymmetric drift
        maxVR = 0.0
        maxVT = optimize.brentq(_vtmaxEq, 0.0, R**self._beta + 0.2, (R, self))
        maxVD = self(Orbit([R, maxVR, maxVT]))
        # Now rejection-sample
        if nsigma == None:
            nsigma = _NSIGMA
        out = []
        if target:
            sigma = numpy.sqrt(self.targetSigma2(R, use_physical=False))
        else:
            sigma = numpy.sqrt(self.sigma2(R, use_physical=False))
        while len(out) &lt; n:
            # sample
            vrg, vtg = numpy.random.normal(), numpy.random.normal()
            propvR = vrg * nsigma * sigma
            propvT = vtg * nsigma * sigma / self._gamma + maxVT
            VDatprop = self(Orbit([R, propvR, propvT]))
            if VDatprop / maxVD &gt; numpy.random.uniform() * numpy.exp(
                -0.5 * (vrg**2.0 + vtg**2.0)
            ):  # accept
                out.append(numpy.array([propvR, propvT]))
        return numpy.array(out)

    def sampleLOS(
        self,
        los,
        n=1,
        deg=True,
        maxd=None,
        nsigma=None,
        targetSurfmass=True,
        targetSigma2=True,
    ):
        &quot;&quot;&quot;
        Sample along a given LOS

        Parameters
        ----------
        los : float or Quantity
            Line of sight Galactic longitude.
        n : int, optional
            Number of distances to sample.
        deg : bool, optional
            If False, los is in radians.
        maxd : float or Quantity, optional
            Maximum distance to consider (for the rejection sampling).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        targetSurfmass : bool, optional
            If True, use target surface mass (default=True).
        targetSigma2 : bool, optional
            If True, use target sigma_R^2 (default=True).

        Returns
        -------
        list
            List of Orbits sampled.

        Notes
        -----
        - target=False uses target distribution for derivatives (this is a detail)
        - 2011-03-24 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        if _APY_LOADED and isinstance(los, units.Quantity):
            l = conversion.parse_angle(los)
        elif deg:
            l = los * _DEGTORAD
        else:
            l = los
        out = []
        # sample distances
        ds = self.sampledSurfacemassLOS(
            l, n=n, maxd=maxd, target=targetSurfmass, use_physical=False
        )
        for ii in range(int(n)):
            # Calculate R and phi
            thisR, thisphi = _dlToRphi(ds[ii], l)
            # sample velocities
            vv = self.sampleVRVT(
                thisR, n=1, nsigma=nsigma, target=targetSigma2, use_physical=False
            )[0]
            if self._roSet and self._voSet:
                out.append(
                    Orbit([thisR, vv[0], vv[1], thisphi], ro=self._ro, vo=self._vo)
                )
            else:
                out.append(Orbit([thisR, vv[0], vv[1], thisphi]))
        return out

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def asymmetricdrift(self, R):
        &quot;&quot;&quot;
        Estimate the asymmetric drift (vc-mean-vphi) from an approximation to the Jeans equation.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate the asymmetric drift.

        Returns
        -------
        float
            Asymmetric drift at R.

        Notes
        -----
        - 2011-04-02 - Written - Bovy (NYU).
        &quot;&quot;&quot;
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        return (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )

    @potential_physical_input
    @physical_conversion(&quot;surfacedensity&quot;, pop=True)
    def surfacemass(self, R, romberg=False, nsigma=None, relative=False):
        &quot;&quot;&quot;
        Calculate the surface-mass at R by marginalizing over velocity

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate the surfacemass density.
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        nsigma : float, optional
            Number of sigma to integrate the velocities over
        relative : bool, optional
            If True, return the relative surface mass at R (default: False)

        Returns
        -------
        float
            Surface mass at R

        Notes
        -----
        - 2011-03-XX - Bovy (NYU)
        &quot;&quot;&quot;
        if nsigma == None:
            nsigma = _NSIGMA
        logSigmaR = self.targetSurfacemass(R, log=True, use_physical=False)
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        sigmaR1 = numpy.sqrt(sigmaR2)
        logsigmaR2 = numpylog(sigmaR2)
        if relative:
            norm = 1.0
        else:
            norm = numpy.exp(logSigmaR)
        # Use the asymmetric drift equation to estimate va
        va = (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if romberg:
            return numpy.real(
                bovy_dblquad(
                    _surfaceIntegrand,
                    self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                    self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    [R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma],
                    tol=10.0**-8,
                )
                / numpy.pi
                * norm
            )
        else:
            return (
                integrate.dblquad(
                    _surfaceIntegrand,
                    self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                    self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    (R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma),
                    epsrel=_EPSREL,
                )[0]
                / numpy.pi
                * norm
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity2surfacedensity&quot;, pop=True)
    def sigma2surfacemass(self, R, romberg=False, nsigma=None, relative=False):
        &quot;&quot;&quot;
        Calculate the product sigma_R^2 x surface-mass at R by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate the sigma_R^2 x surfacemass density.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        relative : bool, optional
            If True, return the relative density (default: False).

        Returns
        -------
        float
            Sigma_R^2 x surface-mass at R.

        Notes
        -----
        - 2010-03-XX - Written - Bovy (NYU).

        &quot;&quot;&quot;
        if nsigma == None:
            nsigma = _NSIGMA
        logSigmaR = self.targetSurfacemass(R, log=True, use_physical=False)
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        sigmaR1 = numpy.sqrt(sigmaR2)
        logsigmaR2 = numpylog(sigmaR2)
        if relative:
            norm = 1.0
        else:
            norm = numpy.exp(logSigmaR + logsigmaR2)
        # Use the asymmetric drift equation to estimate va
        va = (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if romberg:
            return numpy.real(
                bovy_dblquad(
                    _sigma2surfaceIntegrand,
                    self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                    self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    [R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma],
                    tol=10.0**-8,
                )
                / numpy.pi
                * norm
            )
        else:
            return (
                integrate.dblquad(
                    _sigma2surfaceIntegrand,
                    self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                    self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    (R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma),
                    epsrel=_EPSREL,
                )[0]
                / numpy.pi
                * norm
            )

    def vmomentsurfacemass(self, *args, **kwargs):
        &quot;&quot;&quot;
        Calculate the an arbitrary moment of the velocity distribution at R times the surfacmass

        Parameters
        ----------
        R: float or Quantity
            Galactocentric radius at which to calculate the moment.
        n: int
            vR^n in the moment
        m: int
            vT^m in the moment
        nsigma : int, optional
            number of sigma to integrate the velocities over
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        deriv : str, optional
            Calculates derivative of the moment wrt R or phi (default: None)

        Returns
        -------
        float or Quantity
            &lt;vR^n vT^m  x surface-mass&gt; at R (no support for units)

        Notes
        -----
        - 2011-03-30 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        ro = kwargs.pop(&quot;ro&quot;, None)
        if ro is None and hasattr(self, &quot;_roSet&quot;) and self._roSet:
            ro = self._ro
        ro = conversion.parse_length_kpc(ro)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = conversion.parse_velocity_kms(vo)
        if use_physical and not vo is None and not ro is None:
            fac = surfdens_in_msolpc2(vo, ro) * vo ** (args[1] + args[2])
            if _APY_UNITS:
                u = (
                    units.Msun
                    / units.pc**2
                    * (units.km / units.s) ** (args[1] + args[2])
                )
            out = self._vmomentsurfacemass(*args, **kwargs)
            if _APY_UNITS:
                return units.Quantity(out * fac, unit=u)
            else:
                return out * fac
        else:
            return self._vmomentsurfacemass(*args, **kwargs)

    def _vmomentsurfacemass(
        self, R, n, m, romberg=False, nsigma=None, relative=False, phi=0.0, deriv=None
    ):
        &quot;&quot;&quot;Non-physical version of vmomentsurfacemass, otherwise the same&quot;&quot;&quot;
        # odd moments of vR are zero
        if isinstance(n, int) and n % 2 == 1:
            return 0.0
        if nsigma == None:
            nsigma = _NSIGMA
        logSigmaR = self.targetSurfacemass(R, log=True, use_physical=False)
        sigmaR2 = self.targetSigma2(R, use_physical=False)
        sigmaR1 = numpy.sqrt(sigmaR2)
        logsigmaR2 = numpylog(sigmaR2)
        if relative:
            norm = 1.0
        else:
            norm = numpy.exp(logSigmaR + logsigmaR2 * (n + m) / 2.0) / self._gamma**m
        # Use the asymmetric drift equation to estimate va
        va = (
            sigmaR2
            / 2.0
            / R**self._beta
            * (
                1.0 / self._gamma**2.0
                - 1.0
                - R * self._surfaceSigmaProfile.surfacemassDerivative(R, log=True)
                - R * self._surfaceSigmaProfile.sigma2Derivative(R, log=True)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if deriv is None:
            if romberg:
                return numpy.real(
                    bovy_dblquad(
                        _vmomentsurfaceIntegrand,
                        self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                        self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                        lambda x: -nsigma,
                        lambda x: nsigma,
                        [R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma, n, m],
                        tol=10.0**-8,
                    )
                    / numpy.pi
                    * norm
                    / 2.0
                )
            else:
                return (
                    integrate.dblquad(
                        _vmomentsurfaceIntegrand,
                        self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                        self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                        lambda x: -nsigma,
                        lambda x: nsigma,
                        (R, self, logSigmaR, logsigmaR2, sigmaR1, self._gamma, n, m),
                        epsrel=_EPSREL,
                    )[0]
                    / numpy.pi
                    * norm
                    / 2.0
                )
        else:
            if romberg:
                return numpy.real(
                    bovy_dblquad(
                        _vmomentderivsurfaceIntegrand,
                        self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                        self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                        lambda x: -nsigma,
                        lambda x: nsigma,
                        [
                            R,
                            self,
                            logSigmaR,
                            logsigmaR2,
                            sigmaR1,
                            self._gamma,
                            n,
                            m,
                            deriv,
                        ],
                        tol=10.0**-8,
                    )
                    / numpy.pi
                    * norm
                    / 2.0
                )
            else:
                return (
                    integrate.dblquad(
                        _vmomentderivsurfaceIntegrand,
                        self._gamma * (R**self._beta - va) / sigmaR1 - nsigma,
                        self._gamma * (R**self._beta - va) / sigmaR1 + nsigma,
                        lambda x: -nsigma,
                        lambda x: nsigma,
                        (
                            R,
                            self,
                            logSigmaR,
                            logsigmaR2,
                            sigmaR1,
                            self._gamma,
                            n,
                            m,
                            deriv,
                        ),
                        epsrel=_EPSREL,
                    )[0]
                    / numpy.pi
                    * norm
                    / 2.0
                )

    @potential_physical_input
    @physical_conversion(&quot;frequency-kmskpc&quot;, pop=True)
    def oortA(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate the Oort function A.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate A.
        phi : float, optional
            Azimuth (default: 0.0).
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).

        Returns
        -------
        float or Quantity
            Oort A at R.

        Notes
        -----
        - 2011-04-19 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # Could be made more efficient, e.g., surfacemass is calculated multiple times.
        # 2A= meanvphi/R-dmeanvR/R/dphi-dmeanvphi/dR
        meanvphi = self.meanvT(
            R, romberg=romberg, nsigma=nsigma, phi=phi, use_physical=False
        )
        dmeanvRRdphi = 0.0  # We know this, since the DF does not depend on phi
        surfmass = self._vmomentsurfacemass(
            R, 0, 0, phi=phi, romberg=romberg, nsigma=nsigma
        )
        dmeanvphidR = self._vmomentsurfacemass(
            R, 0, 1, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
        ) / surfmass - self._vmomentsurfacemass(
            R, 0, 1, phi=phi, romberg=romberg, nsigma=nsigma
        ) / surfmass**2.0 * self._vmomentsurfacemass(
            R, 0, 0, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
        )
        return 0.5 * (meanvphi / R - dmeanvRRdphi / R - dmeanvphidR)

    @potential_physical_input
    @physical_conversion(&quot;frequency-kmskpc&quot;, pop=True)
    def oortB(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate the Oort function B.

        Parameters
        ----------
        R : float
            Radius at which to calculate B (can be Quantity).
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth angle (in radians) at which to calculate B.

        Returns
        -------
        float or Quantity
            Oort B at R.

        Notes
        -----
        - 2011-04-19 - Written - Bovy (NYU).
        &quot;&quot;&quot;
        # Could be made more efficient, e.g., surfacemass is calculated multiple times.
        # 2B= -meanvphi/R+dmeanvR/R/dphi-dmeanvphi/dR
        meanvphi = self.meanvT(
            R, romberg=romberg, nsigma=nsigma, phi=phi, use_physical=False
        )
        dmeanvRRdphi = 0.0  # We know this, since the DF does not depend on phi
        surfmass = self._vmomentsurfacemass(
            R, 0, 0, phi=phi, romberg=romberg, nsigma=nsigma
        )
        dmeanvphidR = self._vmomentsurfacemass(
            R, 0, 1, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
        ) / surfmass - self._vmomentsurfacemass(
            R, 0, 1, phi=phi, romberg=romberg, nsigma=nsigma
        ) / surfmass**2.0 * self._vmomentsurfacemass(
            R, 0, 0, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
        )
        return 0.5 * (-meanvphi / R + dmeanvRRdphi / R - dmeanvphidR)

    @potential_physical_input
    @physical_conversion(&quot;frequency-kmskpc&quot;, pop=True)
    def oortC(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate the Oort function C.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate C (can be Quantity).
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        phi : float, optional
            Azimuth (default: 0.0).

        Returns
        -------
        float or Quantity
            Oort C at R.

        Notes
        -----
        - 2011-04-19 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # - Could be made more efficient, e.g., surfacemass is calculated multiple times.
        # - We know this is zero, but it is calculated anyway (bug or feature?).
        # 2C= -meanvR/R-dmeanvphi/R/dphi+dmeanvR/dR
        meanvr = self.meanvR(
            R, romberg=romberg, nsigma=nsigma, phi=phi, use_physical=False
        )
        dmeanvphiRdphi = 0.0  # We know this, since the DF does not depend on phi
        surfmass = self._vmomentsurfacemass(
            R, 0, 0, phi=phi, romberg=romberg, nsigma=nsigma
        )
        dmeanvRdR = (
            self._vmomentsurfacemass(
                R, 1, 0, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
            )
            / surfmass
        )  # other terms is zero because f is even in vR
        return 0.5 * (-meanvr / R - dmeanvphiRdphi / R + dmeanvRdR)

    @potential_physical_input
    @physical_conversion(&quot;frequency-kmskpc&quot;, pop=True)
    def oortK(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate the Oort function K.

        Parameters
        ----------
        R : float
            Radius at which to calculate K (can be Quantity).
        phi : float, optional
            Azimuth angle (in radians) at which to calculate K.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).

        Returns
        -------
        float or Quantity
            Oort K at R.

        Notes
        -----
        - 2011-04-19 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        # - Could be made more efficient, e.g., surfacemass is calculated multiple times.
        # - We know this is zero, but it is calculated anyway (bug or feature?).
        # 2K= meanvR/R+dmeanvphi/R/dphi+dmeanvR/dR
        meanvr = self.meanvR(
            R, romberg=romberg, nsigma=nsigma, phi=phi, use_physical=False
        )
        dmeanvphiRdphi = 0.0  # We know this, since the DF does not depend on phi
        surfmass = self._vmomentsurfacemass(
            R, 0, 0, phi=phi, romberg=romberg, nsigma=nsigma
        )
        dmeanvRdR = (
            self._vmomentsurfacemass(
                R, 1, 0, deriv=&quot;R&quot;, phi=phi, romberg=romberg, nsigma=nsigma
            )
            / surfmass
        )  # other terms is zero because f is even in vR
        return 0.5 * (+meanvr / R + dmeanvphiRdphi / R + dmeanvRdR)

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigma2(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate sigma_R^2 at R by marginalizing over velocity.

        Parameters
        ----------
        R : float
            Radius at which to calculate sigma_R^2 density.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth angle at which to calculate sigma_R^2 density.

        Returns
        -------
        float or Quantity
            Sigma_R^2 at R.

        Notes
        -----
        - 2010-03-XX - Written - Bovy (NYU)
        &quot;&quot;&quot;

        return self.sigma2surfacemass(
            R, romberg, nsigma, use_physical=False
        ) / self.surfacemass(R, romberg, nsigma, use_physical=False)

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaT2(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate sigma_T^2 at R by marginalizing over velocity

        Parameters
        ----------
        R : float
            Radius at which to calculate sigma_T^2 (can be Quantity)
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        nsigma : int, optional
            Number of sigma to integrate the velocities over
        phi : float, optional
            Azimuth (default: 0.0)

        Returns
        -------
        float or Quantity
            Sigma_T^2 at R

        Notes
        -----
        - 2011-03-30 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        surfmass = self.surfacemass(
            R, romberg=romberg, nsigma=nsigma, use_physical=False
        )
        return (
            self._vmomentsurfacemass(R, 0, 2, romberg=romberg, nsigma=nsigma)
            - self._vmomentsurfacemass(R, 0, 1, romberg=romberg, nsigma=nsigma) ** 2.0
            / surfmass
        ) / surfmass

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaR2(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate sigma_R^2 at R by marginalizing over velocity.

        Parameters
        ----------
        R : float
            Radius at which to calculate sigma_R^2.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth (default: 0.0).

        Returns
        -------
        float or Quantity
            Sigma_R^2 at R.

        Notes
        -----
        - 2011-03-30 - Written - Bovy (NYU).

        &quot;&quot;&quot;
        return self.sigma2(R, romberg=romberg, nsigma=nsigma, use_physical=False)

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def meanvT(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate the mean tangential velocity at a given radius by marginalizing over velocity.

        Parameters
        ----------
        R : float
            Radius at which to calculate the mean tangential velocity.
        romberg : bool, optional
            If True, use a Romberg integrator. Default is False.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth angle at which to calculate the mean tangential velocity.

        Returns
        -------
        float or Quantity
            The mean tangential velocity at the given radius.

        Notes
        -----
        - 2011-03-30 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        return self._vmomentsurfacemass(
            R, 0, 1, romberg=romberg, nsigma=nsigma
        ) / self.surfacemass(R, romberg=romberg, nsigma=nsigma, use_physical=False)

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def meanvR(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate &lt;vR&gt; at R by marginalizing over velocity.

        Parameters
        ----------
        R : float
            Radius at which to calculate &lt;vR&gt;.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth angle at which to calculate &lt;vR&gt;.

        Returns
        -------
        float or Quantity
            &lt;vR&gt; at R.

        Notes
        -----
        - 2011-03-30 - Written - Bovy (NYU).
        &quot;&quot;&quot;

        return self._vmomentsurfacemass(
            R, 1, 0, romberg=romberg, nsigma=nsigma
        ) / self.surfacemass(R, romberg=romberg, nsigma=nsigma, use_physical=False)

    @potential_physical_input
    def skewvT(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate skew in vT at R by marginalizing over velocity

        Parameters
        ----------
        R : float
            Radius at which to calculate &lt;vR&gt;
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        nsigma : float, optional
            Number of sigma to integrate the velocities over
        phi : float, optional
            Azimuth (default: 0.0)

        Returns
        -------
        float
            Skew in vT

        Notes
        -----
        - 2011-12-07 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        surfmass = self.surfacemass(
            R, romberg=romberg, nsigma=nsigma, use_physical=False
        )
        vt = (
            self._vmomentsurfacemass(R, 0, 1, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vt2 = (
            self._vmomentsurfacemass(R, 0, 2, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vt3 = (
            self._vmomentsurfacemass(R, 0, 3, romberg=romberg, nsigma=nsigma) / surfmass
        )
        s2 = vt2 - vt**2.0
        return (vt3 - 3.0 * vt * vt2 + 2.0 * vt**3.0) * s2 ** (-1.5)

    @potential_physical_input
    def skewvR(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate skew in vR at R by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate &lt;vR&gt;.
        romberg : bool, optional
            If True, use a romberg integrator (default: False).
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        phi : float, optional
            Azimuth (in radians) at which to calculate the skew in vR.

        Returns
        -------
        float
            Skew in vR.

        Notes
        -----
        - 2011-12-07 - Written - Bovy (NYU).
        &quot;&quot;&quot;

        surfmass = self.surfacemass(
            R, romberg=romberg, nsigma=nsigma, use_physical=False
        )
        vr = (
            self._vmomentsurfacemass(R, 1, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vr2 = (
            self._vmomentsurfacemass(R, 2, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vr3 = (
            self._vmomentsurfacemass(R, 3, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        s2 = vr2 - vr**2.0
        return (vr3 - 3.0 * vr * vr2 + 2.0 * vr**3.0) * s2 ** (-1.5)

    @potential_physical_input
    def kurtosisvT(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate excess kurtosis in vT at R by marginalizing over velocity

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate &lt;vR&gt;
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        nsigma : float, optional
            Number of sigma to integrate the velocities over
        phi : float, optional
            (default: 0.0)

        Returns
        -------
        float
            kurtosisvT

        Notes
        -----
        - 2011-12-07 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        surfmass = self.surfacemass(
            R, romberg=romberg, nsigma=nsigma, use_physical=False
        )
        vt = (
            self._vmomentsurfacemass(R, 0, 1, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vt2 = (
            self._vmomentsurfacemass(R, 0, 2, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vt3 = (
            self._vmomentsurfacemass(R, 0, 3, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vt4 = (
            self._vmomentsurfacemass(R, 0, 4, romberg=romberg, nsigma=nsigma) / surfmass
        )
        s2 = vt2 - vt**2.0
        return (vt4 - 4.0 * vt * vt3 + 6.0 * vt**2.0 * vt2 - 3.0 * vt**4.0) * s2 ** (
            -2.0
        ) - 3.0

    @potential_physical_input
    def kurtosisvR(self, R, romberg=False, nsigma=None, phi=0.0):
        &quot;&quot;&quot;
        Calculate excess kurtosis in vR at R by marginalizing over velocity

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate &lt;vR&gt;
        romberg : bool, optional
            If True, use a romberg integrator (default: False)
        nsigma : float, optional
            Number of sigma to integrate the velocities over
        phi : float or Quantity, optional
            Azimuth (default: 0.0)

        Returns
        -------
        float
            KurtosisvR

        Notes
        -----
        - 2011-12-07 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        surfmass = self.surfacemass(
            R, romberg=romberg, nsigma=nsigma, use_physical=False
        )
        vr = (
            self._vmomentsurfacemass(R, 1, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vr2 = (
            self._vmomentsurfacemass(R, 2, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vr3 = (
            self._vmomentsurfacemass(R, 3, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        vr4 = (
            self._vmomentsurfacemass(R, 4, 0, romberg=romberg, nsigma=nsigma) / surfmass
        )
        s2 = vr2 - vr**2.0
        return (vr4 - 4.0 * vr * vr3 + 6.0 * vr**2.0 * vr2 - 3.0 * vr**4.0) * s2 ** (
            -2.0
        ) - 3.0

    def _ELtowRRapRperi(self, E, L):
        &quot;&quot;&quot;
        Calculate the radial frequency based on energy and angular momentum and return the pericenter and apocenter radii.

        Parameters
        ----------
        E : float
            Energy.
        L : float
            Angular momentum.

        Returns
        -------
        tuple
            Tuple containing:
            - wR(E.L) : float
                Radial frequency.
            - rap : float
                Apocenter radius.
            - rperi : float
                Pericenter radius.

        Notes
        -----
        - 2010-07-11 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        if self._beta == 0.0:
            xE = numpy.exp(E - 0.5)
        else:  # non-flat rotation curve
            xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
        _, _, rperi, rap = self._aA.EccZmaxRperiRap(
            xE,
            numpy.sqrt(2.0 * (E - self._psp(xE)) - L**2.0 / xE**2.0),
            L / xE,
            0.0,
            0.0,
        )
        return (
            self._aA._aAS.actionsFreqs(xE, 0.0, L / xE, 0.0, 0.0)[3][0],
            rap[0],
            rperi[0],
        )

    def sample(
        self,
        n=1,
        rrange=None,
        returnROrbit=True,
        returnOrbit=False,
        nphi=1.0,
        los=None,
        losdeg=True,
        nsigma=None,
        maxd=None,
        target=True,
    ):
        &quot;&quot;&quot;
        Sample n*nphi points from this disk DF.

        Parameters
        ----------
        n : int, optional
            Number of desired samples. Default is 1.
        rrange : list, optional
            If you only want samples in this rrange, set this keyword (only works when asking for an (RZ)Orbit).
        returnROrbit : bool, optional
            If True, return a planarROrbit instance: [R,vR,vT] (default).
        returnOrbit : bool, optional
            If True, return a planarOrbit instance (including phi).
        nphi : float, optional
            Number of azimuths to sample for each E,L.
        los : float, optional
            Line of sight sampling along this line of sight.
        losdeg : bool, optional
            If True, los is in degrees (default).
        nsigma : int, optional
            Number of sigma to rejection-sample on.
        maxd : float, optional
            Maximum distance to consider (for the rejection sampling).
        target : bool, optional
            If True, use target surface mass and sigma2 profiles (default).

        Returns
        -------
        list
            n*nphi list of [[E,Lz],...] or list of planar(R)Orbits.
            CAUTION: lists of EL need to be post-processed to account for the
                    \\kappa/\\omega_R discrepancy

        Notes
        -----
        - 2010-07-10 - Started  - Bovy (NYU)

        &quot;&quot;&quot;
        raise NotImplementedError(&quot;'sample' method for this disk df is not implemented&quot;)

    def _estimatemeanvR(self, R, phi=0.0, log=False):
        &quot;&quot;&quot;
        Quickly estimate the mean radial velocity at a given radius R.

        Parameters
        ----------
        R : float
            Radius at which to evaluate (/ro).
        phi : float, optional
            Azimuth angle (not used).
        log : bool, optional
            If True, return the logarithm of the target Sigma_R^2(R).

        Returns
        -------
        float
            The target Sigma_R^2(R).

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        return 0.0

    def _estimatemeanvT(self, R, phi=0.0, log=False):
        &quot;&quot;&quot;
        Quickly estimate the mean tangential velocity at a given radius.

        Parameters
        ----------
        R : float
            Radius at which to evaluate (/ro).
        phi : float, optional
            Azimuth angle (not used).
        log : bool, optional
            If True, return the logarithm of the estimate.

        Returns
        -------
        float
            The estimated mean tangential velocity.

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        return R**self._beta - self.asymmetricdrift(R, use_physical=False)

    def _estimateSigmaR2(self, R, phi=0.0, log=False):
        &quot;&quot;&quot;
        Quickly estimate SigmaR2.

        Parameters
        ----------
        R : float
            Radius at which to evaluate (/ro).
        phi : float, optional
            Azimuth (not used).
        log : bool, optional
            If True, return the log (default: False).

        Returns
        -------
        float
            Target Sigma_R^2(R).

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        return self.targetSigma2(R, log=log, use_physical=False)

    def _estimateSigmaT2(self, R, phi=0.0, log=False):
        &quot;&quot;&quot;
        Quickly estimate SigmaT2.

        Parameters
        ----------
        R : float
            Radius at which to evaluate (/ro).
        phi : float, optional
            Azimuth (not used).
        log : bool, optional
            If True, return the log (default: False).

        Returns
        -------
        float
            Target Sigma_R^2(R).

        Notes
        -----
        - 2010-03-28 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        if log:
            return self.targetSigma2(R, log=log, use_physical=False) - 2.0 * numpylog(
                self._gamma
            )
        else:
            return self.targetSigma2(R, log=log, use_physical=False) / self._gamma**2.0


class dehnendf(diskdf):
    &quot;&quot;&quot;Dehnen's 'new' df&quot;&quot;&quot;

    def __init__(
        self,
        surfaceSigma=expSurfaceSigmaProfile,
        profileParams=(1.0 / 3.0, 1.0, 0.2),
        correct=False,
        beta=0.0,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Initialize a Dehnen 'new' DF.

        Parameters
        ----------
        surfaceSigma : instance or class name of the target surface density and sigma_R profile, optional
            Default: both exponential.
        profileParams : tuple, optional
            Parameters of the surface and sigma_R profile: (xD,xS,Sro) where:
                * xD - disk surface mass scalelength (can be Quantity)
                * xS - disk velocity dispersion scalelength (can be Quantity)
                * Sro - disk velocity dispersion at Ro (can be Quantity)
            Directly given to the 'surfaceSigmaProfile class, so could be anything that class takes.
        beta : float, optional
            Power-law index of the rotation curve.
        correct : bool, optional
            If True, correct the DF.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        **kwargs: dict, optional
            DFcorrection kwargs (except for those already specified).

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        return diskdf.__init__(
            self,
            surfaceSigma=surfaceSigma,
            profileParams=profileParams,
            correct=correct,
            dftype=&quot;dehnen&quot;,
            beta=beta,
            **kwargs,
        )

    def eval(self, E, L, logSigmaR=0.0, logsigmaR2=0.0):
        &quot;&quot;&quot;
        Evaluate the distribution function.

        Parameters
        ----------
        E : float or Quantity
            Energy.
        L : float or Quantity
            Angular momentum.
        logSigmaR : float, optional
            Logarithm of the radial velocity dispersion.
        logsigmaR2 : float, optional
            Logarithm of the square of the radial velocity dispersion.

        Returns
        -------
        float
            DF(E,L)

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU).
        - 2010-03-28 - Moved to dehnenDF - Bovy (NYU).
        &quot;&quot;&quot;
        if _PROFILE:  # pragma: no cover
            import time

            start = time.time()
        E = conversion.parse_energy(E, vo=self._vo)
        L = conversion.parse_angmom(L, ro=self._ro, vo=self._vo)
        # Calculate Re,LE, OmegaE
        if self._beta == 0.0:
            xE = numpy.exp(E - 0.5)
            logOLLE = numpylog(L / xE - 1.0)
        else:  # non-flat rotation curve
            xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
            logOLLE = self._beta * numpylog(xE) + numpylog(L / xE - xE**self._beta)
        if _PROFILE:  # pragma: no cover
            one_time = time.time() - start
            start = time.time()
        if self._correct:
            correction = self._corr.correct(xE, log=True)
        else:
            correction = numpy.zeros(2)
        if _PROFILE:  # pragma: no cover
            corr_time = time.time() - start
            start = time.time()
        SRE2 = self.targetSigma2(xE, log=True, use_physical=False) + correction[1]
        if _PROFILE:  # pragma: no cover
            targSigma_time = time.time() - start
            start = time.time()
            out = (
                self._gamma
                * numpy.exp(
                    logsigmaR2
                    - SRE2
                    + self.targetSurfacemass(xE, log=True, use_physical=False)
                    - logSigmaR
                    + numpy.exp(logOLLE - SRE2)
                    + correction[0]
                )
                / 2.0
                / numpy.pi
            )
            out_time = time.time() - start
            tot_time = one_time + corr_time + targSigma_time + out_time
            print(
                one_time / tot_time,
                corr_time / tot_time,
                targSigma_time / tot_time,
                out_time / tot_time,
                tot_time,
            )
            return out
        else:
            return (
                self._gamma
                * numpy.exp(
                    logsigmaR2
                    - SRE2
                    + self.targetSurfacemass(xE, log=True, use_physical=False)
                    - logSigmaR
                    + numpy.exp(logOLLE - SRE2)
                    + correction[0]
                )
                / 2.0
                / numpy.pi
            )

    def sample(
        self,
        n=1,
        rrange=None,
        returnROrbit=True,
        returnOrbit=False,
        nphi=1.0,
        los=None,
        losdeg=True,
        nsigma=None,
        targetSurfmass=True,
        targetSigma2=True,
        maxd=None,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Sample n*nphi points from this DF.

        Parameters
        ----------
        n : int, optional
            Number of desired samples (specifying this rather than calling
            this routine n times is more efficient). Default is 1.
        rrange : list or tuple, optional
            If you only want samples in this rrange, set this keyword
            (only works when asking for an (RZ)Orbit). Default is None.
        returnROrbit : bool, optional
            If True, return a planarROrbit instance: [R,vR,vT] (default).
            Default is True.
        returnOrbit : bool, optional
            If True, return a planarOrbit instance (including phi).
            Default is False.
        nphi : float, optional
            Number of azimuths to sample for each E,L. Default is 1.0.
        los : float or Quantity, optional
            If set, sample along this line of sight (deg) (assumes that the Sun is located at R=1,phi=0).
            Default is None.
        losdeg : bool, optional
            If False, los is in radians (default=True). Default is True.
        nsigma : int, optional
            Number of sigma to rejection-sample on. Default is None.
        targetSurfmass : bool, optional
            If True, use target surface mass profile. Default is True.
        targetSigma2 : bool, optional
            If True, use target sigma2 profile. Default is True.
        maxd : float or Quantity, optional
            Maximum distance to consider (for the rejection sampling). Default is None.
        **kwargs : dict, optional
            Additional keyword arguments.

        Returns
        -------
        out : list
            n*nphi list of [[E,Lz],...] or list of planar(R)Orbits.
            CAUTION: lists of EL need to be post-processed to account for the
            \\kappa/\\omega_R discrepancy; EL not returned in physical units.

        Notes
        -----
        - 2010-07-10 - Started  - Bovy (NYU)
        &quot;&quot;&quot;
        if not los is None:
            return self.sampleLOS(
                los,
                deg=losdeg,
                n=n,
                maxd=maxd,
                nsigma=nsigma,
                targetSurfmass=targetSurfmass,
                targetSigma2=targetSigma2,
            )
        # First sample xE
        if self._correct:
            xE = numpy.array(
                ars(
                    [0.0, 0.0],
                    [True, False],
                    [0.05, 2.0],
                    _ars_hx,
                    _ars_hpx,
                    nsamples=n,
                    hxparams=(self._surfaceSigmaProfile, self._corr),
                )
            )
        else:
            xE = numpy.array(
                ars(
                    [0.0, 0.0],
                    [True, False],
                    [0.05, 2.0],
                    _ars_hx,
                    _ars_hpx,
                    nsamples=n,
                    hxparams=(self._surfaceSigmaProfile, None),
                )
            )
        # Calculate E
        if self._beta == 0.0:
            E = numpylog(xE) + 0.5
        else:  # non-flat rotation curve
            E = 0.5 * xE ** (2.0 * self._beta) * (1.0 + 1.0 / self._beta)
        # Then sample Lz
        LCE = xE ** (self._beta + 1.0)
        OR = xE ** (self._beta - 1.0)
        Lz = (
            self._surfaceSigmaProfile.sigma2(xE)
            * numpylog(stats.uniform.rvs(size=n))
            / OR
        )
        if self._correct:
            Lz *= self._corr.correct(xE, log=False)[1, :]
        Lz += LCE
        if not returnROrbit and not returnOrbit:
            out = [[e, l] for e, l in zip(E, Lz)]
        else:
            if not rrange is None:
                rrange[0] = conversion.parse_length(rrange[0], ro=self._ro)
                rrange[1] = conversion.parse_length(rrange[1], ro=self._ro)
            out = []
            for ii in range(int(n)):
                try:
                    wR, rap, rperi = self._ELtowRRapRperi(E[ii], Lz[ii])
                except ValueError:  # pragma: no cover
                    # Tests don't get here anymore, because of improvements
                    # in the rperi/rap calculation, but leaving the try/except
                    # in because it can do no harm
                    continue
                TR = 2.0 * numpy.pi / wR
                tr = stats.uniform.rvs() * TR
                if tr &gt; TR / 2.0:
                    tr -= TR / 2.0
                    thisOrbit = Orbit([rperi, 0.0, Lz[ii] / rperi])
                else:
                    thisOrbit = Orbit([rap, 0.0, Lz[ii] / rap])
                thisOrbit.integrate(numpy.array([0.0, tr]), self._psp)
                if returnOrbit:
                    vxvv = thisOrbit(tr).vxvv[0]
                    thisOrbit = Orbit(
                        vxvv=numpy.array(
                            [
                                vxvv[0],
                                vxvv[1],
                                vxvv[2],
                                stats.uniform.rvs() * numpy.pi * 2.0,
                            ]
                        ).reshape(4)
                    )
                else:
                    thisOrbit = thisOrbit(tr)
                kappa = _kappa(thisOrbit.vxvv[0, 0], self._beta)
                if not rrange == None:
                    if (
                        thisOrbit.vxvv[0, 0] &lt; rrange[0]
                        or thisOrbit.vxvv[0, 0] &gt; rrange[1]
                    ):
                        continue
                mult = numpy.ceil(kappa / wR * nphi) - 1.0
                kappawR = kappa / wR * nphi - mult
                while mult &gt; 0:
                    if returnOrbit:
                        out.append(
                            Orbit(
                                vxvv=numpy.array(
                                    [
                                        vxvv[0],
                                        vxvv[1],
                                        vxvv[2],
                                        stats.uniform.rvs() * numpy.pi * 2.0,
                                    ]
                                ).reshape(4)
                            )
                        )
                    else:
                        out.append(thisOrbit)
                    mult -= 1
                if stats.uniform.rvs() &gt; kappawR:
                    continue
                out.append(thisOrbit)
        # Recurse to get enough
        if len(out) &lt; n * nphi:
            out.extend(
                self.sample(
                    n=int(n - len(out) / nphi),
                    rrange=rrange,
                    returnROrbit=returnROrbit,
                    returnOrbit=returnOrbit,
                    nphi=int(nphi),
                    los=los,
                    losdeg=losdeg,
                )
            )
        # Trim to make sure output has the right size
        out = out[0 : int(n * nphi)]
        if kwargs.get(&quot;use_physical&quot;, True) and self._roSet and self._voSet:
            if isinstance(out[0], Orbit):
                dumb = [o.turn_physical_on(ro=self._ro, vo=self._vo) for o in out]
        return out

    def _dlnfdR(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        if self._beta == 0.0:
            E = vR**2.0 / 2.0 + vT**2.0 / 2.0 + numpylog(R)
            xE = numpy.exp(E - 0.5)
            OE = xE**-1.0
            LCE = xE
            dRedR = xE / R
        else:  # non-flat rotation curve
            E = (
                vR**2.0 / 2.0
                + vT**2.0 / 2.0
                + 1.0 / 2.0 / self._beta * R ** (2.0 * self._beta)
            )
            xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
            OE = xE ** (self._beta - 1.0)
            LCE = xE ** (self._beta + 1.0)
            dRedR = xE / 2.0 / self._beta / E * R ** (2.0 * self._beta - 1.0)
        return (
            self._dlnfdRe(R, vR, vT, E=E, xE=xE, OE=OE, LCE=LCE) * dRedR
            + self._dlnfdl(R, vR, vT, E=E, xE=xE, OE=OE) * vT
        )

    def _dlnfdvR(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        if self._beta == 0.0:
            E = vR**2.0 / 2.0 + vT**2.0 / 2.0 + numpylog(R)
            xE = numpy.exp(E - 0.5)
            OE = xE**-1.0
            LCE = xE
            dRedvR = xE * vR
        else:  # non-flat rotation curve
            E = (
                vR**2.0 / 2.0
                + vT**2.0 / 2.0
                + 1.0 / 2.0 / self._beta * R ** (2.0 * self._beta)
            )
            xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
            OE = xE ** (self._beta - 1.0)
            LCE = xE ** (self._beta + 1.0)
            dRedvR = xE / 2.0 / self._beta / E * vR
        return self._dlnfdRe(R, vR, vT, E=E, xE=xE, OE=OE, LCE=LCE) * dRedvR

    def _dlnfdvT(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        if self._beta == 0.0:
            E = vR**2.0 / 2.0 + vT**2.0 / 2.0 + numpylog(R)
            xE = numpy.exp(E - 0.5)
            OE = xE**-1.0
            LCE = xE
            dRedvT = xE * vT
        else:  # non-flat rotation curve
            E = (
                vR**2.0 / 2.0
                + vT**2.0 / 2.0
                + 1.0 / 2.0 / self._beta * R ** (2.0 * self._beta)
            )
            xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
            OE = xE ** (self._beta - 1.0)
            LCE = xE ** (self._beta + 1.0)
            dRedvT = xE / 2.0 / self._beta / E * vT
        return (
            self._dlnfdRe(R, vR, vT, E=E, xE=xE, OE=OE, LCE=LCE) * dRedvT
            + self._dlnfdl(R, vR, vT, E=E, xE=xE, OE=OE) * R
        )

    def _dlnfdRe(self, R, vR, vT, E=None, xE=None, OE=None, LCE=None):
        &quot;&quot;&quot;d ln f(x,v) / d R_e&quot;&quot;&quot;
        # Calculate a bunch of stuff that we need
        if E is None or xE is None or OE is None or LCE is None:
            if self._beta == 0.0:
                E = vR**2.0 / 2.0 + vT**2.0 / 2.0 + numpylog(R)
                xE = numpy.exp(E - 0.5)
                OE = xE**-1.0
                LCE = xE
            else:  # non-flat rotation curve
                E = (
                    vR**2.0 / 2.0
                    + vT**2.0 / 2.0
                    + 1.0 / 2.0 / self._beta * R ** (2.0 * self._beta)
                )
                xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
                OE = xE ** (self._beta - 1.0)
                LCE = xE ** (self._beta + 1.0)
        L = R * vT
        sigma2xE = self._surfaceSigmaProfile.sigma2(xE, log=False)
        return (
            self._surfaceSigmaProfile.surfacemassDerivative(xE, log=True)
            - (1.0 + OE * (L - LCE) / sigma2xE)
            * self._surfaceSigmaProfile.sigma2Derivative(xE, log=True)
            + (L - LCE) / sigma2xE * (self._beta - 1.0) * xE ** (self._beta - 2.0)
            - OE * (self._beta + 1.0) / sigma2xE * xE**self._beta
        )

    def _dlnfdl(self, R, vR, vT, E=None, xE=None, OE=None):
        # Calculate a bunch of stuff that we need
        if E is None or xE is None or OE is None:
            if self._beta == 0.0:
                E = vR**2.0 / 2.0 + vT**2.0 / 2.0 + numpylog(R)
                xE = numpy.exp(E - 0.5)
                OE = xE**-1.0
            else:  # non-flat rotation curve
                E = (
                    vR**2.0 / 2.0
                    + vT**2.0 / 2.0
                    + 1.0 / 2.0 / self._beta * R ** (2.0 * self._beta)
                )
                xE = (2.0 * E / (1.0 + 1.0 / self._beta)) ** (1.0 / 2.0 / self._beta)
                OE = xE ** (self._beta - 1.0)
        sigma2xE = self._surfaceSigmaProfile.sigma2(xE, log=False)
        return OE / sigma2xE


class shudf(diskdf):
    &quot;&quot;&quot;Shu's df (1969)&quot;&quot;&quot;

    def __init__(
        self,
        surfaceSigma=expSurfaceSigmaProfile,
        profileParams=(1.0 / 3.0, 1.0, 0.2),
        correct=False,
        beta=0.0,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Initialize a Shu DF.

        Parameters
        ----------
        surfaceSigma : instance or class name of the target surface density and sigma_R profile, optional
            Default: both exponential.
        profileParams : tuple, optional
            Parameters of the surface and sigma_R profile: (xD,xS,Sro) where
                * xD - disk surface mass scalelength (can be Quantity)
                * xS - disk velocity dispersion scalelength (can be Quantity)
                * Sro - disk velocity dispersion at Ro (can be Quantity)
            Directly given to the 'surfaceSigmaProfile class, so could be anything that class takes.
        beta : float, optional
            Power-law index of the rotation curve.
        correct : bool, optional
            If True, correct the DF.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        **kwargs: dict, optional
            DFcorrection kwargs (except for those already specified).

        Notes
        -----
        - 2010-05-09 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        return diskdf.__init__(
            self,
            surfaceSigma=surfaceSigma,
            profileParams=profileParams,
            correct=correct,
            dftype=&quot;shu&quot;,
            beta=beta,
            **kwargs,
        )

    def eval(self, E, L, logSigmaR=0.0, logsigmaR2=0.0):
        &quot;&quot;&quot;
        Evaluate the distribution function.

        Parameters
        ----------
        E : float
            Energy (/vo^2).
        L : float
            Angular momentum (/ro/vo).
        logSigmaR : float, optional
            Logarithm of the radial velocity dispersion squared.
        logsigmaR2 : float, optional
            Logarithm of the radial velocity dispersion squared.

        Returns
        -------
        float
            DF(E,L).

        Notes
        -----
        - 2010-05-09 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        E = conversion.parse_energy(E, vo=self._vo)
        L = conversion.parse_angmom(L, ro=self._ro, vo=self._vo)
        # Calculate RL,LL, OmegaL
        if self._beta == 0.0:
            xL = L
            logECLE = numpylog(-numpylog(xL) - 0.5 + E)
        else:  # non-flat rotation curve
            xL = L ** (1.0 / (self._beta + 1.0))
            logECLE = numpylog(
                -0.5 * (1.0 / self._beta + 1.0) * xL ** (2.0 * self._beta) + E
            )
        if xL &lt; 0.0:  # We must remove counter-rotating mass
            return 0.0
        if self._correct:
            correction = self._corr.correct(xL, log=True)
        else:
            correction = numpy.zeros(2)
        SRE2 = self.targetSigma2(xL, log=True, use_physical=False) + correction[1]
        return (
            self._gamma
            * numpy.exp(
                logsigmaR2
                - SRE2
                + self.targetSurfacemass(xL, log=True, use_physical=False)
                - logSigmaR
                - numpy.exp(logECLE - SRE2)
                + correction[0]
            )
            / 2.0
            / numpy.pi
        )

    def sample(
        self,
        n=1,
        rrange=None,
        returnROrbit=True,
        returnOrbit=False,
        nphi=1.0,
        los=None,
        losdeg=True,
        nsigma=None,
        maxd=None,
        targetSurfmass=True,
        targetSigma2=True,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Sample n*nphi points from this DF.

        Parameters
        ----------
        n : int, optional
            Number of desired samples (specifying this rather than calling
            this routine n times is more efficient). Default is 1.
        rrange : list or tuple, optional
            If you only want samples in this rrange, set this keyword
            (only works when asking for an (RZ)Orbit). Default is None.
        returnROrbit : bool, optional
            If True, return a planarROrbit instance: [R,vR,vT] (default).
            Default is True.
        returnOrbit : bool, optional
            If True, return a planarOrbit instance (including phi).
            Default is False.
        nphi : float, optional
            Number of azimuths to sample for each E,L. Default is 1.0.
        los : float or Quantity, optional
            If set, sample along this line of sight (deg) (assumes that the Sun is located at R=1,phi=0).
            Default is None.
        losdeg : bool, optional
            If False, los is in radians (default=True). Default is True.
        nsigma : int, optional
            Number of sigma to rejection-sample on. Default is None.
        targetSurfmass : bool, optional
            If True, use target surface mass profile. Default is True.
        targetSigma2 : bool, optional
            If True, use target sigma2 profile. Default is True.
        maxd : float or Quantity, optional
            Maximum distance to consider (for the rejection sampling). Default is None.
        **kwargs : dict, optional
            Additional keyword arguments.

        Returns
        -------
        out : list
            n*nphi list of [[E,Lz],...] or list of planar(R)Orbits.
            CAUTION: lists of EL need to be post-processed to account for the
            \\kappa/\\omega_R discrepancy; EL not returned in physical units.

        Notes
        -----
        - 2010-07-10 - Started  - Bovy (NYU)
        &quot;&quot;&quot;
        if not los is None:
            return self.sampleLOS(
                los,
                n=n,
                maxd=maxd,
                nsigma=nsigma,
                targetSurfmass=targetSurfmass,
                targetSigma2=targetSigma2,
            )
        # First sample xL
        if self._correct:
            xL = numpy.array(
                ars(
                    [0.0, 0.0],
                    [True, False],
                    [0.05, 2.0],
                    _ars_hx,
                    _ars_hpx,
                    nsamples=n,
                    hxparams=(self._surfaceSigmaProfile, self._corr),
                )
            )
        else:
            xL = numpy.array(
                ars(
                    [0.0, 0.0],
                    [True, False],
                    [0.05, 2.0],
                    _ars_hx,
                    _ars_hpx,
                    nsamples=n,
                    hxparams=(self._surfaceSigmaProfile, None),
                )
            )
        # Calculate Lz
        Lz = xL ** (self._beta + 1.0)
        # Then sample E
        if self._beta == 0.0:
            ECL = numpylog(xL) + 0.5
        else:
            ECL = 0.5 * (1.0 / self._beta + 1.0) * xL ** (2.0 * self._beta)
        E = -self._surfaceSigmaProfile.sigma2(xL) * numpylog(stats.uniform.rvs(size=n))
        if self._correct:
            E *= self._corr.correct(xL, log=False)[1, :]
        E += ECL
        if not returnROrbit and not returnOrbit:
            out = [[e, l] for e, l in zip(E, Lz)]
        else:
            if not rrange is None:
                rrange[0] = conversion.parse_length(rrange[0], ro=self._ro)
                rrange[1] = conversion.parse_length(rrange[1], ro=self._ro)
            out = []
            for ii in range(n):
                try:
                    wR, rap, rperi = self._ELtowRRapRperi(E[ii], Lz[ii])
                except ValueError:  # pragma: no cover
                    continue
                TR = 2.0 * numpy.pi / wR
                tr = stats.uniform.rvs() * TR
                if tr &gt; TR / 2.0:
                    tr -= TR / 2.0
                    thisOrbit = Orbit([rperi, 0.0, Lz[ii] / rperi])
                else:
                    thisOrbit = Orbit([rap, 0.0, Lz[ii] / rap])
                thisOrbit.integrate(numpy.array([0.0, tr]), self._psp)
                if returnOrbit:
                    vxvv = thisOrbit(tr).vxvv[0]
                    thisOrbit = Orbit(
                        vxvv=numpy.array(
                            [
                                vxvv[0],
                                vxvv[1],
                                vxvv[2],
                                stats.uniform.rvs() * numpy.pi * 2.0,
                            ]
                        ).reshape(4)
                    )
                else:
                    thisOrbit = thisOrbit(tr)
                kappa = _kappa(thisOrbit.vxvv[0, 0], self._beta)
                if not rrange == None:
                    if (
                        thisOrbit.vxvv[0, 0] &lt; rrange[0]
                        or thisOrbit.vxvv[0, 0] &gt; rrange[1]
                    ):
                        continue
                mult = numpy.ceil(kappa / wR * nphi) - 1.0
                kappawR = kappa / wR * nphi - mult
                while mult &gt; 0:
                    if returnOrbit:
                        out.append(
                            Orbit(
                                vxvv=numpy.array(
                                    [
                                        vxvv[0],
                                        vxvv[1],
                                        vxvv[2],
                                        stats.uniform.rvs() * numpy.pi * 2.0,
                                    ]
                                ).reshape(4)
                            )
                        )
                    else:
                        out.append(thisOrbit)
                    mult -= 1
                if stats.uniform.rvs() &gt; kappawR:
                    continue
                out.append(thisOrbit)
        # Recurse to get enough
        if len(out) &lt; n * nphi:
            out.extend(
                self.sample(
                    n=int(n - len(out) / nphi),
                    rrange=rrange,
                    returnROrbit=returnROrbit,
                    returnOrbit=returnOrbit,
                    nphi=nphi,
                )
            )
        # Trim to make sure output has the right size
        out = out[0 : int(n * nphi)]
        if kwargs.get(&quot;use_physical&quot;, True) and self._roSet and self._voSet:
            if isinstance(out[0], Orbit):
                dumb = [o.turn_physical_on(ro=self._ro, vo=self._vo) for o in out]
        return out

    def _dlnfdR(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        E, L = vRvTRToEL(vR, vT, R, self._beta, self._dftype)
        if self._beta == 0.0:
            xL = L
            dRldR = vT
            ECL = numpylog(xL) + 0.5
            dECLEdR = 0.0
        else:  # non-flat rotation curve
            xL = L ** (1.0 / (self._beta + 1.0))
            dRldR = L ** (1.0 / (self._beta + 1.0)) / R / (self._beta + 1.0)
            ECL = 0.5 * (1.0 / self._beta + 1.0) * xL ** (2.0 * self._beta)
            dECLdRl = (1.0 + self._beta) * xL ** (2.0 * self._beta - 1)
            dEdR = R ** (2.0 * self._beta - 1.0)
            dECLEdR = dECLdRl * dRldR - dEdR
        sigma2xL = self._surfaceSigmaProfile.sigma2(xL, log=False)
        return (
            self._surfaceSigmaProfile.surfacemassDerivative(xL, log=True)
            - (1.0 + (ECL - E) / sigma2xL)
            * self._surfaceSigmaProfile.sigma2Derivative(xL, log=True)
        ) * dRldR + dECLEdR / sigma2xL

    def _dlnfdvR(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        E, L = vRvTRToEL(vR, vT, R, self._beta, self._dftype)
        if self._beta == 0.0:
            xL = L
        else:  # non-flat rotation curve
            xL = L ** (1.0 / (self._beta + 1.0))
        sigma2xL = self._surfaceSigmaProfile.sigma2(xL, log=False)
        return -vR / sigma2xL

    def _dlnfdvT(self, R, vR, vT):
        # Calculate a bunch of stuff that we need
        E, L = vRvTRToEL(vR, vT, R, self._beta, self._dftype)
        if self._beta == 0.0:
            xL = L
            dRldvT = R
            ECL = numpylog(xL) + 0.5
            dECLEdvT = 1.0 / vT - vT
        else:  # non-flat rotation curve
            xL = L ** (1.0 / (self._beta + 1.0))
            dRldvT = L ** (1.0 / (self._beta + 1.0)) / vT / (self._beta + 1.0)
            ECL = 0.5 * (1.0 / self._beta + 1.0) * xL ** (2.0 * self._beta)
            dECLdRl = (1.0 + self._beta) * xL ** (2.0 * self._beta - 1)
            dEdvT = vT
            dECLEdvT = dECLdRl * dRldvT - dEdvT
        sigma2xL = self._surfaceSigmaProfile.sigma2(xL, log=False)
        return (
            self._surfaceSigmaProfile.surfacemassDerivative(xL, log=True)
            - (1.0 + (ECL - E) / sigma2xL)
            * self._surfaceSigmaProfile.sigma2Derivative(xL, log=True)
        ) * dRldvT + dECLEdvT / sigma2xL


class schwarzschilddf(shudf):
    &quot;&quot;&quot;Schwarzschild's df&quot;&quot;&quot;

    def __init__(
        self,
        surfaceSigma=expSurfaceSigmaProfile,
        profileParams=(1.0 / 3.0, 1.0, 0.2),
        correct=False,
        beta=0.0,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Initialize a Schwarzschild DF.

        Parameters
        ----------
        surfaceSigma : instance or class name of the target surface density and sigma_R profile, optional
            (default: both exponential)
        profileParams : tuple, optional
            Parameters of the surface and sigma_R profile: (xD,xS,Sro) where
                * xD - disk surface mass scalelength (can be Quantity)
                * xS - disk velocity dispersion scalelength (can be Quantity)
                * Sro - disk velocity dispersion at Ro (can be Quantity)
            Directly given to the 'surfaceSigmaProfile class, so could be anything that class takes
        beta : float, optional
            Power-law index of the rotation curve
        correct : bool, optional
            If True, correct the DF
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        **kwargs : dict, optional
            DFcorrection kwargs (except for those already specified)

        Notes
        -----
        - 2017-09-17 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        # Schwarzschild == Shu w/ energy computed in epicycle approx.
        # so all functions are the same as in Shu, only thing different is
        # how E is computed
        return diskdf.__init__(
            self,
            surfaceSigma=surfaceSigma,
            profileParams=profileParams,
            correct=correct,
            dftype=&quot;schwarzschild&quot;,
            beta=beta,
            **kwargs,
        )


def _surfaceIntegrand(vR, vT, R, df, logSigmaR, logsigmaR2, sigmaR1, gamma):
    &quot;&quot;&quot;Internal function that is the integrand for the surface mass integration&quot;&quot;&quot;
    E, L = _vRpvTpRToEL(vR, vT, R, df._beta, sigmaR1, gamma, df._dftype)
    return df.eval(E, L, logSigmaR, logsigmaR2) * 2.0 * numpy.pi / df._gamma  # correct


def _sigma2surfaceIntegrand(vR, vT, R, df, logSigmaR, logsigmaR2, sigmaR1, gamma):
    &quot;&quot;&quot;Internal function that is the integrand for the sigma-squared times
    surface mass integration&quot;&quot;&quot;
    E, L = _vRpvTpRToEL(vR, vT, R, df._beta, sigmaR1, gamma, df._dftype)
    return (
        vR**2.0 * df.eval(E, L, logSigmaR, logsigmaR2) * 2.0 * numpy.pi / df._gamma
    )  # correct


def _vmomentsurfaceIntegrand(
    vR, vT, R, df, logSigmaR, logsigmaR2, sigmaR1, gamma, n, m
):
    &quot;&quot;&quot;Internal function that is the integrand for the velocity moment times
    surface mass integration&quot;&quot;&quot;
    E, L = _vRpvTpRToEL(vR, vT, R, df._beta, sigmaR1, gamma, df._dftype)
    return (
        vR**n
        * vT**m
        * df.eval(E, L, logSigmaR, logsigmaR2)
        * 2.0
        * numpy.pi
        / df._gamma
    )  # correct


def _vmomentderivsurfaceIntegrand(
    vR, vT, R, df, logSigmaR, logsigmaR2, sigmaR1, gamma, n, m, deriv
):
    &quot;&quot;&quot;Internal function that is the integrand for the derivative of velocity
    moment times surface mass integration&quot;&quot;&quot;
    E, L = _vRpvTpRToEL(vR, vT, R, df._beta, sigmaR1, gamma, df._dftype)
    if deriv.lower() == &quot;r&quot;:
        return (
            vR**n
            * vT**m
            * df.eval(E, L, logSigmaR, logsigmaR2)
            * 2.0
            * numpy.pi
            / df._gamma
            * df._dlnfdR(R, vR * sigmaR1, vT * sigmaR1 / gamma)
        )  # correct
    else:
        return 0.0


def _vRpvTpRToEL(vR, vT, R, beta, sigmaR1, gamma, dftype=&quot;dehnen&quot;):
    &quot;&quot;&quot;Internal function that calculates E and L given velocities normalized by the velocity dispersion&quot;&quot;&quot;
    vR *= sigmaR1
    vT *= sigmaR1 / gamma
    return vRvTRToEL(vR, vT, R, beta, dftype)


def _oned_intFunc(x, twodfunc, gfun, hfun, tol, args):
    &quot;&quot;&quot;Internal function for bovy_dblquad&quot;&quot;&quot;
    thisargs = copy.deepcopy(args)
    thisargs.insert(0, x)
    return quadpack.romberg(twodfunc, gfun(x), hfun(x), args=thisargs, tol=tol)


def bovy_dblquad(func, a, b, gfun, hfun, args=(), tol=1.48e-08):
    &quot;&quot;&quot;
    Compute a double integral using Romberg integration for the one-dimensional integrals and a specified tolerance.

    Parameters
    ----------
    func : callable
        Function of two variables to integrate.
    a : float
        Lower limit of integration in the outer integral.
    b : float
        Upper limit of integration in the outer integral.
    gfun : callable
        Function of one variable that returns the lower limit of integration in the inner integral for a given value of the outer variable.
    hfun : callable
        Function of one variable that returns the upper limit of integration in the inner integral for a given value of the outer variable.
    args : tuple, optional
        Extra arguments to pass to the integrand function.
    tol : float, optional
        Desired absolute tolerance.

    Returns
    -------
    float
        The value of the double integral.

    Notes
    -----
    - 2010-03-11 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    return quadpack.romberg(
        _oned_intFunc, a, b, args=(func, gfun, hfun, tol, args), tol=tol
    )


class DFcorrection:
    &quot;&quot;&quot;Class that contains the corrections necessary to reach
    exponential profiles&quot;&quot;&quot;

    def __init__(self, **kwargs):
        &quot;&quot;&quot;
        Initialize the corrections: set them, load them, or calculate and save them.

        Parameters
        ----------
        corrections : numpy.ndarray, optional
            If set, these are the corrections and they should be used as such.
        npoints : int, optional
            Number of points from 0 to Rmax.
        rmax : float, optional
            Correct up to this radius (/ro) (default: 5).
        savedir : str, optional
            Save the corrections in this directory.
        surfaceSigmaProfile : object
            Target surfacemass and sigma_R^2 instance.
        beta : float, optional
            Power-law index of the rotation curve (when calculating).
        dftype : class, optional
            Classname of the DF.
        niter : int, optional
            Number of iterations to perform to calculate the corrections.
        interp_k : str, optional
            'k' keyword to give to InterpolatedUnivariateSpline.

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU)

        &quot;&quot;&quot;
        if not &quot;surfaceSigmaProfile&quot; in kwargs:
            raise DFcorrectionError(&quot;surfaceSigmaProfile not given&quot;)
        else:
            self._surfaceSigmaProfile = kwargs[&quot;surfaceSigmaProfile&quot;]
        self._rmax = kwargs.get(&quot;rmax&quot;, 5.0)
        self._niter = kwargs.get(&quot;niter&quot;, 20)
        if not &quot;npoints&quot; in kwargs:
            if &quot;corrections&quot; in kwargs:
                self._npoints = kwargs[&quot;corrections&quot;].shape[0]
            else:  # pragma: no cover
                self._npoints = 151  # would take too long to cover
        else:
            self._npoints = kwargs[&quot;npoints&quot;]
        self._dftype = kwargs.get(&quot;dftype&quot;, dehnendf)
        self._beta = kwargs.get(&quot;beta&quot;, 0.0)
        self._rs = numpy.linspace(_RMIN, self._rmax, self._npoints)
        self._interp_k = kwargs.get(&quot;interp_k&quot;, _INTERPDEGREE)
        if &quot;corrections&quot; in kwargs:
            self._corrections = kwargs[&quot;corrections&quot;]
            if not len(self._corrections) == self._npoints:
                raise DFcorrectionError(
                    &quot;Number of corrections has to be equal to the number of points npoints&quot;
                )
        else:
            self._savedir = kwargs.get(&quot;savedir&quot;, _CORRECTIONSDIR)
            self._savefilename = self._createSavefilename(self._niter)
            if os.path.exists(self._savefilename):
                savefile = open(self._savefilename, &quot;rb&quot;)
                self._corrections = numpy.array(pickle.load(savefile))
                savefile.close()
            else:  # Calculate the corrections
                self._corrections = self._calc_corrections()
        # Interpolation; smoothly go to zero
        interpRs = numpy.append(self._rs, 2.0 * self._rmax)
        self._surfaceInterpolate = interpolate.InterpolatedUnivariateSpline(
            interpRs,
            numpylog(numpy.append(self._corrections[:, 0], 1.0)),
            k=self._interp_k,
        )
        self._sigma2Interpolate = interpolate.InterpolatedUnivariateSpline(
            interpRs,
            numpylog(numpy.append(self._corrections[:, 1], 1.0)),
            k=self._interp_k,
        )
        # Interpolation for R &lt; _RMIN
        surfaceInterpolateSmallR = interpolate.UnivariateSpline(
            interpRs[0 : _INTERPDEGREE + 2],
            numpylog(self._corrections[0 : _INTERPDEGREE + 2, 0]),
            k=_INTERPDEGREE,
        )
        self._surfaceDerivSmallR = surfaceInterpolateSmallR.derivatives(interpRs[0])[1]
        sigma2InterpolateSmallR = interpolate.UnivariateSpline(
            interpRs[0 : _INTERPDEGREE + 2],
            numpylog(self._corrections[0 : _INTERPDEGREE + 2, 1]),
            k=_INTERPDEGREE,
        )
        self._sigma2DerivSmallR = sigma2InterpolateSmallR.derivatives(interpRs[0])[1]
        return None

    def _createSavefilename(self, niter):
        # Form surfaceSigmaProfile string
        sspFormat = self._surfaceSigmaProfile.formatStringParams()
        sspString = &quot;&quot;
        for format in sspFormat:
            sspString += format + &quot;_&quot;
        return os.path.join(
            self._savedir,
            &quot;dfcorrection_&quot;
            + self._dftype.__name__
            + &quot;_&quot;
            + self._surfaceSigmaProfile.__class__.__name__
            + &quot;_&quot;
            + sspString % self._surfaceSigmaProfile.outputParams()
            + &quot;%6.4f_%i_%6.4f_%i.sav&quot; % (self._beta, self._npoints, self._rmax, niter),
        )

    def correct(self, R, log=False):
        &quot;&quot;&quot;
        Calculate the correction in Sigma and sigma2 at R.

        Parameters
        ----------
        R : float
            Galactocentric radius (/ro).
        log : bool, optional
            If True, return the log of the correction.

        Returns
        -------
        tuple
            (Sigma correction, sigma2 correction).

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        if isinstance(R, numpy.ndarray):
            out = numpy.empty((2, len(R)))
            # R &lt; _RMIN
            rmin_indx = R &lt; _RMIN
            if numpy.sum(rmin_indx) &gt; 0:
                out[0, rmin_indx] = numpylog(
                    self._corrections[0, 0]
                ) + self._surfaceDerivSmallR * (R[rmin_indx] - _RMIN)
                out[1, rmin_indx] = numpylog(
                    self._corrections[0, 1]
                ) + self._sigma2DerivSmallR * (R[rmin_indx] - _RMIN)
            # R &gt; 2rmax
            rmax_indx = R &gt; (2.0 * self._rmax)
            if numpy.sum(rmax_indx) &gt; 0:
                out[:, rmax_indx] = 0.0
            #'normal' R
            r_indx = (R &gt;= _RMIN) * (R &lt;= (2.0 * self._rmax))
            if numpy.sum(r_indx) &gt; 0:
                out[0, r_indx] = self._surfaceInterpolate(R[r_indx])
                out[1, r_indx] = self._sigma2Interpolate(R[r_indx])
            if log:
                return out
            else:
                return numpy.exp(out)
        if R &lt; _RMIN:
            out = numpy.array(
                [
                    numpylog(self._corrections[0, 0])
                    + self._surfaceDerivSmallR * (R - _RMIN),
                    numpylog(self._corrections[0, 1])
                    + self._sigma2DerivSmallR * (R - _RMIN),
                ]
            )
        elif R &gt; (2.0 * self._rmax):
            out = numpy.array([0.0, 0.0])
        else:
            if _SCIPY_VERSION &gt;= _SCIPY_VERSION_BREAK:
                out = numpy.array(
                    [self._surfaceInterpolate(R), self._sigma2Interpolate(R)]
                )
            else:  # pragma: no cover
                out = numpy.array(
                    [self._surfaceInterpolate(R)[0], self._sigma2Interpolate(R)[0]]
                )
        if log:
            return out
        else:
            return numpy.exp(out)

    def derivLogcorrect(self, R):
        &quot;&quot;&quot;
        Calculate the derivative of the log of the correction in Sigma and sigma2 at R.

        Parameters
        ----------
        R : float
            Galactocentric radius(/ro)

        Returns
        -------
        numpy.ndarray
            [d log(Sigma correction)/dR, d log(sigma2 correction)/dR]

        Notes
        -----
        - 2010-03-10 - Written - Bovy (NYU)
        &quot;&quot;&quot;
        if R &lt; _RMIN:
            out = numpy.array([self._surfaceDerivSmallR, self._sigma2DerivSmallR])
        elif R &gt; (2.0 * self._rmax):
            out = numpy.array([0.0, 0.0])
        else:
            if _SCIPY_VERSION &gt;= _SCIPY_VERSION_BREAK:
                out = numpy.array(
                    [
                        self._surfaceInterpolate(R, nu=1),
                        self._sigma2Interpolate(R, nu=1),
                    ]
                )
            else:  # pragma: no cover
                out = numpy.array(
                    [
                        self._surfaceInterpolate(R, nu=1)[0],
                        self._sigma2Interpolate(R, nu=1)[0],
                    ]
                )
        return out

    def _calc_corrections(self):
        &quot;&quot;&quot;Internal function that calculates the corrections&quot;&quot;&quot;
        searchIter = self._niter - 1
        while searchIter &gt; 0:
            trySavefilename = self._createSavefilename(searchIter)
            if os.path.exists(trySavefilename):
                trySavefile = open(trySavefilename, &quot;rb&quot;)
                corrections = numpy.array(pickle.load(trySavefile))
                trySavefile.close()
                break
            else:
                searchIter -= 1
        if searchIter == 0:
            corrections = numpy.ones((self._npoints, 2))
        for ii in range(searchIter, self._niter):
            if ii == 0:
                currentDF = self._dftype(
                    surfaceSigma=self._surfaceSigmaProfile, beta=self._beta
                )
            else:
                currentDF = self._dftype(
                    surfaceSigma=self._surfaceSigmaProfile,
                    beta=self._beta,
                    corrections=corrections,
                    npoints=self._npoints,
                    rmax=self._rmax,
                    savedir=self._savedir,
                    interp_k=self._interp_k,
                )
            newcorrections = numpy.zeros((self._npoints, 2))
            for jj in range(self._npoints):
                thisSurface = currentDF.surfacemass(self._rs[jj], use_physical=False)
                newcorrections[jj, 0] = (
                    currentDF.targetSurfacemass(self._rs[jj], use_physical=False)
                    / thisSurface
                )
                newcorrections[jj, 1] = (
                    currentDF.targetSigma2(self._rs[jj], use_physical=False)
                    * thisSurface
                    / currentDF.sigma2surfacemass(self._rs[jj], use_physical=False)
                )
                # print(jj, newcorrections[jj,:])
            corrections *= newcorrections
        # Save
        picklethis = []
        for arr in list(corrections):
            picklethis.append([float(a) for a in arr])
        save_pickles(
            self._savefilename, picklethis
        )  # We pickle a list for platform-independence)
        return corrections


class DFcorrectionError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


def vRvTRToEL(vR, vT, R, beta, dftype=&quot;dehnen&quot;):
    &quot;&quot;&quot;
    Calculate the energy and angular momentum.

    Parameters
    ----------
    vR : float
        Radial velocity.
    vT : float
        Rotational velocity.
    R : float
        Galactocentric radius.
    beta : float
        Parameter that determines the shape of the rotation curve.
    dftype : str, optional
        Type of disk distribution function. Default is &quot;dehnen&quot;.

    Returns
    -------
    tuple
        Energy and angular momentum.

    Notes
    -----
    - 2010-03-10 - Written - Bovy (NYU)

    &quot;&quot;&quot;
    if dftype == &quot;schwarzschild&quot;:
        # Compute E in the epicycle approximation
        gamma = numpy.sqrt(2.0 / (1.0 + beta))
        L = R * vT
        if beta == 0.0:
            xL = L
        else:  # non-flat rotation curve
            xL = L ** (1.0 / (beta + 1.0))
        return (
            0.5 * vR**2.0
            + 0.5 * gamma**2.0 * (vT - R**beta) ** 2.0
            + xL ** (2.0 * beta) / 2.0
            + axipotential(xL, beta=beta),
            L,
        )
    else:
        return (axipotential(R, beta) + 0.5 * vR**2.0 + 0.5 * vT**2.0, vT * R)


def axipotential(R, beta=0.0):
    &quot;&quot;&quot;
    Return the axisymmetric potential at R/Ro.

    Parameters
    ----------
    R : float
        Galactocentric radius.
    beta : float, optional
        Rotation curve power-law.

    Returns
    -------
    float
        Pot(R)/vo**2.

    Notes
    -----
    - 2010-03-01 - Written - Bovy (NYU)

    &quot;&quot;&quot;
    if beta == 0.0:
        if numpy.any(R == 0.0):
            out = numpy.empty(R.shape)
            out[R == 0.0] = numpylog(_RMIN)
            out[R != 0.0] = numpylog(R[R != 0.0])
            return out
        else:
            return numpylog(R)
    else:  # non-flat rotation curve
        return R ** (2.0 * beta) / 2.0 / beta


def _ars_hx(x, args):
    &quot;&quot;&quot;
    h(x) for ARS sampling of the input surfacemass profile

    Parameters
    ----------
    x : float
        R(/ro)
    args : tuple
        surfaceSigma - surfaceSigmaProfile instance
        dfcorr - DFcorrection instance

    Returns
    -------
    float
        log(x)+log surface(x) + log(correction)

    Notes
    -----
    - 2010-07-11 - Written - Bovy (NYU)
    &quot;&quot;&quot;

    surfaceSigma, dfcorr = args
    if dfcorr is None:
        return numpylog(x) + surfaceSigma.surfacemass(x, log=True)
    else:
        return (
            numpylog(x) + surfaceSigma.surfacemass(x, log=True) + dfcorr.correct(x)[0]
        )


def _ars_hpx(x, args):
    &quot;&quot;&quot;
    h'(x) for ARS sampling of the input surfacemass profile

    Parameters
    ----------
    x : float
        R(/ro)
    args : tuple
        surfaceSigma - surfaceSigmaProfile instance
        dfcorr - DFcorrection instance

    Returns
    -------
    float
        derivative of log(x)+log surface(x) + log(correction) wrt x

    Notes
    -----
    - 2010-07-11 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    surfaceSigma, dfcorr = args
    if dfcorr is None:
        return 1.0 / x + surfaceSigma.surfacemassDerivative(x, log=True)
    else:
        return (
            1.0 / x
            + surfaceSigma.surfacemassDerivative(x, log=True)
            + dfcorr.derivLogcorrect(x)[0]
        )


def _kappa(R, beta):
    &quot;&quot;&quot;Internal function to give kappa(r)&quot;&quot;&quot;
    return numpy.sqrt(2.0 * (1.0 + beta)) * R ** (beta - 1)


def _dlToRphi(d, l):
    &quot;&quot;&quot;Convert d and l to R and phi, l is in radians&quot;&quot;&quot;
    R = numpy.sqrt(1.0 + d**2.0 - 2.0 * d * numpy.cos(l))
    if R == 0.0:
        R += 0.0001
        d += 0.0001
    if 1.0 / numpy.cos(l) &lt; d and numpy.cos(l) &gt; 0.0:
        theta = numpy.pi - numpy.arcsin(d / R * numpy.sin(l))
    else:
        theta = numpy.arcsin(d / R * numpy.sin(l))
    return (R, theta)


def _vtmaxEq(vT, R, diskdf):
    &quot;&quot;&quot;Equation to solve to find the max vT at R&quot;&quot;&quot;
    # Calculate a bunch of stuff that we need
    if diskdf._beta == 0.0:
        E = vT**2.0 / 2.0 + numpylog(R)
        xE = numpy.exp(E - 0.5)
        OE = xE**-1.0
        LCE = xE
        dxEdvT = xE * vT
    else:  # non-flat rotation curve
        E = vT**2.0 / 2.0 + 1.0 / 2.0 / diskdf._beta * R ** (2.0 * diskdf._beta)
        xE = (2.0 * E / (1.0 + 1.0 / diskdf._beta)) ** (1.0 / 2.0 / diskdf._beta)
        OE = xE ** (diskdf._beta - 1.0)
        LCE = xE ** (diskdf._beta + 1.0)
        dxEdvT = xE / 2.0 / diskdf._beta / E * vT
    L = R * vT
    sigma2xE = diskdf._surfaceSigmaProfile.sigma2(xE, log=False)
    return (
        OE * R / sigma2xE
        + (
            diskdf._surfaceSigmaProfile.surfacemassDerivative(xE, log=True)
            - (1.0 + OE * (L - LCE) / sigma2xE)
            * diskdf._surfaceSigmaProfile.sigma2Derivative(xE, log=True)
            + (L - LCE) / sigma2xE * (diskdf._beta - 1.0) * xE ** (diskdf._beta - 2.0)
            - OE * (diskdf._beta + 1.0) / sigma2xE * xE**diskdf._beta
        )
        * dxEdvT
    )


def _marginalizeVperpIntegrandSinAlphaLarge(
    vR, df, R, sinalpha, cotalpha, vlos, vcirc, sigma
):
    return df(
        *vRvTRToEL(
            vR * sigma,
            cotalpha * vR * sigma + vlos / sinalpha + vcirc,
            R,
            df._beta,
            df._dftype,
        )
    )


def _marginalizeVperpIntegrandSinAlphaSmall(
    vT, df, R, cosalpha, tanalpha, vlos, vcirc, sigma
):
    return df(
        *vRvTRToEL(
            tanalpha * vT * sigma - vlos / cosalpha,
            vT * sigma + vcirc,
            R,
            df._beta,
            df._dftype,
        )
    )
</file>
    <file path="galpy/df/osipkovmerrittdf.py">
# Class that implements anisotropic DFs of the Osipkov-Merritt type
import numpy
from scipy import integrate, interpolate, special

from ..potential import evaluateDensities
from ..potential.Potential import _evaluatePotentials
from ..util import conversion
from .eddingtondf import eddingtondf
from .sphericaldf import anisotropicsphericaldf, sphericaldf


# This is the general Osipkov-Merritt superclass, implementation of general
# formula can be found following this class
class _osipkovmerrittdf(anisotropicsphericaldf):
    &quot;&quot;&quot;General Osipkov-Merritt superclass with useful functions for any DF of the Osipkov-Merritt type.&quot;&quot;&quot;

    def __init__(
        self, pot=None, denspot=None, ra=1.4, rmax=None, scale=None, ro=None, vo=None
    ):
        &quot;&quot;&quot;
        Initialize a DF with Osipkov-Merritt anisotropy.

        Parameters
        ----------
        pot : Potential instance or list thereof, optional
            Default: None
        denspot : Potential instance or list thereof that represent the density of the tracers (assumed to be spherical; if None, set equal to pot), optional
            Default: None
        ra : float or Quantity, optional
            Anisotropy radius. Default: 1.4
        rmax : float or Quantity, optional
            Maximum radius to consider; DF is cut off at E = Phi(rmax). Default: None
        scale : float or Quantity, optional
            Characteristic scale radius to aid sampling calculations. Not necessary, and will also be overridden by value from pot if available. Default: None
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2020-11-12 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        anisotropicsphericaldf.__init__(
            self, pot=pot, denspot=denspot, rmax=rmax, scale=scale, ro=ro, vo=vo
        )
        self._ra = conversion.parse_length(ra, ro=self._ro)
        self._ra2 = self._ra**2.0

    def _call_internal(self, *args):
        &quot;&quot;&quot;
        Evaluate the DF for an Osipkov-Merritt-anisotropy DF

        Parameters
        ----------
        E : float
            The energy
        L : float
            The angular momentum

        Returns
        -------
        float
            The value of the DF

        Notes
        -----
        - 2020-11-12 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        E, L, _ = args
        return self.fQ(-E - 0.5 * L**2.0 / self._ra2)

    def _dMdE(self, E):
        if not hasattr(self, &quot;_rphi&quot;):
            self._rphi = self._setup_rphi_interpolator()

        def Lintegrand(t, L2lim, E):
            return self((E, numpy.sqrt(L2lim - t**2.0)), use_physical=False)

        # Integrate where Q &gt; 0

        out = (
            16.0
            * numpy.pi**2.0
            * numpy.array(
                [
                    integrate.quad(
                        lambda r: r
                        * integrate.quad(
                            Lintegrand,
                            numpy.sqrt(
                                numpy.amax(
                                    [
                                        (0.0),
                                        (
                                            2.0
                                            * r**2.0
                                            * (
                                                tE
                                                - _evaluatePotentials(self._pot, r, 0.0)
                                            )
                                            + 2.0 * tE * self._ra2
                                        ),
                                    ]
                                )
                            ),
                            numpy.sqrt(
                                2.0
                                * r**2.0
                                * (tE - _evaluatePotentials(self._pot, r, 0.0))
                            ),
                            args=(
                                2.0
                                * r**2.0
                                * (tE - _evaluatePotentials(self._pot, r, 0.0)),
                                tE,
                            ),
                        )[0],
                        0.0,
                        self._rphi(tE),
                    )[0]
                    for ii, tE in enumerate(E)
                ]
            )
        )
        # Numerical issues can make the integrand's sqrt argument negative, only
        # happens at dMdE ~ 0, so just set to zero
        out[numpy.isnan(out)] = 0.0
        return out.reshape(E.shape)

    def _sample_eta(self, r, n=1):
        &quot;&quot;&quot;Sample the angle eta which defines radial vs tangential velocities&quot;&quot;&quot;
        # cumulative distribution of x = cos eta satisfies
        # x/(sqrt(A+1 -A* x^2)) = 2 b - 1 = c
        # where b \in [0,1] and A = (r/ra)^2
        # Solved by
        # x = c sqrt(1+[r/ra]^2) / sqrt( [r/ra]^2 c^2 + 1 ) for c &gt; 0 [b &gt; 0.5]
        # and symmetric wrt c
        c = numpy.random.uniform(size=n)
        x = (
            c
            * numpy.sqrt(1 + r**2.0 / self._ra2)
            / numpy.sqrt(r**2.0 / self._ra2 * c**2.0 + 1)
        )
        x *= numpy.random.choice([1.0, -1.0], size=n)
        return numpy.arccos(x)

    def _p_v_at_r(self, v, r):
        &quot;&quot;&quot;p( v*sqrt[1+r^2/ra^2*sin^2eta] | r) used in sampling&quot;&quot;&quot;
        if hasattr(self, &quot;_logfQ_interp&quot;):
            return (
                numpy.exp(
                    self._logfQ_interp(
                        -_evaluatePotentials(self._pot, r, 0) - 0.5 * v**2.0
                    )
                )
                * v**2.0
            )
        else:
            return (
                self.fQ(-_evaluatePotentials(self._pot, r, 0) - 0.5 * v**2.0) * v**2.0
            )

    def _sample_v(self, r, eta, n=1):
        &quot;&quot;&quot;Generate velocity samples&quot;&quot;&quot;
        # Use super-class method to obtain v*[1+r^2/ra^2*sin^2eta]
        out = super()._sample_v(r, eta, n=n)
        # Transform to v
        return out / numpy.sqrt(1.0 + r**2.0 / self._ra2 * numpy.sin(eta) ** 2.0)

    def _vmomentdensity(self, r, n, m):
        if m % 2 == 1 or n % 2 == 1:
            return 0.0
        return (
            2.0
            * numpy.pi
            * integrate.quad(
                lambda v: v ** (2.0 + m + n)
                * self.fQ(-_evaluatePotentials(self._pot, r, 0) - 0.5 * v**2.0),
                0.0,
                self._vmax_at_r(self._pot, r),
            )[0]
            * special.gamma(m / 2.0 + 1.0)
            * special.gamma((n + 1) / 2.0)
            / special.gamma(0.5 * (m + n + 3.0))
            / (1 + r**2.0 / self._ra2) ** (m / 2 + 1)
        )


class osipkovmerrittdf(_osipkovmerrittdf):
    &quot;&quot;&quot;Class that implements spherical DFs with Osipkov-Merritt-type orbital anisotropy

    .. math::

        \\beta(r) = \\frac{1}{1+r_a^2/r^2}

    with :math:`r_a` the anistropy radius for arbitrary combinations of potential and density profile.
    &quot;&quot;&quot;

    def __init__(
        self, pot=None, denspot=None, ra=1.4, rmax=1e4, scale=None, ro=None, vo=None
    ):
        &quot;&quot;&quot;
        Initialize a DF with Osipkov-Merritt anisotropy.

        Parameters
        ----------
        pot : Potential instance or list thereof, optional
            Default: None
        denspot : Potential instance or list thereof that represent the density of the tracers (assumed to be spherical; if None, set equal to pot), optional
            Default: None
        ra : float or Quantity, optional
            Anisotropy radius. Default: 1.4
        rmax : float or Quantity, optional
            Maximum radius to consider; DF is cut off at E = Phi(rmax). Default: None
        scale : float or Quantity, optional
            Characteristic scale radius to aid sampling calculations. Not necessary, and will also be overridden by value from pot if available. Default: None
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2021-02-07 - Written - Bovy (UofT)
        &quot;&quot;&quot;
        _osipkovmerrittdf.__init__(
            self, pot=pot, denspot=denspot, ra=ra, rmax=rmax, scale=scale, ro=ro, vo=vo
        )
        # Because f(Q) is the same integral as the Eddington conversion, but
        # using the augmented density rawdensx(1+r^2/ra^2), we use a helper
        # eddingtondf to do this integral, hacked to use the augmented density
        self._edf = eddingtondf(
            pot=self._pot, denspot=self._denspot, scale=scale, rmax=rmax, ro=ro, vo=vo
        )
        self._edf._dnudr = (
            (
                lambda r: self._denspot._ddensdr(r) * (1.0 + r**2.0 / self._ra2)
                + 2.0 * self._denspot.dens(r, 0, use_physical=False) * r / self._ra2
            )
            if not isinstance(self._denspot, list)
            else (
                lambda r: numpy.sum([p._ddensdr(r) for p in self._denspot])
                * (1.0 + r**2.0 / self._ra2)
                + 2.0
                * evaluateDensities(self._denspot, r, 0, use_physical=False)
                * r
                / self._ra2
            )
        )
        self._edf._d2nudr2 = (
            (
                lambda r: self._denspot._d2densdr2(r) * (1.0 + r**2.0 / self._ra2)
                + 4.0 * self._denspot._ddensdr(r) * r / self._ra2
                + 2.0 * self._denspot.dens(r, 0, use_physical=False) / self._ra2
            )
            if not isinstance(self._denspot, list)
            else (
                lambda r: numpy.sum([p._d2densdr2(r) for p in self._denspot])
                * (1.0 + r**2.0 / self._ra2)
                + 4.0
                * numpy.sum([p._ddensdr(r) for p in self._denspot])
                * r
                / self._ra2
                + 2.0
                * evaluateDensities(self._denspot, r, 0, use_physical=False)
                / self._ra2
            )
        )

    def sample(self, R=None, z=None, phi=None, n=1, return_orbit=True, rmin=0.0):
        # Slight over-write of superclass method to first build f(Q) interp
        # No docstring so superclass' is used
        if not hasattr(self, &quot;_logfQ_interp&quot;):
            Qs4interp = numpy.hstack(
                (
                    numpy.geomspace(1e-8, 0.5, 101, endpoint=False),
                    sorted(1.0 - numpy.geomspace(1e-8, 0.5, 101)),
                )
            )
            Qs4interp = -(
                Qs4interp * (self._edf._Emin - self._edf._potInf) + self._edf._potInf
            )
            fQ4interp = numpy.log(self.fQ(Qs4interp))
            iindx = numpy.isfinite(fQ4interp)
            self._logfQ_interp = interpolate.InterpolatedUnivariateSpline(
                Qs4interp[iindx], fQ4interp[iindx], k=3, ext=3
            )
        return sphericaldf.sample(
            self, R=R, z=z, phi=phi, n=n, return_orbit=return_orbit, rmin=rmin
        )

    def fQ(self, Q):
        &quot;&quot;&quot;
        Calculate the f(Q) portion of an Osipkov-Merritt Hernquist distribution function

        Parameters
        ----------
        Q : float
            The Osipkov-Merritt 'energy' E-L^2/[2ra^2]

        Returns
        -------
        float
            The value of the f(Q) portion of the DF

        Notes
        -----
        - 2021-02-07 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        return self._edf.fE(-Q)
</file>
    <file path="galpy/df/quasiisothermaldf.py">
# A 'Binney' quasi-isothermal DF
import hashlib
import warnings

import numpy
from scipy import integrate, interpolate, optimize

from .. import actionAngle, potential
from ..actionAngle import actionAngleIsochrone
from ..orbit import Orbit
from ..potential import IsochronePotential
from ..potential import flatten as flatten_potential
from ..util import conversion, galpyWarning
from ..util._optional_deps import _APY_LOADED, _APY_UNITS
from ..util.conversion import (
    actionAngle_physical_input,
    parse_angmom,
    parse_length,
    parse_length_kpc,
    parse_velocity,
    parse_velocity_kms,
    physical_compatible,
    physical_conversion,
    potential_physical_input,
)
from .df import df

if _APY_LOADED:
    from astropy import units
_NSIGMA = 4
_DEFAULTNGL = 10
_DEFAULTNGL2 = 20


class quasiisothermaldf(df):
    &quot;&quot;&quot;Class that represents a 'Binney' quasi-isothermal DF&quot;&quot;&quot;

    def __init__(
        self,
        hr,
        sr,
        sz,
        hsr,
        hsz,
        pot=None,
        aA=None,
        cutcounter=False,
        _precomputerg=True,
        _precomputergrmax=None,
        _precomputergnLz=51,
        refr=1.0,
        lo=10.0 / 220.0 / 8.0,
        ro=None,
        vo=None,
    ):
        &quot;&quot;&quot;
        Initialize a quasi-isothermal DF

        Parameters
        ----------
        hr : float or Quantity
            Radial scale length.
        sr : float or Quantity
            Radial velocity dispersion at the solar radius.
        sz : float or Quantity
            Vertical velocity dispersion at the solar radius.
        hsr : float or Quantity
            Radial-velocity-dispersion scale length.
        hsz : float or Quantity
            Vertial-velocity-dispersion scale length.
        pot : Potential or list thereof
            Potential or list of potentials that represents the underlying potential.
        aA : actionAngle instance
            ActionAngle instance used to convert (x,v) to actions [must be an instance of an actionAngle class that computes (J,Omega,angle) for a given (x,v)].
        cutcounter : bool, optional
            If True, set counter-rotating stars' DF to zero.
        refr : float or Quantity, optional
            Reference radius for dispersions (can be different from ro).
        lo : float or Quantity, optional
            Reference angular momentum below where there are significant numbers of retrograde stars.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).
        _precomputerg : bool, optional
            If True (default), pre-compute the rL(L).
        _precomputergrmax : float or Quantity, optional
            If set, this is the maximum R for which to pre-compute rg (default: 5*hr).
        _precomputergnLz : int, optional
            If set, number of Lz to pre-compute rg for (default: 51).

        Notes
        -----
        - 2012-07-25 - Started - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        df.__init__(self, ro=ro, vo=vo)
        self._hr = parse_length(hr, ro=self._ro)
        self._sr = parse_velocity(sr, vo=self._vo)
        self._sz = parse_velocity(sz, vo=self._vo)
        self._hsr = parse_length(hsr, ro=self._ro)
        self._hsz = parse_length(hsz, ro=self._ro)
        self._refr = parse_length(refr, ro=self._ro)
        self._lo = parse_angmom(lo, ro=self._ro, vo=self._vo)
        self._lnsr = numpy.log(self._sr)
        self._lnsz = numpy.log(self._sz)
        self._maxVT_hash = None
        self._maxVT_ip = None
        if pot is None:
            raise OSError(&quot;pot= must be set&quot;)
        self._pot = flatten_potential(pot)
        if aA is None:
            raise OSError(&quot;aA= must be set&quot;)
        self._aA = aA
        if not self._aA._pot == self._pot:
            if not isinstance(self._aA, actionAngleIsochrone):
                raise OSError(
                    &quot;Potential in aA does not appear to be the same as given potential pot&quot;
                )
            elif (
                isinstance(self._pot, IsochronePotential)
                and not self._aA.b == self._pot.b
                and not self._aA.amp == self._pot._amp
            ):
                raise OSError(
                    &quot;Potential in aA does not appear to be the same as given potential pot&quot;
                )
        self._check_consistent_units()
        self._cutcounter = cutcounter
        if _precomputerg:
            if _precomputergrmax is None:
                _precomputergrmax = 5 * self._hr
            self._precomputergrmax = _precomputergrmax
            self._precomputergnLz = _precomputergnLz
            self._precomputergLzmin = 0.01
            self._precomputergLzmax = self._precomputergrmax * potential.vcirc(
                self._pot, self._precomputergrmax
            )
            self._precomputergLzgrid = numpy.linspace(
                self._precomputergLzmin, self._precomputergLzmax, self._precomputergnLz
            )
            self._rls = numpy.array(
                [potential.rl(self._pot, l) for l in self._precomputergLzgrid]
            )
            # Spline interpolate
            self._rgInterp = interpolate.InterpolatedUnivariateSpline(
                self._precomputergLzgrid, self._rls, k=3
            )
        else:
            self._precomputergrmax = 0.0
            self._rgInterp = None
            self._rls = None
            self._precomputergnr = None
            self._precomputergLzgrid = None
            self._precomputergLzmin = numpy.finfo(numpy.dtype(numpy.float64)).max
            self._precomputergLzmax = numpy.finfo(numpy.dtype(numpy.float64)).min
        self._precomputerg = _precomputerg
        self._glxdef, self._glwdef = numpy.polynomial.legendre.leggauss(_DEFAULTNGL)
        self._glxdef2, self._glwdef2 = numpy.polynomial.legendre.leggauss(_DEFAULTNGL2)
        self._glxdef12, self._glwdef12 = numpy.polynomial.legendre.leggauss(
            _DEFAULTNGL // 2
        )
        return None

    @physical_conversion(&quot;phasespacedensity&quot;, pop=True)
    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Evaluate the DF

        Parameters
        ----------
        args: tuple or Orbit
            Either:
                a) (jr,lz,jz) tuple; each can be a Quantity
                    where:
                        * jr - radial action
                        * lz - z-component of angular momentum
                        * jz - vertical action
                b) R,vR,vT,z,vz
                c) Orbit instance: initial condition used if that's it, orbit(t) if there is a time given as well
        log: bool, optional
            If True, return the natural log.
        func: function of (jr,lz,jz), optional
            Function of the actions to multiply the DF with (useful for moments).
        _return_actions: bool, optional
            If True, return the actions as well.
        _return_freqs: bool, optional
            If True, return the frequencies as well.
        _return_rgr: bool, optional
            If True, return the rg as well.
        kwargs: dict, optional
            scipy.integrate.quadrature kwargs.

        Returns
        -------
        float
            Value of DF.

        Notes
        -----
        - 2012-07-25 - Written - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        # First parse log
        log = kwargs.pop(&quot;log&quot;, False)
        _return_actions = kwargs.pop(&quot;_return_actions&quot;, False)
        _return_freqs = kwargs.pop(&quot;_return_freqs&quot;, False)
        _func = kwargs.pop(&quot;func&quot;, None)
        if &quot;rg&quot; in kwargs:
            thisrg = kwargs.pop(&quot;rg&quot;)
            kappa = kwargs.pop(&quot;kappa&quot;)
            nu = kwargs.pop(&quot;nu&quot;)
            Omega = kwargs.pop(&quot;Omega&quot;)
        else:
            thisrg = None
            kappa = None
            nu = None
            Omega = None
        # First parse args
        if len(args) == 1 and not isinstance(args[0], Orbit):  # (jr,lz,jz)
            jr, lz, jz = args[0]
            jr = parse_angmom(jr, ro=self._ro, vo=self._vo)
            lz = parse_angmom(lz, ro=self._ro, vo=self._vo)
            jz = parse_angmom(jz, ro=self._ro, vo=self._vo)
        else:
            # Use self._aA to calculate the actions
            if isinstance(args[0], Orbit) and len(args[0].shape) &gt; 1:
                raise RuntimeError(
                    &quot;Evaluating quasiisothermaldf with Orbit instances with multi-dimensional shapes is not supported&quot;
                )  # pragma: no cover
            try:
                jr, lz, jz = self._aA(*args, use_physical=False, **kwargs)
            except actionAngle.UnboundError:
                if log:
                    return -numpy.finfo(numpy.dtype(numpy.float64)).max
                else:
                    return 0.0
            # if isinstance(jr,(list,numpy.ndarray)) and len(jr) &gt; 1: jr= jr[0]
            # if isinstance(jz,(list,numpy.ndarray)) and len(jz) &gt; 1: jz= jz[0]
        if not isinstance(lz, numpy.ndarray) and self._cutcounter and lz &lt; 0.0:
            if log:
                return -numpy.finfo(numpy.dtype(numpy.float64)).max
            else:
                return 0.0
        # First calculate rg
        if thisrg is None:
            thisrg = self._rg(lz)
            # Then calculate the epicycle and vertical frequencies
            kappa, nu = self._calc_epifreq(thisrg), self._calc_verticalfreq(thisrg)
            Omega = numpy.fabs(lz) / thisrg / thisrg
        # calculate surface-densities and sigmas
        lnsurfmass = (self._refr - thisrg) / self._hr
        lnsr = self._lnsr + (self._refr - thisrg) / self._hsr
        lnsz = self._lnsz + (self._refr - thisrg) / self._hsz
        # Calculate func
        if not _func is None:
            if log:
                funcTerm = numpy.log(_func(jr, lz, jz))
            else:
                funcFactor = _func(jr, lz, jz)
        # Calculate fsr
        else:
            if log:
                funcTerm = 0.0
            else:
                funcFactor = 1.0
        if log:
            lnfsr = (
                numpy.log(Omega)
                + lnsurfmass
                - 2.0 * lnsr
                - numpy.log(numpy.pi)
                - numpy.log(kappa)
                + numpy.log(1.0 + numpy.tanh(lz / self._lo))
                - kappa * jr * numpy.exp(-2.0 * lnsr)
            )
            lnfsz = (
                numpy.log(nu)
                - numpy.log(2.0 * numpy.pi)
                - 2.0 * lnsz
                - nu * jz * numpy.exp(-2.0 * lnsz)
            )
            out = lnfsr + lnfsz + funcTerm
            if isinstance(lz, numpy.ndarray):
                out[numpy.isnan(out)] = -numpy.finfo(numpy.dtype(numpy.float64)).max
                if self._cutcounter:
                    out[(lz &lt; 0.0)] = -numpy.finfo(numpy.dtype(numpy.float64)).max
            elif numpy.isnan(out):  # pragma: no cover
                out = -numpy.finfo(numpy.dtype(numpy.float64)).max
        else:
            srm2 = numpy.exp(-2.0 * lnsr)
            fsr = (
                Omega
                * numpy.exp(lnsurfmass)
                * srm2
                / numpy.pi
                / kappa
                * (1.0 + numpy.tanh(lz / self._lo))
                * numpy.exp(-kappa * jr * srm2)
            )
            szm2 = numpy.exp(-2.0 * lnsz)
            fsz = nu / 2.0 / numpy.pi * szm2 * numpy.exp(-nu * jz * szm2)
            out = fsr * fsz * funcFactor
            if isinstance(lz, numpy.ndarray):
                out[numpy.isnan(out)] = 0.0
                if self._cutcounter:
                    out[(lz &lt; 0.0)] = 0.0
            elif numpy.isnan(out):  # pragma: no cover
                out = 0.0
        if _return_actions and _return_freqs:
            return (out, jr, lz, jz, thisrg, kappa, nu, Omega)
        elif _return_actions:
            return (out, jr, lz, jz)
        elif _return_freqs:
            return (out, thisrg, kappa, nu, Omega)
        else:
            return out

    @potential_physical_input
    @physical_conversion(&quot;position&quot;, pop=True)
    def estimate_hr(self, R, z=0.0, dR=10.0**-8.0, **kwargs):
        &quot;&quot;&quot;
        Estimate the exponential scale length at R.

        Parameters
        ----------
        R : float or Quantity
            Galactocentric radius.
        z : float or Quantity, optional
            Height (default: 0 pc).
        dR : float or Quantity, optional
            Range in R to use.
        **kwargs
            Density kwargs.

        Returns
        -------
        float or Quantity
            Estimated hR.

        Notes
        -----
        - 2012-09-11 - Written - Bovy (IAS)
        - 2013-01-28 - Re-written - Bovy
        &quot;&quot;&quot;
        Rs = [R - dR / 2.0, R + dR / 2.0]
        if z is None:
            sf = numpy.array(
                [self.surfacemass_z(r, use_physical=False, **kwargs) for r in Rs]
            )
        else:
            sf = numpy.array(
                [self.density(r, z, use_physical=False, **kwargs) for r in Rs]
            )
        lsf = numpy.log(sf)
        return -dR / (lsf[1] - lsf[0])

    @potential_physical_input
    @physical_conversion(&quot;position&quot;, pop=True)
    def estimate_hz(self, R, z, dz=10.0**-8.0, **kwargs):
        &quot;&quot;&quot;
        Estimate the exponential scale height at R.

        Parameters
        ----------
        R : float or Quantity
            Galactocentric radius.
        z : float or Quantity
            Height above the Galactic plane.
        dz : float or Quantity, optional
            z range to use.
        **kwargs
            density kwargs.

        Returns
        -------
        float or Quantity
            Estimated hz.

        Notes
        -----
        - 2012-08-30 - Written - Bovy (IAS)
        - 2013-01-28 - Re-written - Bovy
        &quot;&quot;&quot;
        if z == 0.0:
            zs = [z, z + dz]
        else:
            zs = [z - dz / 2.0, z + dz / 2.0]
        sf = numpy.array(
            [self.density(R, zz, use_physical=False, **kwargs) for zz in zs]
        )
        lsf = numpy.log(sf)
        return -dz / (lsf[1] - lsf[0])

    @potential_physical_input
    @physical_conversion(&quot;position&quot;, pop=True)
    def estimate_hsr(self, R, z=0.0, dR=10.0**-8.0, **kwargs):
        &quot;&quot;&quot;
        Estimate the exponential scale length of the radial dispersion at R.

        Parameters
        ----------
        R : float or Quantity
            Galactocentric radius.
        z : float or Quantity, optional
            Height (default: 0 pc).
        dR : float or Quantity, optional
            Range in R to use.
        **kwargs
            Density kwargs.

        Returns
        -------
        float or Quantity
            Estimated hsR.

        Notes
        -----
        - 2013-03-08 - Written - Bovy (IAS)

        &quot;&quot;&quot;
        Rs = [R - dR / 2.0, R + dR / 2.0]
        sf = numpy.array([self.sigmaR2(r, z, use_physical=False, **kwargs) for r in Rs])
        lsf = numpy.log(sf) / 2.0
        return -dR / (lsf[1] - lsf[0])

    @potential_physical_input
    @physical_conversion(&quot;position&quot;, pop=True)
    def estimate_hsz(self, R, z=0.0, dR=10.0**-8.0, **kwargs):
        &quot;&quot;&quot;
        Estimate the exponential scale length of the vertical dispersion at R.

        Parameters
        ----------
        R : float or Quantity
            Galactocentric radius.
        z : float or Quantity, optional
            Height (default: 0 pc).
        dR : float or Quantity, optional
            Range in R to use.
        **kwargs
            Density kwargs.

        Returns
        -------
        float or Quantity
            Estimated hsz.

        Notes
        -----
        - 2013-03-08 - Written - Bovy (IAS)

        &quot;&quot;&quot;
        Rs = [R - dR / 2.0, R + dR / 2.0]
        sf = numpy.array([self.sigmaz2(r, z, use_physical=False, **kwargs) for r in Rs])
        lsf = numpy.log(sf) / 2.0
        return -dR / (lsf[1] - lsf[0])

    @potential_physical_input
    @physical_conversion(&quot;numbersurfacedensity&quot;, pop=True)
    def surfacemass_z(
        self, R, nz=7, zmax=1.0, fixed_quad=True, fixed_order=8, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the vertically-integrated surface density.

        Parameters
        ----------
        R : float or Quantity
            Galactocentric radius.
        nz : int, optional
            Number of zs to use to estimate. Default is 7.
        zmax : float or Quantity, optional
            Maximum z to use. Default is 1.0.
        fixed_quad : bool, optional
            If True (default), use Gauss-Legendre integration.
        fixed_order : int, optional
            Order of GL integration to use. Default is 8.
        **kwargs : dict
            Density kwargs.

        Returns
        -------
        float or Quantity
            Surface density at R.

        Notes
        -----
        - 2012-08-30 - Written - Bovy (IAS)
        &quot;&quot;&quot;
        if fixed_quad:
            return (
                2.0
                * integrate.fixed_quad(
                    lambda x: self.density(
                        R * numpy.ones(fixed_order), x, use_physical=False
                    ),
                    0.0,
                    0.5,
                    n=fixed_order,
                )[0]
            )
        zs = numpy.linspace(0.0, zmax, nz)
        sf = numpy.array([self.density(R, z, use_physical=False, **kwargs) for z in zs])
        lsf = numpy.log(sf)
        # Interpolate
        lsfInterp = interpolate.UnivariateSpline(zs, lsf, k=3)
        # Integrate
        return 2.0 * integrate.quad((lambda x: numpy.exp(lsfInterp(x))), 0.0, 1.0)[0]

    def vmomentdensity(self, *args, **kwargs):
        &quot;&quot;&quot;
        Calculate the an arbitrary moment of the velocity distribution at R times the density

        Parameters
        ----------
        R : float
            radius at which to calculate the moment(/ro)
        z : float
            height at which to calculate the moment(/ro)
        n : int
            vR^n
        m : int
            vT^m
        o : int
            vz^o
        nsigma : int, optional
            number of sigma to integrate the vR and vz velocities over (when doing explicit numerical integral; default: 4)
        vTmax : float, optional
            upper limit for integration over vT (default: 1.5)
        mc : bool, optional
            if True, calculate using Monte Carlo integration
        nmc : int, optional
            if mc, use nmc samples
        gl : bool, optional
            use Gauss-Legendre
        _returngl : bool, optional
            if True, return the evaluated DF
        _return_actions : bool, optional
            if True, return the evaluated actions (does not work with _returngl currently)
        _return_freqs : bool, optional
            if True, return the evaluated frequencies and rg (does not work with _returngl currently)

        Returns
        -------
        float
            &lt;vR^n vT^m  x density&gt; at R,z (no support for units)

        Notes
        -----
        - 2012-08-06 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        ro = kwargs.pop(&quot;ro&quot;, None)
        if ro is None and hasattr(self, &quot;_roSet&quot;) and self._roSet:
            ro = self._ro
        ro = parse_length_kpc(ro)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = parse_velocity_kms(vo)
        if use_physical and not vo is None and not ro is None:
            fac = vo ** (args[2] + args[3] + args[4]) / ro**3
            if _APY_UNITS:
                u = (
                    1
                    / units.kpc**3
                    * (units.km / units.s) ** (args[2] + args[3] + args[4])
                )
            out = self._vmomentdensity(*args, **kwargs)
            if _APY_UNITS:
                return units.Quantity(out * fac, unit=u)
            else:
                return out * fac
        else:
            return self._vmomentdensity(*args, **kwargs)

    def _vmomentdensity(
        self,
        R,
        z,
        n,
        m,
        o,
        nsigma=None,
        mc=False,
        nmc=10000,
        _returnmc=False,
        _vrs=None,
        _vts=None,
        _vzs=None,
        _rawgausssamples=False,
        gl=False,
        ngl=_DEFAULTNGL,
        _returngl=False,
        _glqeval=None,
        _return_actions=False,
        _jr=None,
        _lz=None,
        _jz=None,
        _return_freqs=False,
        _rg=None,
        _kappa=None,
        _nu=None,
        _Omega=None,
        _sigmaR1=None,
        _sigmaz1=None,
        **kwargs,
    ):
        &quot;&quot;&quot;Non-physical version of vmomentdensity, otherwise the same&quot;&quot;&quot;
        if isinstance(R, numpy.ndarray):
            return numpy.array(
                [
                    self._vmomentdensity(
                        r,
                        zz,
                        n,
                        m,
                        o,
                        nsigma=nsigma,
                        mc=mc,
                        nmc=nmc,
                        gl=gl,
                        ngl=ngl,
                        **kwargs,
                    )
                    for r, zz in zip(R, z)
                ]
            )
        if isinstance(
            self._aA,
            (actionAngle.actionAngleAdiabatic, actionAngle.actionAngleAdiabaticGrid),
        ):
            if n % 2 == 1.0 or o % 2 == 1.0:
                return 0.0  # we know this must be the case
        if nsigma == None:
            nsigma = _NSIGMA
        if _sigmaR1 is None:
            sigmaR1 = self._sr * numpy.exp((self._refr - R) / self._hsr)
        else:
            sigmaR1 = _sigmaR1
        if _sigmaz1 is None:
            sigmaz1 = self._sz * numpy.exp((self._refr - R) / self._hsz)
        else:
            sigmaz1 = _sigmaz1
        thisvc = potential.vcirc(self._pot, R, use_physical=False)
        # Use the asymmetric drift equation to estimate va
        gamma = numpy.sqrt(0.5)
        va = (
            sigmaR1**2.0
            / 2.0
            / thisvc
            * (
                gamma**2.0
                - 1.0  # Assume close to flat rotation curve, sigphi2/sigR2 =~ 0.5
                + R * (1.0 / self._hr + 2.0 / self._hsr)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            if not _glqeval is None and ngl != _glqeval.shape[0]:
                _glqeval = None
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vRgl = nsigma * sigmaR1 / 2.0 * (glx + 1.0)
                vzgl = nsigma * sigmaz1 / 2.0 * (glx + 1.0)
                vRglw = glw
                vzglw = glw
            else:
                vRgl = nsigma * sigmaR1 / 2.0 * (glx12 + 1.0)
                # vRgl= 1.5/2.*(glx12+1.)
                vRgl = list(vRgl)
                vRgl.extend(-nsigma * sigmaR1 / 2.0 * (glx12 + 1.0))
                # vRgl.extend(-1.5/2.*(glx12+1.))
                vRgl = numpy.array(vRgl)
                vzgl = nsigma * sigmaz1 / 2.0 * (glx12 + 1.0)
                # vzgl= 1.5/2.*(glx12+1.)
                vzgl = list(vzgl)
                vzgl.extend(-nsigma * sigmaz1 / 2.0 * (glx12 + 1.0))
                # vzgl.extend(-1.5/2.*(glx12+1.))
                vzgl = numpy.array(vzgl)
                vRglw = glw12
                vRglw = list(vRglw)
                vRglw.extend(glw12)
                vRglw = numpy.array(vRglw)
                vzglw = glw12
                vzglw = list(vzglw)
                vzglw.extend(glw12)
                vzglw = numpy.array(vzglw)
            vTmax = kwargs.get(&quot;vTmax&quot;, 1.5)
            vTgl = vTmax / 2.0 * (glx + 1.0)
            # Tile everything
            vTgl = numpy.tile(vTgl, (ngl, ngl, 1)).T
            vRgl = numpy.tile(numpy.reshape(vRgl, (1, ngl)).T, (ngl, 1, ngl))
            vzgl = numpy.tile(vzgl, (ngl, ngl, 1))
            vTglw = numpy.tile(glw, (ngl, ngl, 1)).T  # also tile weights
            vRglw = numpy.tile(numpy.reshape(vRglw, (1, ngl)).T, (ngl, 1, ngl))
            vzglw = numpy.tile(vzglw, (ngl, ngl, 1))
            # evaluate
            if _glqeval is None and _jr is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    R + numpy.zeros(ngl * ngl * ngl),
                    vRgl.flatten(),
                    vTgl.flatten(),
                    z + numpy.zeros(ngl * ngl * ngl),
                    vzgl.flatten(),
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (ngl, ngl, ngl))
            elif not _jr is None and _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    (_jr, _lz, _jz),
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (ngl, ngl, ngl))
            elif not _jr is None and not _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    (_jr, _lz, _jz),
                    rg=_rg,
                    kappa=_kappa,
                    nu=_nu,
                    Omega=_Omega,
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (ngl, ngl, ngl))
            else:
                logqeval = _glqeval
            if _returngl:
                return (
                    numpy.sum(
                        numpy.exp(logqeval)
                        * vRgl**n
                        * vTgl**m
                        * vzgl**o
                        * vTglw
                        * vRglw
                        * vzglw
                    )
                    * sigmaR1
                    * sigmaz1
                    * 0.125
                    * vTmax
                    * nsigma**2,
                    logqeval,
                )
            elif _return_actions and _return_freqs:
                return (
                    numpy.sum(
                        numpy.exp(logqeval)
                        * vRgl**n
                        * vTgl**m
                        * vzgl**o
                        * vTglw
                        * vRglw
                        * vzglw
                    )
                    * sigmaR1
                    * sigmaz1
                    * 0.125
                    * vTmax
                    * nsigma**2,
                    jr,
                    lz,
                    jz,
                    rg,
                    kappa,
                    nu,
                    Omega,
                )
            elif _return_actions:
                return (
                    numpy.sum(
                        numpy.exp(logqeval)
                        * vRgl**n
                        * vTgl**m
                        * vzgl**o
                        * vTglw
                        * vRglw
                        * vzglw
                    )
                    * sigmaR1
                    * sigmaz1
                    * 0.125
                    * vTmax
                    * nsigma**2,
                    jr,
                    lz,
                    jz,
                )
            else:
                return numpy.sum(
                    numpy.exp(logqeval)
                    * vRgl**n
                    * vTgl**m
                    * vzgl**o
                    * vTglw
                    * vRglw
                    * vzglw
                    * sigmaR1
                    * sigmaz1
                    * 0.125
                    * vTmax
                    * nsigma**2
                )
        elif mc:
            mvT = (thisvc - va) / gamma / sigmaR1
            if _vrs is None:
                vrs = numpy.random.normal(size=nmc)
            else:
                vrs = _vrs
            if _vts is None:
                vts = numpy.random.normal(size=nmc) + mvT
            else:
                if _rawgausssamples:
                    vts = _vts + mvT
                else:
                    vts = _vts
            if _vzs is None:
                vzs = numpy.random.normal(size=nmc)
            else:
                vzs = _vzs
            Is = _vmomentsurfaceMCIntegrand(
                vzs,
                vrs,
                vts,
                numpy.ones(nmc) * R,
                numpy.ones(nmc) * z,
                self,
                sigmaR1,
                gamma,
                sigmaz1,
                mvT,
                n,
                m,
                o,
            )
            if _returnmc:
                if _rawgausssamples:
                    return (
                        numpy.mean(Is)
                        * sigmaR1 ** (2.0 + n + m)
                        * gamma ** (1.0 + m)
                        * sigmaz1 ** (1.0 + o),
                        vrs,
                        vts - mvT,
                        vzs,
                    )
                else:
                    return (
                        numpy.mean(Is)
                        * sigmaR1 ** (2.0 + n + m)
                        * gamma ** (1.0 + m)
                        * sigmaz1 ** (1.0 + o),
                        vrs,
                        vts,
                        vzs,
                    )
            else:
                return (
                    numpy.mean(Is)
                    * sigmaR1 ** (2.0 + n + m)
                    * gamma ** (1.0 + m)
                    * sigmaz1 ** (1.0 + o)
                )
        else:  # pragma: no cover because this is too slow; a warning is shown
            warnings.warn(
                &quot;Calculations using direct numerical integration using tplquad is not recommended and extremely slow; it has also not been carefully tested&quot;,
                galpyWarning,
            )
            return (
                integrate.tplquad(
                    _vmomentsurfaceIntegrand,
                    1.0 / gamma * (thisvc - va) / sigmaR1 - nsigma,
                    1.0 / gamma * (thisvc - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    lambda x, y: 0.0,
                    lambda x, y: nsigma,
                    (R, z, self, sigmaR1, gamma, sigmaz1, n, m, o),
                    **kwargs,
                )[0]
                * sigmaR1 ** (2.0 + n + m)
                * gamma ** (1.0 + m)
                * sigmaz1 ** (1.0 + o)
            )

    def jmomentdensity(self, *args, **kwargs):
        &quot;&quot;&quot;
        Calculate the an arbitrary moment of an action of the velocity distribution at R times the surfacmass.

        Parameters
        ----------
        R : float
            radius at which to calculate the moment(/ro)
        z : float
            height at which to calculate the moment(/ro)
        n : int
            jr^n
        m : int
            lz^m
        o : int
            jz^o
        nsigma : int, optional
            Number of sigma to integrate the velocities over (when doing explicit numerical integral). Default is None.
        mc : bool, optional
            If True, calculate using Monte Carlo integration. Default is False.
        nmc : int, optional
            If mc is True, use nmc samples. Default is None.

        Returns
        -------
        float or Quantity
            &lt;jr^n lz^m jz^o  x density&gt; at R (no support for units)

        Notes
        -----
        - 2012-08-09 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        ro = kwargs.pop(&quot;ro&quot;, None)
        if ro is None and hasattr(self, &quot;_roSet&quot;) and self._roSet:
            ro = self._ro
        ro = parse_length_kpc(ro)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = parse_velocity_kms(vo)
        if use_physical and not vo is None and not ro is None:
            fac = (ro * vo) ** (args[2] + args[3] + args[4]) / ro**3
            if _APY_UNITS:
                u = (
                    1
                    / units.kpc**3
                    * (units.kpc * units.km / units.s) ** (args[2] + args[3] + args[4])
                )
            out = self._jmomentdensity(*args, **kwargs)
            if _APY_UNITS:
                return units.Quantity(out * fac, unit=u)
            else:
                return out * fac
        else:
            return self._jmomentdensity(*args, **kwargs)

    def _jmomentdensity(
        self,
        R,
        z,
        n,
        m,
        o,
        nsigma=None,
        mc=True,
        nmc=10000,
        _returnmc=False,
        _vrs=None,
        _vts=None,
        _vzs=None,
        **kwargs,
    ):
        &quot;&quot;&quot;Non-physical version of jmomentdensity, otherwise the same&quot;&quot;&quot;
        if nsigma == None:
            nsigma = _NSIGMA
        sigmaR1 = self._sr * numpy.exp((self._refr - R) / self._hsr)
        sigmaz1 = self._sz * numpy.exp((self._refr - R) / self._hsz)
        thisvc = potential.vcirc(self._pot, R, use_physical=False)
        # Use the asymmetric drift equation to estimate va
        gamma = numpy.sqrt(0.5)
        va = (
            sigmaR1**2.0
            / 2.0
            / thisvc
            * (
                gamma**2.0
                - 1.0  # Assume close to flat rotation curve, sigphi2/sigR2 =~ 0.5
                + R * (1.0 / self._hr + 2.0 / self._hsr)
            )
        )
        if numpy.fabs(va) &gt; sigmaR1:
            va = 0.0  # To avoid craziness near the center
        if mc:
            mvT = (thisvc - va) / gamma / sigmaR1
            if _vrs is None:
                vrs = numpy.random.normal(size=nmc)
            else:
                vrs = _vrs
            if _vts is None:
                vts = numpy.random.normal(size=nmc) + mvT
            else:
                vts = _vts
            if _vzs is None:
                vzs = numpy.random.normal(size=nmc)
            else:
                vzs = _vzs
            Is = _jmomentsurfaceMCIntegrand(
                vzs,
                vrs,
                vts,
                numpy.ones(nmc) * R,
                numpy.ones(nmc) * z,
                self,
                sigmaR1,
                gamma,
                sigmaz1,
                mvT,
                n,
                m,
                o,
            )
            if _returnmc:
                return (
                    numpy.mean(Is) * sigmaR1**2.0 * gamma * sigmaz1,
                    vrs,
                    vts,
                    vzs,
                )
            else:
                return numpy.mean(Is) * sigmaR1**2.0 * gamma * sigmaz1
        else:  # pragma: no cover because this is too slow; a warning is shown
            warnings.warn(
                &quot;Calculations using direct numerical integration using tplquad is not recommended and extremely slow; it has also not been carefully tested&quot;,
                galpyWarning,
            )
            return (
                integrate.tplquad(
                    _jmomentsurfaceIntegrand,
                    1.0 / gamma * (thisvc - va) / sigmaR1 - nsigma,
                    1.0 / gamma * (thisvc - va) / sigmaR1 + nsigma,
                    lambda x: 0.0,
                    lambda x: nsigma,
                    lambda x, y: 0.0,
                    lambda x, y: nsigma,
                    (R, z, self, sigmaR1, gamma, sigmaz1, n, m, o),
                    **kwargs,
                )[0]
                * sigmaR1**2.0
                * gamma
                * sigmaz1
            )

    @potential_physical_input
    @physical_conversion(&quot;numberdensity&quot;, pop=True)
    def density(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the density at R,z by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate the density.
        z : float or Quantity
            Height at which to calculate the density.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Density at (R,z).

        Notes
        -----
        - 2012-07-26 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        return self._vmomentdensity(
            R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, gl=gl, ngl=ngl, **kwargs
        )

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaR2(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate sigma_R^2 by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            sigma_R^2.

        Notes
        -----
        - 2012-07-30 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    2.0,
                    0.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 2.0, 0.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 2.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaRz(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate sigma_RZ^2 by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            sigma_Rz^2.

        Notes
        -----
        - 2012-07-30 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    1.0,
                    0.0,
                    1.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 1.0, 0.0, 1.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 1.0, 0.0, 1.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;angle&quot;, pop=True)
    def tilt(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the tilt of the velocity ellipsoid by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.

        Returns
        -------
        float
            Tilt in radians.

        Notes
        -----
        - 2012-12-23 - Written - Bovy (IAS)
        - 2017-10-28 - Changed return unit to rad - Bovy (UofT)
        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            tsigmar2 = (
                self._vmomentdensity(
                    R,
                    z,
                    2.0,
                    0.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
            tsigmaz2 = (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    0.0,
                    2.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
            tsigmarz = (
                self._vmomentdensity(
                    R,
                    z,
                    1.0,
                    0.0,
                    1.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
            return 0.5 * numpy.arctan(2.0 * tsigmarz / (tsigmar2 - tsigmaz2))
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            tsigmar2 = (
                self._vmomentdensity(
                    R, z, 2.0, 0.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
            tsigmaz2 = (
                self._vmomentdensity(
                    R, z, 0.0, 0.0, 2.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
            tsigmarz = (
                self._vmomentdensity(
                    R, z, 1.0, 0.0, 1.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
            return 0.5 * numpy.arctan(2.0 * tsigmarz / (tsigmar2 - tsigmaz2))
        else:
            raise NotImplementedError(&quot;Use either mc=True or gl=True&quot;)

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaz2(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate sigma_z^2 by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            sigma_z^2.

        Notes
        -----
        - 2012-07-30 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    0.0,
                    2.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 0.0, 0.0, 2.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 0.0, 0.0, 2.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def meanvT(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the mean rotational velocity by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Mean rotational velocity.

        Notes
        -----
        - 2012-07-30 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    1.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 0.0, 1.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 0.0, 1.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def meanvR(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the mean radial velocity by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Mean radial velocity.

        Notes
        -----
        - 2012-12-23 - Written - Bovy (IAS)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    1.0,
                    0.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 1.0, 0.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 1.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity&quot;, pop=True)
    def meanvz(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate the mean vertical velocity by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs : dict, optional
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Mean vertical velocity

        Notes
        -----
        - 2012-12-23 - Written - Bovy (IAS)
        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    0.0,
                    1.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 0.0, 0.0, 1.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._vmomentdensity(
                R, z, 0.0, 0.0, 1.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;velocity2&quot;, pop=True)
    def sigmaT2(
        self, R, z, nsigma=None, mc=False, nmc=10000, gl=True, ngl=_DEFAULTNGL, **kwargs
    ):
        &quot;&quot;&quot;
        Calculate sigma_T^2 by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : int, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc is True, use nmc samples.
        gl : bool, optional
            If True, calculate using Gauss-Legendre integration.
        ngl : int, optional
            If gl is True, use ngl-th order Gauss-Legendre integration for each dimension.
        **kwargs
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            sigma_T^2.

        Notes
        -----
        - 2012-07-30 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            mvt = (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    1.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
            return (
                self._vmomentdensity(
                    R,
                    z,
                    0.0,
                    2.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
                - mvt**2.0
            )
        elif gl:
            surfmass, glqeval = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, gl=gl, ngl=ngl, _returngl=True, **kwargs
            )
            mvt = (
                self._vmomentdensity(
                    R, z, 0.0, 1.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
            )
            return (
                self._vmomentdensity(
                    R, z, 0.0, 2.0, 0.0, ngl=ngl, gl=gl, _glqeval=glqeval, **kwargs
                )
                / surfmass
                - mvt**2.0
            )

        else:  # pragma: no cover because this is too slow; a warning is shown
            surfmass = self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )
            return (
                self._vmomentdensity(
                    R, z, 0.0, 2.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
                )
                / surfmass
                - (
                    self._vmomentdensity(
                        R, z, 0.0, 2.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
                    )
                    / surfmass
                )
                ** 2.0
            )

    @potential_physical_input
    @physical_conversion(&quot;action&quot;, pop=True)
    def meanjr(self, R, z, nsigma=None, mc=True, nmc=10000, **kwargs):
        &quot;&quot;&quot;
        Calculate the mean radial action by marginalizing over velocity

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this
        z : float or Quantity
            Height at which to calculate this
        nsigma : float, optional
            Number of sigma to integrate the velocities over
        mc : bool, optional
            If True, calculate using Monte Carlo integration
        nmc : int, optional
            If mc, use nmc samples
        **kwargs : dict
            scipy.integrate.tplquad kwargs epsabs and epsrel

        Returns
        -------
        float
            Mean jr

        Notes
        -----
        - 2012-08-09 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._jmomentdensity(
                    R,
                    z,
                    1.0,
                    0.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._jmomentdensity(
                R, z, 1.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;action&quot;, pop=True)
    def meanlz(self, R, z, nsigma=None, mc=True, nmc=10000, **kwargs):
        &quot;&quot;&quot;
        Calculate the mean angular momentum by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        **kwargs
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Mean angular momentum.

        Notes
        -----
        - 2012-08-09 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;

        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._jmomentdensity(
                    R,
                    z,
                    0.0,
                    1.0,
                    0.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._jmomentdensity(
                R, z, 0.0, 1.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    @physical_conversion(&quot;action&quot;, pop=True)
    def meanjz(self, R, z, nsigma=None, mc=True, nmc=10000, **kwargs):
        &quot;&quot;&quot;
        Calculate the mean vertical action by marginalizing over velocity.

        Parameters
        ----------
        R : float or Quantity
            Radius at which to calculate this.
        z : float or Quantity
            Height at which to calculate this.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        mc : bool, optional
            If True, calculate using Monte Carlo integration.
        nmc : int, optional
            If mc, use nmc samples.
        **kwargs : dict
            scipy.integrate.tplquad kwargs epsabs and epsrel.

        Returns
        -------
        float
            Mean jz.

        Notes
        -----
        - 2012-08-09 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        if mc:
            surfmass, vrs, vts, vzs = self._vmomentdensity(
                R,
                z,
                0.0,
                0.0,
                0.0,
                nsigma=nsigma,
                mc=mc,
                nmc=nmc,
                _returnmc=True,
                **kwargs,
            )
            return (
                self._jmomentdensity(
                    R,
                    z,
                    0.0,
                    0.0,
                    1.0,
                    nsigma=nsigma,
                    mc=mc,
                    nmc=nmc,
                    _returnmc=False,
                    _vrs=vrs,
                    _vts=vts,
                    _vzs=vzs,
                    **kwargs,
                )
                / surfmass
            )
        else:  # pragma: no cover because this is too slow; a warning is shown
            return self._jmomentdensity(
                R, z, 0.0, 0.0, 1.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            ) / self._vmomentdensity(
                R, z, 0.0, 0.0, 0.0, nsigma=nsigma, mc=mc, nmc=nmc, **kwargs
            )

    @potential_physical_input
    def sampleV(self, R, z, n=1, **kwargs):
        &quot;&quot;&quot;
        Sample a radial, azimuthal, and vertical velocity at R,z

        Parameters
        ----------
        R : float or Quantity
            Galactocentric distance.
        z : float or Quantity
            Height.
        n : int, optional
            Number of distances to sample.

        Returns
        -------
        list
            List of samples.

        Notes
        -----
        - 2012-12-17 - Written - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = parse_velocity_kms(vo)
        # Determine the maximum of the velocity distribution
        maxVR = 0.0
        maxVz = 0.0
        # scipy 1.5.0: issue scipy#12298: fmin_powell now returns multiD array,
        # so squeeze out single dimensions by hand
        maxVT = numpy.squeeze(
            optimize.fmin_powell(
                (lambda x: -self(R, 0.0, x, z, 0.0, log=True, use_physical=False)), 1.0
            )
        )
        logmaxVD = self(R, maxVR, maxVT, z, maxVz, log=True, use_physical=False)
        # Now rejection-sample
        vRs = []
        vTs = []
        vzs = []
        while len(vRs) &lt; n:
            nmore = n - len(vRs) + 1
            # sample
            propvR = numpy.random.normal(size=nmore) * 2.0 * self._sr
            propvT = numpy.random.normal(size=nmore) * 2.0 * self._sr + maxVT
            propvz = numpy.random.normal(size=nmore) * 2.0 * self._sz
            VDatprop = (
                self(
                    R + numpy.zeros(nmore),
                    propvR,
                    propvT,
                    z + numpy.zeros(nmore),
                    propvz,
                    log=True,
                    use_physical=False,
                )
                - logmaxVD
            )
            VDatprop -= -0.5 * (
                propvR**2.0 / 4.0 / self._sr**2.0
                + propvz**2.0 / 4.0 / self._sz**2.0
                + (propvT - maxVT) ** 2.0 / 4.0 / self._sr**2.0
            )
            VDatprop = numpy.reshape(VDatprop, (nmore))
            indx = VDatprop &gt; numpy.log(numpy.random.random(size=nmore))  # accept
            vRs.extend(list(propvR[indx]))
            vTs.extend(list(propvT[indx]))
            vzs.extend(list(propvz[indx]))
        out = numpy.empty((n, 3))
        out[:, 0] = vRs[0:n]
        out[:, 1] = vTs[0:n]
        out[:, 2] = vzs[0:n]
        if use_physical and not vo is None:
            if _APY_UNITS:
                return units.Quantity(out * vo, unit=units.km / units.s)
            else:
                return out * vo
        else:
            return out

    @potential_physical_input
    def sampleV_interpolate(
        self,
        R,
        z,
        R_pixel,
        z_pixel,
        num_std=3,
        R_min=None,
        R_max=None,
        z_max=None,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Sample radial, azimuthal, and vertical velocity at R,z using interpolation.

        Parameters
        ----------
        R : numpy.ndarray or Quantity
            Galactocentric distance.
        z : numpy.ndarray or Quantity
            Height.
        R_pixel : float
            The pixel size for creating the grid for interpolation (in natural units).
        z_pixel : float
            The pixel size for creating the grid for interpolation (in natural units).
        num_std : float, optional
            Number of standard deviation to be considered outliers sampled separately from interpolation.
        R_min : float, optional
            Minimum R value for the grid.
        R_max : float, optional
            Maximum R value for the grid.
        z_max : float, optional
            Maximum z value for the grid.

        Returns
        -------
        numpy.ndarray
            A numpy array containing the sampled velocity, (vR, vT, vz), where each row corresponds to the row of (R,z).

        Notes
        -----
        - 2018-08-10 - Written - Samuel Wong (University of Toronto)
        &quot;&quot;&quot;
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = parse_velocity_kms(vo)
        # Initialize output array
        coord_v = numpy.empty((numpy.size(R), 3))
        # Since the sign of z doesn't matter, work with absolute value of z
        z = numpy.abs(z)
        # Grid edges
        if R_min is None:
            R_min = numpy.amax([numpy.mean(R) - num_std * numpy.std(R), numpy.amin(R)])
        if R_max is None:
            R_max = numpy.amin([numpy.mean(R) + num_std * numpy.std(R), numpy.amax(R)])
        if z_max is None:
            z_max = numpy.amin([numpy.mean(z) + num_std * numpy.std(z), numpy.amax(z)])
        z_min = 0.0  # Always start grid at z=0 for stars close to plane
        # Separate the coordinates into outliers and normal points
        # Define outliers as points outside of grid
        mask = numpy.any([R &lt; R_min, R &gt; R_max, z &gt; z_max], axis=0)
        outliers_R = R[mask]
        outliers_z = z[mask]
        normal_R = R[~mask]
        normal_z = z[~mask]
        # Sample the velocity of outliers directly (without interpolation)
        outlier_coord_v = numpy.empty((outliers_R.size, 3))
        for i in range(outliers_R.size):
            outlier_coord_v[i] = self.sampleV(
                outliers_R[i], outliers_z[i], use_physical=False
            )[0]
        # Prepare for optimizing maxVT on a grid
        # Get the new hash of the parameters of grid
        new_hash = hashlib.md5(
            numpy.array([R_min, R_max, z_max, R_pixel, z_pixel])
        ).hexdigest()
        # Reuse old interpolated object if new hash matches the old one
        if new_hash == self._maxVT_hash:
            ip_max_vT = self._maxVT_ip
        # Generate a new interpolation object if different from before
        else:
            R_number = int((R_max - R_min) / R_pixel)
            z_number = int((z_max - z_min) / z_pixel)
            R_linspace = numpy.linspace(R_min, R_max, R_number)
            z_linspace = numpy.linspace(z_min, z_max, z_number)
            Rv, zv = numpy.meshgrid(R_linspace, z_linspace)
            grid = numpy.dstack((Rv, zv))  # This grid stores (R,z) coordinate
            # Grid is a 3 dimensional array since it stores pairs of values, but
            # grid max vT is a 2 dimensional array
            grid_max_vT = numpy.empty((grid.shape[0], grid.shape[1]))
            # Optimize max_vT on the grid
            for i in range(z_number):
                for j in range(R_number):
                    R, z = grid[i][j]
                    grid_max_vT[i][j] = numpy.squeeze(
                        optimize.fmin_powell(
                            (
                                lambda x: -self(
                                    R, 0.0, x, z, 0.0, log=True, use_physical=False
                                )
                            ),
                            1.0,
                        )
                    )
            # Determine degree of interpolation
            ky = numpy.min([R_number - 1, 3])
            kx = numpy.min([z_number - 1, 3])
            # Generate interpolation object
            ip_max_vT = interpolate.RectBivariateSpline(
                z_linspace, R_linspace, grid_max_vT, kx=kx, ky=ky
            )
            # Store interpolation object
            self._maxVT_ip = ip_max_vT
            # Update hash of parameters
            self._maxVT_hash = new_hash
        # Evaluate interpolation object to get maxVT at the normal coordinates
        normal_max_vT = ip_max_vT.ev(normal_z, normal_R)
        # Sample all 3 velocities at a normal point and use interpolated vT
        normal_coord_v = self._sampleV_preoptimized(normal_R, normal_z, normal_max_vT)
        # Combine normal and outlier result, preserving original order
        coord_v[mask] = outlier_coord_v
        coord_v[~mask] = normal_coord_v
        if use_physical and not vo is None:
            if _APY_UNITS:
                return units.Quantity(coord_v * vo, unit=units.km / units.s)
            else:
                return coord_v * vo
        else:
            return coord_v

    def _sampleV_preoptimized(self, R, z, maxVT):
        &quot;&quot;&quot;
        Sample a radial, azimuthal, and vertical velocity at R,z.

        Parameters
        ----------
        R : float or numpy.ndarray
            Galactocentric distance.
        z : float or numpy.ndarray
            Height.
        maxVT : numpy.ndarray
            An array of pre-optimized maximum vT at corresponding R,z.

        Returns
        -------
        numpy.ndarray
            A numpy array containing the sampled velocity, (vR, vT, vz), where each row correspond to the row of (R,z).

        Notes
        -----
        - 2018-08-10 - Written - Samuel Wong (University of Toronto)

        &quot;&quot;&quot;
        length = numpy.size(R)
        out = numpy.empty((length, 3))  # Initialize output
        # Determine the maximum of the velocity distribution
        maxVR = numpy.zeros(length)
        maxVz = numpy.zeros(length)
        logmaxVD = self(R, maxVR, maxVT, z, maxVz, log=True, use_physical=False)
        # Now rejection-sample
        # Initialize boolean index of position remaining to be sampled
        remain_indx = numpy.full(length, True)
        while numpy.any(remain_indx):
            nmore = numpy.sum(remain_indx)
            propvR = numpy.random.normal(size=nmore) * 2.0 * self._sr
            propvT = (
                numpy.random.normal(size=nmore) * 2.0 * self._sr + maxVT[remain_indx]
            )
            propvz = numpy.random.normal(size=nmore) * 2.0 * self._sz
            VDatprop = (
                self(
                    R[remain_indx],
                    propvR,
                    propvT,
                    z[remain_indx],
                    propvz,
                    log=True,
                    use_physical=False,
                )
                - logmaxVD[remain_indx]
            )
            VDatprop -= -0.5 * (
                propvR**2.0 / 4.0 / self._sr**2.0
                + propvz**2.0 / 4.0 / self._sz**2.0
                + (propvT - maxVT[remain_indx]) ** 2.0 / 4.0 / self._sr**2.0
            )
            accept_indx = VDatprop &gt; numpy.log(numpy.random.random(size=nmore))
            vR_accept = propvR[accept_indx]
            vT_accept = propvT[accept_indx]
            vz_accept = propvz[accept_indx]
            # Get the indexing of rows of output array that need to be updated
            # with newly accepted velocity
            to_change = numpy.copy(remain_indx)
            to_change[remain_indx] = accept_indx
            out[to_change] = numpy.stack((vR_accept, vT_accept, vz_accept), axis=1)
            # Removing accepted sampled from remain index
            remain_indx[remain_indx] = ~accept_indx
        return out

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity2&quot;, pop=True)
    def pvR(self, vR, R, z, gl=True, ngl=_DEFAULTNGL2, nsigma=4.0, vTmax=1.5):
        &quot;&quot;&quot;
        Calculate the marginalized vR probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vR : float or Quantity
            Radial velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        vTmax : float, optional
            Sets integration limits to [0,vTmax] for integration over vT.

        Returns
        -------
        float
            p(vR,R,z).

        Notes
        -----
        - 2012-12-22 - Written - Bovy (IAS@MPIA)

        &quot;&quot;&quot;
        sigmaz1 = self._sz * numpy.exp((self._refr - R) / self._hsz)
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vzgl = nsigma * sigmaz1 / 2.0 * (glx + 1.0)
                vzglw = glw
                vzfac = nsigma * sigmaz1  # 2 x integration over [0,nsigma*sigmaz1]
            else:
                vzgl = nsigma * sigmaz1 / 2.0 * (glx12 + 1.0)
                vzgl = list(vzgl)
                vzgl.extend(-nsigma * sigmaz1 / 2.0 * (glx12 + 1.0))
                vzgl = numpy.array(vzgl)
                vzglw = glw12
                vzglw = list(vzglw)
                vzglw.extend(glw12)
                vzglw = numpy.array(vzglw)
                vzfac = (
                    0.5 * nsigma * sigmaz1
                )  # integration over [-nsigma*sigmaz1,0] and [0,nsigma*sigmaz1]
            vTgl = vTmax / 2.0 * (glx + 1.0)
            vTfac = 0.5 * vTmax  # integration over [0.,vTmax]
            # Tile everything
            vTgl = numpy.tile(vTgl, (ngl, 1)).T
            vzgl = numpy.tile(vzgl, (ngl, 1))
            vTglw = numpy.tile(glw, (ngl, 1)).T  # also tile weights
            vzglw = numpy.tile(vzglw, (ngl, 1))
            # evaluate
            logqeval = numpy.reshape(
                self(
                    R + numpy.zeros(ngl * ngl),
                    vR + numpy.zeros(ngl * ngl),
                    vTgl.flatten(),
                    z + numpy.zeros(ngl * ngl),
                    vzgl.flatten(),
                    log=True,
                    use_physical=False,
                ),
                (ngl, ngl),
            )
            return numpy.sum(numpy.exp(logqeval) * vTglw * vzglw * vzfac) * vTfac

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity2&quot;, pop=True)
    def pvT(self, vT, R, z, gl=True, ngl=_DEFAULTNGL2, nsigma=4.0):
        &quot;&quot;&quot;
        Calculate the marginalized vT probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vT : float or Quantity
            Azimuthal velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.

        Returns
        -------
        float
            p(vT,R,z).

        Notes
        -----
        - 2012-12-22 - Written - Bovy (IAS@MPIA)
        - 2018-01-12 - Added Gauss-Legendre integration prefactor nsigma^2/4 - Trick (MPA)

        &quot;&quot;&quot;
        sigmaR1 = self._sr * numpy.exp((self._refr - R) / self._hsr)
        sigmaz1 = self._sz * numpy.exp((self._refr - R) / self._hsz)
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vRgl = nsigma * sigmaR1 / 2.0 * (glx + 1.0)
                vzgl = nsigma * sigmaz1 / 2.0 * (glx + 1.0)
                vRglw = glw
                vzglw = glw
                vRfac = nsigma * sigmaR1  # 2 x integration over [0,nsigma*sigmaR1]
                vzfac = nsigma * sigmaz1  # 2 x integration over [0,nsigma*sigmaz1]
            else:
                vRgl = nsigma * sigmaR1 / 2.0 * (glx12 + 1.0)
                vRgl = list(vRgl)
                vRgl.extend(-nsigma * sigmaR1 / 2.0 * (glx12 + 1.0))
                vRgl = numpy.array(vRgl)
                vzgl = nsigma * sigmaz1 / 2.0 * (glx12 + 1.0)
                vzgl = list(vzgl)
                vzgl.extend(-nsigma * sigmaz1 / 2.0 * (glx12 + 1.0))
                vzgl = numpy.array(vzgl)
                vRglw = glw12
                vRglw = list(vRglw)
                vRglw.extend(glw12)
                vRglw = numpy.array(vRglw)
                vzglw = glw12
                vzglw = list(vzglw)
                vzglw.extend(glw12)
                vzglw = numpy.array(vzglw)
                vRfac = (
                    0.5 * nsigma * sigmaR1
                )  # integration over [-nsigma*sigmaR1,0] and [0,nsigma*sigmaR1]
                vzfac = (
                    0.5 * nsigma * sigmaz1
                )  # integration over [-nsigma*sigmaz1,0] and [0,nsigma*sigmaz1]
            # Tile everything
            vRgl = numpy.tile(vRgl, (ngl, 1)).T
            vzgl = numpy.tile(vzgl, (ngl, 1))
            vRglw = numpy.tile(vRglw, (ngl, 1)).T  # also tile weights
            vzglw = numpy.tile(vzglw, (ngl, 1))
            # evaluate
            logqeval = numpy.reshape(
                self(
                    R + numpy.zeros(ngl * ngl),
                    vRgl.flatten(),
                    vT + numpy.zeros(ngl * ngl),
                    z + numpy.zeros(ngl * ngl),
                    vzgl.flatten(),
                    log=True,
                    use_physical=False,
                ),
                (ngl, ngl),
            )
            return numpy.sum(numpy.exp(logqeval) * vRglw * vzglw * vRfac * vzfac)

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity2&quot;, pop=True)
    def pvz(
        self,
        vz,
        R,
        z,
        gl=True,
        ngl=_DEFAULTNGL2,
        nsigma=4.0,
        vTmax=1.5,
        _return_actions=False,
        _jr=None,
        _lz=None,
        _jz=None,
        _return_freqs=False,
        _rg=None,
        _kappa=None,
        _nu=None,
        _Omega=None,
        _sigmaR1=None,
    ):
        &quot;&quot;&quot;
        Calculate the marginalized vz probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vz : float or Quantity
            Vertical velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.
        vTmax : float, optional
            Sets integration limits to [0,vTmax] for integration over vT.

        Returns
        -------
        float
            p(vz,R,z).

        Notes
        -----
        - 2012-12-22 - Written - Bovy (IAS)
        &quot;&quot;&quot;
        if _sigmaR1 is None:
            sigmaR1 = self._sr * numpy.exp((self._refr - R) / self._hsr)
        else:
            sigmaR1 = _sigmaR1
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vRgl = glx + 1.0
                vRglw = glw
                vRfac = nsigma * sigmaR1  # 2 x integration over [0,nsigma*sigmaR1]
            else:
                vRgl = glx12 + 1.0
                vRgl = list(vRgl)
                vRgl.extend(-(glx12 + 1.0))
                vRgl = numpy.array(vRgl)
                vRglw = glw12
                vRglw = list(vRglw)
                vRglw.extend(glw12)
                vRglw = numpy.array(vRglw)
                vRfac = (
                    0.5 * nsigma * sigmaR1
                )  # integration over [-nsigma*sigmaR1,0] and [0,nsigma*sigmaR1]
            vTgl = vTmax / 2.0 * (glx + 1.0)
            vTfac = 0.5 * vTmax  # integration over [0.,vTmax]
            # Tile everything
            vTgl = numpy.tile(vTgl, (ngl, 1)).T
            vRgl = numpy.tile(vRgl, (ngl, 1))
            vTglw = numpy.tile(glw, (ngl, 1)).T  # also tile weights
            vRglw = numpy.tile(vRglw, (ngl, 1))
            # If inputs are arrays, tile
            if isinstance(R, numpy.ndarray):
                nR = len(R)
                R = numpy.tile(R, (ngl, ngl, 1)).T.flatten()
                z = numpy.tile(z, (ngl, ngl, 1)).T.flatten()
                vz = numpy.tile(vz, (ngl, ngl, 1)).T.flatten()
                vTgl = numpy.tile(vTgl, (nR, 1, 1)).flatten()
                vRgl = numpy.tile(vRgl, (nR, 1, 1)).flatten()
                vTglw = numpy.tile(vTglw, (nR, 1, 1))
                vRglw = numpy.tile(vRglw, (nR, 1, 1))
                scalarOut = False
            else:
                R = R + numpy.zeros(ngl * ngl)
                z = z + numpy.zeros(ngl * ngl)
                vz = vz + numpy.zeros(ngl * ngl)
                nR = 1
                scalarOut = True
                vRgl = vRgl.flatten()
            vRgl *= numpy.tile(nsigma * sigmaR1 / 2.0, (ngl, ngl, 1)).T.flatten()
            # evaluate
            if _jr is None and _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    R,
                    vRgl.flatten(),
                    vTgl.flatten(),
                    z,
                    vz,
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (nR, ngl * ngl))
            elif not _jr is None and not _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    (_jr, _lz, _jz),
                    rg=_rg,
                    kappa=_kappa,
                    nu=_nu,
                    Omega=_Omega,
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (nR, ngl * ngl))
            elif not _jr is None and _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    (_jr, _lz, _jz),
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (nR, ngl * ngl))
            elif _jr is None and not _rg is None:
                logqeval, jr, lz, jz, rg, kappa, nu, Omega = self(
                    R,
                    vRgl.flatten(),
                    vTgl.flatten(),
                    z,
                    vz,
                    rg=_rg,
                    kappa=_kappa,
                    nu=_nu,
                    Omega=_Omega,
                    log=True,
                    _return_actions=True,
                    _return_freqs=True,
                    use_physical=False,
                )
                logqeval = numpy.reshape(logqeval, (nR, ngl * ngl))
            vRglw = numpy.reshape(vRglw, (nR, ngl * ngl))
            vTglw = numpy.reshape(vTglw, (nR, ngl * ngl))
            if scalarOut:
                result = (
                    numpy.sum(numpy.exp(logqeval) * vTglw * vRglw, axis=1)[0]
                    * vRfac
                    * vTfac
                )
            else:
                result = (
                    numpy.sum(numpy.exp(logqeval) * vTglw * vRglw, axis=1)
                    * vRfac
                    * vTfac
                )
            if _return_actions and _return_freqs:
                return (result, jr, lz, jz, rg, kappa, nu, Omega)
            elif _return_freqs:
                return (result, rg, kappa, nu, Omega)
            elif _return_actions:
                return (result, jr, lz, jz)
            else:
                return result

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity&quot;, pop=True)
    def pvRvT(self, vR, vT, R, z, gl=True, ngl=_DEFAULTNGL2, nsigma=4.0):
        &quot;&quot;&quot;
        Calculate the marginalized (vR,vT) probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vR : float or Quantity
            Radial velocity.
        vT : float or Quantity
            Azimuthal velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.

        Returns
        -------
        float
            p(vR,vT,R,z).

        Notes
        -----
        - 2012-12-22 - Written - Bovy (IAS)
        - 2018-01-12 - Added Gauss-Legendre integration prefactor nsigma/2 - Trick (MPA)
        &quot;&quot;&quot;
        sigmaz1 = self._sz * numpy.exp((self._refr - R) / self._hsz)
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vzgl = nsigma * sigmaz1 / 2.0 * (glx + 1.0)
                vzglw = glw
                vzfac = nsigma * sigmaz1  # 2 x integration over [0,nsigma*sigmaz1]
            else:
                vzgl = nsigma * sigmaz1 / 2.0 * (glx12 + 1.0)
                vzgl = list(vzgl)
                vzgl.extend(-nsigma * sigmaz1 / 2.0 * (glx12 + 1.0))
                vzgl = numpy.array(vzgl)
                vzglw = glw12
                vzglw = list(vzglw)
                vzglw.extend(glw12)
                vzglw = numpy.array(vzglw)
                vzfac = (
                    0.5 * nsigma * sigmaz1
                )  # integration over [-nsigma*sigmaz1,0] and [0,nsigma*sigmaz1]
            # evaluate
            logqeval = self(
                R + numpy.zeros(ngl),
                vR + numpy.zeros(ngl),
                vT + numpy.zeros(ngl),
                z + numpy.zeros(ngl),
                vzgl,
                log=True,
                use_physical=False,
            )
            return numpy.sum(numpy.exp(logqeval) * vzglw * vzfac)

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity&quot;, pop=True)
    def pvTvz(self, vT, vz, R, z, gl=True, ngl=_DEFAULTNGL2, nsigma=4.0):
        &quot;&quot;&quot;
        Calculate the marginalized (vT,vz) probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vT : float or Quantity
            Azimuthal velocity.
        vz : float or Quantity
            Vertical velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        nsigma : float, optional
            Number of sigma to integrate the velocities over.

        Returns
        -------
        float or Quantity
            p(vT,vz,R,z).

        Notes
        -----
        - 2012-12-22 - Written - Bovy (IAS)
        - 2018-01-12 - Added Gauss-Legendre integration prefactor nsigma/2 - Trick (MPA)

        &quot;&quot;&quot;
        sigmaR1 = self._sr * numpy.exp((self._refr - R) / self._hsr)
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            if isinstance(
                self._aA,
                (
                    actionAngle.actionAngleAdiabatic,
                    actionAngle.actionAngleAdiabaticGrid,
                ),
            ):
                vRgl = nsigma * sigmaR1 / 2.0 * (glx + 1.0)
                vRglw = glw
                vRfac = nsigma * sigmaR1  # 2 x integration over [0,nsigma*sigmaR1]
            else:
                vRgl = nsigma * sigmaR1 / 2.0 * (glx12 + 1.0)
                vRgl = list(vRgl)
                vRgl.extend(-nsigma * sigmaR1 / 2.0 * (glx12 + 1.0))
                vRgl = numpy.array(vRgl)
                vRglw = glw12
                vRglw = list(vRglw)
                vRglw.extend(glw12)
                vRglw = numpy.array(vRglw)
                vRfac = (
                    0.5 * nsigma * sigmaR1
                )  # integration over [-nsigma*sigmaR1,0] and [0,nsigma*sigmaR1]
            # evaluate
            logqeval = self(
                R + numpy.zeros(ngl),
                vRgl,
                vT + numpy.zeros(ngl),
                z + numpy.zeros(ngl),
                vz + numpy.zeros(ngl),
                log=True,
                use_physical=False,
            )
            return numpy.sum(numpy.exp(logqeval) * vRglw * vRfac)

    @actionAngle_physical_input
    @physical_conversion(&quot;phasespacedensityvelocity&quot;, pop=True)
    def pvRvz(self, vR, vz, R, z, gl=True, ngl=_DEFAULTNGL2, vTmax=1.5):
        &quot;&quot;&quot;
        Calculate the marginalized (vR,vz) probability at this location (NOT normalized by the density).

        Parameters
        ----------
        vR : float or Quantity
            Radial velocity.
        vz : float or Quantity
            Vertical velocity.
        R : float or Quantity
            Radius.
        z : float or Quantity
            Height.
        gl : bool, optional
            If True, use Gauss-Legendre integration.
        ngl : int, optional
            If gl, use ngl-th order Gauss-Legendre integration for each dimension.
        vTmax : float, optional
            Sets integration limits to [0,vTmax] for integration over vT.

        Returns
        -------
        float or Quantity
            p(vR,vz,R,z).

        Notes
        -----
        - 2013-01-02 - Written - Bovy (IAS)
        - 2018-01-12 - Added Gauss-Legendre integration prefactor vTmax/2 - Trick (MPA)
        &quot;&quot;&quot;
        if gl:
            if ngl % 2 == 1:
                raise ValueError(&quot;ngl must be even&quot;)
            # Use Gauss-Legendre integration for all
            if ngl == _DEFAULTNGL:
                glx, glw = self._glxdef, self._glwdef
                glx12, glw12 = self._glxdef12, self._glwdef12
            elif ngl == _DEFAULTNGL2:
                glx, glw = self._glxdef2, self._glwdef2
                glx12, glw12 = self._glxdef, self._glwdef
            else:
                glx, glw = numpy.polynomial.legendre.leggauss(ngl)
                glx12, glw12 = numpy.polynomial.legendre.leggauss(ngl // 2)
            # Evaluate everywhere
            vTgl = vTmax / 2.0 * (glx + 1.0)
            vTglw = glw
            vTfac = 0.5 * vTmax  # integration over [0.,vTmax]
            # If inputs are arrays, tile
            if isinstance(R, numpy.ndarray):
                nR = len(R)
                R = numpy.tile(R, (ngl, 1)).T.flatten()
                z = numpy.tile(z, (ngl, 1)).T.flatten()
                vR = numpy.tile(vR, (ngl, 1)).T.flatten()
                vz = numpy.tile(vz, (ngl, 1)).T.flatten()
                vTgl = numpy.tile(vTgl, (nR, 1)).flatten()
                vTglw = numpy.tile(vTglw, (nR, 1))
                scalarOut = False
            else:
                R = R + numpy.zeros(ngl)
                vR = vR + numpy.zeros(ngl)
                z = z + numpy.zeros(ngl)
                vz = vz + numpy.zeros(ngl)
                nR = 1
                scalarOut = True
            # evaluate
            logqeval = numpy.reshape(
                self(R, vR, vTgl, z, vz, log=True, use_physical=False), (nR, ngl)
            )
            out = numpy.sum(numpy.exp(logqeval) * vTglw * vTfac, axis=1)
            if scalarOut:
                return out[0]
            else:
                return out

    def _calc_epifreq(self, r):
        &quot;&quot;&quot;
        Calculate the epicycle frequency at r.

        Parameters
        ----------
        r : float
            Radius.

        Returns
        -------
        float
            Epicycle frequency.

        Notes
        -----
        - 2012-07-25 - Written - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        return potential.epifreq(self._pot, r)

    def _calc_verticalfreq(self, r):
        &quot;&quot;&quot;
        Calculate the vertical frequency at r.

        Parameters
        ----------
        r : float
            Radius.

        Returns
        -------
        float
            Vertical frequency.

        Notes
        -----
        - 2012-07-25 - Written - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        return potential.verticalfreq(self._pot, r)

    def _rg(self, lz):
        &quot;&quot;&quot;
        Calculate the radius of a circular orbit of Lz.

        Parameters
        ----------
        lz : float
            Angular momentum.

        Returns
        -------
        float
            Radius.

        Notes
        -----
        - 2012-07-25 - Written - Bovy (IAS@MPIA)
        &quot;&quot;&quot;
        if isinstance(lz, numpy.ndarray):
            indx = (lz &gt; self._precomputergLzmax) * (lz &lt; self._precomputergLzmin)
            indxc = True ^ indx
            out = numpy.empty(lz.shape)
            out[indxc] = self._rgInterp(lz[indxc])
            out[indx] = numpy.array(
                [potential.rl(self._pot, lz[indx][ii]) for ii in range(numpy.sum(indx))]
            )
            return out
        else:
            if lz &gt; self._precomputergLzmax or lz &lt; self._precomputergLzmin:
                return potential.rl(self._pot, lz)
            return numpy.atleast_1d(self._rgInterp(lz))


def _vmomentsurfaceIntegrand(
    vz, vR, vT, R, z, df, sigmaR1, gamma, sigmaz1, n, m, o
):  # pragma: no cover because this is too slow; a warning is shown
    &quot;&quot;&quot;Internal function that is the integrand for the vmomentsurface mass integration&quot;&quot;&quot;
    return (
        vR**n
        * vT**m
        * vz**o
        * df(R, vR * sigmaR1, vT * sigmaR1 * gamma, z, vz * sigmaz1, use_physical=False)
    )


def _vmomentsurfaceMCIntegrand(
    vz, vR, vT, R, z, df, sigmaR1, gamma, sigmaz1, mvT, n, m, o
):
    &quot;&quot;&quot;Internal function that is the integrand for the vmomentsurface mass integration&quot;&quot;&quot;
    return (
        vR**n
        * vT**m
        * vz**o
        * df(R, vR * sigmaR1, vT * sigmaR1 * gamma, z, vz * sigmaz1, use_physical=False)
        * numpy.exp(vR**2.0 / 2.0 + (vT - mvT) ** 2.0 / 2.0 + vz**2.0 / 2.0)
    )


def _jmomentsurfaceIntegrand(
    vz, vR, vT, R, z, df, sigmaR1, gamma, sigmaz1, n, m, o
):  # pragma: no cover because this is too slow; a warning is shown
    &quot;&quot;&quot;Internal function that is the integrand for the vmomentsurface mass integration&quot;&quot;&quot;
    return df(
        R,
        vR * sigmaR1,
        vT * sigmaR1 * gamma,
        z,
        vz * sigmaz1,
        use_physical=False,
        func=(lambda x, y, z: x**n * y**m * z**o),
    )


def _jmomentsurfaceMCIntegrand(
    vz, vR, vT, R, z, df, sigmaR1, gamma, sigmaz1, mvT, n, m, o
):
    &quot;&quot;&quot;Internal function that is the integrand for the vmomentsurface mass integration&quot;&quot;&quot;
    return df(
        R,
        vR * sigmaR1,
        vT * sigmaR1 * gamma,
        z,
        vz * sigmaz1,
        use_physical=False,
        func=(lambda x, y, z: x**n * y**m * z**o),
    ) * numpy.exp(vR**2.0 / 2.0 + (vT - mvT) ** 2.0 / 2.0 + vz**2.0 / 2.0)
</file>
    <file path="galpy/df/sphericaldf.py">
# Superclass for spherical distribution functions, contains
#   - sphericaldf: superclass of all spherical DFs
#   - isotropicsphericaldf: superclass of all isotropic spherical DFs
#   - anisotropicsphericaldf: superclass of all anisotropic spherical DFs
#
# To implement a new DF do something like:
#   - Inherit from isotropicsphericaldf for an isotropic DF and implement
#     fE(self,E) which returns the DF as a function of E (see kingdf), then
#     you should be set! You may also have to implement _vmax_at_r(self,pot,r)
#     when the maximum velocity at a given position is less than the escape
#     velocity
#   - Inherit from anisotropicsphericaldf for an anisotropic DF, then you need
#     to implement a bunch of functions:
#       * _call_internal(self,*args,**kwargs): which returns the DF as a
#                                              function of (E,L,Lz)
#       * _sample_eta(self,r,n=1): to sample the velocity angle at r
#       * _p_v_at_r(self,v,r): which returns p(v|r)
#     constantbetadf is an example of this
#
import warnings

import numpy
import scipy.interpolate
from scipy import integrate, interpolate, special

from ..orbit import Orbit
from ..potential import interpSphericalPotential, mass
from ..potential.Potential import _evaluatePotentials
from ..potential.SCFPotential import _RToxi, _xiToR
from ..util import _optional_deps, conversion, galpyWarning
from ..util.conversion import physical_conversion
from .df import df

# Use _APY_LOADED/_APY_UNITS like this to be able to change them in tests
if _optional_deps._APY_LOADED:
    from astropy import units


class sphericaldf(df):
    &quot;&quot;&quot;Superclass for spherical distribution functions&quot;&quot;&quot;

    def __init__(self, pot=None, denspot=None, rmax=None, scale=None, ro=None, vo=None):
        &quot;&quot;&quot;
        Initializes a spherical DF

        Parameters
        ----------
        pot : Potential instance or list thereof
            The potential. Default is None.
        denspot : Potential instance or list thereof, optional
            The potential that represents the density of the tracers (assumed to be spherical). If None, set equal to pot. Default is None.
        rmax : float or Quantity, optional
            The maximum radius to consider. DF is cut off at E = Phi(rmax). Default is None.
        scale : float or Quantity, optional
            The length-scale parameter to be used internally. Default is None.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2020-07-22 - Written - Lane (UofT)
        &quot;&quot;&quot;
        df.__init__(self, ro=ro, vo=vo)
        if not conversion.physical_compatible(self, pot):
            raise RuntimeError(
                &quot;Unit-conversion parameters of input potential incompatible with those of the DF instance&quot;
            )
        phys = conversion.get_physical(pot, include_set=True)
        # if pot has physical units, transfer them (if already on, we know
        # they are compatible)
        if phys[&quot;roSet&quot;] and phys[&quot;voSet&quot;]:
            self.turn_physical_on(ro=phys[&quot;ro&quot;], vo=phys[&quot;vo&quot;])
        if pot is None:  # pragma: no cover
            raise OSError(&quot;pot= must be set&quot;)
        self._pot = pot
        self._denspot = self._pot if denspot is None else denspot
        if not conversion.physical_compatible(self._pot, self._denspot):
            raise RuntimeError(
                &quot;Unit-conversion parameters of input potential incompatible with those of the density potential&quot;
            )
        self._rmax = (
            numpy.inf if rmax is None else conversion.parse_length(rmax, ro=self._ro)
        )
        try:
            self._scale = pot._scale
        except AttributeError:
            try:
                self._scale = pot[0]._scale
            except (TypeError, AttributeError):
                self._scale = (
                    conversion.parse_length(scale, ro=self._ro)
                    if scale is not None
                    else 1.0
                )
        # Check that interpolated potential has appropriate grid range for DF
        if isinstance(pot, interpSphericalPotential) and pot._rmax &lt; self._rmax:
            warnings.warn(
                &quot;The interpolated potential's rmax is smaller than the DF's rmax&quot;,
                galpyWarning,
            )

    ############################## EVALUATING THE DF###############################
    @physical_conversion(&quot;massphasespacedensity&quot;, pop=True)
    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Evaluate the DF

        Parameters
        ----------
        *args: tuple
            Either:
                a) (E,L,Lz): tuple of E and (optionally) L and (optionally) Lz. Each may be Quantity
                b) R,vR,vT,z,vz,phi: cylindrical coordinates (can be Quantity)
                c) Orbit instance: orbit.Orbit instance and if specific time then orbit.Orbit(t)

        Returns
        -------
        ndarray or Quantity
            Value of DF

        Notes
        -----
        - 2020-07-22 - Written - Lane (UofT)
        - 2024-10-29 - Fixed to return mass/phase-space volume units for physical-unit output - Bovy (UofT)
        &quot;&quot;&quot;
        # Get E,L,Lz
        if len(args) == 1:
            if not isinstance(args[0], Orbit):  # Assume tuple (E,L,Lz)
                E, L, Lz = (args[0] + (None, None))[:3]
            else:  # Orbit
                E = args[0].E(pot=self._pot, use_physical=False)
                L = numpy.sqrt(numpy.sum(args[0].L(use_physical=False) ** 2.0))
                Lz = args[0].Lz(use_physical=False)
            E = numpy.atleast_1d(conversion.parse_energy(E, vo=self._vo))
            L = numpy.atleast_1d(conversion.parse_angmom(L, ro=self._ro, vo=self._vo))
            Lz = numpy.atleast_1d(conversion.parse_angmom(Lz, ro=self._vo, vo=self._vo))
        else:  # Assume R,vR,vT,z,vz,(phi)
            R, vR, vT, z, vz, phi = (args + (None,))[:6]
            R = conversion.parse_length(R, ro=self._ro)
            vR = conversion.parse_velocity(vR, vo=self._vo)
            vT = conversion.parse_velocity(vT, vo=self._vo)
            z = conversion.parse_length(z, ro=self._ro)
            vz = conversion.parse_velocity(vz, vo=self._vo)
            vtotSq = vR**2.0 + vT**2.0 + vz**2.0
            E = numpy.atleast_1d(0.5 * vtotSq + _evaluatePotentials(self._pot, R, z))
            Lz = numpy.atleast_1d(R * vT)
            r = numpy.sqrt(R**2.0 + z**2.0)
            vrad = (R * vR + z * vz) / r
            L = numpy.atleast_1d(numpy.sqrt(vtotSq - vrad**2.0) * r)
        return self._call_internal(E, L, Lz).reshape(
            args[0].shape
            if len(args) == 1 and hasattr(args[0], &quot;shape&quot;)
            else (
                args[0][0].shape
                if len(args) == 1
                and hasattr(args[0], &quot;__len__&quot;)
                and hasattr(args[0][0], &quot;shape&quot;)
                else (args[0].shape if hasattr(args[0], &quot;shape&quot;) else ())
            )
        )

    @physical_conversion(&quot;massenergydensity&quot;, pop=True)
    def dMdE(self, E):
        &quot;&quot;&quot;
        Compute the differential energy distribution dM/dE: the amount of mass per unit energy

        Parameters
        ----------
        E : float or numpy.ndarray
            Energy; can be a Quantity

        Returns
        -------
        float, numpy.ndarray, or Quantity
            The differential energy distribution

        Notes
        -----
        - 2023-05-23 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        return self._dMdE(
            numpy.atleast_1d(conversion.parse_energy(E, vo=self._vo))
        ).reshape(E.shape if isinstance(E, numpy.ndarray) else ())

    def vmomentdensity(self, r, n, m, **kwargs):
        &quot;&quot;&quot;
        Calculate an arbitrary moment of the velocity distribution at r times the density.

        Parameters
        ----------
        r : float
            Spherical radius at which to calculate the moment.
        n : float
            vr^n, where vr = v x cos eta.
        m : float
            vt^m, where vt = v x sin eta.

        Returns
        -------
        float or Quantity
            &lt;vr^n vt^m x density&gt; at r.

        Notes
        -----
        - 2020-09-04 - Written - Bovy (UofT)
        &quot;&quot;&quot;
        r = conversion.parse_length(r, ro=self._ro)
        use_physical = kwargs.pop(&quot;use_physical&quot;, True)
        ro = kwargs.pop(&quot;ro&quot;, None)
        if ro is None and hasattr(self, &quot;_roSet&quot;) and self._roSet:
            ro = self._ro
        ro = conversion.parse_length_kpc(ro)
        vo = kwargs.pop(&quot;vo&quot;, None)
        if vo is None and hasattr(self, &quot;_voSet&quot;) and self._voSet:
            vo = self._vo
        vo = conversion.parse_velocity_kms(vo)
        if use_physical and vo is not None and ro is not None:
            fac = conversion.mass_in_msol(vo, ro) * vo ** (n + m) / ro**3
            if _optional_deps._APY_UNITS:
                u = units.Msun / units.kpc**3 * (units.km / units.s) ** (n + m)
            out = self._vmomentdensity(r, n, m)
            if _optional_deps._APY_UNITS:
                return units.Quantity(out * fac, unit=u)
            else:
                return out * fac
        else:
            return self._vmomentdensity(r, n, m)

    def _vmomentdensity(self, r, n, m):
        return (
            2.0
            * numpy.pi
            * integrate.dblquad(
                lambda eta, v: v ** (2.0 + m + n)
                * numpy.sin(eta) ** (1 + m)
                * numpy.cos(eta) ** n
                * self(
                    r,
                    v * numpy.cos(eta),
                    v * numpy.sin(eta),
                    0.0,
                    0.0,
                    use_physical=False,
                ),
                0.0,
                self._vmax_at_r(self._pot, r),
                lambda x: 0.0,
                lambda x: numpy.pi,
            )[0]
        )

    @physical_conversion(&quot;velocity&quot;, pop=True)
    def sigmar(self, r):
        &quot;&quot;&quot;
        Calculate the radial velocity dispersion at radius r.

        Parameters
        ----------
        r : float
            Spherical radius at which to calculate the radial velocity dispersion.

        Returns
        -------
        float or Quantity
            The radial velocity dispersion at radius r.

        Notes
        -----
        - 2020-09-04 - Written - Bovy (UofT)
        &quot;&quot;&quot;
        r = conversion.parse_length(r, ro=self._ro)
        return numpy.sqrt(self._vmomentdensity(r, 2, 0) / self._vmomentdensity(r, 0, 0))

    @physical_conversion(&quot;velocity&quot;, pop=True)
    def sigmat(self, r):
        &quot;&quot;&quot;
        Calculate the tangential velocity dispersion at radius r.

        Parameters
        ----------
        r : float
            Spherical radius at which to calculate the tangential velocity dispersion.

        Returns
        -------
        float or Quantity
            The tangential velocity dispersion at radius r.

        Notes
        -----
        - 2020-09-04 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        r = conversion.parse_length(r, ro=self._ro)
        return numpy.sqrt(self._vmomentdensity(r, 0, 2) / self._vmomentdensity(r, 0, 0))

    def beta(self, r):
        &quot;&quot;&quot;
        Calculate the anisotropy at radius r.

        Parameters
        ----------
        r : float
            Spherical radius at which to calculate the anisotropy.

        Returns
        -------
        float
            Anisotropy at radius r.

        Notes
        -----
        - 2020-09-04 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        r = conversion.parse_length(r, ro=self._ro)
        return 1.0 - self._vmomentdensity(r, 0, 2) / 2.0 / self._vmomentdensity(r, 2, 0)

    ############################### SAMPLING THE DF################################
    def sample(self, R=None, z=None, phi=None, n=1, return_orbit=True, rmin=0.0):
        &quot;&quot;&quot;
        Sample the DF

        Parameters
        ----------
        R : float, numpy.ndarray, Quantity, or None, optional
            If set, sample velocities at this radius. If array, sample velocities at these radii, ignoring n.
        z : float, numpy.ndarray, Quantity, or None, optional
            If set, sample velocities at this height. If array, sample velocities at these heights, ignoring n.
        phi : float, numpy.ndarray, Quantity, or None, optional
            If set, sample velocities at this azimuth. If array, sample velocities at these azimuths, ignoring n.
        n : int, optional
            Number of samples to generate. Default is 1.
        return_orbit : bool, optional
            If True, return an orbit.Orbit instance. If False, return a tuple of (R,vR,vT,z,vz,phi). Default is True.
        rmin : float, Quantity, optional
            Minimum radius at which to sample. Default is 0.

        Returns
        -------
        orbit.Orbit instance or tuple
            If return_orbit is True, an orbit.Orbit instance. Otherwise, a tuple of (R,vR,vT,z,vz,phi).

        Notes
        -----
        - When specifying position, it is necessary to specify both R and z; if phi is not set in this case, it is sampled
        - 2020-07-22 - Written - Lane (UofT)
        &quot;&quot;&quot;
        rmin = conversion.parse_length(rmin, ro=self._ro)
        if hasattr(self, &quot;_rmin_sampling&quot;) and rmin != self._rmin_sampling:
            # Build new grids, easiest
            if hasattr(self, &quot;_xi_cmf_interpolator&quot;):
                delattr(self, &quot;_xi_cmf_interpolator&quot;)
            if hasattr(self, &quot;_v_vesc_pvr_interpolator&quot;):
                delattr(self, &quot;_v_vesc_pvr_interpolator&quot;)
        self._rmin_sampling = conversion.parse_length(rmin, ro=self._ro)
        if R is None or z is None:  # Full 6D samples
            r = self._sample_r(n=n)
            phi, theta = self._sample_position_angles(n=n)
            R = r * numpy.sin(theta)
            z = r * numpy.cos(theta)
        else:  # 3D velocity samples
            R = conversion.parse_length(R, ro=self._ro)
            z = conversion.parse_length(z, ro=self._ro)
            if isinstance(R, numpy.ndarray):
                assert len(R) == len(z), (
                    &quot;&quot;&quot;When R= is set to an array, z= needs to be set to &quot;&quot;&quot;
                    &quot;&quot;&quot;an equal-length array&quot;&quot;&quot;
                )
                n = len(R)
            else:
                R = R * numpy.ones(n)
                z = z * numpy.ones(n)
            r = numpy.sqrt(R**2.0 + z**2.0)
            theta = numpy.arctan2(R, z)
            if phi is None:  # Otherwise assume phi input type matches R,z
                phi, _ = self._sample_position_angles(n=n)
            else:
                phi = conversion.parse_angle(phi)
                phi = (
                    phi * numpy.ones(n)
                    if not hasattr(phi, &quot;__len__&quot;) or len(phi) &lt; n
                    else phi
                )
        eta, psi = self._sample_velocity_angles(r, n=n)
        v = self._sample_v(r, eta, n=n)
        vr = v * numpy.cos(eta)
        vtheta = v * numpy.sin(eta) * numpy.cos(psi)
        vT = v * numpy.sin(eta) * numpy.sin(psi)
        vR = vr * numpy.sin(theta) + vtheta * numpy.cos(theta)
        vz = vr * numpy.cos(theta) - vtheta * numpy.sin(theta)
        if return_orbit:
            o = Orbit(vxvv=numpy.array([R, vR, vT, z, vz, phi]).T)
            if self._roSet and self._voSet:
                o.turn_physical_on(ro=self._ro, vo=self._vo)
            return o
        else:
            if _optional_deps._APY_UNITS and self._voSet and self._roSet:
                R = units.Quantity(R) * self._ro * units.kpc
                vR = units.Quantity(vR) * self._vo * units.km / units.s
                vT = units.Quantity(vT) * self._vo * units.km / units.s
                z = units.Quantity(z) * self._ro * units.kpc
                vz = units.Quantity(vz) * self._vo * units.km / units.s
                phi = units.Quantity(phi) * units.rad
            return (R, vR, vT, z, vz, phi)

    def _sample_r(self, n=1):
        &quot;&quot;&quot;Generate radial position samples from potential
        Note - the function interpolates the normalized CMF onto the variable
        xi defined as:

        .. math:: \\xi = \\frac{r/a-1}{r/a+1}

        so that xi is in the range [-1,1], which corresponds to an r range of
        [0,infinity)&quot;&quot;&quot;
        rand_mass_frac = numpy.random.uniform(size=n)
        if hasattr(self, &quot;_icmf&quot;):
            r_samples = self._icmf(rand_mass_frac)
        else:
            if not hasattr(self, &quot;_xi_cmf_interpolator&quot;):
                self._xi_cmf_interpolator = self._make_cmf_interpolator()
            xi_samples = self._xi_cmf_interpolator(rand_mass_frac)
            r_samples = _xiToR(xi_samples, a=self._scale)
        return r_samples

    def _make_cmf_interpolator(self):
        &quot;&quot;&quot;Create the interpolator object for calculating radii from the CMF
        Note - must use self.xi_to_r() on any output of interpolator
        Note - the function interpolates the normalized CMF onto the variable
        xi defined as:

        .. math:: \\xi = \\frac{r-1}{r+1}

        so that xi is in the range [-1,1], which corresponds to an r range of
        [0,infinity)&quot;&quot;&quot;
        ximin = _RToxi(self._rmin_sampling, a=self._scale)
        ximax = _RToxi(self._rmax, a=self._scale)
        xis = numpy.arange(ximin, ximax, 1e-4)
        rs = _xiToR(xis, a=self._scale)
        # try/except necessary when mass doesn't take arrays, also need to
        # switch to a more general mass method at some point...
        try:
            ms = mass(self._denspot, rs, use_physical=False)
        except (ValueError, TypeError):
            ms = numpy.array([mass(self._denspot, r, use_physical=False) for r in rs])
        mnorm = mass(self._denspot, self._rmax, use_physical=False)
        if self._rmin_sampling &gt; 0:
            ms -= mass(self._denspot, self._rmin_sampling, use_physical=False)
            mnorm -= mass(self._denspot, self._rmin_sampling, use_physical=False)
        ms /= mnorm
        # Add total mass point
        if numpy.isinf(self._rmax):
            xis = numpy.append(xis, 1)
            ms = numpy.append(ms, 1)
        return scipy.interpolate.InterpolatedUnivariateSpline(ms, xis, k=1)

    def _sample_position_angles(self, n=1):
        &quot;&quot;&quot;Generate spherical angle samples&quot;&quot;&quot;
        phi_samples = numpy.random.uniform(size=n) * 2 * numpy.pi
        theta_samples = numpy.arccos(1.0 - 2 * numpy.random.uniform(size=n))
        return phi_samples, theta_samples

    def _sample_v(self, r, eta, n=1):
        &quot;&quot;&quot;Generate velocity samples: typically the total velocity, but not for OM&quot;&quot;&quot;
        if not hasattr(self, &quot;_v_vesc_pvr_interpolator&quot;):
            self._v_vesc_pvr_interpolator = self._make_pvr_interpolator()
        return self._v_vesc_pvr_interpolator(
            numpy.log10(r / self._scale), numpy.random.uniform(size=n), grid=False
        ) * self._vmax_at_r(self._pot, r)

    def _sample_velocity_angles(self, r, n=1):
        &quot;&quot;&quot;Generate samples of angles that set radial vs tangential
        velocities&quot;&quot;&quot;
        eta_samples = self._sample_eta(r, n)
        psi_samples = numpy.random.uniform(size=n) * 2 * numpy.pi
        return eta_samples, psi_samples

    def _vmax_at_r(self, pot, r, **kwargs):
        &quot;&quot;&quot;Function that gives the max velocity in the DF at r;
        typically equal to vesc, but not necessarily for finite systems
        such as King&quot;&quot;&quot;
        return numpy.sqrt(
            2.0
            * (
                _evaluatePotentials(self._pot, self._rmax + 1e-10, 0)
                - _evaluatePotentials(self._pot, r, 0.0)
            )
        )

    def _make_pvr_interpolator(self, r_a_start=-3, r_a_end=3, n_r_a=120, n_v_vesc=100):
        &quot;&quot;&quot;
        Calculate a grid of the velocity sampling function v^2*f(E) over many
        radii. The radii are fractional with respect to some scale radius
        which characteristically describes the size of the potential,
        and the velocities are fractional with respect to the escape velocity
        at each radius r. This information is saved in a 2D interpolator which
        represents the inverse cumulative distribution at many radii. This
        allows for sampling of v/vesc given an input r/a

        Parameters
        ----------
        r_a_start : float, optional
            Radius grid start location in units of log10(r/a). Default is -3.
        r_a_end : float, optional
            Radius grid end location in units of log10(r/a). Default is 3.
        n_r_a : int, optional
            Number of radius grid points to use. Default is 120.
        n_v_vesc : int, optional
            Number of velocity grid points to use. Default is 100.

        Returns
        -------
        scipy.interpolate.RectBivariateSpline
            Interpolator for v/vesc given an input r/a.

        Notes
        -----
        - 2020-07-24 - Written - Lane (UofT)
        &quot;&quot;&quot;
        # Check that interpolated potential has appropriate grid range
        if (
            isinstance(self._pot, interpSphericalPotential)
            and self._rmin_sampling &lt; self._pot._rmin
        ):
            warnings.warn(
                &quot;Interpolated potential grid rmin is larger than the rmin to be used for the v_vesc_interpolator grid. This may adversely affect the generated samples. Proceed with care!&quot;,
                galpyWarning,
            )
        # Make an array of r/a by v/vesc and then calculate p(v|r)
        r_a_start = numpy.amax(
            [numpy.log10((self._rmin_sampling + 1e-8) / self._scale), r_a_start]
        )
        r_a_end = numpy.amin([numpy.log10((self._rmax - 1e-8) / self._scale), r_a_end])
        r_a_values = 10.0 ** numpy.linspace(r_a_start, r_a_end, n_r_a)
        v_vesc_values = numpy.linspace(0, 1, n_v_vesc)
        r_a_grid, v_vesc_grid = numpy.meshgrid(r_a_values, v_vesc_values)
        vesc_grid = self._vmax_at_r(self._pot, r_a_grid * self._scale)
        r_grid = r_a_grid * self._scale
        vr_grid = v_vesc_grid * vesc_grid
        # Calculate p(v|r) and normalize
        pvr_grid = self._p_v_at_r(vr_grid, r_grid)
        pvr_grid_cml = numpy.cumsum(pvr_grid, axis=0)
        pvr_grid_cml_norm = (
            pvr_grid_cml
            / numpy.repeat(
                pvr_grid_cml[-1, :][:, numpy.newaxis], pvr_grid_cml.shape[0], axis=1
            ).T
        )

        # Construct the inverse cumulative distribution on a regular grid
        n_new_pvr = 100  # Must be multiple of r_a_grid.shape[0]
        icdf_pvr_grid_reg = numpy.zeros((n_new_pvr, len(r_a_values)))
        icdf_v_vesc_grid_reg = numpy.zeros((n_new_pvr, len(r_a_values)))
        for i in range(pvr_grid_cml_norm.shape[1]):
            cml_pvr = pvr_grid_cml_norm[:, i]
            if numpy.any(cml_pvr &lt; 0):
                warnings.warn(
                    &quot;The DF appears to have negative regions; we'll try to ignore these for sampling the DF, but this may adversely affect the generated samples. Proceed with care!&quot;,
                    galpyWarning,
                )
            cml_pvr[cml_pvr &lt; 0] = 0.0
            start_indx = numpy.amax(
                numpy.arange(len(cml_pvr))[cml_pvr == numpy.amin(cml_pvr)]
            )
            end_indx = (
                numpy.amin(numpy.arange(len(cml_pvr))[cml_pvr == numpy.amax(cml_pvr)])
                + 1
            )
            cml_pvr_inv_interp = scipy.interpolate.InterpolatedUnivariateSpline(
                cml_pvr[start_indx:end_indx], v_vesc_values[start_indx:end_indx], k=1
            )
            pvr_samples_reg = numpy.linspace(0, 1, n_new_pvr)
            v_vesc_samples_reg = cml_pvr_inv_interp(pvr_samples_reg)
            icdf_pvr_grid_reg[:, i] = pvr_samples_reg
            icdf_v_vesc_grid_reg[:, i] = v_vesc_samples_reg
        # Create the interpolator
        return scipy.interpolate.RectBivariateSpline(
            numpy.log10(r_a_grid[0, :]),
            icdf_pvr_grid_reg[:, 0],
            icdf_v_vesc_grid_reg.T,
            kx=1,
            ky=1,
        )

    def _setup_rphi_interpolator(self, r_a_min=1e-6, r_a_max=1e6, nra=10001):
        &quot;&quot;&quot;
        Set up the interpolator for r(phi)

        Parameters
        ----------
        r_a_min : float, optional
            Minimum r/a. Default is 1e-6.
        r_a_max : float, optional
            Maximum r/a. Default is 1e6.
        nra : int, optional
            Number of points to use in the r/a grid. Default is 10001.

        Returns
        -------
        scipy.interpolate.InterpolatedUnivariateSpline
            Interpolator for r(phi).

        Notes
        -----
        - 2023-02-23 - Written - Lane (UofT)
        &quot;&quot;&quot;

        r_a_values = numpy.concatenate(
            (numpy.array([0.0]), numpy.geomspace(r_a_min, r_a_max, nra))
        )
        phis = numpy.array(
            [_evaluatePotentials(self._pot, r * self._scale, 0) for r in r_a_values]
        )
        # Ensure phi is monotonic (required if coming from interpolated pot)
        if numpy.any(numpy.diff(phis) &lt;= 0):
            phim = numpy.maximum.accumulate(phis)
            indx_rm = numpy.where(numpy.diff(phim) == 0)[0]
            phis = numpy.delete(phim, indx_rm)
            r_a_values = numpy.delete(r_a_values, indx_rm)
        return interpolate.InterpolatedUnivariateSpline(
            phis, r_a_values * self._scale, k=3
        )


class isotropicsphericaldf(sphericaldf):
    &quot;&quot;&quot;Superclass for isotropic spherical distribution functions&quot;&quot;&quot;

    def __init__(self, pot=None, denspot=None, rmax=None, scale=None, ro=None, vo=None):
        &quot;&quot;&quot;
        Initialize an isotropic distribution function

        Parameters
        ----------
        pot : Potential instance or list thereof
            Default: None
        denspot : Potential instance or list thereof that represent the density of the tracers (assumed to be spherical; if None, set equal to pot), optional
            Default: None
        rmax : float or Quantity, optional
            Maximum radius to consider; DF is cut off at E = Phi(rmax)
            Default: None
        scale : float, optional
            Scale parameter to be used internally
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2020-09-02 - Written - Bovy (UofT)

        &quot;&quot;&quot;
        sphericaldf.__init__(
            self, pot=pot, denspot=denspot, rmax=rmax, scale=scale, ro=ro, vo=vo
        )

    def _call_internal(self, *args):
        &quot;&quot;&quot;
        Calculate the distribution function for an isotropic DF.

        Parameters
        ----------
        *args : tuple of (E,L,Lz) with L and Lz optionalA

        Returns
        -------
        float
            The distribution function evaluated at E.

        Notes
        -----
        - 2020-07 - Written - Lane (UofT)

        &quot;&quot;&quot;
        return self.fE(args[0])

    def _dMdE(self, E):
        if not hasattr(self, &quot;_rphi&quot;):
            self._rphi = self._setup_rphi_interpolator()
        fE = self.fE(E)
        out = numpy.zeros_like(E)
        out[fE &gt; 0.0] = (
            16.0
            * numpy.pi**2.0
            * numpy.sqrt(2.0)
            * fE[fE &gt; 0.0]
            * numpy.array(
                [
                    integrate.quad(
                        lambda r: r**2.0
                        * numpy.sqrt(tE - _evaluatePotentials(self._pot, r, 0.0)),
                        0.0,
                        self._rphi(tE),
                    )[0]
                    for ii, tE in enumerate(E)
                    if fE[ii] &gt; 0.0
                ]
            )
        )
        # Numerical issues can make the integrand's sqrt argument negative, only
        # happens at dMdE ~ 0, so just set to zero
        out[numpy.isnan(out)] = 0.0
        return out

    def _vmomentdensity(self, r, n, m):
        if m % 2 == 1 or n % 2 == 1:
            return 0.0
        return (
            2.0
            * numpy.pi
            * integrate.quad(
                lambda v: v ** (2.0 + m + n)
                * self.fE(_evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0),
                0.0,
                self._vmax_at_r(self._pot, r),
            )[0]
            * special.gamma(m // 2 + 1)
            * special.gamma(n // 2 + 0.5)
            / special.gamma(m // 2 + n // 2 + 1.5)
        )

    def _sample_eta(self, r, n=1):
        &quot;&quot;&quot;Sample the angle eta which defines radial vs tangential velocities&quot;&quot;&quot;
        return numpy.arccos(1.0 - 2.0 * numpy.random.uniform(size=n))

    def _p_v_at_r(self, v, r):
        if hasattr(self, &quot;_fE_interp&quot;):
            return (
                self._fE_interp(_evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0)
                * v**2.0
            )
        else:
            return self.fE(_evaluatePotentials(self._pot, r, 0) + 0.5 * v**2.0) * v**2.0


class anisotropicsphericaldf(sphericaldf):
    &quot;&quot;&quot;Superclass for anisotropic spherical distribution functions&quot;&quot;&quot;

    def __init__(self, pot=None, denspot=None, rmax=None, scale=None, ro=None, vo=None):
        &quot;&quot;&quot;
        Initialize an anisotropic distribution function

        Parameters
        ----------
        pot : Potential instance or list thereof
            The potential. Default: None.
        denspot : Potential instance or list thereof, optional
            The potential representing the density of the tracers (assumed to be spherical). If None, set equal to pot. Default: None.
        rmax : float or Quantity, optional
            Maximum radius to consider. DF is cut off at E = Phi(rmax). Default: None.
        scale : float, optional
            Length-scale parameter to be used internally. Default: None.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2020-07-22 - Written - Lane (UofT)

        &quot;&quot;&quot;
        sphericaldf.__init__(
            self, pot=pot, denspot=denspot, rmax=rmax, scale=scale, ro=ro, vo=vo
        )

    def _dMdE(self, E):
        if not hasattr(self, &quot;_rphi&quot;):
            self._rphi = self._setup_rphi_interpolator()

        def Lintegrand(t, L2lim, E):
            return self((E, numpy.sqrt(L2lim - t**2.0)), use_physical=False)

        out = (
            16.0
            * numpy.pi**2.0
            * numpy.array(
                [
                    integrate.quad(
                        lambda r: r
                        * integrate.quad(
                            Lintegrand,
                            0.0,
                            numpy.sqrt(
                                2.0
                                * r**2.0
                                * (tE - _evaluatePotentials(self._pot, r, 0.0))
                            ),
                            args=(
                                2.0
                                * r**2.0
                                * (tE - _evaluatePotentials(self._pot, r, 0.0)),
                                tE,
                            ),
                        )[0],
                        0.0,
                        self._rphi(tE),
                    )[0]
                    for ii, tE in enumerate(E)
                ]
            )
        )
        # Numerical issues can make the integrand's sqrt argument negative, only
        # happens at dMdE ~ 0, so just set to zero
        out[numpy.isnan(out)] = 0.0
        return out
</file>
    <file path="galpy/df/streamspraydf.py">
import warnings

import numpy

from ..df.df import df
from ..orbit import Orbit
from ..potential import MovingObjectPotential, evaluateRforces
from ..potential import flatten as flatten_potential
from ..potential import rtide
from ..util import _rotate_to_arbitrary_vector, conversion, coords
from ..util._optional_deps import _APY_LOADED, _APY_UNITS

if _APY_LOADED:
    from astropy import units


class basestreamspraydf(df):
    def __init__(
        self,
        progenitor_mass,
        progenitor=None,
        pot=None,
        rtpot=None,
        tdisrupt=None,
        leading=True,
        center=None,
        centerpot=None,
        progpot=None,
        ro=None,
        vo=None,
    ):
        &quot;&quot;&quot;
        Initialize a stream spray DF model of a tidal stream

        Parameters
        ----------
        progenitor_mass : float or Quantity
            Mass of the progenitor.
        progenitor : galpy.orbit.Orbit, optional
            Progenitor orbit as Orbit instance (will be re-integrated, so don't bother integrating the orbit before).
        pot : galpy.potential.Potential or list of such instances, optional
            Potential for integrating orbits.
        rtpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating tidal radius and circular velocity (should generally be the same as pot, but sometimes you need to drop parts of the potential that don't allow the tidal radius / circular velocity to be computed, such as velocity-dependent forces; when using center, rtpot should be the relevant potential in the frame of the center, thus, also being different from pot).
        tdisrupt : float or Quantity, optional
            Time since start of disruption. Default is 5 Gyr.
        leading : bool, optional
            If True, model the leading part of the stream. If False, model the trailing part. Default is True.
        center : galpy.orbit.Orbit, optional
            Orbit instance that represents the center around which the progenitor is orbiting for the purpose of stream formation; allows for a stream to be generated from a progenitor orbiting a moving object, like a satellite galaxy. Integrated internally using centerpot.
        centerpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating the orbit of the center; this might be different from the potential that the progenitor is integrated in if, for example, dynamical friction is important for the orbit of the center (if it's a satellite).
        progpot : galpy.potential.Potential or list of such instances or None, optional
            Potential for the progenitor. Ignored if None.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2018-07-31 - Written - Bovy (UofT)
        - 2021-05-05 - Added center keyword - Yansong Qian (UofT)
        - 2024-08-11 - Generalized to allow different particle-spray methods - Yingtian Chen (UMich)
        &quot;&quot;&quot;
        super().__init__(ro=ro, vo=vo)
        self._progenitor_mass = conversion.parse_mass(
            progenitor_mass, ro=self._ro, vo=self._vo
        )
        self._tdisrupt = (
            5.0 / conversion.time_in_Gyr(self._vo, self._ro)
            if tdisrupt is None
            else conversion.parse_time(tdisrupt, ro=self._ro, vo=self._vo)
        )
        if pot is None:  # pragma: no cover
            raise OSError(&quot;pot= must be set&quot;)
        self._pot = flatten_potential(pot)
        self._rtpot = self._pot if rtpot is None else flatten_potential(rtpot)
        assert conversion.physical_compatible(
            self, self._pot
        ), &quot;Physical conversion for the potential is not consistent with that of the basestreamspraydf object being initialized&quot;
        assert conversion.physical_compatible(
            self, self._rtpot
        ), &quot;Physical conversion for the rt potential is not consistent with that of the basestreamspraydf object being initialized&quot;
        # Set up progenitor orbit
        assert conversion.physical_compatible(
            self, progenitor
        ), &quot;Physical conversion for the progenitor Orbit object is not consistent with that of the basestreamspraydf object being initialized&quot;
        self._orig_progenitor = progenitor  # Store so we can use its ro/vo/etc.
        self._progenitor = progenitor()
        self._progenitor.turn_physical_off()
        self._progenitor_times = numpy.linspace(0.0, -self._tdisrupt, 10001)
        self._progenitor.integrate(self._progenitor_times, self._pot)
        self._leading = leading
        # Set up center orbit if given
        if not center is None:
            self._centerpot = (
                self._pot if centerpot is None else flatten_potential(centerpot)
            )
            assert conversion.physical_compatible(
                self, self._centerpot
            ), &quot;Physical conversion for the center potential is not consistent with that of the basestreamspraydf object being initialized&quot;
            self._center = center()
            self._center.turn_physical_off()
            self._center.integrate(self._progenitor_times, self._centerpot)
        else:
            self._center = None
        if progpot is not None:
            progtrajpot = MovingObjectPotential(
                orbit=self._progenitor,
                pot=progpot,
                ro=self._ro,
                vo=self._vo,
            )
            self._pot = self._pot + progtrajpot

        return None

    def sample(self, n, return_orbit=True, returndt=False, integrate=True):
        &quot;&quot;&quot;
        Sample from the DF

        Parameters
        ----------
        n : int
            Number of points to return.
        return_orbit : bool, optional
            If True, the output phase-space positions is an orbit.Orbit object. If False, the output is (R,vR,vT,z,vz,phi). Default is True.
        returndt : bool, optional
            If True, also return the time since the star was stripped. Default is False.
        integrate : bool, optional
            If True, integrate the orbits to the present time. If False, return positions at stripping (probably want to combine with returndt=True then to make sense of them!). Default is True.

        Returns
        -------
        Orbit, numpy.ndarray, or tuple
            Orbit instance or (R,vR,vT,z,vz,phi) of points on the stream in 6,N array (set of 6 Quantities when physical output is on); optionally the time is included as well. The ro/vo unit-conversion parameters and the zo/solarmotion parameters as well as whether physical outputs are on, match the settings of the progenitor Orbit given to the class initialization

        Notes
        -----
        - 2018-07-31 - Written - Bovy (UofT)
        - 2022-05-18 - Made output Orbit ro/vo/zo/solarmotion/roSet/voSet match that of the progenitor orbit - Bovy (UofT)
        - 2024-08-11 - Include the progenitor's potential - Yingtian Chen (Umich)
        &quot;&quot;&quot;
        # First sample times
        dt = numpy.random.uniform(size=n) * self._tdisrupt
        # Build all rotation matrices
        rot, rot_inv = self._setup_rot(dt)
        # Compute progenitor position in the instantaneous frame,
        # relative to the center orbit if necessary
        centerx = self._progenitor.x(-dt)
        centery = self._progenitor.y(-dt)
        centerz = self._progenitor.z(-dt)
        centervx = self._progenitor.vx(-dt)
        centervy = self._progenitor.vy(-dt)
        centervz = self._progenitor.vz(-dt)
        if not self._center is None:
            centerx -= self._center.x(-dt)
            centery -= self._center.y(-dt)
            centerz -= self._center.z(-dt)
            centervx -= self._center.vx(-dt)
            centervy -= self._center.vy(-dt)
            centervz -= self._center.vz(-dt)
        xyzpt = numpy.einsum(
            &quot;ijk,ik-&gt;ij&quot;, rot, numpy.array([centerx, centery, centerz]).T
        )
        vxyzpt = numpy.einsum(
            &quot;ijk,ik-&gt;ij&quot;, rot, numpy.array([centervx, centervy, centervz]).T
        )

        # generate the initial conditions
        xst, yst, zst, vxst, vyst, vzst = self.spray_df(xyzpt, vxyzpt, dt)

        xyzs = numpy.einsum(&quot;ijk,ik-&gt;ij&quot;, rot_inv, numpy.array([xst, yst, zst]).T)
        vxyzs = numpy.einsum(&quot;ijk,ik-&gt;ij&quot;, rot_inv, numpy.array([vxst, vyst, vzst]).T)

        absx = xyzs[:, 0]
        absy = xyzs[:, 1]
        absz = xyzs[:, 2]
        absvx = vxyzs[:, 0]
        absvy = vxyzs[:, 1]
        absvz = vxyzs[:, 2]
        if not self._center is None:
            absx += self._center.x(-dt)
            absy += self._center.y(-dt)
            absz += self._center.z(-dt)
            absvx += self._center.vx(-dt)
            absvy += self._center.vy(-dt)
            absvz += self._center.vz(-dt)
        Rs, phis, Zs = coords.rect_to_cyl(absx, absy, absz)
        vRs, vTs, vZs = coords.rect_to_cyl_vec(
            absvx, absvy, absvz, Rs, phis, Zs, cyl=True
        )
        out = numpy.empty((6, n))
        if integrate:
            # Now integrate the orbits
            for ii in range(n):
                o = Orbit([Rs[ii], vRs[ii], vTs[ii], Zs[ii], vZs[ii], phis[ii]])
                o.integrate(numpy.linspace(-dt[ii], 0.0, 10001), self._pot)
                o = o(0.0)
                out[:, ii] = [o.R(), o.vR(), o.vT(), o.z(), o.vz(), o.phi()]
        else:
            out[0] = Rs
            out[1] = vRs
            out[2] = vTs
            out[3] = Zs
            out[4] = vZs
            out[5] = phis
        if return_orbit:
            # Output Orbit ro/vo/zo/solarmotion/roSet/voSet match progenitor
            o = Orbit(
                vxvv=out.T,
                ro=self._orig_progenitor._ro,
                vo=self._orig_progenitor._vo,
                zo=self._orig_progenitor._zo,
                solarmotion=self._orig_progenitor._solarmotion,
            )
            if not self._orig_progenitor._roSet:
                o._roSet = False
            if not self._orig_progenitor._voSet:
                o._voSet = False
            out = o
        elif _APY_UNITS and self._voSet and self._roSet:
            out = (
                out[0] * self._ro * units.kpc,
                out[1] * self._vo * units.km / units.s,
                out[2] * self._vo * units.km / units.s,
                out[3] * self._ro * units.kpc,
                out[4] * self._vo * units.km / units.s,
                out[5] * units.rad,
            )
            dt = dt * conversion.time_in_Gyr(self._vo, self._ro) * units.Gyr
        if returndt:
            return (out, dt)
        else:
            return out

    def _setup_rot(self, dt):
        n = len(dt)
        centerx = self._progenitor.x(-dt)
        centery = self._progenitor.y(-dt)
        centerz = self._progenitor.z(-dt)
        if self._center is None:
            L = self._progenitor.L(-dt)
        # Compute relative angular momentum to the center orbit
        else:
            centerx -= self._center.x(-dt)
            centery -= self._center.y(-dt)
            centerz -= self._center.z(-dt)
            centervx = self._progenitor.vx(-dt) - self._center.vx(-dt)
            centervy = self._progenitor.vy(-dt) - self._center.vy(-dt)
            centervz = self._progenitor.vz(-dt) - self._center.vz(-dt)
            L = numpy.array(
                [
                    centery * centervz - centerz * centervy,
                    centerz * centervx - centerx * centervz,
                    centerx * centervy - centery * centervx,
                ]
            ).T
        Lnorm = L / numpy.tile(numpy.sqrt(numpy.sum(L**2.0, axis=1)), (3, 1)).T
        z_rot = numpy.swapaxes(
            _rotate_to_arbitrary_vector(
                numpy.atleast_2d(Lnorm), [0.0, 0.0, 1], inv=True
            ),
            1,
            2,
        )
        z_rot_inv = numpy.swapaxes(
            _rotate_to_arbitrary_vector(
                numpy.atleast_2d(Lnorm), [0.0, 0.0, 1], inv=False
            ),
            1,
            2,
        )
        xyzt = numpy.einsum(
            &quot;ijk,ik-&gt;ij&quot;, z_rot, numpy.array([centerx, centery, centerz]).T
        )
        Rt = numpy.sqrt(xyzt[:, 0] ** 2.0 + xyzt[:, 1] ** 2.0)
        cosphi, sinphi = xyzt[:, 0] / Rt, xyzt[:, 1] / Rt
        pa_rot = numpy.array(
            [
                [cosphi, -sinphi, numpy.zeros(n)],
                [sinphi, cosphi, numpy.zeros(n)],
                [numpy.zeros(n), numpy.zeros(n), numpy.ones(n)],
            ]
        ).T
        pa_rot_inv = numpy.array(
            [
                [cosphi, sinphi, numpy.zeros(n)],
                [-sinphi, cosphi, numpy.zeros(n)],
                [numpy.zeros(n), numpy.zeros(n), numpy.ones(n)],
            ]
        ).T
        rot = numpy.einsum(&quot;ijk,ikl-&gt;ijl&quot;, pa_rot, z_rot)
        rot_inv = numpy.einsum(&quot;ijk,ikl-&gt;ijl&quot;, z_rot_inv, pa_rot_inv)
        return (rot, rot_inv)

    def _calc_rtide(self, Rpt, phipt, Zpt, dt):
        try:
            rtides = rtide(
                self._rtpot,
                Rpt,
                Zpt,
                phi=phipt,
                t=-dt,
                M=self._progenitor_mass,
                use_physical=False,
            )
        except (ValueError, TypeError):
            rtides = numpy.array(
                [
                    rtide(
                        self._rtpot,
                        Rpt[ii],
                        Zpt[ii],
                        phi=phipt[ii],
                        t=-dt[ii],
                        M=self._progenitor_mass,
                        use_physical=False,
                    )
                    for ii in range(len(Rpt))
                ]
            )
        return rtides

    def _calc_vc(self, Rpt, phipt, Zpt, dt):
        try:
            vcs = numpy.sqrt(
                -Rpt
                * evaluateRforces(
                    self._rtpot, Rpt, Zpt, phi=phipt, t=-dt, use_physical=False
                )
            )
        except (ValueError, TypeError):
            vcs = numpy.array(
                [
                    numpy.sqrt(
                        -Rpt[ii]
                        * evaluateRforces(
                            self._rtpot,
                            Rpt[ii],
                            Zpt[ii],
                            phi=phipt[ii],
                            t=-dt[ii],
                            use_physical=False,
                        )
                    )
                    for ii in range(len(Rpt))
                ]
            )
        return vcs

    def spray_df(self, xyzpt, vxyzpt, dt):
        &quot;&quot;&quot;
        Sample the positions and velocities around the progenitor
        Must be implemented in a subclass

        Parameters
        ----------
        xyzpt : array, shape (N,3)
            Positions of progenitor in the progenitor coordinates.
        vxyzpt : array, shape (N,3)
            Velocities of progenitor in the progenitor coordinates.
        dt : array, shape (N,)
            Time of sampling.

        Returns
        -------
        xst, yst, zst : array, shape (N,)
            Positions of points on the stream in the progenitor coordinates.
        vxst, vyst, vzst : array, shape (N,)
            Velocities of points on the stream in the progenitor coordinates.
        &quot;&quot;&quot;
        raise NotImplementedError


class chen24spraydf(basestreamspraydf):
    def __init__(
        self,
        progenitor_mass,
        progenitor=None,
        pot=None,
        rtpot=None,
        tdisrupt=None,
        leading=True,
        center=None,
        centerpot=None,
        progpot=None,
        mean=None,
        cov=None,
        ro=None,
        vo=None,
    ):
        &quot;&quot;&quot;
        Initialize a `Chen et al. (2024) &lt;https://ui.adsabs.harvard.edu/abs/2024arXiv240801496C/abstract&gt;`_ stream spray DF model of a tidal stream.


        Parameters
        ----------
        progenitor_mass : float or Quantity
            Mass of the progenitor.
        progenitor : galpy.orbit.Orbit, optional
            Progenitor orbit as Orbit instance (will be re-integrated, so don't bother integrating the orbit before).
        pot : galpy.potential.Potential or list of such instances, optional
            Potential for integrating orbits.
        rtpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating tidal radius and circular velocity (should generally be the same as pot, but sometimes you need to drop parts of the potential that don't allow the tidal radius / circular velocity to be computed, such as velocity-dependent forces; when using center, rtpot should be the relevant potential in the frame of the center, thus, also being different from pot).
        tdisrupt : float or Quantity, optional
            Time since start of disruption. Default is 5 Gyr.
        leading : bool, optional
            If True, model the leading part of the stream. If False, model the trailing part. Default is True.
        center : galpy.orbit.Orbit, optional
            Orbit instance that represents the center around which the progenitor is orbiting for the purpose of stream formation; allows for a stream to be generated from a progenitor orbiting a moving object, like a satellite galaxy. Integrated internally using centerpot.
        centerpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating the orbit of the center; this might be different from the potential that the progenitor is integrated in if, for example, dynamical friction is important for the orbit of the center (if it's a satellite).
        progpot : galpy.potential.Potential or list of such instances or None, optional
            Potential for the progenitor. Ignored if None.
        mean : None or array, shape (6,), optional
            Means of the multivariate Gaussian distribution (angles in radians). If None, use the default values.
        cov : None or array, shape (6,6), optional
            Covariance of the multivariate Gaussian distribution (angles in radians). If None, use the default values.
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2024-08-11 - Written - Yingtian Chen (UMich)
        &quot;&quot;&quot;
        super().__init__(
            progenitor_mass=progenitor_mass,
            progenitor=progenitor,
            pot=pot,
            rtpot=rtpot,
            tdisrupt=tdisrupt,
            leading=leading,
            center=center,
            centerpot=centerpot,
            progpot=progpot,
            ro=ro,
            vo=vo,
        )
        if mean is None:
            self._mean = numpy.array([1.6, -0.523599, 0, 1, 0.349066, 0])
        else:
            self._mean = mean
        if cov is None:
            self._cov = numpy.array(
                [
                    [0.1225, 0, 0, 0, -0.085521, 0],
                    [0, 0.161143, 0, 0, 0, 0],
                    [0, 0, 0.043865, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [-0.085521, 0, 0, 0, 0.121847, 0],
                    [0, 0, 0, 0, 0, 0.147435],
                ]
            )
        else:
            self._cov = cov
        return None

    def spray_df(self, xyzpt, vxyzpt, dt):
        &quot;&quot;&quot;
        Sample the positions and velocities around the progenitor

        Parameters
        ----------
        xyzpt : array, shape (N,3)
            Positions of progenitor in the progenitor coordinates.
        vxyzpt : array, shape (N,3)
            Velocities of progenitor in the progenitor coordinates.
        dt : array, shape (N,)
            Time of sampling.

        Returns
        -------
        xst, yst, zst : array, shape (N,)
            Positions of points on the stream in the progenitor coordinates.
        vxst, vyst, vzst : array, shape (N,)
            Velocities of points on the stream in the progenitor coordinates.
        &quot;&quot;&quot;
        Rpt, phipt, Zpt = coords.rect_to_cyl(xyzpt[:, 0], xyzpt[:, 1], xyzpt[:, 2])
        rtides = self._calc_rtide(Rpt, phipt, Zpt, dt)

        # Sample positions and velocities in the instantaneous frame
        posvel = numpy.random.multivariate_normal(self._mean, self._cov, size=len(dt))
        Dr = posvel[:, 0] * rtides
        v_esc = numpy.sqrt(2 * self._progenitor_mass / Dr)
        Dv = posvel[:, 3] * v_esc
        if self._leading:
            Dr *= -1.0
            Dv *= -1.0

        dR, dz, dp = coords.spher_to_cyl(
            r=Dr, theta=0.5 * numpy.pi - posvel[:, 2], phi=posvel[:, 1]
        )
        dx, dy, dz = coords.cyl_to_rect(R=dR, phi=dp, Z=dz)

        dvR, dvz, dvp = coords.spher_to_cyl(
            r=Dv, theta=0.5 * numpy.pi - posvel[:, 5], phi=posvel[:, 4]
        )
        dvx, dvy, dvz = coords.cyl_to_rect(R=dvR, phi=dvp, Z=dvz)

        return (
            xyzpt[:, 0] + dx,
            xyzpt[:, 1] + dy,
            xyzpt[:, 2] + dz,
            vxyzpt[:, 0] + dvx,
            vxyzpt[:, 1] + dvy,
            vxyzpt[:, 2] + dvz,
        )


class fardal15spraydf(basestreamspraydf):
    def __init__(
        self,
        progenitor_mass,
        progenitor=None,
        pot=None,
        rtpot=None,
        tdisrupt=None,
        leading=True,
        center=None,
        centerpot=None,
        progpot=None,
        meankvec=[2.0, 0.0, 0.3, 0.0, 0.0, 0.0],
        sigkvec=[0.4, 0.0, 0.4, 0.5, 0.5, 0.0],
        ro=None,
        vo=None,
    ):
        &quot;&quot;&quot;
        Initialize a `Fardal et al. (2015) &lt;https://ui.adsabs.harvard.edu/abs/2014arXiv1410.1861F/abstract&gt;`_ stream spray DF model of a tidal stream.


        Parameters
        ----------
        progenitor_mass : float or Quantity
            Mass of the progenitor.
        progenitor : galpy.orbit.Orbit, optional
            Progenitor orbit as Orbit instance (will be re-integrated, so don't bother integrating the orbit before).
        pot : galpy.potential.Potential or list of such instances, optional
            Potential for integrating orbits.
        rtpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating tidal radius and circular velocity (should generally be the same as pot, but sometimes you need to drop parts of the potential that don't allow the tidal radius / circular velocity to be computed, such as velocity-dependent forces; when using center, rtpot should be the relevant potential in the frame of the center, thus, also being different from pot).
        tdisrupt : float or Quantity, optional
            Time since start of disruption. Default is 5 Gyr.
        leading : bool, optional
            If True, model the leading part of the stream. If False, model the trailing part. Default is True.
        center : galpy.orbit.Orbit, optional
            Orbit instance that represents the center around which the progenitor is orbiting for the purpose of stream formation; allows for a stream to be generated from a progenitor orbiting a moving object, like a satellite galaxy. Integrated internally using centerpot.
        centerpot : galpy.potential.Potential or list of such instances, optional
            Potential for calculating the orbit of the center; this might be different from the potential that the progenitor is integrated in if, for example, dynamical friction is important for the orbit of the center (if it's a satellite).
        progpot : galpy.potential.Potential or list of such instances or None, optional
            Potential for the progenitor. Ignored if None.
        meankvec : list or array, optional
            Mean of the action-angle distribution. Default is [2.0, 0.0, 0.3, 0.0, 0.0, 0.0].
        sigkvec : list or array, optional
            Dispersion of the action-angle distribution. Default is [0.4, 0.0, 0.4, 0.5, 0.5, 0.0].
        ro : float or Quantity, optional
            Distance scale for translation into internal units (default from configuration file).
        vo : float or Quantity, optional
            Velocity scale for translation into internal units (default from configuration file).

        Notes
        -----
        - 2018-07-31 - Written - Bovy (UofT)
        - 2021-05-05 - Added center keyword - Yansong Qian (UofT)
        &quot;&quot;&quot;
        super().__init__(
            progenitor_mass=progenitor_mass,
            progenitor=progenitor,
            pot=pot,
            rtpot=rtpot,
            tdisrupt=tdisrupt,
            leading=leading,
            center=center,
            centerpot=centerpot,
            progpot=progpot,
            ro=ro,
            vo=vo,
        )
        self._meankvec = numpy.array(meankvec)
        self._sigkvec = numpy.array(sigkvec)
        if leading:
            self._meankvec *= -1.0
        return None

    def spray_df(self, xyzpt, vxyzpt, dt):
        &quot;&quot;&quot;
        Sample the positions and velocities around the progenitor

        Parameters
        ----------
        xyzpt : array, shape (N,3)
            Positions of progenitor in the progenitor coordinates.
        vxyzpt : array, shape (N,3)
            Velocities of progenitor in the progenitor coordinates.
        dt : array, shape (N,)
            Time of sampling.

        Returns
        -------
        xst, yst, zst : array, shape (N,)
            Positions of points on the stream in the progenitor coordinates.
        vxst, vyst, vzst : array, shape (N,)
            Velocities of points on the stream in the progenitor coordinates.
        &quot;&quot;&quot;
        Rpt, phipt, Zpt = coords.rect_to_cyl(xyzpt[:, 0], xyzpt[:, 1], xyzpt[:, 2])
        rtides = self._calc_rtide(Rpt, phipt, Zpt, dt)
        vcs = self._calc_vc(Rpt, phipt, Zpt, dt)
        rtides_as_frac = rtides / Rpt

        vRpt, vTpt, vZpt = coords.rect_to_cyl_vec(
            vxyzpt[:, 0], vxyzpt[:, 1], vxyzpt[:, 2], Rpt, phipt, Zpt, cyl=True
        )
        # Sample positions and velocities in the instantaneous frame
        k = self._meankvec + numpy.random.normal(size=(len(dt), 6)) * self._sigkvec

        RpZst = numpy.array(
            [
                Rpt + k[:, 0] * rtides,
                phipt + k[:, 5] * rtides_as_frac,
                k[:, 3] * rtides_as_frac,
            ]
        ).T
        vRTZst = numpy.array(
            [
                vRpt * (1.0 + k[:, 1]),
                vTpt + k[:, 2] * vcs * rtides_as_frac,
                k[:, 4] * vcs * rtides_as_frac,
            ]
        ).T
        # Now rotate these back to the galactocentric frame
        xst, yst, zst = coords.cyl_to_rect(RpZst[:, 0], RpZst[:, 1], RpZst[:, 2])
        vxst, vyst, vzst = coords.cyl_to_rect_vec(
            vRTZst[:, 0], vRTZst[:, 1], vRTZst[:, 2], RpZst[:, 1]
        )

        return xst, yst, zst, vxst, vyst, vzst


class streamspraydf(fardal15spraydf):
    def __init__(self, args, **kwargs):
        &quot;&quot;&quot;
        For backward compatibility
        &quot;&quot;&quot;
        super().__init__(args, **kwargs)
        warnings.warn(
            &quot;Class `streamspraydf` will be deprecated in version 1.11. &quot;
            &quot;Please use class `fardal15spraydf` for the Fardal+15 particle spray model.&quot;,
            DeprecationWarning,
            stacklevel=1,
        )
        return None
</file>
    <file path="galpy/util/ars.py">
#############################################################################
# Copyright (c) 2011, Jo Bovy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#   Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#   The name of the author may not be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
# WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#############################################################################
import numpy
import scipy.stats as stats

# TO DO:
# Throw errors in the sample_hull routine


def ars(domain, isDomainFinite, abcissae, hx, hpx, nsamples=1, hxparams=(), maxn=100):
    &quot;&quot;&quot;
    Implementation of the Adaptive-Rejection Sampling algorithm by Gilks &amp; Wild (1992): Adaptive Rejection Sampling for Gibbs Sampling, Applied Statistics, 41, 337. Based on Wild &amp; Gilks (1993), Algorithm AS 287: Adaptive Rejection Sampling from Log-concave Density Functions, Applied Statistics, 42, 701

    Parameters
    ----------
    domain : list or numpy.ndarray
        [.,.] upper and lower limit to the domain
    isDomainFinite : list or numpy.ndarray
        [.,.] is there a lower/upper limit to the domain?
    abcissae : list or numpy.ndarray
        initial list of abcissae (must lie on either side of the peak in hx if the domain is unbounded)
    hx : function
        function that evaluates h(x) = ln g(x)
    hpx : function
        function that evaluates hp(x) =  d h(x) / d x
    nsamples : int, optional
        number of desired samples (default=1)
    hxparams : tuple, optional
        a tuple of parameters for h(x) and h'(x)
    maxn : int, optional
        maximum number of updates to the hull (default=100)

    Returns
    -------
    list
        list with nsamples of samples from exp(h(x))

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    # First set-up the upper and lower hulls
    hull = setup_hull(domain, isDomainFinite, abcissae, hx, hpx, hxparams)
    # Then start  sampling: call sampleone repeatedly
    out = []
    nupdates = 0
    for ii in range(int(nsamples)):
        thissample, hull, nupdates = sampleone(
            hull, hx, hpx, domain, isDomainFinite, maxn, nupdates, hxparams
        )
        out.append(thissample)
    return out


def setup_hull(domain, isDomainFinite, abcissae, hx, hpx, hxparams):
    &quot;&quot;&quot;
    Set up the upper and lower hull and everything that comes with that

    Parameters
    ----------
    domain : list or numpy.ndarray
        [.,.] upper and lower limit to the domain
    isDomainFinite : list or numpy.ndarray
        [.,.] is there a lower/upper limit to the domain?
    abcissae : list or numpy.ndarray
        initial list of abcissae (must lie on either side of the peak in hx if the domain is unbounded)
    hx : function
        function that evaluates h(x)
    hpx : function
        function that evaluates hp(x)
    hxparams : tuple
        tuple of parameters for h(x) and h'(x)

    Returns
    -------
    list
        list with:
        [0]= c_u
        [1]= xs
        [2]= h(xs)
        [3]= hp(xs)
        [4]= zs
        [5]= s_cum
        [6]= hu(zi)

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    nx = len(abcissae)
    # Create the output arrays
    xs = numpy.zeros(nx)
    hxs = numpy.zeros(nx)
    hpxs = numpy.zeros(nx)
    zs = numpy.zeros(nx - 1)
    scum = numpy.zeros(nx - 1)
    hus = numpy.zeros(nx - 1)
    # Function evaluations
    xs = numpy.sort(abcissae)
    for ii in range(nx):
        hxs[ii] = hx(xs[ii], hxparams)
        hpxs[ii] = hpx(xs[ii], hxparams)
    # THERE IS NO CHECKING HERE TO SEE WHETHER IN THE INFINITE DOMAIN CASE
    # WE HAVE ABCISSAE ON BOTH SIDES OF THE PEAK
    # zi
    for jj in range(nx - 1):
        zs[jj] = (
            hxs[jj + 1] - hxs[jj] - xs[jj + 1] * hpxs[jj + 1] + xs[jj] * hpxs[jj]
        ) / (hpxs[jj] - hpxs[jj + 1])
    # hu
    for jj in range(nx - 1):
        hus[jj] = hpxs[jj] * (zs[jj] - xs[jj]) + hxs[jj]
    # Calculate cu and scum
    if isDomainFinite[0]:
        scum[0] = (
            1.0
            / hpxs[0]
            * (numpy.exp(hus[0]) - numpy.exp(hpxs[0] * (domain[0] - xs[0]) + hxs[0]))
        )
    else:
        scum[0] = 1.0 / hpxs[0] * numpy.exp(hus[0])
    if nx &gt; 2:
        for jj in range(nx - 2):
            if hpxs[jj + 1] == 0.0:
                scum[jj + 1] = (zs[jj + 1] - zs[jj]) * numpy.exp(hxs[jj + 1])
            else:
                scum[jj + 1] = (
                    1.0 / hpxs[jj + 1] * (numpy.exp(hus[jj + 1]) - numpy.exp(hus[jj]))
                )
    if isDomainFinite[1]:
        cu = (
            1.0
            / hpxs[nx - 1]
            * (
                numpy.exp(hpxs[nx - 1] * (domain[1] - xs[nx - 1]) + hxs[nx - 1])
                - numpy.exp(hus[nx - 2])
            )
        )
    else:
        cu = -1.0 / hpxs[nx - 1] * numpy.exp(hus[nx - 2])
    cu = cu + numpy.sum(scum)
    scum = numpy.cumsum(scum) / cu
    out = []
    out.append(cu)
    out.append(xs)
    out.append(hxs)
    out.append(hpxs)
    out.append(zs)
    out.append(scum)
    out.append(hus)

    return out


def sampleone(hull, hx, hpx, domain, isDomainFinite, maxn, nupdates, hxparams):
    &quot;&quot;&quot;
    Sample one point by ars

    Parameters
    ----------
    hull : list
        the hull (see doc of setup_hull for definition)
    hx : function
        function that evaluates h(x)
    hpx : function
        function that evaluates hp(x)
    domain : list or numpy.ndarray
        [.,.] upper and lower limit to the domain
    isDomainFinite : list or numpy.ndarray
        [.,.] is there a lower/upper limit to the domain?
    maxn : int
        maximum number of updates to the hull
    nupdates : int
        number of updates to the hull that have occurred
    hxparams : tuple
        tuple of parameters for h(x) and h'(x)

    Returns
    -------
    list
        [0]= a sample
        [1]= a new hull
        [2]= nupdates

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    thishull = hull
    noSampleYet = True
    while noSampleYet:
        # Sample a candidate from the upper hull
        candidate = sample_hull(thishull, domain, isDomainFinite)
        thishux, thishlx = evaluate_hull(candidate, thishull)
        u = stats.uniform.rvs()
        if u &lt; numpy.exp(thishlx - thishux):
            thissample = candidate
            noSampleYet = False
        else:
            thishx = hx(candidate, hxparams)
            if u &lt; numpy.exp(thishx - thishux):
                thissample = candidate
                noSampleYet = False
            if nupdates &lt; maxn:
                thishpx = hpx(candidate, hxparams)
                thishull = update_hull(
                    thishull, candidate, thishx, thishpx, domain, isDomainFinite
                )
                nupdates = nupdates + 1
    return thissample, thishull, nupdates


def sample_hull(hull, domain, isDomainFinite):
    &quot;&quot;&quot;
    Sample the upper hull

    Parameters
    ----------
    hull : list
        the hull (see doc of setup_hull for definition)
    domain : list or numpy.ndarray
        [.,.] upper and lower limit to the domain
    isDomainFinite : list or numpy.ndarray
        [.,.] is there a lower/upper limit to the domain?

    Returns
    -------
    float
        a sample from the hull

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    u = stats.uniform.rvs()
    # Find largest zs[jj] such that scum[jj] &lt; u
    # The first bin is a special case
    if hull[5][0] &gt;= u:
        if hull[3][0] == 0:
            if isDomainFinite[0]:
                thissample = domain[0] + u / hull[5][0] * (hull[4][0] - domain[0])
            else:
                thissample = 100000000  # Throw some kind of error
        else:
            thissample = hull[4][0] + 1.0 / hull[3][0] * numpy.log(
                1.0 - hull[3][0] * hull[0] * (hull[5][0] - u) / numpy.exp(hull[6][0])
            )
    else:
        if len(hull[5]) == 1:
            indx = 0
        else:
            indx = 1
            while indx &lt; len(hull[5]) and hull[5][indx] &lt; u:
                indx = indx + 1
            indx = indx - 1
        if numpy.fabs(hull[3][indx + 1]) == 0:
            if indx != (len(hull[5]) - 1):
                thissample = hull[4][indx] + (u - hull[5][indx]) / (
                    hull[5][indx + 1] - hull[5][indx]
                ) * (hull[4][indx + 1] - hull[4][indx])
            else:
                if isDomainFinite[1]:
                    thissample = hull[4][indx] + (u - hull[5][indx]) / (
                        1.0 - hull[5][indx]
                    ) * (domain[1] - hull[4][indx])
                else:
                    thissample = 100000  # Throw some kind of error
        else:
            thissample = hull[4][indx] + 1.0 / hull[3][indx + 1] * numpy.log(
                1.0
                + hull[3][indx + 1]
                * hull[0]
                * (u - hull[5][indx])
                / numpy.exp(hull[6][indx])
            )
    return thissample


def evaluate_hull(x, hull):
    &quot;&quot;&quot;
    Evaluate h_u(x) and (optional) h_l(x)

    Parameters
    ----------
    x : float
        abcissa
    hull : list
        the hull (see doc of setup_hull for definition)

    Returns
    -------
    float or tuple
        hu(x) (optional), hl(x)

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    # Find in which [z_{i-1},z_i] interval x lies
    if x &lt; hull[4][0]:
        # x lies in the first interval
        hux = hull[3][0] * (x - hull[1][0]) + hull[2][0]
        indx = 0
    else:
        if len(hull[5]) == 1:
            # There are only two intervals
            indx = 1
        else:
            indx = 1
            while indx &lt; len(hull[4]) and hull[4][indx] &lt; x:
                indx = indx + 1
            indx = indx - 1
        hux = hull[3][indx] * (x - hull[1][indx]) + hull[2][indx]
    # Now evaluate hlx
    neginf = numpy.finfo(numpy.dtype(numpy.float64)).min
    if x &lt; hull[1][0] or x &gt; hull[1][-1]:
        hlx = neginf
    else:
        if indx == 0:
            hlx = ((hull[1][1] - x) * hull[2][0] + (x - hull[1][0]) * hull[2][1]) / (
                hull[1][1] - hull[1][0]
            )
        elif indx == len(hull[4]):
            hlx = (
                (hull[1][-1] - x) * hull[2][-2] + (x - hull[1][-2]) * hull[2][-1]
            ) / (hull[1][-1] - hull[1][-2])
        elif x &lt; hull[1][indx + 1]:
            hlx = (
                (hull[1][indx + 1] - x) * hull[2][indx]
                + (x - hull[1][indx]) * hull[2][indx + 1]
            ) / (hull[1][indx + 1] - hull[1][indx])
        else:
            hlx = (
                (hull[1][indx + 2] - x) * hull[2][indx + 1]
                + (x - hull[1][indx + 1]) * hull[2][indx + 2]
            ) / (hull[1][indx + 2] - hull[1][indx + 1])
    return hux, hlx


def update_hull(hull, newx, newhx, newhpx, domain, isDomainFinite):
    &quot;&quot;&quot;
    Update the hull with a new function evaluation

    Parameters
    ----------
    hull : list
        the hull (see doc of setup_hull for definition)
    newx : float
        new abcissa
    newhx : float
        h(newx)
    newhpx : float
        hp(newx)
    domain : list or numpy.ndarray
        [.,.] upper and lower limit to the domain
    isDomainFinite : list or numpy.ndarray
        [.,.] is there a lower/upper limit to the domain?

    Returns
    -------
    list
        new hull

    Notes
    -----
    - 2009-05-21 - Written - Bovy (NYU)
    &quot;&quot;&quot;
    # BOVY: Perhaps add a check that newx is sufficiently far from any existing point
    # Find where newx fits in with the other xs
    if newx &gt; hull[1][-1]:
        newxs = numpy.append(hull[1], newx)
        newhxs = numpy.append(hull[2], newhx)
        newhpxs = numpy.append(hull[3], newhpx)
        # new z
        newz = (newhx - hull[2][-1] - newx * newhpx + hull[1][-1] * hull[3][-1]) / (
            hull[3][-1] - newhpx
        )
        newzs = numpy.append(hull[4], newz)
        # New hu
        newhu = hull[3][-1] * (newz - hull[1][-1]) + hull[2][-1]
        newhus = numpy.append(hull[6], newhu)
    else:
        indx = 0
        while newx &gt; hull[1][indx]:
            indx = indx + 1
        newxs = numpy.insert(hull[1], indx, newx)
        newhxs = numpy.insert(hull[2], indx, newhx)
        newhpxs = numpy.insert(hull[3], indx, newhpx)
        # Replace old z with new zs
        if newx &lt; hull[1][0]:
            newz = (hull[2][0] - newhx - hull[1][0] * hull[3][0] + newx * newhpx) / (
                newhpx - hull[3][0]
            )
            newzs = numpy.insert(hull[4], 0, newz)
            # Also add the new hu
            newhu = newhpx * (newz - newx) + newhx
            newhus = numpy.insert(hull[6], 0, newhu)
        else:
            newz1 = (
                newhx
                - hull[2][indx - 1]
                - newx * newhpx
                + hull[1][indx - 1] * hull[3][indx - 1]
            ) / (hull[3][indx - 1] - newhpx)
            newz2 = (
                hull[2][indx] - newhx - hull[1][indx] * hull[3][indx] + newx * newhpx
            ) / (newhpx - hull[3][indx])
            # Insert newz1 and replace z_old
            newzs = numpy.insert(hull[4], indx - 1, newz1)
            newzs[indx] = newz2
            # Update the hus
            newhu1 = hull[3][indx - 1] * (newz1 - hull[1][indx - 1]) + hull[2][indx - 1]
            newhu2 = newhpx * (newz2 - newx) + newhx
            newhus = numpy.insert(hull[6], indx - 1, newhu1)
            newhus[indx] = newhu2
    # Recalculate the cumulative sum
    nx = len(newxs)
    newscum = numpy.zeros(nx - 1)
    if isDomainFinite[0]:
        newscum[0] = (
            1.0
            / newhpxs[0]
            * (
                numpy.exp(newhus[0])
                - numpy.exp(newhpxs[0] * (domain[0] - newxs[0]) + newhxs[0])
            )
        )
    else:
        newscum[0] = 1.0 / newhpxs[0] * numpy.exp(newhus[0])
    if nx &gt; 2:
        for jj in range(nx - 2):
            if newhpxs[jj + 1] == 0.0:
                newscum[jj + 1] = (newzs[jj + 1] - newzs[jj]) * numpy.exp(
                    newhxs[jj + 1]
                )
            else:
                newscum[jj + 1] = (
                    1.0
                    / newhpxs[jj + 1]
                    * (numpy.exp(newhus[jj + 1]) - numpy.exp(newhus[jj]))
                )
    if isDomainFinite[1]:
        newcu = (
            1.0
            / newhpxs[nx - 1]
            * (
                numpy.exp(
                    newhpxs[nx - 1] * (domain[1] - newxs[nx - 1]) + newhxs[nx - 1]
                )
                - numpy.exp(newhus[nx - 2])
            )
        )
    else:
        newcu = -1.0 / newhpxs[nx - 1] * numpy.exp(newhus[nx - 2])
    newcu = newcu + numpy.sum(newscum)
    newscum = numpy.cumsum(newscum) / newcu
    newhull = []
    newhull.append(newcu)
    newhull.append(newxs)
    newhull.append(newhxs)
    newhull.append(newhpxs)
    newhull.append(newzs)
    newhull.append(newscum)
    newhull.append(newhus)
    return newhull
</file>
    <file path="tests/conftest.py">
def pytest_generate_tests(metafunc):
    # galpy imports must be hear to not interfere with different config settings
    # in different files
    # Maybe I should define a cmdline option to set the config instead...
    from galpy import potential

    if metafunc.function.__name__ == &quot;test_energy_jacobi_conservation&quot;:
        # Generate orbit integration tests for all potentials
        # Grab all of the potentials
        pots = [
            p
            for p in dir(potential)
            if (
                &quot;Potential&quot; in p
                and not &quot;plot&quot; in p
                and not &quot;RZTo&quot; in p
                and not &quot;FullTo&quot; in p
                and not &quot;toPlanar&quot; in p
                and not &quot;evaluate&quot; in p
                and not &quot;Wrapper&quot; in p
                and not &quot;toVertical&quot; in p
            )
        ]
        pots.append(&quot;mockFlatEllipticalDiskPotential&quot;)
        pots.append(&quot;mockFlatLopsidedDiskPotential&quot;)
        pots.append(&quot;mockFlatCosmphiDiskPotential&quot;)
        pots.append(&quot;mockFlatCosmphiDiskwBreakPotential&quot;)
        pots.append(&quot;mockSlowFlatEllipticalDiskPotential&quot;)
        pots.append(&quot;mockFlatDehnenBarPotential&quot;)
        pots.append(&quot;mockSlowFlatDehnenBarPotential&quot;)
        pots.append(&quot;mockFlatSteadyLogSpiralPotential&quot;)
        pots.append(&quot;mockSlowFlatSteadyLogSpiralPotential&quot;)
        pots.append(&quot;mockFlatTransientLogSpiralPotential&quot;)
        pots.append(&quot;specialMiyamotoNagaiPotential&quot;)
        pots.append(&quot;specialFlattenedPowerPotential&quot;)
        pots.append(&quot;BurkertPotentialNoC&quot;)
        pots.append(&quot;testMWPotential&quot;)
        pots.append(&quot;testplanarMWPotential&quot;)
        pots.append(&quot;mockMovingObjectLongIntPotential&quot;)
        pots.append(&quot;oblateHernquistPotential&quot;)
        pots.append(&quot;oblateNFWPotential&quot;)
        pots.append(&quot;prolateNFWPotential&quot;)
        pots.append(&quot;prolateJaffePotential&quot;)
        pots.append(&quot;triaxialNFWPotential&quot;)
        pots.append(&quot;fullyRotatedTriaxialNFWPotential&quot;)
        pots.append(&quot;NFWTwoPowerTriaxialPotential&quot;)  # for planar-from-full
        pots.append(&quot;mockSCFZeeuwPotential&quot;)
        pots.append(&quot;mockSCFNFWPotential&quot;)
        pots.append(&quot;mockSCFAxiDensity1Potential&quot;)
        pots.append(&quot;mockSCFAxiDensity2Potential&quot;)
        pots.append(&quot;mockSCFDensityPotential&quot;)
        pots.append(&quot;sech2DiskSCFPotential&quot;)
        pots.append(&quot;expwholeDiskSCFPotential&quot;)
        pots.append(&quot;altExpwholeDiskSCFPotential&quot;)
        pots.append(&quot;mockFlatSpiralArmsPotential&quot;)
        pots.append(&quot;mockRotatingFlatSpiralArmsPotential&quot;)
        pots.append(&quot;mockSpecialRotatingFlatSpiralArmsPotential&quot;)
        pots.append(&quot;mockFlatDehnenSmoothBarPotential&quot;)
        pots.append(&quot;mockSlowFlatDehnenSmoothBarPotential&quot;)
        pots.append(&quot;mockSlowFlatDecayingDehnenSmoothBarPotential&quot;)
        pots.append(&quot;mockFlatSolidBodyRotationSpiralArmsPotential&quot;)
        pots.append(&quot;mockFlatSolidBodyRotationPlanarSpiralArmsPotential&quot;)
        pots.append(&quot;triaxialLogarithmicHaloPotential&quot;)
        pots.append(&quot;testorbitHenonHeilesPotential&quot;)
        pots.append(&quot;mockFlatCorotatingRotationSpiralArmsPotential&quot;)
        pots.append(&quot;mockFlatGaussianAmplitudeBarPotential&quot;)
        pots.append(&quot;nestedListPotential&quot;)
        pots.append(&quot;mockInterpSphericalPotential&quot;)
        pots.append(&quot;mockAdiabaticContractionMWP14WrapperPotential&quot;)
        pots.append(&quot;mockRotatedAndTiltedMWP14WrapperPotential&quot;)
        pots.append(&quot;testNullPotential&quot;)
        pots.append(&quot;mockKuzminLikeWrapperPotential&quot;)
        rmpots = [
            &quot;Potential&quot;,
            &quot;MWPotential&quot;,
            &quot;MWPotential2014&quot;,
            &quot;MovingObjectPotential&quot;,
            &quot;interpRZPotential&quot;,
            &quot;linearPotential&quot;,
            &quot;planarAxiPotential&quot;,
            &quot;planarPotential&quot;,
            &quot;verticalPotential&quot;,
            &quot;PotentialError&quot;,
            &quot;SnapshotRZPotential&quot;,
            &quot;InterpSnapshotRZPotential&quot;,
            &quot;EllipsoidalPotential&quot;,
            &quot;NumericalPotentialDerivativesMixin&quot;,
            &quot;SphericalPotential&quot;,
            &quot;interpSphericalPotential&quot;,
        ]
        rmpots.append(&quot;SphericalShellPotential&quot;)
        rmpots.append(&quot;RingPotential&quot;)
        for p in rmpots:
            pots.remove(p)
        # tolerances in log10
        tol = {}
        tol[&quot;default&quot;] = -10.0
        tol[&quot;DoubleExponentialDiskPotential&quot;] = -6.0  # these are more difficult
        jactol = {}
        jactol[&quot;default&quot;] = -10.0
        jactol[&quot;RazorThinExponentialDiskPotential&quot;] = -9.0  # these are more difficult
        jactol[&quot;DoubleExponentialDiskPotential&quot;] = -6.0  # these are more difficult
        jactol[&quot;mockFlatDehnenBarPotential&quot;] = -8.0  # these are more difficult
        jactol[&quot;mockFlatDehnenSmoothBarPotential&quot;] = -8.0  # these are more difficult
        jactol[&quot;mockMovingObjectLongIntPotential&quot;] = -8.0  # these are more difficult
        jactol[
            &quot;mockSlowFlatEllipticalDiskPotential&quot;
        ] = -6.0  # these are more difficult (and also not quite conserved)
        jactol[
            &quot;mockSlowFlatSteadyLogSpiralPotential&quot;
        ] = -8.0  # these are more difficult (and also not quite conserved)
        jactol[
            &quot;mockSlowFlatDehnenSmoothBarPotential&quot;
        ] = -8.0  # these are more difficult (and also not quite conserved)
        jactol[
            &quot;mockSlowFlatDecayingDehnenSmoothBarPotential&quot;
        ] = -8.0  # these are more difficult (and also not quite conserved)
        # Now generate all inputs and run tests
        tols = [tol[p] if p in tol else tol[&quot;default&quot;] for p in pots]
        jactols = [jactol[p] if p in jactol else tol[&quot;default&quot;] for p in pots]
        firstTest = [True if ii == 0 else False for ii in range(len(pots))]
        metafunc.parametrize(
            &quot;pot,ttol,tjactol,firstTest&quot;, zip(pots, tols, jactols, firstTest)
        )
    elif metafunc.function.__name__ == &quot;test_energy_conservation_linear&quot;:
        # Generate linear orbit integration tests for all potentials
        # Grab all of the potentials
        pots = [
            p
            for p in dir(potential)
            if (
                &quot;Potential&quot; in p
                and not &quot;plot&quot; in p
                and not &quot;RZTo&quot; in p
                and not &quot;FullTo&quot; in p
                and not &quot;toPlanar&quot; in p
                and not &quot;evaluate&quot; in p
                and not &quot;Wrapper&quot; in p
                and not &quot;toVertical&quot; in p
            )
        ]
        pots.append(&quot;specialMiyamotoNagaiPotential&quot;)
        pots.append(&quot;specialFlattenedPowerPotential&quot;)
        pots.append(&quot;BurkertPotentialNoC&quot;)
        pots.append(&quot;testMWPotential&quot;)
        pots.append(&quot;testplanarMWPotential&quot;)
        pots.append(&quot;testlinearMWPotential&quot;)
        pots.append(&quot;mockCombLinearPotential&quot;)
        pots.append(&quot;mockSimpleLinearPotential&quot;)
        pots.append(&quot;oblateNFWPotential&quot;)
        pots.append(&quot;prolateNFWPotential&quot;)
        pots.append(&quot;triaxialNFWPotential&quot;)
        pots.append(&quot;fullyRotatedTriaxialNFWPotential&quot;)
        pots.append(&quot;NFWTwoPowerTriaxialPotential&quot;)  # for planar-from-full
        pots.append(&quot;mockSCFZeeuwPotential&quot;)
        pots.append(&quot;mockSCFNFWPotential&quot;)
        pots.append(&quot;mockSCFAxiDensity1Potential&quot;)
        pots.append(&quot;mockSCFAxiDensity2Potential&quot;)
        pots.append(&quot;sech2DiskSCFPotential&quot;)
        pots.append(&quot;expwholeDiskSCFPotential&quot;)
        pots.append(&quot;altExpwholeDiskSCFPotential&quot;)
        pots.append(&quot;triaxialLogarithmicHaloPotential&quot;)
        pots.append(&quot;nestedListPotential&quot;)
        pots.append(&quot;mockInterpSphericalPotential&quot;)
        pots.append(&quot;mockAdiabaticContractionMWP14WrapperPotential&quot;)
        pots.append(&quot;mockRotatedAndTiltedMWP14WrapperPotential&quot;)
        pots.append(&quot;testNullPotential&quot;)
        pots.append(&quot;mockKuzminLikeWrapperPotential&quot;)
        rmpots = [
            &quot;Potential&quot;,
            &quot;MWPotential&quot;,
            &quot;MWPotential2014&quot;,
            &quot;MovingObjectPotential&quot;,
            &quot;interpRZPotential&quot;,
            &quot;linearPotential&quot;,
            &quot;planarAxiPotential&quot;,
            &quot;planarPotential&quot;,
            &quot;verticalPotential&quot;,
            &quot;PotentialError&quot;,
            &quot;SnapshotRZPotential&quot;,
            &quot;InterpSnapshotRZPotential&quot;,
            &quot;EllipsoidalPotential&quot;,
            &quot;NumericalPotentialDerivativesMixin&quot;,
            &quot;SphericalPotential&quot;,
            &quot;interpSphericalPotential&quot;,
        ]
        rmpots.append(&quot;SphericalShellPotential&quot;)
        rmpots.append(&quot;RingPotential&quot;)
        rmpots.append(&quot;SoftenedNeedleBarPotential&quot;)
        for p in rmpots:
            pots.remove(p)
        # tolerances in log10
        tol = {}
        tol[&quot;default&quot;] = -10.0
        tol[&quot;DoubleExponentialDiskPotential&quot;] = -6.0  # these are more difficult
        # Now generate all inputs and run tests
        tols = [tol[p] if p in tol else tol[&quot;default&quot;] for p in pots]
        firstTest = [True if ii == 0 else False for ii in range(len(pots))]
        metafunc.parametrize(&quot;pot,ttol,firstTest&quot;, zip(pots, tols, firstTest))
    return None
</file>
    <file path="tests/orbitint4sigint.py">
import sys

import numpy

from galpy.orbit import Orbit
from galpy.potential import MiyamotoNagaiPotential

if __name__ == &quot;__main__&quot;:
    # python orbitint4sigint.py symplec4_c full
    mp = MiyamotoNagaiPotential(normalize=1.0, a=0.5, b=0.05)
    ts = numpy.linspace(0.0, 10000000.0, 1000001)
    if sys.argv[2] == &quot;full&quot; or sys.argv[2] == &quot;planar&quot;:
        if sys.argv[2] == &quot;full&quot;:
            o = Orbit([1.0, 0.1, 1.1, 0.1, 0.1, 0.0])
        elif sys.argv[2] == &quot;planar&quot;:
            o = Orbit([1.0, 0.1, 1.1, 0.1])
        print(&quot;Starting long C integration ...&quot;)
        sys.stdout.flush()
        o.integrate(ts, mp, method=sys.argv[1])
    elif sys.argv[2] == &quot;planardxdv&quot;:
        o = Orbit([1.0, 0.1, 1.1, 0.1])
        print(&quot;Starting long C integration ...&quot;)
        sys.stdout.flush()
        o.integrate_dxdv([0.1, 0.1, 0.1, 0.1], ts, mp, method=sys.argv[1])
    sys.exit(0)
</file>
    <file path="tests/test_amuse.py">
# Test consistency between galpy and amuse
import numpy
from amuse.couple import bridge
from amuse.datamodel import Particles
from amuse.lab import *  # nopycln: import
from astropy import units as apy_u

from galpy import potential
from galpy.orbit import Orbit
from galpy.potential import to_amuse
from galpy.util import conversion


def test_amuse_potential_with_physical():
    ro, vo = 8.0, 220.0
    amp = 1e8 / conversion.mass_in_msol(ro=ro, vo=vo)
    a = 0.8 / ro

    amp_u = 1e8 * apy_u.solMass
    a_u = 0.8 * apy_u.kpc
    ro_u, vo_u = 8.0 * apy_u.kpc, 220.0 * apy_u.km / apy_u.s

    x, y, z = 3 | units.kpc, 4 | units.kpc, 2 | units.kpc
    r = 5 | units.kpc

    # ------------------------------------
    # get_potential_at_point
    pot1 = potential.TwoPowerSphericalPotential(amp=amp, a=a, ro=ro, vo=vo)
    gg1 = pot1(5 / ro, 2 / ro)
    gg1 = gg1.to_value(apy_u.km**2 / apy_u.s**2) if hasattr(gg1, &quot;unit&quot;) else gg1
    amuse_pot1 = to_amuse(pot1)
    ag1 = amuse_pot1.get_potential_at_point(0, x, y, z)

    assert numpy.abs(gg1 - ag1.value_in(units.kms**2)) &lt; 1e-10

    pot2 = potential.TwoPowerSphericalPotential(amp=amp_u, a=a_u, ro=ro_u, vo=vo_u)
    gg2 = pot1(5 * apy_u.kpc, 2 * apy_u.kpc)
    gg2 = gg2.to_value(apy_u.km**2 / apy_u.s**2) if hasattr(gg2, &quot;unit&quot;) else gg2
    amuse_pot2 = to_amuse(pot2)
    ag2 = amuse_pot2.get_potential_at_point(0, x, y, z)

    assert numpy.abs(gg2 - ag2.value_in(units.kms**2)) &lt; 1e-10

    assert numpy.abs(ag1 - ag2) &lt; 1e-10 | units.kms**2

    # ------------------------------------
    # test get_gravity_at_point
    pot1 = potential.TwoPowerSphericalPotential(amp=amp, a=a, ro=ro, vo=vo)
    amuse_pot1 = to_amuse(pot1)
    ax1, ay1, az1 = amuse_pot1.get_gravity_at_point(0, x, y, z)

    pot2 = potential.TwoPowerSphericalPotential(amp=amp_u, a=a_u, ro=ro_u, vo=vo_u)
    amuse_pot2 = to_amuse(pot2)
    ax2, ay2, az2 = amuse_pot2.get_gravity_at_point(0, x, y, z)

    assert numpy.abs(ax1 - ax2) &lt; 1e-10 | units.kms / units.Myr
    assert numpy.abs(ay1 - ay2) &lt; 1e-10 | units.kms / units.Myr
    assert numpy.abs(az1 - az2) &lt; 1e-10 | units.kms / units.Myr

    # ------------------------------------
    # test mass_density
    pot1 = potential.TwoPowerSphericalPotential(amp=amp, a=a, ro=ro, vo=vo)
    grho1 = pot1.dens(5 / ro, 2 / ro)
    grho1 = (
        grho1.to_value(apy_u.solMass / apy_u.pc**3) if hasattr(grho1, &quot;unit&quot;) else grho1
    )
    amuse_pot1 = to_amuse(pot1)
    arho1 = amuse_pot1.mass_density(x, y, z)

    assert numpy.abs(grho1 - arho1.value_in(units.MSun / units.parsec**3)) &lt; 1e-10

    pot2 = potential.TwoPowerSphericalPotential(amp=amp_u, a=a_u, ro=ro_u, vo=vo_u)
    grho2 = pot2.dens(5 * apy_u.kpc, 2 * apy_u.kpc)
    grho2 = (
        grho2.to_value(apy_u.solMass / apy_u.pc**3) if hasattr(grho2, &quot;unit&quot;) else grho2
    )
    amuse_pot2 = to_amuse(pot2)
    arho2 = amuse_pot2.mass_density(x, y, z)

    assert numpy.abs(grho2 - arho2.value_in(units.MSun / units.parsec**3)) &lt; 1e-10

    assert numpy.abs(arho1 - arho2) &lt; 1e-10 | units.MSun / units.parsec**3

    # ------------------------------------
    # test circular_velocity
    pot1 = potential.TwoPowerSphericalPotential(amp=amp, a=a, ro=ro, vo=vo)
    gv1 = pot1.vcirc(1 * apy_u.kpc)
    gv1 = gv1.to_value(apy_u.km / apy_u.s) if hasattr(gv1, &quot;unit&quot;) else gv1
    amuse_pot1 = to_amuse(pot1)
    av1 = amuse_pot1.circular_velocity(1 | units.kpc)

    assert numpy.abs(gv1 - av1.value_in(units.kms)) &lt; 1e-10

    pot2 = potential.TwoPowerSphericalPotential(amp=amp_u, a=a_u, ro=ro_u, vo=vo_u)
    gv2 = pot2.vcirc(1 * apy_u.kpc)
    gv2 = gv2.to_value(apy_u.km / apy_u.s) if hasattr(gv2, &quot;unit&quot;) else gv2
    amuse_pot2 = to_amuse(pot2)
    av2 = amuse_pot2.circular_velocity(1 | units.kpc)

    assert numpy.abs(gv2 - av2.value_in(units.kms)) &lt; 1e-10

    assert numpy.abs(av1 - av2) &lt; 1e-10 | units.kms

    # ------------------------------------
    # test enclosed_mass

    pot1 = potential.TwoPowerSphericalPotential(amp=amp, a=a, ro=ro, vo=vo)
    gm1 = pot1.mass(1 / ro)
    gm1 = gm1.to_value(apy_u.solMass) if hasattr(gm1, &quot;unit&quot;) else gm1
    amuse_pot1 = to_amuse(pot1)
    am1 = amuse_pot1.enclosed_mass(1 | units.kpc)

    assert numpy.abs(gm1 - am1.value_in(units.MSun)) &lt; 3e-8

    pot2 = potential.TwoPowerSphericalPotential(amp=amp_u, a=a_u, ro=ro_u, vo=vo_u)
    gm2 = pot2.mass(1 * apy_u.kpc)
    gm2 = gm2.to_value(apy_u.solMass) if hasattr(gm2, &quot;unit&quot;) else gm2
    amuse_pot2 = to_amuse(pot2)
    am2 = amuse_pot2.enclosed_mass(1 | units.kpc)

    assert numpy.abs(gm2 - am2.value_in(units.MSun)) &lt; 3e-8

    assert numpy.abs(am1 - am2) &lt; 1e-10 | units.MSun

    return None


def test_amuse_MN3ExponentialDiskPotential():
    mn = potential.MN3ExponentialDiskPotential(normalize=1.0, hr=0.5, hz=0.1)
    tmax = 3.0
    vo, ro = 215.0, 8.75
    o = Orbit([1.0, 0.1, 1.1, 0.3, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, mn, tmax, vo, ro)
    return None


def test_amuse_MiyamotoNagaiPotential():
    mp = potential.MiyamotoNagaiPotential(normalize=1.0, a=0.5, b=0.1)
    tmax = 4.0
    vo, ro = 220.0, 8.0
    o = Orbit([1.0, 0.1, 1.1, 0.3, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, mp, tmax, vo, ro)
    return None


def test_amuse_NFWPotential():
    np = potential.NFWPotential(normalize=1.0, a=3.0)
    tmax = 3.0
    vo, ro = 200.0, 7.0
    o = Orbit([1.0, 0.5, 1.3, 0.3, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, np, tmax, vo, ro)
    return None


def test_amuse_HernquistPotential():
    hp = potential.HernquistPotential(normalize=1.0, a=3.0)
    tmax = 3.0
    vo, ro = 210.0, 7.5
    o = Orbit([1.0, 0.25, 1.4, 0.3, -0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, hp, tmax, vo, ro, tol=0.02)
    return None


def test_amuse_PowerSphericalPotentialwCutoffPotential():
    pp = potential.PowerSphericalPotentialwCutoff(normalize=1.0, alpha=1.0, rc=0.4)
    tmax = 2.0
    vo, ro = 180.0, 9.0
    o = Orbit([1.0, 0.03, 1.03, 0.2, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, pp, tmax, vo, ro)
    return None


def test_amuse_LogarithmicHaloPotential():
    lp = potential.LogarithmicHaloPotential(normalize=1.0)
    tmax = 2.0
    vo, ro = 210.0, 8.5
    o = Orbit([1.0, 0.1, 1.1, 0.3, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, lp, tmax, vo, ro, tol=0.03)
    return None


def test_amuse_PlummerPotential():
    pp = potential.PlummerPotential(normalize=1.0, b=2.0)
    tmax = 3.0
    vo, ro = 213.0, 8.23
    o = Orbit([1.0, 0.1, 1.1, 0.3, 0.1, 0.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, pp, tmax, vo, ro, tol=0.03)
    return None


def test_amuse_MWPotential2014():
    mp = potential.MWPotential2014
    tmax = 3.5
    vo, ro = 220.0, 8.0
    o = Orbit([1.0, 0.1, 1.1, 0.2, 0.1, 1.4], ro=ro, vo=vo)
    run_orbitIntegration_comparison(o, mp, tmax, vo, ro)
    return None


def run_orbitIntegration_comparison(orb, pot, tmax, vo, ro, tol=0.01):
    # Integrate in galpy
    ts = numpy.linspace(0.0, tmax / conversion.time_in_Gyr(vo, ro), 1001)
    orb.integrate(ts, pot)

    # Integrate with amuse
    x, y, z, vx, vy, vz = integrate_amuse(orb, pot, tmax | units.Gyr, vo, ro)

    # Read and compare

    xdiff = numpy.fabs((x - orb.x(ts[-1])) / x)
    ydiff = numpy.fabs((y - orb.y(ts[-1])) / y)
    zdiff = numpy.fabs((z - orb.z(ts[-1])) / z)
    vxdiff = numpy.fabs((vx - orb.vx(ts[-1])) / vx)
    vydiff = numpy.fabs((vy - orb.vy(ts[-1])) / vy)
    vzdiff = numpy.fabs((vz - orb.vz(ts[-1])) / vz)
    assert xdiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for x by %g&quot; % xdiff
    )
    assert ydiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for y by %g&quot; % ydiff
    )
    assert zdiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for z by %g&quot; % zdiff
    )
    assert vxdiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for vx by %g&quot; % vxdiff
    )
    assert vydiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for vy by %g&quot; % vydiff
    )
    assert vzdiff &lt; tol, (
        &quot;galpy and amuse orbit integration inconsistent for vz by %g&quot; % vzdiff
    )

    return None


def integrate_amuse(orb, pot, tmax, vo, ro):
    &quot;&quot;&quot;Integrate a snapshot in infile until tmax in Gyr, save to outfile&quot;&quot;&quot;

    time = 0.0 | tmax.unit
    dt = tmax / 10001.0

    orbit = Particles(1)

    orbit.mass = 1.0 | units.MSun
    orbit.radius = 1.0 | units.RSun

    orbit.position = [orb.x(), orb.y(), orb.z()] | units.kpc
    orbit.velocity = [orb.vx(), orb.vy(), orb.vz()] | units.kms
    galaxy_code = to_amuse(pot, ro=ro, vo=vo)

    orbit_gravity = drift_without_gravity(orbit)
    orbit_gravity.particles.add_particles(orbit)
    channel_from_gravity_to_orbit = orbit_gravity.particles.new_channel_to(orbit)

    gravity = bridge.Bridge(use_threading=False)
    gravity.add_system(orbit_gravity, (galaxy_code,))
    gravity.add_system(
        galaxy_code,
    )
    gravity.timestep = dt

    while time &lt;= tmax:
        time += dt
        gravity.evolve_model(time)

    channel_from_gravity_to_orbit.copy()
    gravity.stop()

    return (
        orbit.x[0].value_in(units.kpc),
        orbit.y[0].value_in(units.kpc),
        orbit.z[0].value_in(units.kpc),
        orbit.vx[0].value_in(units.kms),
        orbit.vy[0].value_in(units.kms),
        orbit.vz[0].value_in(units.kms),
    )


class drift_without_gravity:
    def __init__(self, convert_nbody, time=0 | units.Myr):
        self.model_time = time
        self.particles = Particles()

    def evolve_model(self, t_end):
        dt = t_end - self.model_time
        self.particles.position += self.particles.velocity * dt
        self.model_time = t_end

    @property
    def potential_energy(self):
        return quantities.zero

    @property
    def get_potential_at_point(self):
        return quantities.zero

    @property
    def kinetic_energy(self):
        return (
            0.5 * self.particles.mass * self.particles.velocity.lengths() ** 2
        ).sum()

    @property
    def angular_momenum(self):
        return numpy.cross(self.particles.position, self.particles.velocity)

    def stop(self):
        pass
</file>
    <file path="tests/test_import.py">
###################TEST WHETHER THE PACKAGE CAN BE IMPORTED####################
def test_top_import():
    import galpy


def test_orbit_import():
    import galpy.orbit


def test_potential_import():
    import galpy.potential


def test_actionAngle_import():
    import galpy.actionAngle


def test_df_import():
    import galpy.df


def test_util_import():
    import galpy.util
    import galpy.util.conversion
    import galpy.util.coords
    import galpy.util.multi
    import galpy.util.plot
</file>
    <file path="tests/test_jeans.py">
# Tests of the galpy.df.jeans module: Jeans equations
import numpy

from galpy.df import jeans


# Test sigmar: radial velocity dispersion from the spherical Jeans equation
# For log halo, constant beta: sigma(r) = vc/sqrt(2.-2*beta)
def test_sigmar_wlog_constbeta():
    from galpy.potential import LogarithmicHaloPotential

    lp = LogarithmicHaloPotential(normalize=1.0, q=1.0)
    rs = numpy.linspace(0.001, 5.0, 101)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r) for r in rs]) - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # general beta --&gt; sigma = vc/sqrt(2-2beta)
    beta = 0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r, beta=beta) for r in rs])
            - 1.0 / numpy.sqrt(2.0 - 2.0 * beta)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0.5&quot;
    beta = -0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r, beta=beta) for r in rs])
            - 1.0 / numpy.sqrt(2.0 - 2.0 * beta)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=-0.5&quot;
    return None


# Test sigmar: radial velocity dispersion from the spherical Jeans equation
# For log halo, constant beta: sigma(r) = vc/sqrt(2.-2*beta)
def test_sigmar_wlog_constbeta_diffdens_powerlaw():
    from galpy.potential import LogarithmicHaloPotential

    lp = LogarithmicHaloPotential(normalize=1.0, q=1.0)
    rs = numpy.linspace(0.001, 5.0, 101)
    # general beta and r^-gamma --&gt; sigma = vc/sqrt(gamma-2beta)
    gamma, beta = 1.0, 0.0
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [jeans.sigmar(lp, r, beta=beta, dens=lambda r: r**-gamma) for r in rs]
            )
            - 1.0 / numpy.sqrt(gamma - 2.0 * beta)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential, beta=0, and power-law density r^-1&quot;
    gamma, beta = 3.0, 0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [jeans.sigmar(lp, r, beta=beta, dens=lambda r: r**-gamma) for r in rs]
            )
            - 1.0 / numpy.sqrt(gamma - 2.0 * beta)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential, beta=0.5, and power-law density r^-3&quot;
    gamma, beta = 0.0, -0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [jeans.sigmar(lp, r, beta=beta, dens=lambda r: r**-gamma) for r in rs]
            )
            - 1.0 / numpy.sqrt(gamma - 2.0 * beta)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential, beta=-0.5, and power-law density r^0&quot;
    return None


def test_sigmar_wlog_constbeta_asbetafunc():
    from galpy.potential import LogarithmicHaloPotential

    lp = LogarithmicHaloPotential(normalize=1.0, q=1.0)
    rs = numpy.linspace(0.001, 5.0, 101)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r, beta=lambda x: 0.0) for r in rs])
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # general beta --&gt; sigma = vc/sqrt(2-2beta)
    beta = lambda x: 0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r, beta=beta) for r in rs])
            - 1.0 / numpy.sqrt(2.0 - 2.0 * beta(0))
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0.5&quot;
    beta = lambda x: -0.5
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmar(lp, r, beta=beta) for r in rs])
            - 1.0 / numpy.sqrt(2.0 - 2.0 * beta(0))
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=-0.5&quot;
    return None


def test_sigmar_wlog_linbeta():
    # for log halo, dens ~ r^-gamma, and beta = -b x r --&gt;
    # sigmar = vc sqrt( scipy.special.gamma(-gamma)*scipy.special.gammaincc(-gamma,2*b*r)/[(2*b*r)**-gamma*exp(-2*b*r)]
    from scipy import special

    from galpy.potential import LogarithmicHaloPotential

    lp = LogarithmicHaloPotential(normalize=1.0, q=1.0)
    rs = numpy.linspace(0.001, 5.0, 101)
    gamma, b = -0.1, 3.0
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmar(lp, r, beta=lambda x: -b * x, dens=lambda x: x**-gamma)
                    - numpy.sqrt(
                        special.gamma(-gamma)
                        * special.gammaincc(-gamma, 2 * b * r)
                        / ((2 * b * r) ** -gamma * numpy.exp(-2.0 * b * r))
                    )
                    for r in rs
                ]
            )
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential, beta= -b*r, and dens ~ r^-gamma&quot;
    gamma, b = -0.5, 4.0
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmar(lp, r, beta=lambda x: -b * x, dens=lambda x: x**-gamma)
                    - numpy.sqrt(
                        special.gamma(-gamma)
                        * special.gammaincc(-gamma, 2 * b * r)
                        / ((2 * b * r) ** -gamma * numpy.exp(-2.0 * b * r))
                    )
                    for r in rs
                ]
            )
        )
        &lt; 1e-10
    ), &quot;Radial sigma computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential, beta= -b*r, and dens ~ r^-gamma&quot;
    return None


# Test sigmalos: radial velocity dispersion from the spherical Jeans equation
# For log halo, beta = 0: sigmalos(r) = vc/sqrt(2.)
def test_sigmalos_wlog_zerobeta():
    from galpy.potential import LogarithmicHaloPotential

    lp = LogarithmicHaloPotential(normalize=1.0, q=1.0)
    rs = numpy.linspace(0.5, 2.0, 3)
    assert numpy.all(
        numpy.fabs(
            numpy.array([jeans.sigmalos(lp, r) for r in rs]) - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed sigmar
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [jeans.sigmalos(lp, r, sigma_r=1.0 / numpy.sqrt(2.0)) for r in rs]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed, callable sigmar
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmalos(lp, r, sigma_r=lambda x: 1.0 / numpy.sqrt(2.0))
                    for r in rs
                ]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed, callable sigmar and dens given
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmalos(
                        lp,
                        r,
                        dens=lambda x: x**-2,
                        sigma_r=lambda x: 1.0 / numpy.sqrt(2.0),
                    )
                    for r in rs
                ]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed, callable sigmar and dens,surfdens given as func
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmalos(
                        lp,
                        r,
                        dens=lambda x: lp.dens(x, 0.0),
                        surfdens=lambda x: lp.surfdens(x, numpy.inf),
                        sigma_r=lambda x: 1.0 / numpy.sqrt(2.0),
                    )
                    for r in rs
                ]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed, callable sigmar and dens,surfdens given (value)
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmalos(
                        lp,
                        r,
                        dens=lambda x: lp.dens(x, 0.0),
                        surfdens=lp.surfdens(r, numpy.inf),
                        sigma_r=lambda x: 1.0 / numpy.sqrt(2.0),
                    )
                    for r in rs
                ]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    # Also with pre-computed sigmar and callable beta
    rs = numpy.linspace(0.5, 2.0, 11)
    # beta = 0 --&gt; sigma = vc/sqrt(2)
    assert numpy.all(
        numpy.fabs(
            numpy.array(
                [
                    jeans.sigmalos(
                        lp, r, sigma_r=1.0 / numpy.sqrt(2.0), beta=lambda x: 0.0
                    )
                    for r in rs
                ]
            )
            - 1.0 / numpy.sqrt(2.0)
        )
        &lt; 1e-8
    ), &quot;Radial sigma_los computed w/ spherical Jeans equation incorrect for LogarithmicHaloPotential and beta=0&quot;
    return None
</file>
    <file path=".generate_lcov.sh">
#!/bin/bash
# rm old build
rm -rf build/
rm -vf galpy_integrate_c.so galpy_actionAngle_c.so galpy_interppotential_c.so
# Test the extensions
$PYTHON setup.py build_ext --coverage --single_ext --inplace
$PYTHON setup.py develop --coverage --single_ext --prefix=~/local
/usr/local/python-2.7.3/bin/nosetests -v -w nose/ -e plotting
lcov --capture --directory build/temp.linux-x86_64-2.7/galpy/ --output-file coverage.info
# Generate HTML
genhtml coverage.info --output-directory ~/public_html/galpy_lcov/
rm -vf coverage.info
</file>
    <file path="galpy/actionAngle/__init__.py">
from . import (
    actionAngle,
    actionAngleAdiabatic,
    actionAngleAdiabaticGrid,
    actionAngleHarmonic,
    actionAngleHarmonicInverse,
    actionAngleInverse,
    actionAngleIsochrone,
    actionAngleIsochroneApprox,
    actionAngleIsochroneInverse,
    actionAngleSpherical,
    actionAngleStaeckel,
    actionAngleStaeckelGrid,
    actionAngleTorus,
    actionAngleVertical,
    actionAngleVerticalInverse,
)

#
# Exceptions
#
UnboundError = actionAngle.UnboundError

#
# Functions
#
estimateDeltaStaeckel = actionAngleStaeckel.estimateDeltaStaeckel
estimateBIsochrone = actionAngleIsochroneApprox.estimateBIsochrone
dePeriod = actionAngleIsochroneApprox.dePeriod
#
# Classes
#
actionAngle = actionAngle.actionAngle
actionAngleInverse = actionAngleInverse.actionAngleInverse
actionAngleAdiabatic = actionAngleAdiabatic.actionAngleAdiabatic
actionAngleAdiabaticGrid = actionAngleAdiabaticGrid.actionAngleAdiabaticGrid
actionAngleStaeckelSingle = actionAngleStaeckel.actionAngleStaeckelSingle
actionAngleStaeckel = actionAngleStaeckel.actionAngleStaeckel
actionAngleStaeckelGrid = actionAngleStaeckelGrid.actionAngleStaeckelGrid
actionAngleIsochrone = actionAngleIsochrone.actionAngleIsochrone
actionAngleIsochroneApprox = actionAngleIsochroneApprox.actionAngleIsochroneApprox
actionAngleSpherical = actionAngleSpherical.actionAngleSpherical
actionAngleTorus = actionAngleTorus.actionAngleTorus
actionAngleIsochroneInverse = actionAngleIsochroneInverse.actionAngleIsochroneInverse
actionAngleHarmonic = actionAngleHarmonic.actionAngleHarmonic
actionAngleHarmonicInverse = actionAngleHarmonicInverse.actionAngleHarmonicInverse
actionAngleVertical = actionAngleVertical.actionAngleVertical
actionAngleVerticalInverse = actionAngleVerticalInverse.actionAngleVerticalInverse
</file>
    <file path="galpy/orbit/__init__.py">
from . import Orbits

#
# Functions
#

# none

#
# Classes
#
Orbit = Orbits.Orbit
</file>
  </repository_files>
</compressed_repository>
