<?xml version="1.0" ?>
<compressed_repository total_tokens="99992">
  <file_summary>
    
This section contains a summary of this file.


    <purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>
    


    <file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>
    


    <usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>
    


    <notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>
    


    <additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>
    


  </file_summary>
  <repository_structure>
.github/
  workflows/
    cron-tests.yml
    tests.yml
    tutorials.yml
    wheels.yml
  dependabot.yml
  pull_request_template.md
docs/
  _static/
    gala.css
  _templates/
    autosummary/
      base.rst
      class.rst
      module.rst
  coordinates/
    greatcircle.rst
    index.rst
  dynamics/
    actionangle.rst
    index.rst
    mockstreams.rst
    nbody.rst
    nd-representations.rst
    nonlinear.rst
    orbits-in-detail.rst
    references.txt
  integrate/
    index.rst
  potential/
    compositepotential.rst
    define-new-potential.rst
    hamiltonian-reference-frames.rst
    index.rst
    origin-rotation.rst
    scf-examples.rst
    scf.rst
  tutorials/
    data/
      MW_mass_enclosed.csv
    .gitignore
    Arbitrary-density-SCF.py
    circ-restricted-3body.rst
    define-milky-way-model.py
    integrate-potential-example.rst
    integrate-rotating-frame.rst
    Milky-Way-model.py
    mock-stream-heliocentric.rst
    nb_setup
    pyia-gala-orbit.py
  whatsnew/
    1.0.rst
    index.rst
  _static_animations.py
  .gitignore
  conf.py
  contributing.rst
  conventions.rst
  docs.rst
  getting_started.rst
  glossary.rst
  index.rst
  install.rst
  interop.rst
  make.bat
  Makefile
  references.txt
  refs.bib
  testing.rst
  tutorials.rst
  units.rst
  user_guide.rst
  util.rst
gala/
  coordinates/
    tests/
      gd1_coord.txt
      idl_vgsr_vhel.txt
      sergey_orphan.txt
      SgrCoord_data
      SgrCoord.cpp
      SgrCoord.h
      test_all_streamframes.py
      test_gd1.py
      test_greatcircle.py
      test_jhelum.py
      test_orphan.py
      test_pal5.py
      test_pm_cov_transform.py
      test_reflex.py
      test_sgr.py
      test_velocity_frame_transforms.py
      Vasiliev2020-Sagittarius-subset.csv
    __init__.py
    gd1.py
    greatcircle.py
    helpers.py
    jhelum.py
    magellanic_stream.py
    oph.py
    orphan.py
    pal13.py
    pal5.py
    pm_cov_transform.py
    poincarepolar.py
    reflex.py
    sgr.py
    velocity_frame_transforms.py
  dynamics/
    actionangle/
      _genfunc/
        genfunc_3d.py
        solver.py
        test_potentials.py
        toy_potentials.py
        visualize_surfaces.py
      tests/
        helpers.py
        staeckel_helpers.py
        test_actionangle_o2gf.py
        test_actionangle_staeckel.py
        test_analyticactionangle.py
      __init__.py
      actionangle_o2gf.py
      actionangle_staeckel.py
      analyticactionangle.py
    lyapunov/
      __init__.py
      dop853_lyapunov.pyx
    mockstream/
      tests/
        test_coord.py
        test_df.py
        test_mockstream_class.py
        test_mockstream.py
      __init__.py
      _coord.pxd
      _coord.pyx
      core.py
      df.pxd
      df.pyx
      mockstream_generator.py
      mockstream.pyx
    nbody/
      tests/
        test_nbody.py
      __init__.py
      core.py
      nbody_helper.h
      nbody.pxd
      nbody.pyx
    tests/
      test_core.py
      test_nonlinear.py
      test_orbit.py
      test_plot.py
      test_representation_nd.py
      test_util.py
    __init__.py
    core.py
    nonlinear.py
    orbit.py
    plot.py
    representation_nd.py
    setup_package.py
    util.py
  integrate/
    cyintegrators/
      dopri/
        dop853.c
        dop853.h
        licence.txt
      __init__.py
      dop853.pxd
      dop853.pyx
      leapfrog.pxd
      leapfrog.pyx
      ruth4.pxd
      ruth4.pyx
    pyintegrators/
      __init__.py
      dopri853.py
      leapfrog.py
      rk5.py
      ruth4.py
    tests/
      test_cyintegrators.py
      test_pyintegrators.py
      test_timespec.py
    __init__.py
    core.py
    setup_package.py
    timespec.py
  potential/
    frame/
      builtin/
        __init__.py
        builtin_frames.c
        builtin_frames.h
        frames.pyx
        transformations.py
      src/
        cframe.c
        cframe.h
      tests/
        test_builtin.py
        test_transformations.py
      __init__.py
      cframe.pxd
      cframe.pyx
      core.py
      setup_package.py
    hamiltonian/
      src/
        chamiltonian.c
        chamiltonian.h
      tests/
        helpers.py
        test_hamiltonian.py
        test_with_frame_potential.py
      __init__.py
      chamiltonian.pyx
      setup_package.py
    potential/
      builtin/
        __init__.py
        builtin_potentials.c
        builtin_potentials.h
        core.py
        cybuiltin.pyx
        multipole.c
        multipole.h
        pybuiltin.py
        special.py
      src/
        cpotential.c
        cpotential.h
      tests/
        ccomposite.yml
        Composite.yml
        generate_agama.py
        HarmonicOscillator1D.yml
        helpers.py
        lm10.yml
        Plummer.yml
        pot_disk_506151.pot
        test_all_builtin.py
        test_composite.py
        test_core.py
        test_cpotential.py
        test_interop_agama.py
        test_interop_galpy.py
        test_io.py
        test_special.py
        test_util.py
      __init__.py
      ccompositepotential.pyx
      core.py
      cpotential.pxd
      cpotential.pyx
      interop.py
      io.py
      setup_package.py
      util.py
    scf/
      src/
        bfe_helper.c
        bfe_helper.h
        bfe.c
        bfe.h
        coeff_helper.c
        coeff_helper.h
      tests/
        data/
          computed-hernquist.coeff
          multi-hernquist.coeff
          plummer_coeff_nmax10_lmax5.txt
          plummer_coeff_var_nmax10_lmax5.txt
          random.coeff
          README.md
          simple-hernquist.coeff
          simple-nonsph.coeff
          Snlm-mathematica.csv
          wang-zhao.coeff
        test_accp_fortran.py
        test_bfe_interp.py
        test_bfe.py
        test_class.py
        test_computecoeff_discrete.py
        test_computecoeff_fortran.py
        test_computecoeff.py
      __init__.py
      bfe_class.pyx
      bfe.pyx
      computecoeff.pyx
      core.py
      setup_package.py
    src/
      funcdefs.h
    __init__.py
    common.py
  tests/
    optional_deps.py
    setup_package.py
    test_units.py
    test_util.py
  __init__.py
  _compat_utils.py
  cconfig.pyx
  conftest.py
  io.py
  logging.py
  setup_package.py
  units.py
  util.py
paper/
  paper.bib
  paper.md
.gitignore
.readthedocs.yml
.rtd-environment.yml
AUTHORS.rst
CHANGES.rst
CODE_OF_CONDUCT.md
codemeta.json
LICENSE
pyproject.toml
README.rst
setup.py
</repository_structure>
  <repository_files>
    <file path=".github/workflows/cron-tests.yml">
name: Cron tests

on:
  schedule:
    - cron: &quot;0 10 * * 1&quot;  # Mondays @ 6AM Eastern
  pull_request:
    # We also want this workflow triggered if the 'Extra CI' label is added
    # or present when PR is updated
    types:
      - synchronize
      - labeled

jobs:
  tests:
    name: Python ${{ matrix.python }} on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    if: (github.event_name == 'schedule' || contains(github.event.pull_request.labels.*.name, 'Extra CI'))
    strategy:
      fail-fast: true
      matrix:
        os: [ubuntu-latest, macos-latest]  # TODO: re-enable windows-latest
        python: ['3.9', '3.10', '3.11']
        include:
          # These set options for each python version. So, for example, when any
          # python 3.11 job in the matrix runs, it should use this toxenv
          - python: '3.11'
            toxenv: py311-test

          - python: '3.10'
            toxenv: py310-test

          - python: 3.9
            toxenv: py39-test-cov

          - python: 3.11
            toxenv: py311-test-extradeps

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # For animation tests
      - uses: FedericoCarboni/setup-ffmpeg@v3
        with:
          # Not strictly necessary, but it may prevent rate limit
          # errors especially on GitHub-hosted macos machines.
          token: ${{ secrets.GITHUB_TOKEN }}
        id: setup-ffmpeg

      - name: Set up Python ${{ matrix.python-version }} on ${{ matrix.os }}
        if: &quot;!startsWith(matrix.os, 'windows')&quot;
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      # Windows:
      - uses: conda-incubator/setup-miniconda@v3
        if: startsWith(matrix.os, 'windows')
        with:
          auto-update-conda: true
          python-version: ${{ matrix.python-version }}

      - name: Install Python dependencies - Windows
        if: startsWith(matrix.os, 'windows')
        shell: bash -l {0}
        run: |
          conda install -c conda-forge -q gsl libpython
          python -m pip install -e .[test]
          python -m pip install tox

      - name: Run tests - Windows
        if: startsWith(matrix.os, 'windows')
        shell: bash -l {0}
        run: |
          tox ${{ matrix.toxargs }} -e ${{ matrix.toxenv }} ${{ matrix.toxposargs }}

      # Mac:
      - name: Setup Mac - GSL
        if: startsWith(matrix.os, 'mac')
        run: |
          brew install gsl

      # Ubuntu:
      - name: Setup Linux - GSL
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install gsl-bin libgsl0-dev build-essential

      # Any *nix:
      - name: Install Python dependencies - nix
        if: &quot;!startsWith(matrix.os, 'windows')&quot;
        run: python -m pip install --upgrade tox codecov

      - name: Run tests - nix
        if: &quot;!startsWith(matrix.os, 'windows')&quot;
        run: tox ${{ matrix.toxargs }} -e ${{ matrix.toxenv }} -- ${{ matrix.toxposargs }}
</file>
    <file path=".github/workflows/tests.yml">
name: Tests

on:
  push:
    branches:
    - main
    tags:
    - '*'
  pull_request:

jobs:
  check_skip_flags:
    name: Check skip flags
    runs-on: ubuntu-latest
    outputs:
      head-commit-message: ${{ steps.get_head_commit_message.outputs.HEAD_COMMIT_MESSAGE }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GITHUB_SHA }}
      - name: Get head commit message
        id: get_head_commit_message
        run: echo &quot;HEAD_COMMIT_MESSAGE=$(git show -s --format=%s)&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;

  tests:
    name: Python ${{ matrix.python-version }} on ${{ matrix.os }} with numpy ${{ matrix.numpy-version }}, no gsl ${{ matrix.gala-nogsl }}, deps ${{ matrix.pip-test-deps }}
    runs-on: ${{ matrix.os }}
    needs: check_skip_flags
    if: ${{ github.event.pull_request.draft == false &amp;&amp; !contains(github.event.pull_request.labels.*.name, 'docs only') &amp;&amp; !contains(needs.check_skip_flags.outputs.head-commit-message, '[skip tests]') }}
    strategy:
      fail-fast: true
      matrix:
        python-version: [&quot;3.10&quot;, &quot;3.11&quot;, &quot;3.12&quot;]
        os: [&quot;ubuntu-latest&quot;, &quot;macos-latest&quot;]
        numpy-version: [&quot;latest&quot;]
        gala-nogsl: [&quot;0&quot;]
        pip-test-deps: [&quot;test&quot;]
        include:

          - name: Oldest numpy version supported
            os: ubuntu-latest
            python-version: &quot;3.11&quot;
            numpy-version: &quot;1.24&quot;
            gala-nogsl: &quot;0&quot;
            pip-test-deps: &quot;test&quot;

          - name: Install without GSL
            os: ubuntu-latest
            python-version: &quot;3.11&quot;
            numpy-version: &quot;latest&quot;
            gala-nogsl: &quot;1&quot;
            pip-test-deps: &quot;test&quot;

          - name: With optional dependencies
            os: ubuntu-latest  # note: galpy install failed on macos here
            python-version: &quot;3.11&quot;
            numpy-version: &quot;latest&quot;
            gala-nogsl: &quot;0&quot;
            pip-test-deps: &quot;test,extra&quot;

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          allow-prereleases: true

      # For animation tests
      - uses: FedericoCarboni/setup-ffmpeg@v3
        if: ${{ !startsWith(matrix.os, 'mac') }}
        continue-on-error: true
        with:
          # Not strictly necessary, but it may prevent rate limit
          # errors especially on GitHub-hosted macos machines.
          github-token: ${{ secrets.GITHUB_TOKEN }}
          ffmpeg-version: &quot;6.1.0&quot;
        id: setup-ffmpeg

      # Mac:
      - name: Setup Mac - GSL
        if: startsWith(matrix.os, 'mac')
        run: |
          brew install gsl

      # Ubuntu:
      - name: Setup Linux - GSL
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install gsl-bin libgsl0-dev build-essential
          sudo apt-get install libhdf5-serial-dev  # TODO: remove when h5py has 3.11 wheels

      - name: Install package and dependencies
        run: python -m pip install -e &quot;.[${{ matrix.pip-test-deps }}]&quot;
        env:
          GALA_NOGSL: ${{ matrix.gala-nogsl }}

      - name: Update versions if testing min versions
        if: matrix.numpy-version != 'latest'
        run: |
          python -m pip install numpy~=${{ matrix.numpy-version }}

      - name: Run tests
        run: &gt;-
          python -m pytest -ra --cov --cov-report=xml --cov-report=term
          --durations=20 .

      - name: Upload coverage report
        uses: codecov/codecov-action@v4.5.0
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
</file>
    <file path=".github/workflows/tutorials.yml">
name: Tutorials
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  release:
    types:
      - published

jobs:
  check_skip_flags:
    name: Check skip flags
    runs-on: ubuntu-latest
    outputs:
      head-commit-message: ${{ steps.get_head_commit_message.outputs.HEAD_COMMIT_MESSAGE }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GITHUB_SHA }}
      - name: Get head commit message
        id: get_head_commit_message
        run: echo &quot;HEAD_COMMIT_MESSAGE=$(git show -s --format=%s)&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;

  notebooks:
    name: &quot;Build the notebooks for the docs&quot;
    runs-on: ubuntu-latest
    needs: check_skip_flags
    if: ${{ github.event.pull_request.draft == false &amp;&amp; !contains(needs.check_skip_flags.outputs.head-commit-message, '[skip docs]') }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install -U pip wheel
          python -m pip install &quot;.[tutorials]&quot;

      - name: Execute the notebooks
        run: |
          cd docs
          make exectutorials

      - uses: actions/upload-artifact@v3
        with:
          name: notebooks-for-${{ github.sha }}
          path: docs/tutorials

      - name: Trigger RTDs build
        if: ${{ github.event_name != 'pull_request' }}
        uses: dfm/rtds-action@v1.1.0
        with:
          webhook_url: ${{ secrets.RTDS_WEBHOOK_URL }}
          webhook_token: ${{ secrets.RTDS_WEBHOOK_TOKEN }}
          commit_ref: ${{ github.ref }}
</file>
    <file path="docs/potential/scf-examples.rst">
********
Examples
********

For the examples below the following imports have already been executed::

    import astropy.units as u
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import numpy as np
    from gala.potential import scf

.. _coeff-particle:

Computing expansion coefficients from particle positions
--------------------------------------------------------

To compute expansion coefficients for a distribution of particles or discrete
samples from a density distribution, use
`~gala.potential.scf.compute_coeffs_discrete`. In this example, we will generate
particle positions from a Plummer density profile, compute the expansion
coefficients assuming spherical symmetry, then re-compute the expansion
coefficients and variances (Weinberg 1996; [W96]_) allowing for non-spherical
terms (e.g., :math:`l,m&gt;0`).

We'll start by generating samples from a Plummer sphere (see Section 3 of
[HMV11]_ for more details). To do this, we will use inverse transform sampling
by inverting the cumulative mass function (in this case, the mass enclosed):

.. math::

    \rho(r) &amp;= \frac{M}{\frac{4}{3}\pi a^3} \, \left(1 + \frac{r^2}{a^2}\right)^{-5/2}

    m(&lt;r) &amp;= \frac{M \, r^3}{(r^2 + a^2)^{3/2}}

    r(\mu) &amp;= a \, (\mu^{-2/3} - 1)^{-1/2}

    \mu &amp;= m(&lt;r) / M

For simplicity, we will work with units in which :math:`a=1` and :math:`M=1`. To
generate radii, we first randomly generate values of :math:`\mu` uniformly
distributed between 0 and 1, then compute the value of :math:`r` for each
sample; the radii will then be distributed following a Plummer profile. For this
example, we'll use 16384 samples::

    def sample_r(size=1):
        mu = np.random.random(size=size)
        return 1 / np.sqrt(mu**(-2/3) - 1)

    n_samples = 16384
    r = sample_r(size=n_samples)

Let's plot the density profile derived from these samples vs. the true profile:

.. plot::
    :align: center
    :context:

    import astropy.units as u
    import numpy as np
    import matplotlib.pyplot as plt
    import gala.potential as gp
    from gala.units import dimensionless

    pot = gp.PlummerPotential(m=1., b=1., units=dimensionless)

    def sample_r(size=1):
        mu = np.random.random(size=size)
        return 1 / np.sqrt(mu**(-2/3) - 1)

    n_samples = 16384
    r = sample_r(size=n_samples)

    bins = np.logspace(-2, 3, 128)
    bin_cen = (bins[1:] + bins[:-1]) / 2.
    H,edges = np.histogram(r, bins=bins, weights=np.zeros_like(r) + pot.parameters['m']/r.size)

    V = 4/3.*np.pi*(bins[1:]**3 - bins[:-1]**3)

    _r = np.logspace(-2, 2, 1024)
    q = np.zeros((3,_r.size))
    q[0] = _r

    fig = plt.figure(figsize=(6,4))
    plt.loglog(_r, pot.density(q), marker=None, label='True profile', color='#cccccc', lw=3)
    plt.loglog(bin_cen, H / V, marker=None, label='Particles', color='k')
    plt.legend(loc='lower left')
    plt.xlim(1E-2, 1E2)
    plt.xlabel('$r$')
    plt.ylabel(r'$\rho(r)$')
    fig.tight_layout()

With the above, we now have sampled spherical radii that follow the desired
density profile. To compute the expansion coefficients needed to represent this
density using SCF with Hernquist radial functions, we first need to convert to
3D cartesian positions. We will distribute these particles uniformly in angles::

    phi = np.random.uniform(0, 2*np.pi, size=n_samples)
    theta = np.arccos(2*np.random.random(size=n_samples) - 1)

    xyz = np.zeros((n_samples, 3))
    xyz[:,0] = r * np.cos(phi) * np.sin(theta)
    xyz[:,1] = r * np.sin(phi) * np.sin(theta)
    xyz[:,2] = r * np.cos(theta)

    plt.figure(figsize=(5,5))
    plt.plot(xyz[:,0], xyz[:,1], linestyle='none',
             marker=',', alpha=0.25, color='k')
    plt.xlim(-5, 5)
    plt.ylim(-5, 5)
    plt.xlabel('$x$')
    plt.ylabel('$y$')

.. plot::
    :align: center
    :context: close-figs

    phi = np.random.uniform(0, 2*np.pi, size=n_samples)
    theta = np.arccos(2*np.random.random(size=n_samples) - 1)

    xyz = np.zeros((n_samples, 3))
    xyz[:,0] = r * np.cos(phi) * np.sin(theta)
    xyz[:,1] = r * np.sin(phi) * np.sin(theta)
    xyz[:,2] = r * np.cos(theta)

    plt.figure(figsize=(5,5))
    plt.plot(xyz[:,0], xyz[:,1], linestyle='none',
             marker=',', alpha=0.25, color='k')
    plt.xlim(-5, 5)
    plt.ylim(-5, 5)
    plt.xlabel('$x$')
    plt.ylabel('$y$')

To compute the expansion coefficients, we then pass the positions ``xyz`` and
masses of each &quot;particle&quot; to `~gala.potential.scf.compute_coeffs_discrete`. We
will generate an array of masses that sum to 1, per our choice of units above.
To start, we'll assume that the particle distribution has spherical symmetry and
ignore terms with :math:`l&gt;0`. We'll then plot the magnitude of the coefficients
as a function of :math:`n` (but we'll ignore the sine terms, :math:`T_{nlm}` for
this example)::

    mass = np.ones(n_samples) / n_samples
    S,T = scf.compute_coeffs_discrete(xyz, mass=mass, nmax=16, lmax=0, r_s=1.)

    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S_{n00}$&quot;)
    plt.tight_layout()

.. plot::
    :align: center
    :context: close-figs

    from gala.potential import scf

    mass = np.ones(n_samples) / n_samples
    S,T = scf.compute_coeffs_discrete(xyz, mass=mass, nmax=20, lmax=0, r_s=1.)

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S_{n00}$&quot;)
    plt.tight_layout()

In addition to computing the coefficient values, we can also compute the
variances of the coefficients. Here we will relax the assumption about spherical
symmetry by setting :math:`l_{\rm max}=4`. By computing the variance of each
coefficient, we can estimate the signal-to-noise ratio of each expansion term
and use this to help decide when to truncate the expansion (see [W96]_ for the
methodology and reasoning behind this)::

    S, T, Cov = scf.compute_coeffs_discrete(
        xyz, mass=mass, r_s=1.,
        nmax=10, lmax=4, skip_m=True,
        compute_var=True
    )

    signal_to_noise = np.sqrt(S**2 / Cov[0, 0])

    for l in range(S.shape[1]):
        plt.semilogy(signal_to_noise[:,l,0], marker=None, lw=2,
                     alpha=0.5, label='l={}'.format(l))

    plt.axhline(1., linestyle='dashed')
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S/N$&quot;)
    plt.legend()

.. plot::
    :align: center
    :context: close-figs

    S, T, Cov = scf.compute_coeffs_discrete(
        xyz, mass=mass, r_s=1.,
        nmax=10, lmax=4, skip_m=True,
        compute_var=True
    )

    signal_to_noise = np.sqrt(S**2 / Cov[0, 0])

    plt.figure(figsize=(6,4))
    for l in range(S.shape[1]):
        plt.semilogy(signal_to_noise[:,l,0], marker=None, lw=2,
                     alpha=0.5, label='l={}'.format(l))
    plt.axhline(1., linestyle='dashed')
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S/N$&quot;)
    plt.legend()
    plt.tight_layout()

The horizontal line in the plot above is for a signal-to-noise ratio of 1 -- any
coefficients with a SNR near or below this line are suspect and likely just
adding noise to the expansion. Note that all of the SNR values for :math:`l &gt; 0`
hover around 1 -- this is a good indication that we only need the :math:`l=0`
terms to accurately represent the density distribution of the particles.

.. _coeff-analytic:

Computing expansion coefficients for an analytic density
--------------------------------------------------------

To compute expansion coefficients for an analytic density profile, use
`~gala.potential.scf.compute_coeffs`. In this example, we will write a function
to evaluate an oblate density distribution and compute the expansion
coefficients.

We'll use a flattened Hernquist profile as our density profile:

.. math::

    \rho(s) &amp;= \frac{M \, a}{2\pi} \, \frac{1}{s (s+a)^3}

    s^2 &amp;= x^2 + y^2 + \frac{z^2}{q^2}

In code::

    def hernquist_density(r, M, a):
        return M*a / (2*np.pi) / (r*(r+a)**3)

    def flattened_hernquist_density(x, y, z, M, a, q):
        s = np.sqrt(x**2 + y**2 + (z/q)**2)
        return hernquist_density(s, M, a)

The function to evaluate the density must take at least 3 arguments: the
cartesian coordinates ``x``, ``y``, ``z``.

We'll again set :math:`M=a=1` and we'll use a flattening :math:`q=0.8`. Let's
visualize this by plotting isodensity contours in the :math:`x`-:math:`z` plane:

.. plot::
    :align: center
    :context: reset

    import astropy.units as u
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    from matplotlib import ticker
    import numpy as np
    from gala.potential import scf

    def hernquist_density(r, M, a):
        return M*a / (2*np.pi) / (r*(r+a)**3)

    def flattened_hernquist_density(x, y, z, M, a, q):
        s = np.sqrt(x**2 + y**2 + (z/q)**2)
        return hernquist_density(s, M, a)

    M = 1.
    a = 1.
    q = 0.8

    x,z = np.meshgrid(np.linspace(-10., 10., 128),
                      np.linspace(-10., 10., 128))
    y = np.zeros_like(x)

    dens = flattened_hernquist_density(x, y, z, M, a, q)

    plt.figure(figsize=(6,6))
    plt.contourf(x, z, dens, cmap='magma',
                 levels=np.logspace(np.log10(dens.min()), np.log10(dens.max()), 32),
                 locator=ticker.LogLocator())
    plt.title(&quot;Isodensity&quot;)
    plt.xlabel(&quot;$x$&quot;, fontsize=22)
    plt.ylabel(&quot;$z$&quot;, fontsize=22)
    plt.tight_layout()

To compute the expansion coefficients, we pass the
``flattened_hernquist_density()`` function in to
`~gala.potential.scf.compute_coeffs`.  Because this is an axisymmetric density,
we will ignore terms with :math:`m&gt;0` by setting ``skip_m=True``::

    M = 1.
    a = 1.
    q = 0.8
    coeff = scf.compute_coeffs(flattened_hernquist_density, nmax=8, lmax=8,
                                M=M, r_s=a, args=(M,a,q), skip_m=True)
    (S,Serr),(T,Terr) = coeff

Computing the coefficients involves a numerical integration that uses
`scipy.integrate.quad`, which simultaneously estimates the error in the computed
integral. `~gala.potential.scf.compute_coeffs` returns the coefficient arrays
and these error estimates.

Now that we have the coefficients in hand, we can visualize their magnitudes::

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S_{n00}$&quot;)

.. plot::
    :align: center
    :context: close-figs

    nmax = 8
    lmax = 8
    coeff = scf.compute_coeffs(flattened_hernquist_density, nmax=nmax, lmax=lmax,
                               M=M, r_s=a, args=(M,a,q), skip_m=True)
    (S,Serr),(T,Terr) = coeff

    plt.figure(figsize=(6,4))
    plt.semilogy(np.abs(S[:,0,0]), marker=None, lw=2)
    plt.xlabel(&quot;$n$&quot;)
    plt.ylabel(&quot;$S_{n00}$&quot;)
    plt.tight_layout()

Because we ignored any :math:`m` terms, the coefficients are computed in a 2D
grid in :math:`n,l`: we can visualize their magnitude by coloring points on such
a grid::

    nl_grid = np.mgrid[0:lmax+1, 0:nmax+1]

    plt.figure(figsize=(5,4))
    plt.scatter(nl_grid[0].ravel(), nl_grid[1].ravel(),
                c=np.abs(S[:,:,0].ravel()), norm=mpl.colors.LogNorm(),
                cmap='viridis', s=80)
    plt.xlabel('$n$')
    plt.ylabel('$l$')
    plt.colorbar()

.. plot::
    :align: center
    :context: close-figs

    nl_grid = np.mgrid[0:lmax+1, 0:nmax+1]

    plt.figure(figsize=(5,4))
    plt.scatter(nl_grid[0].ravel(), nl_grid[1].ravel(),
                c=np.abs(S[:,:,0].ravel()), norm=mpl.colors.LogNorm(),
                cmap='viridis', s=80)
    plt.xlabel('$n$')
    plt.ylabel('$l$')
    plt.colorbar()
    plt.tight_layout()

.. _potential-class:

Using `~gala.potential.scf.SCFPotential` to evaluate the density, potential, gradient
-------------------------------------------------------------------------------------

In this example we'll continue where the :ref:`previous example
&lt;coeff-analytic&gt;` left off: we now have computed expansion coefficients for a
given density function and we would like to evaluate the gradient of the
gravitational potential at various locations. We will use `gala` to integrate
an orbit in the expansion potential.

From the previous example, we have a set of cosine and sine coefficients (``S``
and ``T``) for an SCF representation of a flattened (oblate) Hernquist density
profile. First, we'll create an `~gala.potential.scf.SCFPotential` object using
these coefficients::

    potential = scf.SCFPotential(Snlm=S, Tnlm=T, m=M, r_s=a) # M=a=1

Let's compare how our expansion density to the true density by
recreating the above isodensity contour figure with SCF density contours
overlaid::

    x,z = np.meshgrid(np.linspace(-10., 10., 128),
                      np.linspace(-10., 10., 128))
    y = np.zeros_like(x)
    true_dens = flattened_hernquist_density(x, y, z, M, a, q)

    # we need an array of positions with shape (3,n_samples) for SCFPotential
    xyz = np.vstack((x.ravel(),y.ravel(),z.ravel()))
    scf_dens = potential.density(xyz).value

    # log-spaced contour levels
    levels = np.logspace(np.log10(true_dens.min()), np.log10(true_dens.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contourf(x, z, true_dens, cmap='magma',
                 levels=levels, locator=ticker.LogLocator())
    plt.contour(x, z, scf_dens.reshape(x.shape), colors='w',
                levels=levels, locator=ticker.LogLocator())

    plt.title(&quot;Isodensity&quot;)
    plt.xlabel(&quot;$x$&quot;, fontsize=22)
    plt.ylabel(&quot;$z$&quot;, fontsize=22)

.. plot::
    :align: center
    :context: close-figs

    potential = scf.SCFPotential(Snlm=S, Tnlm=T, m=M, r_s=a) # M=a=1

    # we need an array of positions with shape (3,n_samples) for SCFPotential
    xyz = np.vstack((x.ravel(),y.ravel(),z.ravel()))
    scf_dens = potential.density(xyz).value

    # log-spaced contour levels
    true_dens = flattened_hernquist_density(x, y, z, M, a, q)
    levels = np.logspace(np.log10(true_dens.min()), np.log10(true_dens.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contourf(x, z, true_dens, cmap='magma',
                 levels=levels, locator=ticker.LogLocator())
    plt.contour(x, z, scf_dens.reshape(x.shape), colors='w',
                levels=levels, locator=ticker.LogLocator())

    plt.title(&quot;Isodensity&quot;)
    plt.xlabel(&quot;$x$&quot;, fontsize=22)
    plt.ylabel(&quot;$z$&quot;, fontsize=22)
    plt.tight_layout()

By eye, the SCF representation looks pretty good. Let's now create a plot of
equipotential contours using the `~gala.potential.scf.SCFPotential` instance::

    scf_pot = np.abs(potential.energy(xyz))
    scf_pot = scf_pot.value # get numerical value from `~astropy.units.Quantity`

    # log-spaced contour levels
    levels = np.logspace(np.log10(scf_pot.min()), np.log10(scf_pot.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contour(x, z, scf_pot.reshape(x.shape), cmap='inferno_r',
                levels=levels, locator=ticker.LogLocator())

    plt.title(&quot;Equipotential&quot;)
    plt.xlabel(&quot;$x$&quot;, fontsize=22)
    plt.ylabel(&quot;$z$&quot;, fontsize=22)

.. plot::
    :align: center
    :context: close-figs

    scf_pot = np.abs(potential.energy(xyz))
    scf_pot = scf_pot.value # get numerical value from Astropy Quantity

    # log-spaced contour levels
    levels = np.logspace(np.log10(scf_pot.min()), np.log10(scf_pot.max()), 16)

    plt.figure(figsize=(6,6))

    plt.contour(x, z, scf_pot.reshape(x.shape), cmap='inferno_r',
                levels=levels, locator=ticker.LogLocator())

    plt.title(&quot;Equipotential&quot;)
    plt.xlabel(&quot;$x$&quot;, fontsize=22)
    plt.ylabel(&quot;$z$&quot;, fontsize=22)
    plt.tight_layout()

(the above is actually provided as a convenience method of any
`~gala.potential.PotentialBase` subclass -- see
`~gala.potential.PotentialBase.plot_contours`).

Now let's integrate an orbit in this potential. We'll use the orbit integration
framework from `gala.integrate` and the convenience method
`~gala.potential.scf.SCFPotential.integrate_orbit` to do this::

    import gala.dynamics as gd

    # when using dimensionless units, we don't need to specify units for the
    # initial conditions
    w0 = gd.PhaseSpacePosition(pos=[1.,0,0.25],
                               vel=[0.,0.3,0.])

    # by default this uses Leapfrog integration
    orbit = potential.integrate_orbit(w0, dt=0.1, n_steps=10000)

    fig = orbit_l.plot(marker=',', linestyle='none', alpha=0.5)

.. plot::
    :align: center
    :context: close-figs

    import gala.dynamics as gd

    # when using dimensionless units, we don't need to specify units for the
    # initial conditions
    w0 = gd.PhaseSpacePosition(pos=[1.,0,0.25],
                               vel=[0.,0.3,0.])

    # by default this uses Leapfrog integration
    orbit = potential.integrate_orbit(w0, dt=0.1, n_steps=10000)

    fig = orbit.plot(marker=',', linestyle='none', alpha=0.5)

References
----------
.. [W96] http://dx.doi.org/10.1086/177902
.. [HMV11] http://www.artcompsci.org/kali/vol/plummer/volume11.pdf
</file>
    <file path="docs/tutorials/.gitignore">
*.ipynb
</file>
    <file path="docs/tutorials/Arbitrary-density-SCF.py">
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx=&quot;hidden&quot;
# %matplotlib inline

# + nbsphinx=&quot;hidden&quot;
# %run nb_setup
# -

# # Compute an SCF representation of an arbitrary density distribution
#
# Basis function expansions are a useful tool for computing gravitational
# potentials and forces from an arbitrary density function that may not have an
# analytic solution to Poisson's equation. They are also useful for generating
# smoothed or compressed representations of gravitational potentials from
# discrete particle distributions. For astronomical density distributions, a
# useful expansion technique is the Self-Consistent Field (SCF) method, as
# initially developed by [Hernquist &amp; Ostriker
# (1992)](http://dx.doi.org/10.1086/171025). In this method, using the notation
# of [Lowing et al. 2011](http://dx.doi.org/10.1111/j.1365-2966.2011.19222.x),
# the density and potential functions are expressed as:
#
# $$
# \rho(r, \phi, \theta) = \sum_{l=0}^{l_{\rm max}} \sum_{m=0}^{l} \sum_{n=0}^{n_{\rm max}}
#     Y_{lm}(\theta) \, \rho_{nl}(r) \, \left[S_{nlm}\,\cos(m\phi) + T_{nlm}\,\sin(m\phi) \right] \\
# \Phi(r, \phi, \theta) = \sum_{l=0}^{l_{\rm max}} \sum_{m=0}^{l} \sum_{n=0}^{n_{\rm max}}
#     Y_{lm}(\theta) \, \Phi_{nl}(r) \, \left[S_{nlm}\,\cos(m\phi) + T_{nlm}\,\sin(m\phi) \right]
# $$
#
# where $Y_{lm}(\theta)$ are the usual spherical harmonics, $\rho_{nlm}(r)$ and
# $\Phi_{nlm}(r)$ are bi-orthogonal radial basis functions, and $S_{nlm}$ and
# $T_{nlm}$ are expansion coefficients, which need to be computed from a given
# density function. In this notebook, we'll estimate low-order expansion
# coefficients for an analytic density distribution (written as a Python
# function).

# +
# Some imports we'll need later:

# Third-party
import matplotlib.pyplot as plt
import numpy as np

# Gala
import gala.dynamics as gd
import gala.potential as gp
from gala.potential.scf import compute_coeffs

# -

# ## SCF representation of an analytic density distribution
#
# ### Custom spherical density function
#
# For this example, we'll assume that we want a potential representation of the
# spherical density function:
# $$
# \rho(r) = \frac{1}{r^{1.8} \, (1 + r)^{2.7}}
# $$
#
# Let's start by writing a density function that takes a single set of Cartesian
# coordinates (x, y, z) and returns the (scalar) value of the density at that
# location:


def density_func(x, y, z):
    r = np.sqrt(x**2 + y**2 + z**2)
    return 1 / (r**1.8 * (1 + r) ** 2.7)


# Let's visualize this density function. For comparison, let's also over-plot
# the Hernquist density distribution. The SCF expansion uses the Hernquist
# density for radial basis functions, so the similarity of the density we want
# to represent and the Hernquist function gives us a sense of how many radial
# terms we will need in the expansion:

hern = gp.HernquistPotential(m=1, c=1)

# +
x = np.logspace(-1, 1, 128)
plt.plot(x, density_func(x, 0, 0), marker=&quot;&quot;, label=&quot;custom density&quot;)

# need a 3D grid for the potentials in Gala
xyz = np.zeros((3, len(x)))
xyz[0] = x
plt.plot(x, hern.density(xyz), marker=&quot;&quot;, label=&quot;Hernquist&quot;)

plt.xscale(&quot;log&quot;)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$r$&quot;)
plt.ylabel(r&quot;$\rho(r)$&quot;)

plt.legend(loc=&quot;best&quot;)
# -

# These functions are not *too* different, implying that we probably don't need
# too many radial expansion terms in order to well represent the
# density/potential from this custom function. As an arbitrary number, let's
# choose to compute radial terms up to and including $n = 10$. In this case,
# because the density we want to represent is spherical, we don't need any $l,
# m$ terms, so we set `lmax=0`. We can also neglect the sin() terms of the
# expansion ($T_{nlm}$):

(S, Serr), _ = compute_coeffs(
    density_func, nmax=10, lmax=0, M=1.0, r_s=1.0, S_only=True
)

# The above variable `S` will contain the expansion coefficients, and the
# variable `Serr` will contain an estimate of the error in this coefficient
# value. Let's now construct an `SCFPotential` object with the coefficients we
# just computed:

S

pot = gp.SCFPotential(m=1.0, r_s=1, Snlm=S, Tnlm=np.zeros_like(S))

# Now let's visualize the SCF estimated density with the true density:

# +
x = np.logspace(-1, 1, 128)
plt.plot(x, density_func(x, 0, 0), marker=&quot;&quot;, label=&quot;custom density&quot;)

# need a 3D grid for the potentials in Gala
xyz = np.zeros((3, len(x)))
xyz[0] = x
plt.plot(x, pot.density(xyz), marker=&quot;&quot;, label=&quot;SCF density&quot;)

plt.xscale(&quot;log&quot;)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$r$&quot;)
plt.ylabel(r&quot;$\rho(r)$&quot;)

plt.legend(loc=&quot;best&quot;)


# -

# This does a pretty good job of capturing the radial fall-off of our custom
# density function, but you may want to iterate a bit to satisfy your own
# constraints. For example, you may want the density to be represented with a
# less than 1% deviation over some range of radii, or whatever.
#
# As a second example, let's now try a custom axisymmetric density distribution:

# ### Custom axisymmetric density function
#
# For this example, we'll assume that we want a potential representation of the
# flattened Hernquist density function:
# $$
# \rho(R, z) = \frac{1}{r \, (1 + r)^{3}}\\
# r^2 = R^2 + \frac{z^2}{q^2}
# $$
#
# where $q$ is the flattening, which we'll set to $q=0.6$.
#
# Let's again start by writing a density function that takes a single set of
# Cartesian coordinates (x, y, z) and returns the (scalar) value of the density
# at that location:


def density_func_flat(x, y, z, q):
    r = np.sqrt(x**2 + y**2 + (z / q) ** 2)
    return 1 / (r * (1 + r) ** 3) / (2 * np.pi)


# Let's compute the density along a diagonal line for a few different
# flattenings and again compare to the non-flattened Hernquist profile:

# +
x = np.logspace(-1, 1, 128)
xyz = np.zeros((3, len(x)))
xyz[0] = x
xyz[2] = x

for q in np.arange(0.6, 1 + 1e-3, 0.2):
    plt.plot(
        x,
        density_func_flat(xyz[0], 0.0, xyz[2], q),
        marker=&quot;&quot;,
        label=f&quot;custom density: q={q}&quot;,
    )

plt.plot(x, hern.density(xyz), marker=&quot;&quot;, ls=&quot;--&quot;, label=&quot;Hernquist&quot;)

plt.xscale(&quot;log&quot;)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$r$&quot;)
plt.ylabel(r&quot;$\rho(r)$&quot;)

plt.legend(loc=&quot;best&quot;)
# -

# Because this is an axisymmetric density distribution, we need to also compute
# $l$ terms in the expansion, so we set `lmax=6`, but we can skip the $m$ terms
# using `skip_m=True`. Because this computes more coefficients, we might want to
# see the progress in real time - if you install the Python package `tqdm` and
# pass `progress=True`, it will also display a progress bar:

q = 0.6
(S_flat, Serr_flat), _ = compute_coeffs(
    density_func_flat,
    nmax=4,
    lmax=6,
    args=(q,),
    M=1.0,
    r_s=1.0,
    S_only=True,
    skip_m=True,
    progress=True,
)

pot_flat = gp.SCFPotential(m=1.0, r_s=1, Snlm=S_flat, Tnlm=np.zeros_like(S_flat))

# +
x = np.logspace(-1, 1, 128)
xyz = np.zeros((3, len(x)))
xyz[0] = x
xyz[2] = x

plt.plot(
    x,
    density_func_flat(xyz[0], xyz[1], xyz[2], q),
    marker=&quot;&quot;,
    label=f&quot;true density q={q}&quot;,
)

plt.plot(x, pot_flat.density(xyz), marker=&quot;&quot;, ls=&quot;--&quot;, label=&quot;SCF density&quot;)

plt.xscale(&quot;log&quot;)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$r$&quot;)
plt.ylabel(r&quot;$\rho(r)$&quot;)

plt.legend(loc=&quot;best&quot;)
# -

# The SCF potential object acts like any other `gala.potential` object, meaning
# we can, e.g., plot density or potential contours:

# +
grid = np.linspace(-8, 8, 128)

fig, axes = plt.subplots(1, 2, figsize=(10, 5), sharex=True, sharey=True)
_ = pot_flat.plot_contours((grid, grid, 0), ax=axes[0])
axes[0].set_xlabel(&quot;$x$&quot;)
axes[0].set_ylabel(&quot;$y$&quot;)

_ = pot_flat.plot_contours((grid, 0, grid), ax=axes[1])
axes[1].set_xlabel(&quot;$x$&quot;)
axes[1].set_ylabel(&quot;$z$&quot;)

for ax in axes:
    ax.set_aspect(&quot;equal&quot;)
# -

# And numerically integrate orbits by passing in initial conditions and
# integration parameters:

w0 = gd.PhaseSpacePosition(pos=[3.5, 0, 1], vel=[0, 0.4, 0.05])

orbit_flat = pot_flat.integrate_orbit(w0, dt=1.0, n_steps=5000)
_ = orbit_flat.plot()
</file>
    <file path="docs/tutorials/circ-restricted-3body.rst">
.. _restricted_three_body:

======================================
Circular restricted three-body problem
======================================

As a demonstration of the flexibility of the potential clases and reference
frame machinery, below we'll demonstrate how to integrate orbits in the
`circular restricted three-body problem &lt;https://en.wikipedia.org/wiki/Three-body_problem#Circular_restricted_three-body_problem&gt;`_.

We first need to import some relevant packages::

   &gt;&gt;&gt; import astropy.units as u
   &gt;&gt;&gt; import matplotlib.pyplot as plt
   &gt;&gt;&gt; import numpy as np
   &gt;&gt;&gt; from scipy.optimize import root
   &gt;&gt;&gt; import gala.integrate as gi
   &gt;&gt;&gt; import gala.dynamics as gd
   &gt;&gt;&gt; import gala.potential as gp

The &quot;restricted three-body problem&quot; is the problem of solving for the orbit of a
test particle interacting with a binary bass system, typically also in the
rotating frame of the binary. We'll assume that the binary consists of a more
massive component :math:`m_1` and a secondary mass :math:`m_2`. If the binary
components are on circular orbits, and we restict to the plane of motion of the
binary, we can change to a rotating reference frame that rotates with the
angular frequency of the binary, and cast the problem in terms of scaled units
that simplify the expressions and math. In detail, we'll work in units such that
the masses of the two components are :math:`1 - \mu` and :math:`\mu`, where
:math:`\mu = \frac{m_2}{m_1+m_2}`. We'll also set :math:`G=1` and the orbital
frequency of the binary to :math:`\Omega=1`. For more information about the
problem setup, see, e.g., `this paper &lt;https://arxiv.org/abs/1511.04881&gt;`_.

For our example, we'll use the value :math:`\mu = 1/11`, corresponding to a 1:10
mass ratio between the two components of the central binary. In the units
defined above, and assuming that the binary components lie on the coordinate
:math:`x`-axis in the rotating frame, the positions and masses of the two binary
components are :math:`x_1 = -\mu`, :math:`m_1 = 1-\mu` and :math:`x_2 = 1-\mu`,
:math:`m_2 = \mu`, respectively. Let's start by defining these quantities::

   &gt;&gt;&gt; mu = 1/11.
   &gt;&gt;&gt; x1 = -mu
   &gt;&gt;&gt; m1 = 1-mu
   &gt;&gt;&gt; x2 = 1-mu
   &gt;&gt;&gt; m2 = mu

Since the potential classes in ``Gala`` work with 3-dimensional quantities,
we'll define the frequency of the binary as a 3D vector::

   &gt;&gt;&gt; Omega = np.array([0, 0, 1.])

We'll now define the gravitational potential of the binary. To do this, we have
to make use of the ``origin`` keyword in the potential class initializer to
shift the positions of the component masses to the values defined above. We'll
store the potentials of the two masses together in a
`~gala.potential.CCompositePotential`::

   &gt;&gt;&gt; pot = gp.CCompositePotential()
   &gt;&gt;&gt; pot['m1'] = gp.KeplerPotential(m=m1, origin=[x1, 0, 0.])
   &gt;&gt;&gt; pot['m2'] = gp.KeplerPotential(m=m2, origin=[x2, 0, 0.])

We now have to define the rotating reference frame::

   &gt;&gt;&gt; frame = gp.ConstantRotatingFrame(Omega=Omega)

And finally, we combine the potential and frame into a
`~gala.potential.Hamiltonian` object::

   &gt;&gt;&gt; H = gp.Hamiltonian(pot, frame)

We're now ready to start integrating orbits! But before we do that, let's look
at the geometry of phase-space to get a sense for what the orbits will look like
with different choices of the Jacobi energy. We'll make a grid of x and y
positions and evalutes the Jacobi energy at each position in the grid assuming
a zero velocity. We'll draw filled contours at each value of 4 chosen Jacobi
energy values, which will visualize &quot;forbidden regions&quot; of the plane at each
value of the Jacobi energy (see Section 3.3.2 in Binney and Tremaine 2008)::

   &gt;&gt;&gt; grid = np.linspace(-1.75, 1.75, 128)
   &gt;&gt;&gt; x_grid, y_grid = np.meshgrid(grid, grid)
   &gt;&gt;&gt; xyz = np.vstack((x_grid.ravel(),
   ...                  y_grid.ravel(),
   ...                  np.zeros_like(x_grid.ravel())))
   &gt;&gt;&gt; Om_cross_x = np.cross(Omega, xyz.T)
   &gt;&gt;&gt; E_J = H.potential.energy(xyz) - 0.5*np.sum(Om_cross_x**2, axis=1)
   &gt;&gt;&gt; E_J_levels = [-1.82, -1.73, -1.7, -1.5]

.. plot::
   :align: center
   :context: close-figs

   import astropy.units as u
   import matplotlib.pyplot as plt
   import numpy as np
   import gala.integrate as gi
   import gala.dynamics as gd
   import gala.potential as gp

   mu = 1/11.
   x1 = -mu
   m1 = 1-mu
   x2 = 1-mu
   m2 = mu

   Omega = np.array([0, 0, 1.])

   pot = (gp.KeplerPotential(m=1-mu, origin=[x1, 0, 0]) +
          gp.KeplerPotential(m=mu, origin=[x2, 0, 0]))

   frame = gp.ConstantRotatingFrame(Omega=Omega)
   static = gp.StaticFrame()
   H = gp.Hamiltonian(pot, frame)

   grid = np.linspace(-1.75, 1.75, 128)
   x_grid, y_grid = np.meshgrid(grid, grid)
   xyz = np.vstack((x_grid.ravel(),
                    y_grid.ravel(),
                    np.zeros_like(x_grid.ravel())))
   Om_cross_x = np.cross(Omega, xyz.T)
   E_J = H.potential.energy(xyz) - 0.5*np.sum(Om_cross_x**2, axis=1)

   fig,axes = plt.subplots(2, 2, figsize=(8,8), sharex=True, sharey=True)

   E_J_levels = [-1.82, -1.73, -1.7, -1.5]

   for ax, level in zip(axes.flat, E_J_levels):
       ax.contourf(x_grid, y_grid, E_J.reshape(128,128).value,
                   levels=[level,0], colors='#aaaaaa')
       ax.scatter(-mu, 0, c='k')
       ax.scatter(1-mu, 0, c='k')
       ax.set_title(r'$E_{{\rm J}} = {:.2f}$'.format(level))

   ax.set_xlim(-1.6, 1.6)
   ax.set_ylim(-1.6, 1.6)

   axes[0,0].set_ylabel('$y$')
   axes[1,0].set_ylabel('$y$')
   axes[1,0].set_xlabel('$x$')
   axes[1,1].set_xlabel('$x$')

   fig.tight_layout()


At each of the values of the Jacobi energy chosen above, we'll now integrate
an orbit. To do this, we have to solve for the initial conditions given the
Jacobi energy, and convert from rotating frame (Lagrangian) coordinates to
canonical coordinates. Let's define some functions to help with this::

   &gt;&gt;&gt; def func_ydot(val, x, H, E_J):
   ...    ydot = val[0]
   ...    Om_cross_x = np.cross(H.frame.parameters['Omega'].value, x)
   ...    eff_pot = H.potential.energy(x).value[0] - 0.5*Om_cross_x.dot(Om_cross_x)
   ...    return E_J - 0.5*ydot**2 - eff_pot
   &gt;&gt;&gt; def xxdot_to_qp(x, xdot, Omega):
   ...     q = x
   ...     p = np.array(xdot) + np.cross(Omega, x)
   ...     return q, p

Now we'll integrate the orbits at each energy level. We'll assert that the orbit
starts from the y axis at :math:`x = 0.5` and solve for the y velocity,
:math:`\dot{y}`, then convert to canonical coordinates::

   &gt;&gt;&gt; x0 = [0.5, 0, 0]
   &gt;&gt;&gt; orbits = []
   &gt;&gt;&gt; for level in E_J_levels:
   ...     res = root(func_ydot, x0=0.3, args=(x0, H, level))
   ...     xdot0 = [0, res.x[0], 0.]
   ...     w0 = np.concatenate(xxdot_to_qp(x0, xdot0, Omega))
   ...     orbit = H.integrate_orbit(w0, dt=1E-2, n_steps=100000,
   ...                               Integrator=gi.DOPRI853Integrator)
   ...     orbits.append(orbit)

.. plot::
   :align: center
   :context: close-figs

   from scipy.optimize import root

   def func_ydot(val, x, H, E_J):
      ydot = val[0]
      Om_cross_x = np.cross(H.frame.parameters['Omega'].value, x)
      eff_pot = H.potential.energy(x).value[0] - 0.5*Om_cross_x.dot(Om_cross_x)
      return E_J - 0.5*ydot**2 - eff_pot

   def xxdot_to_qp(x, xdot, Omega):
       q = x
       p = np.array(xdot) + np.cross(Omega, x)
       return q, p

   x0 = [0.5, 0., 0.]
   orbits = []
   for level in E_J_levels:
       res = root(func_ydot, x0=0.3, args=(x0, H, level))
       xdot0 = [0, res.x[0], 0.]
       w0 = np.concatenate(xxdot_to_qp(x0, xdot0, Omega))
       orbit = H.integrate_orbit(w0, dt=1E-2, n_steps=100000,
                                 Integrator=gi.DOPRI853Integrator)
       orbits.append(orbit)

   fig,axes = plt.subplots(2, 2, figsize=(8,8), sharex=True, sharey=True)

   for ax, level, orbit in zip(axes.flat, E_J_levels, orbits):
       ax.contourf(x_grid, y_grid, E_J.reshape(128,128).value,
                   levels=[level,0], colors='#aaaaaa')
       ax.scatter(-mu, 0, c='r')
       ax.scatter(1-mu, 0, c='r')
       ax.set_title(r'$E_{{\rm J}} = {:.2f}$'.format(level))

       ax.plot(orbit.x, orbit.y, marker='None', linewidth=1.)

   ax.set_xlim(-1.6, 1.6)
   ax.set_ylim(-1.6, 1.6)

   fig.tight_layout()
</file>
    <file path="docs/tutorials/define-milky-way-model.py">
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx=&quot;hidden&quot;
# %matplotlib inline

# + nbsphinx=&quot;hidden&quot;
# %run nb_setup
# -

# # Defining a Milky Way potential model

# +
# Third-party dependencies
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
from astropy.io import ascii
from scipy.optimize import leastsq

# Gala
import gala.potential as gp
from gala.units import galactic

# -

# ## Introduction
#
# `gala` provides a simple and easy way to access and integrate orbits in an
# approximate mass model for the Milky Way. The parameters of the mass model are
# determined by least-squares fitting the enclosed mass profile of a pre-defined
# potential form to recent measurements compiled from the literature. These
# measurements are provided with the documentation of `gala` and are shown
# below. The radius units are kpc, and mass units are solar masses:

tbl = ascii.read(&quot;data/MW_mass_enclosed.csv&quot;)

tbl

# Let's now plot the above data and uncertainties:

# +
fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl[&quot;r&quot;],
    tbl[&quot;Menc&quot;],
    yerr=(tbl[&quot;Menc_err_neg&quot;], tbl[&quot;Menc_err_pos&quot;]),
    marker=&quot;o&quot;,
    markersize=2,
    color=&quot;k&quot;,
    alpha=1.0,
    ecolor=&quot;#aaaaaa&quot;,
    capthick=0,
    linestyle=&quot;none&quot;,
    elinewidth=1.0,
)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel(&quot;$r$ [kpc]&quot;)
ax.set_ylabel(&quot;$M(&lt;r)$ [M$_\odot$]&quot;)

ax.set_xscale(&quot;log&quot;)
ax.set_yscale(&quot;log&quot;)

fig.tight_layout()


# -

# We now need to assume some form for the potential. For simplicity and within
# reason, we'll use a four component potential model consisting of a Hernquist
# ([1990](https://ui.adsabs.harvard.edu/#abs/1990ApJ...356..359H/abstract))
# bulge and nucleus, a Miyamoto-Nagai
# ([1975](https://ui.adsabs.harvard.edu/#abs/1975PASJ...27..533M/abstract))
# disk, and an NFW
# ([1997](https://ui.adsabs.harvard.edu/#abs/1997ApJ...490..493N/abstract))
# halo. We'll fix the parameters of the disk and bulge to be consistent with
# previous work ([Bovy
# 2015](https://ui.adsabs.harvard.edu/#abs/2015ApJS..216...29B/abstract) -
# please cite that paper if you use this potential model) and vary the scale
# mass and scale radius of the nucleus and halo, respectively. We'll fit for
# these parameters in log-space, so we'll first define a function that returns a
# `gala.potential.CCompositePotential` object given these four parameters:


def get_potential(log_M_h, log_r_s, log_M_n, log_a):
    mw_potential = gp.CCompositePotential()
    mw_potential[&quot;bulge&quot;] = gp.HernquistPotential(m=5e9, c=1.0, units=galactic)
    mw_potential[&quot;disk&quot;] = gp.MiyamotoNagaiPotential(
        m=6.8e10 * u.Msun, a=3 * u.kpc, b=280 * u.pc, units=galactic
    )
    mw_potential[&quot;nucl&quot;] = gp.HernquistPotential(
        m=np.exp(log_M_n), c=np.exp(log_a) * u.pc, units=galactic
    )
    mw_potential[&quot;halo&quot;] = gp.NFWPotential(
        m=np.exp(log_M_h), r_s=np.exp(log_r_s), units=galactic
    )

    return mw_potential


# We now need to specify an initial guess for the parameters - let's do that (by
# making them up), and then plot the initial guess potential over the data:

# Initial guess for the parameters- units are:
#     [Msun, kpc, Msun, pc]
x0 = [np.log(6e11), np.log(20.0), np.log(2e9), np.log(100.0)]
init_potential = get_potential(*x0)

# +
xyz = np.zeros((3, 256))
xyz[0] = np.logspace(-3, 3, 256)

fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl[&quot;r&quot;],
    tbl[&quot;Menc&quot;],
    yerr=(tbl[&quot;Menc_err_neg&quot;], tbl[&quot;Menc_err_pos&quot;]),
    marker=&quot;o&quot;,
    markersize=2,
    color=&quot;k&quot;,
    alpha=1.0,
    ecolor=&quot;#aaaaaa&quot;,
    capthick=0,
    linestyle=&quot;none&quot;,
    elinewidth=1.0,
)

fit_menc = init_potential.mass_enclosed(xyz * u.kpc)
ax.loglog(xyz[0], fit_menc.value, marker=&quot;&quot;, color=&quot;#3182bd&quot;, linewidth=2, alpha=0.7)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel(&quot;$r$ [kpc]&quot;)
ax.set_ylabel(&quot;$M(&lt;r)$ [M$_\odot$]&quot;)

ax.set_xscale(&quot;log&quot;)
ax.set_yscale(&quot;log&quot;)

fig.tight_layout()


# -

# It looks pretty good already! But let's now use least-squares fitting to
# optimize our nucleus and halo parameters. We first need to define an error
# function:


def err_func(p, r, Menc, Menc_err):
    pot = get_potential(*p)
    xyz = np.zeros((3, len(r)))
    xyz[0] = r
    model_menc = pot.mass_enclosed(xyz).to(u.Msun).value
    return (model_menc - Menc) / Menc_err


# Because the uncertainties are all approximately but not exactly symmetric,
# we'll take the maximum of the upper and lower uncertainty values and assume
# that the uncertainties in the mass measurements are Gaussian (a bad but simple
# assumption):

err = np.max([tbl[&quot;Menc_err_pos&quot;], tbl[&quot;Menc_err_neg&quot;]], axis=0)
p_opt, ier = leastsq(err_func, x0=x0, args=(tbl[&quot;r&quot;], tbl[&quot;Menc&quot;], err))
assert ier in range(1, 4 + 1), &quot;least-squares fit failed!&quot;
fit_potential = get_potential(*p_opt)

# Now we have a best-fit potential! Let's plot the enclosed mass of the fit potential over the data:

# +
xyz = np.zeros((3, 256))
xyz[0] = np.logspace(-3, 3, 256)

fig, ax = plt.subplots(1, 1, figsize=(4, 4))

ax.errorbar(
    tbl[&quot;r&quot;],
    tbl[&quot;Menc&quot;],
    yerr=(tbl[&quot;Menc_err_neg&quot;], tbl[&quot;Menc_err_pos&quot;]),
    marker=&quot;o&quot;,
    markersize=2,
    color=&quot;k&quot;,
    alpha=1.0,
    ecolor=&quot;#aaaaaa&quot;,
    capthick=0,
    linestyle=&quot;none&quot;,
    elinewidth=1.0,
)

fit_menc = fit_potential.mass_enclosed(xyz * u.kpc)
ax.loglog(xyz[0], fit_menc.value, marker=&quot;&quot;, color=&quot;#3182bd&quot;, linewidth=2, alpha=0.7)

ax.set_xlim(1e-3, 10**2.6)
ax.set_ylim(7e6, 10**12.25)

ax.set_xlabel(&quot;$r$ [kpc]&quot;)
ax.set_ylabel(&quot;$M(&lt;r)$ [M$_\odot$]&quot;)

ax.set_xscale(&quot;log&quot;)
ax.set_yscale(&quot;log&quot;)

fig.tight_layout()
# -

# This potential is already implemented in `gala` in `gala.potential.special`,
# and we can import it with:

from gala.potential import MilkyWayPotential

potential = MilkyWayPotential()
potential
</file>
    <file path="docs/tutorials/integrate-potential-example.rst">
.. _integrate_potential_example:

=====================================================
Integrating and plotting an orbit in an NFW potential
=====================================================

We first need to import some relevant packages::

   &gt;&gt;&gt; import astropy.units as u
   &gt;&gt;&gt; import matplotlib.pyplot as plt
   &gt;&gt;&gt; import numpy as np
   &gt;&gt;&gt; import gala.integrate as gi
   &gt;&gt;&gt; import gala.dynamics as gd
   &gt;&gt;&gt; import gala.potential as gp
   &gt;&gt;&gt; from gala.units import galactic

In the examples below, we will work use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

We first create a potential object to work with. For this example, we'll
use a spherical NFW potential, parametrized by a scale radius and the
circular velocity at the scale radius::

   &gt;&gt;&gt; pot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,
   ...                                              r_s=10.*u.kpc,
   ...                                              units=galactic)

As a demonstration, we're going to first integrate a single orbit in this
potential.

The easiest way to do this is to use the
`~gala.potential.PotentialBase.integrate_orbit` method of the potential object,
which accepts a set of initial conditions and a specification for the
time-stepping. We'll define the initial conditions as a
`~gala.dynamics.PhaseSpacePosition` object::

   &gt;&gt;&gt; ics = gd.PhaseSpacePosition(pos=[10,0,0.] * u.kpc,
   ...                             vel=[0,175,0] * u.km/u.s)
   &gt;&gt;&gt; orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000)

This method returns a `~gala.dynamics.Orbit` object that contains an
array of times and the (6D) position at each time-step. By default, this method
uses Leapfrog integration to compute the orbit
(:class:`~gala.integrate.LeapfrogIntegrator`), but you can optionally specify
a different (more precise) integrator class as a keyword argument::

   &gt;&gt;&gt; orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000,
   ...                             Integrator=gi.DOPRI853Integrator)

We can integrate many orbits in parallel by passing in a 2D array of initial
conditions. Here, as an example, we'll generate some random initial
conditions by sampling from a Gaussian around the initial orbit (with a
positional scale of 100 pc, and a velocity scale of 1 km/s)::

   &gt;&gt;&gt; norbits = 128
   &gt;&gt;&gt; new_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,
   ...                            size=(norbits,3)).T * u.pc
   &gt;&gt;&gt; new_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,
   ...                            size=(norbits,3)).T * u.km/u.s
   &gt;&gt;&gt; new_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)
   &gt;&gt;&gt; orbits = gp.Hamiltonian(pot).integrate_orbit(new_ics, dt=2., n_steps=2000)

We'll now plot the final positions of these orbits over isopotential contours.
We use the :meth:`~gala.potential.Potential.plot_contours` method of the potential
object to plot the potential contours. This function returns a
:class:`~matplotlib.figure.Figure` object, which we can then use to over-plot
the orbit points::

   &gt;&gt;&gt; grid = np.linspace(-15,15,64)
   &gt;&gt;&gt; fig,ax = plt.subplots(1, 1, figsize=(5,5))
   &gt;&gt;&gt; fig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)
   &gt;&gt;&gt; fig = orbits[-1].plot(['x', 'y'], color='#9ecae1', s=1., alpha=0.5,
   ...                       axes=[ax], auto_aspect=False) # doctest: +SKIP

.. plot::
   :align: center
   :context: close-figs

   import astropy.units as u
   import numpy as np
   import gala.integrate as gi
   import gala.dynamics as gd
   import gala.potential as gp
   from gala.units import galactic

   np.random.seed(42)

   pot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,
                                                r_s=10.*u.kpc,
                                                units=galactic)

   ics = gd.PhaseSpacePosition(pos=[10,0,0.]*u.kpc,
                               vel=[0,175,0]*u.km/u.s)
   orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=2., n_steps=2000)

   norbits = 1024
   new_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,
                              size=(norbits,3)).T * u.pc
   new_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,
                              size=(norbits,3)).T * u.km/u.s
   new_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)
   orbits = gp.Hamiltonian(pot).integrate_orbit(new_ics, dt=2., n_steps=2000)

   grid = np.linspace(-15,15,64)
   fig,ax = plt.subplots(1, 1, figsize=(5,5))
   fig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)
   orbits[-1].plot(['x', 'y'], color='#9ecae1', s=1., alpha=0.5,
                   axes=[ax], auto_aspect=False)
   fig.tight_layout()
</file>
    <file path="docs/tutorials/integrate-rotating-frame.rst">
.. _integrate_rotating_frame:

==================================================
Integrating an orbit in a rotating reference frame
==================================================

We first need to import some relevant packages::

   &gt;&gt;&gt; import astropy.units as u
   &gt;&gt;&gt; import matplotlib.pyplot as plt
   &gt;&gt;&gt; import numpy as np
   &gt;&gt;&gt; import gala.integrate as gi
   &gt;&gt;&gt; import gala.dynamics as gd
   &gt;&gt;&gt; import gala.potential as gp
   &gt;&gt;&gt; from gala.units import galactic
   &gt;&gt;&gt; from scipy.optimize import minimize

-----------------------------------
Orbits in a barred galaxy potential
-----------------------------------

In the example below, we will work use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

For this example, we'll use a simple, analytic representation of the potential
from a Galactic bar and integrate an orbit in the rotating frame of the bar,
which has some pattern speed :math:`\Omega`. We'll use a three-component
potential model consisting of the bar (an implementation of the model used in
`Long &amp; Murali 1992 &lt;http://adsabs.harvard.edu/abs/1992ApJ...397...44L&gt;`_), a
Miyamoto-Nagai potential for the galactic disk, and a spherical NFW potential
for the dark matter distribution. We'll tilt the bar with respect to the x-axis
by 25 degrees (the angle ``alpha`` below). First, we'll define the disk and
halo potential components::

    &gt;&gt;&gt; disk = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
    ...                                  a=3.5*u.kpc, b=280*u.pc,
    ...                                  units=galactic)
    &gt;&gt;&gt; halo = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc, units=galactic)

We'll set the mass of the bar to be 1/6 the mass of the disk component, and
we'll set the long-axis scale length of the bar to :math:`4~{\rm kpc}`. We can
now define the bar component::

    &gt;&gt;&gt; bar = gp.LongMuraliBarPotential(m=1E10*u.Msun, a=4*u.kpc,
    ...                                 b=0.8*u.kpc, c=0.25*u.kpc,
    ...                                 alpha=25*u.degree,
    ...                                 units=galactic)

The full potential is the composition of the three potential objects. We can
combine potential classes by defining a `~gala.potential.CCompositePotential`
class and adding named components::

    &gt;&gt;&gt; pot = gp.CCompositePotential()
    &gt;&gt;&gt; pot['disk'] = disk
    &gt;&gt;&gt; pot['halo'] = halo
    &gt;&gt;&gt; pot['bar'] = bar

Let's visualize the isopotential contours of the potential in the x-y plane to
see the bar perturbation::

    &gt;&gt;&gt; grid = np.linspace(-15,15,128)
    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, figsize=(5,5)) # doctest: +SKIP
    &gt;&gt;&gt; fig = pot.plot_contours(grid=(grid,grid,0.), ax=ax) # doctest: +SKIP
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$ [kpc]&quot;) # doctest: +SKIP
    &gt;&gt;&gt; ax.set_ylabel(&quot;$y$ [kpc]&quot;) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import matplotlib.pyplot as plt
    import astropy.units as u
    import numpy as np
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    grid = np.linspace(-15,15,128)
    fig, ax = plt.subplots(1, 1, figsize=(5,5))
    fig = pot.plot_contours(grid=(grid,grid,0.), ax=ax)
    ax.set_xlabel(&quot;$x$ [kpc]&quot;)
    ax.set_ylabel(&quot;$y$ [kpc]&quot;)

We assume that the bar rotates around the z-axis so that the frequency vector is
just :math:`\boldsymbol{\Omega} = (0,0,42)~{\rm km}~{\rm s}^{-1}~{\rm
kpc}^{-1}`. We'll create a
:class:`~gala.potential.hamiltonian.chamiltonian.Hamiltonian` object with a
:class:`~gala.potential.frame.builtin.ConstantRotatingFrame` with this
frequency::

    &gt;&gt;&gt; Om_bar = 42. * u.km/u.s/u.kpc
    &gt;&gt;&gt; frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
    ...                                  units=galactic)
    &gt;&gt;&gt; H = gp.Hamiltonian(potential=pot, frame=frame)

We can now numerically find the co-rotation radius in this potential and
integrate an orbit from a set of initial conditions near the co-rotation
radius::

    &gt;&gt;&gt; import scipy.optimize as so
    &gt;&gt;&gt; def func(r):
    ...     Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
    ...     return (Om - Om_bar).to(Om_bar.unit).value**2
    &gt;&gt;&gt; res = so.minimize(func, x0=10., method='powell')
    &gt;&gt;&gt;
    &gt;&gt;&gt; r_corot = res.x[0] * u.kpc
    &gt;&gt;&gt; v_circ = Om_bar * r_corot * u.kpc
    &gt;&gt;&gt;
    &gt;&gt;&gt; w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
    ...                            vel=[0, v_circ.value, 0.] * v_circ.unit)
    &gt;&gt;&gt; orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
    ...                           Integrator=gi.DOPRI853Integrator)
    &gt;&gt;&gt; fig = orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    &gt;&gt;&gt; for ax in fig.axes: # doctest: +SKIP
    ...     ax.set_xlim(-15,15) # doctest: +SKIP
    ...     ax.set_ylim(-15,15) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import gala.integrate as gi
    import scipy.optimize as so

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    Om_bar = 42. * u.km/u.s/u.kpc
    frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
                                     units=galactic)
    H = gp.Hamiltonian(potential=pot, frame=frame)

    def func(r):
        Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
        return (Om - Om_bar).to(Om_bar.unit).value**2

    res = so.minimize(func, x0=10., method='powell')
    r_corot = res.x[0] * u.kpc
    v_circ = Om_bar * r_corot

    w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
                               vel=[0,v_circ.value, 0.] * v_circ.unit)

    orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
                              Integrator=gi.DOPRI853Integrator)

    fig = orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    for ax in fig.axes:
        ax.set_xlim(-15,15)
        ax.set_ylim(-15,15)

This is an orbit circulation around the Lagrange point L5! Let's see what this
orbit looks like in an inertial frame::

    &gt;&gt;&gt; inertial_orbit = orbit.to_frame(gp.StaticFrame(galactic))
    &gt;&gt;&gt; fig = inertial_orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    &gt;&gt;&gt; for ax in fig.axes: # doctest: +SKIP
    ...     ax.set_xlim(-15,15) # doctest: +SKIP
    ...     ax.set_ylim(-15,15) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    pot = gp.CCompositePotential()
    pot['bar'] = gp.LongMuraliBarPotential(m=2E10*u.Msun, a=4*u.kpc,
                                           b=0.5*u.kpc, c=0.5*u.kpc,
                                           alpha=25*u.degree,
                                           units=galactic)
    pot['disk'] = gp.MiyamotoNagaiPotential(m=5E10*u.Msun, a=3.*u.kpc,
                                            b=280.*u.pc, units=galactic)
    pot['halo'] = gp.NFWPotential(m=6E11*u.Msun, r_s=20.*u.kpc,
                                  units=galactic)

    Om_bar = 42. * u.km/u.s/u.kpc
    frame = gp.ConstantRotatingFrame(Omega=[0,0,Om_bar.value]*Om_bar.unit,
                                     units=galactic)
    H = gp.Hamiltonian(potential=pot, frame=frame)

    def func(r):
        Om = pot.circular_velocity([r[0], 0, 0]*u.kpc)[0] / (r[0]*u.kpc)
        return (Om - Om_bar).to(Om_bar.unit).value**2

    res = so.minimize(func, x0=10., method='powell')
    r_corot = res.x[0] * u.kpc
    v_circ = Om_bar * r_corot

    w0 = gd.PhaseSpacePosition(pos=[r_corot.value, 0, 0] * r_corot.unit,
                               vel=[0,v_circ.value, 0.] * v_circ.unit)

    orbit = H.integrate_orbit(w0, dt=0.1, n_steps=40000,
                              Integrator=gi.DOPRI853Integrator)

    inertial_orbit = orbit.to_frame(gp.StaticFrame(galactic))
    fig = inertial_orbit.plot(marker=',', linestyle='none', alpha=0.5) # doctest: +SKIP
    for ax in fig.axes:
        ax.set_xlim(-15,15)
        ax.set_ylim(-15,15)
</file>
    <file path="docs/tutorials/Milky-Way-model.py">
# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx=&quot;hidden&quot;
# %matplotlib inline

# + nbsphinx=&quot;hidden&quot;
# %run nb_setup
# -

# # Integrate an orbit with uncertainties in Milky Way model

# `gala` provides a simple mass model for the Milky Way based on recent
# measurements of the enclosed mass compiled from the literature. See the
# [Defining a Milky Way potential
# model](define-milky-way-model.html) documentation for more
# information about how this model was defined.
#
# In this example, we will use the position and velocity and uncertainties of
# the Milky Way satellite galaxy &quot;Draco&quot; to integrate orbits in a Milky Way mass
# model starting from samples from the error distribution over initial
# conditions defined by its observed kinematics. We will then compute
# distributions of orbital properties like orbital period, pericenter, and
# eccentricity.
#
# Let's start by importing packages we will need:

# +
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np

# Gala
import gala.dynamics as gd
import gala.potential as gp

# -

# We will also set the default Astropy Galactocentric frame parameters to the
# values adopted in Astropy v4.0:

coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;)

# For the Milky Way model, we'll use the built-in potential class in `gala` (see
# above for definition):

potential = gp.MilkyWayPotential()

# For the sky position and distance of Draco, we'll use measurements from
# [Bonanos et al. 2004](https://arxiv.org/abs/astro-ph/0310477). For proper
# motion components, we'll use the recent HSTPROMO measurements ([Sohn et al.
# 2017](https://arxiv.org/abs/1707.02593)) and the line-of-sight velocity from
# [Walker et al. 2007](https://arxiv.org/abs/0708.0010).

# +
icrs = coord.SkyCoord(
    ra=coord.Angle(&quot;17h 20m 12.4s&quot;),
    dec=coord.Angle(&quot;+57 54 55&quot;),
    distance=76 * u.kpc,
    pm_ra_cosdec=0.0569 * u.mas / u.yr,
    pm_dec=-0.1673 * u.mas / u.yr,
    radial_velocity=-291 * u.km / u.s,
)

icrs_err = coord.SkyCoord(
    ra=0 * u.deg,
    dec=0 * u.deg,
    distance=6 * u.kpc,
    pm_ra_cosdec=0.009 * u.mas / u.yr,
    pm_dec=0.009 * u.mas / u.yr,
    radial_velocity=0.1 * u.km / u.s,
)
# -

# Let's start by transforming the measured values to a Galactocentric reference
# frame so we can integrate an orbit in our Milky Way model. We'll do this using
# the velocity transformation support in
# [`astropy.coordinates`](http://docs.astropy.org/en/stable/coordinates/velocities.html).
# We first have to define the position and motion of the sun relative to the
# Galactocentric frame, and create an
# [`astropy.coordinates.Galactocentric`](http://docs.astropy.org/en/stable/api/astropy.coordinates.Galactocentric.html#astropy.coordinates.Galactocentric)
# object with these parameters. We could specify these things explicitly, but
# instead we will use the default values that were recently updated in Astropy:

galcen_frame = coord.Galactocentric()
galcen_frame

# To transform the mean observed kinematics to this frame, we simply do:

galcen = icrs.transform_to(galcen_frame)

# That's it! Now we have to turn the resulting `Galactocentric` object into
# orbital initial conditions, and integrate the orbit in our Milky Way model.
# We'll use a timestep of 0.5 Myr and integrate the orbit backwards for 10000
# steps (5 Gyr):

w0 = gd.PhaseSpacePosition(galcen.data)
orbit = potential.integrate_orbit(w0, dt=-0.5 * u.Myr, n_steps=10000)

# Let's visualize the orbit:

fig = orbit.plot()

# With the `orbit` object, we can easily compute quantities like the pericenter,
# apocenter, or eccentricity of the orbit:

orbit.pericenter(), orbit.apocenter(), orbit.eccentricity()

# We can also use these functions to get the time of each pericenter or
# apocenter - let's plot the time of pericenter, and time of apocenter over the
# time series of the Galactocentric radius of the orbit:

# +
plt.plot(orbit.t, orbit.spherical.distance, marker=&quot;None&quot;)

per, per_times = orbit.pericenter(return_times=True, func=None)
apo, apo_times = orbit.apocenter(return_times=True, func=None)

for t in per_times:
    plt.axvline(t.value, color=&quot;#67a9cf&quot;)

for t in apo_times:
    plt.axvline(t.value, color=&quot;#ef8a62&quot;)

plt.xlabel(&quot;$t$ [{0}]&quot;.format(orbit.t.unit.to_string(&quot;latex&quot;)))
plt.ylabel(&quot;$r$ [{0}]&quot;.format(orbit.x.unit.to_string(&quot;latex&quot;)))
# -

# Now we'll sample from the error distribution over the distance, proper
# motions, and radial velocity, compute orbits, and plot distributions of mean
# pericenter and apocenter:

# +
n_samples = 128

dist = (
    np.random.normal(icrs.distance.value, icrs_err.distance.value, n_samples)
    * icrs.distance.unit
)

pm_ra_cosdec = (
    np.random.normal(icrs.pm_ra_cosdec.value, icrs_err.pm_ra_cosdec.value, n_samples)
    * icrs.pm_ra_cosdec.unit
)

pm_dec = (
    np.random.normal(icrs.pm_dec.value, icrs_err.pm_dec.value, n_samples)
    * icrs.pm_dec.unit
)

rv = (
    np.random.normal(
        icrs.radial_velocity.value, icrs_err.radial_velocity.value, n_samples
    )
    * icrs.radial_velocity.unit
)

ra = np.full(n_samples, icrs.ra.degree) * u.degree
dec = np.full(n_samples, icrs.dec.degree) * u.degree
# -

icrs_samples = coord.SkyCoord(
    ra=ra,
    dec=dec,
    distance=dist,
    pm_ra_cosdec=pm_ra_cosdec,
    pm_dec=pm_dec,
    radial_velocity=rv,
)

icrs_samples.shape

galcen_samples = icrs_samples.transform_to(galcen_frame)

w0_samples = gd.PhaseSpacePosition(galcen_samples.data)
orbit_samples = potential.integrate_orbit(w0_samples, dt=-1 * u.Myr, n_steps=4000)

orbit_samples.shape

# +
peris = orbit_samples.pericenter(approximate=True)

apos = orbit_samples.apocenter(approximate=True)

eccs = orbit_samples.eccentricity(approximate=True)

# +
fig, axes = plt.subplots(1, 3, figsize=(12, 4), sharey=True)

axes[0].hist(peris.to_value(u.kpc), bins=np.linspace(20, 80, 32))
axes[0].set_xlabel(&quot;pericenter [kpc]&quot;)

axes[1].hist(apos.to_value(u.kpc), bins=np.linspace(60, 140, 32))
axes[1].set_xlabel(&quot;apocenter [kpc]&quot;)

axes[2].hist(eccs.value, bins=np.linspace(0.3, 0.5, 41))
axes[2].set_xlabel(&quot;eccentricity&quot;)
</file>
    <file path="docs/tutorials/mock-stream-heliocentric.rst">
.. _mockstream-heliocentric:

===========================================================================
Generating a mock stellar stream and converting to Heliocentric coordinates
===========================================================================

We first need to import some relevant packages::

   &gt;&gt;&gt; import astropy.coordinates as coord
   &gt;&gt;&gt; import astropy.units as u
   &gt;&gt;&gt; import numpy as np
   &gt;&gt;&gt; import gala.coordinates as gc
   &gt;&gt;&gt; import gala.dynamics as gd
   &gt;&gt;&gt; import gala.potential as gp
   &gt;&gt;&gt; from gala.units import galactic

We will also set the default Astropy Galactocentric frame parameters to the
values adopted in Astropy v4.0:

    &gt;&gt;&gt; _ = coord.galactocentric_frame_defaults.set('v4.0')

In the examples below, we will use the ``galactic``
`~gala.units.UnitSystem`: as I define it, this is: :math:`{\rm kpc}`,
:math:`{\rm Myr}`, :math:`{\rm M}_\odot`.

We first create a potential object to work with. For this example, we'll
use a two-component potential: a Miyamoto-Nagai disk with a spherical NFW
potential to represent a dark matter halo.

   &gt;&gt;&gt; pot = gp.CCompositePotential()
   &gt;&gt;&gt; pot['disk'] = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
   ...                                         a=3.5*u.kpc, b=280*u.pc,
   ...                                         units=galactic)
   &gt;&gt;&gt; pot['halo'] = gp.NFWPotential(m=7E11, r_s=15*u.kpc, units=galactic)

We'll use the Palomar 5 globular cluster and stream as a motivation for this
example. For the position and velocity of the cluster, we'll use
:math:`(\alpha, \delta) = (229, 0.124)~{\rm deg}` [odenkirchen02]_,
:math:`d = 22.9~{\rm kpc}` [bovy16]_,
:math:`v_r = -58.7~{\rm km}~{\rm s}^{-1}` [bovy16]_, and
:math:`(\mu_{\alpha,*}, \mu_\delta) = (-2.296,-2.257)~{\rm mas}~{\rm yr}^{-1}`
[fritz15]_::

   &gt;&gt;&gt; c = coord.ICRS(ra=229 * u.deg, dec=-0.124 * u.deg,
   ...                distance=22.9 * u.kpc,
   ...                pm_ra_cosdec=-2.296 * u.mas/u.yr,
   ...                pm_dec=-2.257 * u.mas/u.yr,
   ...                radial_velocity=-58.7 * u.km/u.s)

We'll first convert this position and velocity to Galactocentric coordinates::

   &gt;&gt;&gt; c_gc = c.transform_to(coord.Galactocentric).cartesian
   &gt;&gt;&gt; c_gc
   &lt;CartesianRepresentation (x, y, z) in kpc
      (7.86390455, 0.22748727, 16.41622487)
   (has differentials w.r.t.: 's')&gt;
   &gt;&gt;&gt; pal5_w0 = gd.PhaseSpacePosition(c_gc)

We can now use the position and velocity of the cluster to generate a :ref:`mock
stellar stream &lt;mockstreams&gt;` with a progenitor that ends up at the present-day
position of the cluster. We will generate a stream using the prescription
defined in [fardal15]_, but including the self-gravity of the cluster mass
itself. We will represent the cluster with a Plummer potential, with mass
:math:`2.5 \times 10^4~{\rm M}_\odot`::

    &gt;&gt;&gt; pal5_mass = 2.5e4 * u.Msun
    &gt;&gt;&gt; pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)

We now have to specify that we want to use the Fardal method for generating
stream particle initial conditions by creating a
`~gala.dynamics.mockstream.FardalStreamDF` instance::

    &gt;&gt;&gt; from gala.dynamics import mockstream as ms
    &gt;&gt;&gt; df = ms.FardalStreamDF()

Finally, we can generate the stream using the
`~gala.dynamics.mockstream.MockStreamGenerator`::

    &gt;&gt;&gt; gen_pal5 = ms.MockStreamGenerator(df, pot,
    ...                                   progenitor_potential=pal5_pot)
    &gt;&gt;&gt; pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
    ...                               dt=-1 * u.Myr, n_steps=4000)

Here the negative timestep tells the stream generator to first integrate the orbit of the progenitor (the Pal 5 cluster itself) backwards in time, then generate the stream forwards from the past until present day::

    &gt;&gt;&gt; pal5_stream.plot(alpha=0.1) # doctest: +SKIP

.. plot::
    :align: center
    :context: close-figs

    import astropy.coordinates as coord
    import astropy.units as u
    import numpy as np
    import gala.coordinates as gc
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.units import galactic
    from gala.dynamics import mockstream as ms

    coord.galactocentric_frame_defaults.set('v4.0')

    pot = gp.CCompositePotential()
    pot['disk'] = gp.MiyamotoNagaiPotential(m=6E10*u.Msun,
                                            a=3.5*u.kpc, b=280*u.pc,
                                            units=galactic)
    pot['halo'] = gp.NFWPotential(m=1E12, r_s=20*u.kpc, units=galactic)

    c = coord.ICRS(ra=229 * u.deg, dec=-0.124 * u.deg,
                   distance=22.9 * u.kpc,
                   pm_ra_cosdec=-2.296 * u.mas/u.yr,
                   pm_dec=-2.257 * u.mas/u.yr,
                   radial_velocity=-58.7 * u.km/u.s)

    c_gc = c.transform_to(coord.Galactocentric).cartesian
    pal5_w0 = gd.PhaseSpacePosition(c_gc)

    pal5_mass = 2.5e4 * u.Msun
    pal5_pot = gp.PlummerPotential(m=pal5_mass, b=4*u.pc, units=galactic)

    df = ms.FardalStreamDF(gala_modified=True)
    gen_pal5 = ms.MockStreamGenerator(df, pot, progenitor_potential=pal5_pot)
    pal5_stream, _ = gen_pal5.run(pal5_w0, pal5_mass,
                                 dt=-1 * u.Myr, n_steps=4000)

    pal5_stream.plot(alpha=0.1)

We now have the model stream particle positions and velocities in a
Galactocentric coordinate frame. To convert these to observable, Heliocentric
coordinates, we have to specify a desired coordinate frame. We'll convert to the
ICRS coordinate system and plot some of the Heliocentric kinematic quantities::

   &gt;&gt;&gt; stream_c = pal5_stream.to_coord_frame(coord.ICRS)

.. plot::
   :align: center
   :context: close-figs

   stream_c = pal5_stream.to_coord_frame(coord.ICRS)

   style = dict(marker='.', s=1, alpha=0.5)

   fig, axes = plt.subplots(1, 2, figsize=(10,5), sharex=True)

   axes[0].scatter(stream_c.ra.degree,
                   stream_c.dec.degree, **style)
   axes[0].set_xlim(250, 220)
   axes[0].set_ylim(-15, 15)

   axes[1].scatter(stream_c.ra.degree,
                   stream_c.radial_velocity.to(u.km/u.s), **style)
   axes[1].set_xlim(250, 220)
   axes[1].set_ylim(-100, 0)

   axes[0].set_xlabel(r'$\alpha\,[{\rm deg}]$')
   axes[1].set_xlabel(r'$\alpha\,[{\rm deg}]$')
   axes[0].set_ylabel(r'$\delta\,[{\rm deg}]$')
   axes[1].set_ylabel(r'$v_r\,[{\rm km}\,{\rm s}^{-1}]$')

   fig.tight_layout()

References
==========

.. [odenkirchen02] `Odenkirchen et al. (2002) &lt;https://arxiv.org/abs/astro-ph/0206276&gt;`_
.. [fritz15] `Fritz &amp; Kallivayalil (2015) &lt;https://arxiv.org/abs/1508.06647&gt;`_
.. [bovy16] `Bovy et al. (2016) &lt;https://arxiv.org/abs/1609.01298&gt;`_
</file>
    <file path="docs/tutorials/nb_setup">
get_ipython().magic('config InlineBackend.figure_format = &quot;retina&quot;')  # noqa

import matplotlib.pyplot as plt

plt.style.use(&quot;default&quot;)

# NOTE: if you update these, also update docs/conf.py
plot_rcparams = {
    &quot;image.cmap&quot;: &quot;magma&quot;,
    # Fonts:
    &quot;font.size&quot;: 16,
    &quot;figure.titlesize&quot;: &quot;x-large&quot;,
    &quot;axes.titlesize&quot;: &quot;large&quot;,
    &quot;axes.labelsize&quot;: &quot;large&quot;,
    &quot;xtick.labelsize&quot;: &quot;medium&quot;,
    &quot;ytick.labelsize&quot;: &quot;medium&quot;,
    # Axes:
    &quot;axes.labelcolor&quot;: &quot;k&quot;,
    &quot;axes.axisbelow&quot;: True,
    # Ticks
    &quot;xtick.color&quot;: &quot;#333333&quot;,
    &quot;xtick.direction&quot;: &quot;in&quot;,
    &quot;ytick.color&quot;: &quot;#333333&quot;,
    &quot;ytick.direction&quot;: &quot;in&quot;,
    &quot;xtick.top&quot;: True,
    &quot;ytick.right&quot;: True,
    &quot;figure.dpi&quot;: 300,
    &quot;savefig.dpi&quot;: 300,
}

plt.rcParams.update(plot_rcparams)
</file>
    <file path="docs/tutorials/pyia-gala-orbit.py">
# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.11.1
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# + nbsphinx=&quot;hidden&quot;
# %run nb_setup
# -

# %matplotlib inline

# # Compute a Galactic orbit for a star using Gaia data
#
# In this tutorial, we will retrieve the sky coordinates, astrometry, and radial velocity for a star  [Kepler-444](https://en.wikipedia.org/wiki/Kepler-444)  and compute its orbit in the default Milky Way mass model implemented in Gala. We will compare the orbit of Kepler-444 to the orbit of the Sun.
#
# ### Notebook Setup and Package Imports

# +
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
from pyia import GaiaData

# Gala
import gala.dynamics as gd
import gala.potential as gp

# -

# ## Define a Galactocentric Coordinate Frame
#
# We will start by defining a Galactocentric coordinate system using `astropy.coordinates` by adopting the latest parameter set for the Solar position and velocity with respect to the Galactic Center implemented in Astropy.

with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
    galcen_frame = coord.Galactocentric()
galcen_frame

# ## Define the Solar Position and Velocity

# In this coordinate system, the sun is along the $x$-axis (at a negative $x$ value), and the Galactic rotation at this position is in the $+y$ direction. In this coordinate system, the 3D position of the sun is therefore given by:

sun_xyz = u.Quantity(
    [-galcen_frame.galcen_distance, 0 * u.kpc, galcen_frame.z_sun]  # x  # y  # z
)

# We can combine this with the solar velocity vector (set on the `astropy.coordinates.Galactocentric` frame) to define the sun's phase-space position, which we will use as initial conditions shortly to compute the orbit of the Sun:

sun_w0 = gd.PhaseSpacePosition(pos=sun_xyz, vel=galcen_frame.galcen_v_sun)

# To compute the sun's orbit, we need to specify a mass model for the Galaxy. Here, we will use the same default, four-component Milky Way mass model introduced in [Defining a Milky Way model](define-milky-way-model.html):

mw_potential = gp.MilkyWayPotential()

# We can now compute the Sun's orbit using the default integrator (Leapfrog integration): We will compute the orbit for 4 Gyr, which is about 16 orbital periods:

sun_orbit = mw_potential.integrate_orbit(sun_w0, dt=0.5 * u.Myr, t1=0, t2=4 * u.Gyr)

# ## Retrieve Gaia Data for Kepler-444

# For our comparison star, we will use the exoplanet-hosting star Kepler-444. To get Gaia data for this source, we first have to retrieve its sky coordinates so that we can do a positional cross-match query on the Gaia catalog. We can retrieve the sky position of Kepler-444 using the `SkyCoord.from_name()` classmethod, which queries Simbad under the hood to resolve the name:

star_sky_c = coord.SkyCoord.from_name(&quot;Kepler-444&quot;)
star_sky_c

# We happen to know a priori that Kepler-444 has a large proper motion, so the sky position reported by Simbad (unknown epoch) could be off from the Gaia sky position (epoch=2016) by many arcseconds. To run and retrieve the Gaia data, we will use the [pyia](http://pyia.readthedocs.io/) package: We can pass in an ADQL query, which `pyia` uses to query the Gaia science archive using `astroquery`, and returns the data as a `pyia` object that understands how to convert the Gaia data columns into a `astropy.coordinates.SkyCoord` object. To run the query, we will do a large sky position cross-match (with a radius of 15 arcseconds), and take the brightest cross-matched source within this region:

star_gaia = GaiaData.from_query(
    f&quot;&quot;&quot;
    SELECT TOP 1 * FROM gaiadr3.gaia_source
    WHERE 1=CONTAINS(
        POINT('ICRS', {star_sky_c.ra.degree}, {star_sky_c.dec.degree}),
        CIRCLE('ICRS', ra, dec, {(15*u.arcsec).to_value(u.degree)})
    )
    ORDER BY phot_g_mean_mag
    &quot;&quot;&quot;
)
star_gaia

# We will assume (and hope!) that this source is Kepler-444, but we know that it is fairly bright compared to a typical Gaia source, so we should be safe.
#
# We can now use the returned `pyia.GaiaData` object to convert the Gaia astrometric and radial velocity measurements into an Astropy `SkyCoord` object (with all position and velocity data):

star_gaia_c = star_gaia.get_skycoord()

# To compute this star's Galactic orbit, we need to convert its observed, Heliocentric (actually solar system barycentric) data into the Galactocentric coordinate frame we defined above. To do this, we will use the `astropy.coordinates` transformation framework:

star_galcen = star_gaia_c.transform_to(galcen_frame)
star_galcen

# Now with Galactocentric position and velocity components for Kepler-444, we can create Gala initial conditions and compute its orbit on the time grid used to compute the Sun's orbit above:

star_w0 = gd.PhaseSpacePosition(star_galcen.data)
star_orbit = mw_potential.integrate_orbit(star_w0, t=sun_orbit.t)

# +
fig, axes = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)

sun_orbit.plot([&quot;x&quot;, &quot;y&quot;], axes=axes[0])
star_orbit.plot([&quot;x&quot;, &quot;y&quot;], axes=axes[0])
axes[0].set_xlim(-10, 10)
axes[0].set_ylim(-10, 10)

sun_orbit.cylindrical.plot(
    [&quot;rho&quot;, &quot;z&quot;],
    axes=axes[1],
    auto_aspect=False,
    labels=[&quot;$R$ [kpc]&quot;, &quot;$z$ [kpc]&quot;],
    label=&quot;Sun&quot;,
)
star_orbit.cylindrical.plot(
    [&quot;rho&quot;, &quot;z&quot;],
    axes=axes[1],
    auto_aspect=False,
    labels=[&quot;$R$ [kpc]&quot;, &quot;$z$ [kpc]&quot;],
    label=&quot;Kepler-444&quot;,
)
axes[1].set_xlim(0, 10)
axes[1].set_ylim(-5, 5)
axes[1].set_aspect(&quot;auto&quot;)
axes[1].legend(loc=&quot;best&quot;, fontsize=15)
# -
# ### Exercise: How does Kepler-444's orbit differ from the Sun's?
#
# What is the maximum $z$ height reached by each orbit? What are their eccentricities? What are the guiding center radii of the two orbits? Can you guess which star is older based on their kinematics? Which star do you think has a higher metallicity?


# ### Exercise: Comparing these orbits to the orbits of other Gaia stars
#
# Retrieve Gaia data for a set of 100 random Gaia stars within 200 pc of the sun with measured radial velocities and well-measured parallaxes using the query:
#
#     SELECT TOP 100 * FROM gaiadr3.gaia_source
#         WHERE radial_velocity IS NOT NULL AND
#             parallax_over_error &gt; 10 AND
#             ruwe &lt; 1.2 AND
#             parallax &gt; 5
#         ORDER BY random_index

random_stars_g = GaiaData.from_query(
    &quot;&quot;&quot;
    SELECT TOP 100 * FROM gaiadr3.gaia_source
    WHERE radial_velocity IS NOT NULL AND
        parallax_over_error &gt; 10 AND
        ruwe &lt; 1.2 AND
        parallax &gt; 5
    ORDER BY random_index
    &quot;&quot;&quot;
)

# Compute orbits for these stars for the same time grid used above to compute the sun's orbit:

random_stars_c = random_stars_g.get_skycoord()

random_stars_galcen = random_stars_c.transform_to(galcen_frame)
random_stars_w0 = gd.PhaseSpacePosition(random_stars_galcen.data)

random_stars_orbits = mw_potential.integrate_orbit(random_stars_w0, t=sun_orbit.t)

# Plot the initial (present-day) positions of all of these stars in Galactocentric Cartesian coordinates:

_ = random_stars_w0.plot()

# Plot the orbits of these stars in the x-y and R-z planes:

# +
fig, axes = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)

random_stars_orbits.plot([&quot;x&quot;, &quot;y&quot;], axes=axes[0])
axes[0].set_xlim(-15, 15)
axes[0].set_ylim(-15, 15)

random_stars_orbits.cylindrical.plot(
    [&quot;rho&quot;, &quot;z&quot;],
    axes=axes[1],
    auto_aspect=False,
    labels=[&quot;$R$ [kpc]&quot;, &quot;$z$ [kpc]&quot;],
)

axes[1].set_xlim(0, 15)
axes[1].set_ylim(-5, 5)
axes[1].set_aspect(&quot;auto&quot;)
# -

# Compute maximum $z$ heights ($z_\textrm{max}$) and eccentricities for all of these orbits. Compare the Sun, Kepler-444, and this random sampling of nearby stars. Where do the Sun and Kepler-444 sit relative to the random sample of nearby stars in terms of $z_\textrm{max}$ and eccentricity? (Hint: plot $z_\textrm{max}$ vs. eccentricity and highlight the Sun and Kepler-444!) Are either of them outliers in any way?

rand_zmax = random_stars_orbits.zmax()

rand_ecc = random_stars_orbits.eccentricity()

fig, ax = plt.subplots(figsize=(8, 6))
ax.scatter(
    rand_ecc, rand_zmax, color=&quot;k&quot;, alpha=0.4, s=14, lw=0, label=&quot;random nearby stars&quot;
)
ax.scatter(sun_orbit.eccentricity(), sun_orbit.zmax(), color=&quot;tab:orange&quot;, label=&quot;Sun&quot;)
ax.scatter(
    star_orbit.eccentricity(), star_orbit.zmax(), color=&quot;tab:cyan&quot;, label=&quot;Kepler-444&quot;
)
ax.legend(loc=&quot;best&quot;, fontsize=14)
ax.set_xlabel(&quot;eccentricity, $e$&quot;)
ax.set_ylabel(r&quot;max. $z$ height, $z_{\rm max}$ [kpc]&quot;)
</file>
    <file path="docs/testing.rst">
.. _gala-test:

=================
Running the tests
=================

The tests are written assuming they will be run with `tox
&lt;https://tox.readthedocs.io/en/latest/&gt;`_ or `pytest &lt;http://doc.pytest.org/&gt;`_.

To run the tests with tox, first make sure that tox is installed;

    pip install tox

then run the basic test suite with:

    tox -e test

or run the test suite with all optional dependencies with:

    tox -e test-alldeps

You can see a list of available test environments with:

    tox -l -v

which will also explain what each of them does.

You can also run the tests directly with pytest. To do this, make sure to
install the testing requirements (from the cloned ``gala`` repository
directory)::

    pip install -e &quot;.[test]&quot;

Then you can run the tests with:

    pytest gala
</file>
    <file path="docs/tutorials.rst">
.. _gala-tutorials:

*********
Tutorials
*********

The tutorials listed below are meant to be step-by-step demonstrations of common
functionality in `gala`. If you are interested in contributing a tutorial, or
requesting a tutorial about material that is not covered here, please `open an
issue on GitHub &lt;https://github.com/adrn/gala/issues&gt;`_.

.. The _tutorials.rst file is auto-generated in conf.py. Add new tutorials to
.. the list of files in conf.py

.. include:: _tutorials.rst
</file>
    <file path="gala/coordinates/tests/test_all_streamframes.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# This package
from .. import (
    GD1Koposov10,
    MagellanicStreamNidever08,
    OphiuchusPriceWhelan16,
    OrphanKoposov19,
    OrphanNewberg10,
    Pal5PriceWhelan18,
    SagittariusLaw10,
)

stream_frames = (
    GD1Koposov10,
    MagellanicStreamNidever08,
    OphiuchusPriceWhelan16,
    OrphanKoposov19,
    OrphanNewberg10,
    Pal5PriceWhelan18,
    SagittariusLaw10,
)


@pytest.mark.parametrize(&quot;frame_cls&quot;, stream_frames)
def test_wrapping(frame_cls):
    c = frame_cls([-60, 300] * u.deg, [15, -15] * u.deg)
    lon_name = list(c.get_representation_component_names().keys())[0]
    lat_name = list(c.get_representation_component_names().keys())[1]
    assert np.allclose(getattr(c, lon_name).value, -60)

    # with velocity data:
    data = dict()
    data[&quot;pm_{}_cos{}&quot;.format(lon_name, lat_name)] = [1.0, 2.0] * u.mas / u.yr
    data[&quot;pm_{}&quot;.format(lat_name)] = [1.0, 2.0] * u.mas / u.yr
    c = frame_cls([-60, 300] * u.deg, [15, -15] * u.deg, **data)
    assert np.allclose(getattr(c, lon_name).value, -60)
</file>
    <file path="gala/coordinates/tests/test_gd1.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..gd1 import GD1Koposov10


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    c = GD1Koposov10(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(GD1Koposov10())

    # with distance
    c = GD1Koposov10(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)


def test_koposov():
    # Compare against Table 1 in Koposov et al. 2010

    filename = get_pkg_data_filename(&quot;gd1_coord.txt&quot;)
    k10_data = np.genfromtxt(filename, names=True, dtype=None, encoding='utf-8')

    k10_icrs = coord.SkyCoord(
        ra=k10_data[&quot;ra&quot;].astype(str),
        dec=k10_data[&quot;dec&quot;].astype(str),
        unit=(u.hourangle, u.degree),
    )

    k10_gd1 = GD1Koposov10(
        phi1=k10_data[&quot;phi1&quot;] * u.degree, phi2=k10_data[&quot;phi2&quot;] * u.degree
    )

    gala_gd1 = k10_icrs.transform_to(GD1Koposov10())

    # TODO: why are these so different from the values in Koposov?
    assert np.allclose(k10_gd1.phi1.degree, gala_gd1.phi1.degree, atol=1e-1)
    assert np.allclose(k10_gd1.phi2.degree, gala_gd1.phi2.degree, atol=0.2)
</file>
    <file path="gala/coordinates/tests/test_greatcircle.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np
import pytest

# This project
from ..greatcircle import (
    GreatCircleICRSFrame,
    make_greatcircle_cls,
    pole_from_endpoints,
    sph_midpoint,
)

rng = np.random.default_rng(seed=42)
rand_lon = rng.uniform(0, 2 * np.pi, 15) * u.rad
rand_lat = np.arcsin(rng.uniform(-1, 1, size=15)) * u.rad
poles = [
    coord.SkyCoord(ra=0 * u.deg, dec=90 * u.deg),
    coord.SkyCoord(ra=0 * u.deg, dec=-90 * u.deg),
    coord.SkyCoord(ra=12.3 * u.deg, dec=45.6 * u.deg, distance=1 * u.kpc),
] + [coord.SkyCoord(lon, lat) for lon, lat in zip(rand_lon, rand_lat)]


def get_random_orthogonal(skycoord, rng):
    zhat = np.squeeze((skycoord.cartesian / skycoord.cartesian.norm()).xyz)

    # Random vector orthogonal to the pole:
    x = rng.uniform(size=3)
    x /= np.linalg.norm(x)
    xhat = x - (x @ zhat) * zhat
    xhat /= np.linalg.norm(xhat)
    return coord.SkyCoord(coord.CartesianRepresentation(xhat), frame=skycoord.frame)


@pytest.mark.parametrize(&quot;pole&quot;, poles)
def test_init_cls(pole):
    origin = get_random_orthogonal(pole, rng)

    GreatCircleICRSFrame(pole=pole, origin=origin)
    GreatCircleICRSFrame(pole=pole, origin=origin, priority=&quot;pole&quot;)

    with pytest.raises(ValueError):
        GreatCircleICRSFrame(pole=pole, ra0=origin.ra)

    # Slightly adjust the origin so it is not orthogonal:
    new_origin = origin.spherical_offsets_by(
        1.23 * u.deg, -2.42 * u.deg
    )  # random values

    with pytest.warns():
        f1 = GreatCircleICRSFrame(pole=pole, origin=new_origin)

    # default priority=&quot;origin&quot;
    assert f1.origin.ra == new_origin.ra
    assert f1.origin.dec == new_origin.dec
    assert np.isclose(f1.origin.cartesian.xyz @ f1.pole.cartesian.xyz, 0.0)

    with pytest.warns():
        f2 = GreatCircleICRSFrame(pole=pole, origin=new_origin, priority=&quot;pole&quot;)

    assert f2.pole.ra == pole.ra
    assert f2.pole.dec == pole.dec
    assert np.isclose(f2.origin.cartesian.xyz @ f2.pole.cartesian.xyz, 0.0)


@pytest.mark.parametrize(&quot;pole&quot;, poles)
def test_init_from_pole_ra0(pole):
    GreatCircleICRSFrame.from_pole_ra0(pole, ra0=153 * u.deg)

    disamb = coord.SkyCoord(ra=210 * u.deg, dec=-17 * u.deg)
    GreatCircleICRSFrame.from_pole_ra0(
        pole, ra0=153 * u.deg, origin_disambiguate=disamb
    )


fail_poles = [
    coord.SkyCoord(ra=90 * u.deg, dec=0 * u.deg),
    coord.SkyCoord(ra=13.5399 * u.deg, dec=0 * u.deg),
]


@pytest.mark.parametrize(&quot;pole&quot;, fail_poles)
def test_init_from_pole_ra0_fail(pole):
    with pytest.raises(ValueError):
        test_init_from_pole_ra0(pole)


@pytest.mark.parametrize(&quot;c1&quot;, poles)
def test_init_from_endpoints(c1):
    # Random vector for other endpoint:
    x = rng.uniform(size=3)
    x /= np.linalg.norm(x)
    c2 = coord.SkyCoord(coord.CartesianRepresentation(x))

    midpt = coord.SkyCoord(sph_midpoint(c1.squeeze(), c2))
    origin_off = midpt.spherical_offsets_by(1.423 * u.deg, -2.182 * u.deg)

    f1 = GreatCircleICRSFrame.from_endpoints(c1, c2)
    f2 = GreatCircleICRSFrame.from_endpoints(c1, c2, origin=midpt)
    with pytest.warns():
        f3 = GreatCircleICRSFrame.from_endpoints(c1, c2, origin=origin_off)
    assert u.isclose(f3.origin.ra, origin_off.ra)
    assert u.isclose(f3.origin.dec, origin_off.dec)

    if np.abs(c1.dec) != 90 * u.deg:
        f4 = GreatCircleICRSFrame.from_endpoints(c1, c2, ra0=origin_off.ra)

    with pytest.warns():
        f5 = GreatCircleICRSFrame.from_endpoints(
            c1, c2, origin=origin_off, priority=&quot;pole&quot;
        )
    assert u.isclose(f5.pole.ra, f1.pole.ra)
    assert u.isclose(f5.pole.dec, f1.pole.dec)


@pytest.mark.parametrize(&quot;pole&quot;, poles)
def test_make_function(pole):
    origin = get_random_orthogonal(pole, rng)

    cls = make_greatcircle_cls(
        &quot;Michael&quot;, &quot;This is the docstring header&quot;, pole=pole, origin=origin
    )
    fr = cls(phi1=100 * u.deg, phi2=10 * u.deg)
    fr.transform_to(coord.ICRS())


def test_pole_from_endpoints():
    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(90 * u.deg, 0 * u.deg)
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.dec, 90 * u.deg)

    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(0 * u.deg, 90 * u.deg)
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.ra, 270 * u.deg)
    assert u.allclose(pole.dec, 0 * u.deg)

    # Should work even if coord has velocities:
    c1 = coord.SkyCoord(
        0 * u.deg, 0 * u.deg, pm_ra_cosdec=10 * u.mas / u.yr, pm_dec=-0.5 * u.mas / u.yr
    )
    c2 = coord.SkyCoord(
        0 * u.deg,
        90 * u.deg,
        pm_ra_cosdec=10 * u.mas / u.yr,
        pm_dec=-0.5 * u.mas / u.yr,
    )
    pole = pole_from_endpoints(c1, c2)
    assert u.allclose(pole.ra, 270 * u.deg)
    assert u.allclose(pole.dec, 0 * u.deg)


def test_init_pole_from_xyz():
    xnew = coord.UnitSphericalRepresentation(185 * u.deg, 32.5 * u.deg).to_cartesian()
    ynew = coord.UnitSphericalRepresentation(275 * u.deg, 0 * u.deg).to_cartesian()
    znew = xnew.cross(ynew)

    fr1 = GreatCircleICRSFrame.from_xyz(xnew, ynew, znew)
    fr2 = GreatCircleICRSFrame.from_xyz(xnew, ynew)
    fr3 = GreatCircleICRSFrame.from_xyz(xnew, znew=znew)
    fr4 = GreatCircleICRSFrame.from_xyz(ynew=ynew, znew=znew)

    for fr in [fr2, fr3, fr4]:
        assert np.isclose(fr1.pole.ra.degree, fr.pole.ra.degree)
        assert np.isclose(fr1.pole.dec.degree, fr.pole.dec.degree)
        assert np.isclose(fr1.origin.ra.degree, fr.origin.ra.degree)
        assert np.isclose(fr1.origin.dec.degree, fr.origin.dec.degree)

    with pytest.raises(ValueError):
        GreatCircleICRSFrame.from_xyz(xnew)


def test_sph_midpoint():
    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(90 * u.deg, 0 * u.deg)
    midpt = sph_midpoint(c1, c2)
    assert u.allclose(midpt.ra, 45 * u.deg)
    assert u.allclose(midpt.dec, 0 * u.deg)

    c1 = coord.SkyCoord(0 * u.deg, 0 * u.deg)
    c2 = coord.SkyCoord(0 * u.deg, 90 * u.deg)
    midpt = sph_midpoint(c1, c2)
    assert u.allclose(midpt.ra, 0 * u.deg)
    assert u.allclose(midpt.dec, 45 * u.deg)


def test_init_from_R():
    from ..gd1 import GD1Koposov10
    from ..gd1 import R as gd1_R

    N = 128
    rnd = np.random.RandomState(42)

    gd1_gc_frame = GreatCircleICRSFrame.from_R(gd1_R)
    tmp_in = GD1Koposov10(
        phi1=rnd.uniform(0, 360, N) * u.deg, phi2=rnd.uniform(-90, 90, N) * u.deg
    )

    tmp_out = tmp_in.transform_to(gd1_gc_frame)

    assert u.allclose(tmp_in.phi1, tmp_out.phi1)
    assert u.allclose(tmp_in.phi2, tmp_out.phi2)
</file>
    <file path="gala/coordinates/tests/test_jhelum.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np

# This package
from ..jhelum import JhelumBonaca19


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    c = JhelumBonaca19(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(JhelumBonaca19())

    # with distance
    c = JhelumBonaca19(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)
</file>
    <file path="gala/coordinates/tests/test_orphan.py">
&quot;&quot;&quot;
Test the coordinates class that represents the plane of orbit of the Sgr dwarf galaxy.
&quot;&quot;&quot;

# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.io import ascii
from astropy.table import Table
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This project
from ..orphan import OrphanNewberg10, OrphanKoposov19


def test_table():
    &quot;&quot;&quot;Test the transformation code against table 2 values from
    Newberg et al. 2010 (below)
    &quot;&quot;&quot;

    names = [&quot;l&quot;, &quot;b&quot;, &quot;db&quot;, &quot;Lambda&quot;, &quot;Beta&quot;, &quot;g0&quot;, &quot;dg0&quot;]
    table = &quot;&quot;&quot;255 48.5 0.7 22.34 0.08 17.1 0.1
245 52.0 0.7 15.08 0.56 0. 0.
235 53.5 0.7 8.86 0.21 0. 0.
225 54.0 0.7 2.95 -0.23 17.6 0.2
215 54.0 0.7 -2.93 -0.33 17.9 0.1
205 53.5 0.7 -8.85 -0.09 18.0 0.1
195 52.0 0.7 -15.08 0.05 0. 0.
185 50.5 0.7 -21.42 1.12 18.6 0.1
175 47.5 0.7 -28.59 1.88 0. 0.
171 45.8 1.0 -31.81 2.10 0. 0.&quot;&quot;&quot;

    table = ascii.read(table, names=names)

    for line in table:
        galactic = coord.Galactic(l=line[&quot;l&quot;] * u.deg, b=line[&quot;b&quot;] * u.deg)

        orp = galactic.transform_to(OrphanNewberg10())
        true_orp = OrphanNewberg10(
            phi1=line[&quot;Lambda&quot;] * u.deg, phi2=line[&quot;Beta&quot;] * u.deg
        )

        # TODO: why does this suck so badly?
        assert true_orp.separation(orp) &lt; 20 * u.arcsec


def test_kopsov():
    tbl = Table.read(get_pkg_data_filename(&quot;sergey_orphan.txt&quot;), format=&quot;ascii&quot;)
    c = coord.SkyCoord(ra=tbl[&quot;ra&quot;] * u.deg, dec=tbl[&quot;dec&quot;] * u.deg)
    orp_gc = c.transform_to(OrphanKoposov19())
    assert np.percentile(orp_gc.phi2.degree, 95) &lt; 5
</file>
    <file path="gala/coordinates/tests/test_pal5.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np

# This package
from ..pal5 import Pal5PriceWhelan18


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    c = Pal5PriceWhelan18(217.2141 * u.degree, -11.4351 * u.degree)
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(Pal5PriceWhelan18())

    # with distance
    c = Pal5PriceWhelan18(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)
</file>
    <file path="gala/coordinates/tests/test_pm_cov_transform.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# This project
from ..orphan import OrphanKoposov19
from ..pm_cov_transform import transform_pm_cov

sky_offset_frame = coord.SkyOffsetFrame(
    origin=coord.ICRS(ra=&quot;20d&quot;, dec=&quot;30d&quot;), rotation=135.7 * u.deg
)


def setup_function(fn):
    ra, dec, pmra, pmdec = np.load(get_pkg_data_filename(&quot;c_pm.npy&quot;))
    c = coord.SkyCoord(
        ra=ra * u.deg,
        dec=dec * u.deg,
        pm_ra_cosdec=pmra * u.mas / u.yr,
        pm_dec=pmdec * u.mas / u.yr,
    )
    cov = np.load(get_pkg_data_filename(&quot;pm_cov.npy&quot;))

    fn.c = c
    fn.cov = cov


@pytest.mark.parametrize(
    &quot;to_frame&quot;,
    [
        coord.Galactic,
        coord.Galactic(),
        coord.Supergalactic,
        coord.Supergalactic(),
        OrphanKoposov19,
        OrphanKoposov19(),
        sky_offset_frame,
    ],
)
def test_transform(to_frame):
    c = test_transform.c
    cov = test_transform.cov

    # First, don't validate, just check input paths:
    transform_pm_cov(c[0], cov[0], to_frame)
    transform_pm_cov(c[:4], cov[:4], to_frame)

    with pytest.raises(ValueError):
        transform_pm_cov(c[:4], cov[:8], to_frame)

    with pytest.raises(ValueError):
        transform_pm_cov(c[0], cov[0, :1], to_frame)

    new_cov1 = transform_pm_cov(c[0], cov[0], to_frame)
    new_cov2 = np.squeeze(transform_pm_cov(c[0:1], cov[0:1], to_frame))
    assert np.allclose(new_cov1, new_cov2)


@pytest.mark.parametrize(
    &quot;to_frame&quot;,
    [
        coord.Galactic,
        coord.Galactic(),
        coord.Supergalactic,
        coord.Supergalactic(),
        OrphanKoposov19,
        OrphanKoposov19(),
        sky_offset_frame,
    ],
)
def test_transform_correctness(to_frame):
    c = test_transform_correctness.c[:4]
    cov = test_transform_correctness.cov[:4]

    # generate proper motion samples and transform the samples:
    pm = np.vstack((c.pm_ra_cosdec.value, c.pm_dec.value)).T
    rnd = np.random.RandomState(42)

    for i in range(len(c)):
        pm_samples = rnd.multivariate_normal(pm[i], cov[i], size=2**16)
        c1 = coord.SkyCoord(
            ra=[c[i].ra.value] * pm_samples.shape[0] * u.deg,
            dec=[c[i].dec.value] * pm_samples.shape[0] * u.deg,
            pm_ra_cosdec=pm_samples[:, 0] * u.mas / u.yr,
            pm_dec=pm_samples[:, 1] * u.mas / u.yr,
        )
        new_c1 = c1.transform_to(to_frame)

        dsph = new_c1.represent_as(
            coord.SphericalRepresentation, coord.SphericalCosLatDifferential
        ).differentials[&quot;s&quot;]
        new_pm_samples = np.vstack((dsph.d_lon_coslat.value, dsph.d_lat.value))
        cov_est = np.cov(new_pm_samples)
        cov_trans = transform_pm_cov(c[i], cov[i], to_frame)
        assert np.allclose(cov_est, cov_trans, atol=1e-2)
        assert np.allclose(
            np.sort(np.linalg.eigvals(cov[i])), np.sort(np.linalg.eigvals(cov_trans))
        )
</file>
    <file path="gala/coordinates/tests/test_reflex.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u

# This package
from ..reflex import reflex_correct


def test_reflex():
    c = coord.SkyCoord(
        ra=162 * u.deg,
        dec=-17 * u.deg,
        distance=172 * u.pc,
        pm_ra_cosdec=-11 * u.mas / u.yr,
        pm_dec=4 * u.mas / u.yr,
        radial_velocity=110 * u.km / u.s,
    )

    # First, test execution but don't validate
    reflex_correct(c)
    with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
        reflex_correct(c, coord.Galactocentric(z_sun=0 * u.pc))

    # Reflext correct the observed, Reid &amp; Brunthaler (2004) Sgr A* measurements
    # and make sure the corrected velocity is close to zero
    # https://ui.adsabs.harvard.edu/abs/2004ApJ...616..872R/abstract
    # also using
    # https://ui.adsabs.harvard.edu/abs/2018RNAAS...2d.210D/abstract
    # https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G/abstract
    vsun = coord.CartesianDifferential([12.9, 245.6, 7.78] * u.km / u.s)
    with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
        galcen_fr = coord.Galactocentric(
            galcen_distance=8.122 * u.kpc, galcen_v_sun=vsun, z_sun=20.8 * u.pc
        )

    sgr_Astar_obs = coord.SkyCoord(
        ra=galcen_fr.galcen_coord.ra,
        dec=galcen_fr.galcen_coord.dec,
        distance=galcen_fr.galcen_distance,
        pm_ra_cosdec=-3.151 * u.mas / u.yr,
        pm_dec=-5.547 * u.mas / u.yr,
        radial_velocity=-12.9 * u.km / u.s,
    )

    new_c = reflex_correct(sgr_Astar_obs, galcen_fr)
    assert u.allclose(new_c.pm_ra_cosdec, 0 * u.mas / u.yr, atol=1e-2 * u.mas / u.yr)
    assert u.allclose(new_c.pm_dec, 0 * u.mas / u.yr, atol=1e-2 * u.mas / u.yr)
    assert u.allclose(new_c.radial_velocity, 0 * u.km / u.s, atol=1e-1 * u.km / u.s)
</file>
    <file path="gala/coordinates/tests/test_sgr.py">
&quot;&quot;&quot;
Test the coordinates class that represents the plane of orbit of the Sgr dwarf galaxy.
&quot;&quot;&quot;

# Third-party
import astropy.coordinates as coord
import astropy.table as at
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..sgr import SagittariusLaw10, SagittariusVasiliev21


def test_simple():
    c = coord.ICRS(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    c = SagittariusLaw10(
        coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree)
    )
    c.transform_to(coord.ICRS())
    c.transform_to(coord.Galactic())

    c = coord.Galactic(coord.Angle(217.2141, u.degree), coord.Angle(-11.4351, u.degree))
    c.transform_to(SagittariusLaw10())

    # with distance
    c = SagittariusLaw10(
        coord.Angle(217.2141, u.degree),
        coord.Angle(-11.4351, u.degree),
        distance=15 * u.kpc,
    )
    c.transform_to(coord.ICRS())
    c2 = c.transform_to(coord.Galactic())
    assert np.allclose(c2.distance.value, c.distance.value)


def test_against_David_Law():
    &quot;&quot;&quot;Test my code against an output file from using David Law's cpp code. Do:

        g++ SgrCoord.cpp; ./a.out

    to generate the data file, SgrCoord_data.

    &quot;&quot;&quot;
    filename = get_pkg_data_filename(&quot;SgrCoord_data&quot;)
    law_data = np.genfromtxt(filename, names=True, delimiter=&quot;,&quot;)

    c = coord.Galactic(law_data[&quot;l&quot;] * u.deg, law_data[&quot;b&quot;] * u.deg)
    sgr_coords = c.transform_to(SagittariusLaw10())

    law_sgr_coords = SagittariusLaw10(
        Lambda=law_data[&quot;lambda&quot;] * u.deg, Beta=law_data[&quot;beta&quot;] * u.deg
    )

    sep = sgr_coords.separation(law_sgr_coords).arcsec * u.arcsec
    assert np.all(sep &lt; 1.0 * u.arcsec)


def test_v21():
    filename = get_pkg_data_filename(&quot;Vasiliev2020-Sagittarius-subset.csv&quot;)
    test_data = at.Table.read(filename, format=&quot;ascii.csv&quot;)

    c = coord.SkyCoord(test_data[&quot;ra&quot;] * u.deg, test_data[&quot;dec&quot;] * u.deg)
    sgr_c = c.transform_to(SagittariusVasiliev21())

    assert np.allclose(sgr_c.Lambda.degree, test_data[&quot;Lambda&quot;], atol=1e-3)
    assert np.allclose(sgr_c.Beta.degree, test_data[&quot;Beta&quot;], atol=1e-3)
</file>
    <file path="gala/coordinates/tests/test_velocity_frame_transforms.py">
&quot;&quot;&quot;
    Test conversions in core.py
&quot;&quot;&quot;

# Third-party
import astropy.coordinates as coord
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np

# This package
from ..velocity_frame_transforms import vgsr_to_vhel, vhel_to_vgsr


def test_vgsr_to_vhel():
    filename = get_pkg_data_filename(&quot;idl_vgsr_vhel.txt&quot;)
    data = np.genfromtxt(filename, names=True, skip_header=2)

    # one row
    row = data[0]
    l = coord.Angle(row[&quot;lon&quot;] * u.degree)
    b = coord.Angle(row[&quot;lat&quot;] * u.degree)
    c = coord.Galactic(l, b)
    vgsr = row[&quot;vgsr&quot;] * u.km / u.s
    vlsr = [row[&quot;vx&quot;], row[&quot;vy&quot;], row[&quot;vz&quot;]] * u.km / u.s  # this is right
    vcirc = row[&quot;vcirc&quot;] * u.km / u.s

    vsun = vlsr + [0, 1, 0] * vcirc
    vhel = vgsr_to_vhel(c, vgsr, vsun=vsun)
    assert np.allclose(vhel.value, row[&quot;vhelio&quot;], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vhel = vgsr_to_vhel(c.transform_to(coord.ICRS()), vgsr, vsun=vsun)
    assert np.allclose(vhel.value, row[&quot;vhelio&quot;], atol=1e-3)

    # all together now
    l = coord.Angle(data[&quot;lon&quot;] * u.degree)
    b = coord.Angle(data[&quot;lat&quot;] * u.degree)
    c = coord.Galactic(l, b)
    vgsr = data[&quot;vgsr&quot;] * u.km / u.s
    vhel = vgsr_to_vhel(c, vgsr, vsun=vsun)
    assert np.allclose(vhel.value, data[&quot;vhelio&quot;], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vhel = vgsr_to_vhel(c.transform_to(coord.ICRS()), vgsr, vsun=vsun)
    assert np.allclose(vhel.value, data[&quot;vhelio&quot;], atol=1e-3)


def test_vgsr_to_vhel_misc():
    # make sure it works with longitude in 0-360 or -180-180
    l1 = coord.Angle(190.0 * u.deg)
    l2 = coord.Angle(-170.0 * u.deg)
    b = coord.Angle(30.0 * u.deg)

    c1 = coord.Galactic(l1, b)
    c2 = coord.Galactic(l2, b)

    vgsr = -110.0 * u.km / u.s
    vhel1 = vgsr_to_vhel(c1, vgsr)
    vhel2 = vgsr_to_vhel(c2, vgsr)

    assert np.allclose(vhel1.value, vhel2.value)


def test_vhel_to_vgsr():
    filename = get_pkg_data_filename(&quot;idl_vgsr_vhel.txt&quot;)
    data = np.genfromtxt(filename, names=True, skip_header=2)

    # one row
    row = data[0]
    l = coord.Angle(row[&quot;lon&quot;] * u.degree)
    b = coord.Angle(row[&quot;lat&quot;] * u.degree)
    c = coord.Galactic(l, b)
    vhel = row[&quot;vhelio&quot;] * u.km / u.s
    vlsr = [row[&quot;vx&quot;], row[&quot;vy&quot;], row[&quot;vz&quot;]] * u.km / u.s  # this is right
    vcirc = row[&quot;vcirc&quot;] * u.km / u.s

    vsun = vlsr + [0, 1, 0] * vcirc
    vgsr = vhel_to_vgsr(c, vhel, vsun=vsun)
    assert np.allclose(vgsr.value, row[&quot;vgsr&quot;], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vgsr = vhel_to_vgsr(c.transform_to(coord.ICRS()), vhel, vsun=vsun)
    assert np.allclose(vgsr.value, row[&quot;vgsr&quot;], atol=1e-3)

    # all together now
    l = coord.Angle(data[&quot;lon&quot;] * u.degree)
    b = coord.Angle(data[&quot;lat&quot;] * u.degree)
    c = coord.Galactic(l, b)
    vhel = data[&quot;vhelio&quot;] * u.km / u.s
    vgsr = vhel_to_vgsr(c, vhel, vsun=vsun)
    assert np.allclose(vgsr.value, data[&quot;vgsr&quot;], atol=1e-3)

    # now check still get right answer passing in ICRS coordinates
    vgsr = vhel_to_vgsr(c.transform_to(coord.ICRS()), vhel, vsun=vsun)
    assert np.allclose(vgsr.value, data[&quot;vgsr&quot;], atol=1e-3)
</file>
    <file path="gala/dynamics/actionangle/_genfunc/test_potentials.py">
#################
#   Potentials  #
#################
import numpy as np
from scipy.integrate import quad, ode

Grav = 430091.7270069976

class LMPot(object):
    &quot;&quot;&quot; Potential used in Law-Majewski 2010 &quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot; Best-fit parameters - units = kpc, km/s and 10^11 M_sol &quot;&quot;&quot;
        self.M_disk = 1.
        self.a_disk = 6.5
        self.b_disk = 0.26
        self.M_bulge = 0.34
        self.c_bulge = 0.7
        self.vhalo2 = 121.7**2
        phi = 97./180.*np.pi
        q1 = 1.38
        q2 = 1.
        self.C_1 = (np.cos(phi)/q1)**2+(np.sin(phi)/q2)**2
        self.C_2 = (np.cos(phi)/q2)**2+(np.sin(phi)/q1)**2
        self.C_3 = 2.*np.sin(phi)*np.cos(phi)*(1./q1/q1-1./q2/q2)
        self.q_z = 1.36
        self.rhalo2 = 144.
        rot90 = np.array([[0., 1.],[-1., 0.]])
        self.rotmatrix =  np.dot(rot90, np.linalg.svd(np.array([[self.C_1, self.C_3/2.],[self.C_3/2., self.C_2]]))[0])
        self.invrotmatrix = np.linalg.inv(self.rotmatrix)

    def disk_pot(self, x, y, z):
        R = np.sqrt(x*x+y*y)
        return -Grav*self.M_disk/np.sqrt(R*R+(self.a_disk+np.sqrt(z*z+self.b_disk*self.b_disk))**2)

    def disk_force(self, x, y, z):
        R = np.sqrt(x*x+y*y)
        e = self.a_disk+np.sqrt(z*z+self.b_disk*self.b_disk)
        d = -Grav*self.M_disk/np.sqrt(R*R+e**2)**3
        return np.array([x*d, y*d, z*d*e/(e-self.a_disk)])

    def bulge_pot(self, x, y, z):
        r = np.sqrt(x*x+y*y+z*z)
        return -Grav*self.M_bulge/(r+self.c_bulge)

    def bulge_force(self, x, y, z):
        r = np.sqrt(x*x+y*y+z*z)
        if(r==0.):
            return -Grav*self.M_bulge/(r+self.c_bulge)**2
        else:
            return -Grav*self.M_bulge/(r+self.c_bulge)**2/r*np.array([x, y, z])

    def halo_pot(self, x, y, z):
        return self.vhalo2*np.log(self.C_1*x*x+self.C_2*y*y+self.C_3*x*y+(z/self.q_z)**2+self.rhalo2)

    def halo_force(self, x, y, z):
        p = -self.vhalo2/(self.C_1*x*x+self.C_2*y*y+self.C_3*x*y+(z/self.q_z)**2+self.rhalo2)
        return np.array([(2.*x*self.C_1+self.C_3*y)*p, (2.*y*self.C_2+self.C_3*x)*p, 2.*z*p/self.q_z**2])

    def tot_pot(self, x, y, z):
        return self.disk_pot(x, y, z)+self.bulge_pot(x, y, z)+self.halo_pot(x, y, z)

    def H(self, X):
        return 0.5*np.sum(X[3:]**2)+self.tot_pot(*X[:3])

    def tot_force(self, x, y, z):
        return self.disk_force(x, y, z)+self.bulge_force(x, y, z)+self.halo_force(x, y, z)

    def coordrot(self, x, y):
        return np.dot(self.rotmatrix, np.array([x, y]))

    def invcoordrot(self, x, y):
        return np.dot(self.invrotmatrix, np.array([x, y]))


class log_triax(object):
    &quot;&quot;&quot; test triaxial logarithmic potential
        Phi(x, y, z) = 0.5 v_c^2 log(Rc^2+x^2+(y/qy)^2+(z/qz)^2) &quot;&quot;&quot;
    def __init__(self, vc, Rc, qy, qz):
        self.vc2=vc*vc
        self.Rc2=Rc*Rc
        self.qy2=qy*qy
        self.qz2=qz*qz

    def pot(self, x, y, z):
        return self.vc2/2.*np.log(self.Rc2+x*x+y*y/self.qy2+z*z/self.qz2)

    def H(self, X):
        return 0.5*np.sum(X[3:]**2)+self.pot(*X[:3])

    def tot_force(self, x, y, z):
        p = self.Rc2+x*x+y*y/self.qy2+z*z/self.qz2
        return -self.vc2/p*np.array([x, y/self.qy2, z/self.qz2])


class quartic(object):
    &quot;&quot;&quot; Quartic potential
        Phi(x, y, z) = 0.25(lam[0] x^4+lam[1] y^4+lam[2] z^4.
    &quot;&quot;&quot;

    def __init__(self, lam = np.array([1., 0.8, 3.3])):
        self.lambd = lam

    def H(self, x):
        &quot;&quot;&quot; Quartic potential Hamiltonian &quot;&quot;&quot;
        return 0.5*np.sum(x[3:]**2+0.5*self.lambd*x[:3]**4)

    def tot_force(self, x, y, z):
        &quot;&quot;&quot; Derivatives of quartic potential for orbit integration &quot;&quot;&quot;
        return np.array([-self.lambd[0]*x**3,-self.lambd[1]*y**3,-self.lambd[2]*z**3])

    def action(self, x):
        &quot;&quot;&quot; Find true action for quartic potential \Phi = \sum_i 0.25*x_i**4 &quot;&quot;&quot;
        acts = np.ones(3)
        for i in range(3):
            En = 0.5*x[i+3]**2+0.25*self.lambd[i]*x[i]**4
            xlim=(4.*En/self.lambd[i])**0.25
            acts[i]=2.*quad(lambda y:np.sqrt(2.*En-0.5*self.lambd[i]*y**4), 0., xlim)[0]/np.pi
        return acts

    def freq(self, x):
        &quot;&quot;&quot; Find true freq. for quartic potential \Phi = 0.25*x**4 &quot;&quot;&quot;
        freq = np.ones(3)
        for i in range(3):
            En = 0.5*x[i+3]**2+0.25*self.lambd[i]*x[i]**4
            xlim=(4.*En/self.lambd[i])**0.25
            freq[i]=np.pi/quad(lambda y:2./np.sqrt(2.*En-0.5*self.lambd[i]*y**4), 0., xlim)[0]
        return freq

import sys
# sys.path.append(&quot;new_struct&quot;)
# import triax_py

class stackel_triax(object):
    &quot;&quot;&quot; For interface with C code to find actions in triaxial Stackel potential &quot;&quot;&quot;
    def __init__(self):
        pass

    def H(self, x):
        &quot;&quot;&quot; triaxial stackel potential Hamiltonian &quot;&quot;&quot;
        return triax_py.Stack_Triax_H(x)

    def tot_force(self, x, y, z):
        &quot;&quot;&quot; Derivatives of triaxial stackel potential for orbit integration &quot;&quot;&quot;
        X = np.array([x, y, z])
        return triax_py.Stack_Triax_Forces(X)

    def action(self, x):
        &quot;&quot;&quot; Find true action for triaxial stackel potential &quot;&quot;&quot;
        return triax_py.Stack_Triax_Actions(x)

    def freq(self, x):
        &quot;&quot;&quot; Find true action for triaxial stackel potential &quot;&quot;&quot;
        return triax_py.Stack_Triax_Freqs(x)


class harmonic_oscillator(object):
    &quot;&quot;&quot;
        Triaxial harmonic oscillator
        Phi(x, y, z) = 0.5*(omega[0]^2 x^2+omega[1]^2 y^2 + omega[2]^2 z^2
    &quot;&quot;&quot;
    def __init__(self, omega=np.array([1., 1., 1.])):
        self.omega = omega

    def H(self, x):
        &quot;&quot;&quot; Hamiltonian &quot;&quot;&quot;
        return 0.5*np.sum(x[3:]**2+(self.omega*x[:3])**2)

    def tot_force(self, x, y, z):
        &quot;&quot;&quot; Derivatives of ho potential for orbit integration &quot;&quot;&quot;
        return -np.array([self.omega[0]**2*x, self.omega[1]**2*y, self.omega[2]**2*z])


class isochrone(object):
    &quot;&quot;&quot;
        Isochrone potential
        Phi(r) = -GM/(b+sqrt(b^2+r^2))
    &quot;&quot;&quot;
    def __init__(self, par = np.array([1./Grav, 4.2, 0.])):
        &quot;&quot;&quot; params = {M, b, r0} &quot;&quot;&quot;
        self.params = par

    def H(self, x):
        &quot;&quot;&quot; Hamiltonian &quot;&quot;&quot;
        r = (np.sqrt(np.sum(x[:3]**2))-self.params[2])**2
        return 0.5*np.sum(x[3:]**2)-Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))

    def pot(self, x):
        r = (np.sqrt(np.sum(x[:3]**2))-self.params[2])**2
        return -Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))

    def tot_force(self, x, y, z):
        &quot;&quot;&quot; Derivatives of isochrone potential for orbit integration &quot;&quot;&quot;
        r = (np.sqrt(x*x+y*y+z*z)-self.params[2])**2
        fac = np.sqrt(r)/(np.sqrt(r)+self.params[2])
        return np.array([x, y, z])*fac*-Grav*self.params[0]/(self.params[1]+np.sqrt(self.params[1]**2+r))**2/np.sqrt(self.params[1]**2+r)


def orbit_derivs(t, x, Pot):
    &quot;&quot;&quot; Simple interface for derivatives for orbit integration
        t = time
        x = Cartesian coordinates
        Pot is an object which has a function tot_force(x, y, z) which
        calculates the total force at Cartesian x, y, z &quot;&quot;&quot;
    X=x[0]
    Y=x[1]
    Z=x[2]
    return np.concatenate((x[3:],Pot.tot_force(X, Y, Z)))

def orbit_derivs2(x, t, Pot):
    return orbit_derivs(t, x, Pot)

import warnings

def orbit_integrate(x, tmax, Pot):
    &quot;&quot;&quot; Integrates an orbit with initial coordinates x for time tmax in
    potential Pot using Dormund Prince 8 adaptive step size &quot;&quot;&quot;
    solver = ode(orbit_derivs).set_integrator('dopri5', n_steps=1, rtol=1e-10, atol=1e-10)
    solver.set_initial_value(x, 0.).set_f_params(Pot)
    solver._integrator.iwork[2] = -1
    warnings.filterwarnings(&quot;ignore&quot;, category=UserWarning)
    t = np.array([0.])
    while solver.t &lt; tmax:
        solver.integrate(tmax)
        x=np.vstack((x, solver.y))
        t=np.append(t, solver.t)
    warnings.resetwarnings()
    return x, t

def leapfrog_integrator(x, tmax, NT, Pot):
    deltat = tmax/NT
    h = deltat/100.
    t = 0.
    counter = 0
    X = np.copy(x)
    results = np.array([x])
    while(t&lt;tmax):
        X[3:] += 0.5*h*Pot.tot_force(X[0],X[1],X[2])
        X[:3] += h*X[3:]
        X[3:] += 0.5*h*Pot.tot_force(X[0],X[1],X[2])
        # if(t==0.1):
        if(counter % 100 == 0):
            results=np.vstack((results, X))
        t+=h
        counter+=1
    return results
</file>
    <file path="gala/dynamics/actionangle/tests/helpers.py">
&quot;&quot;&quot; Test helpers &quot;&quot;&quot;

# Third-party
import astropy.coordinates as coord
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np

# Project
# from ..actionangle import classify_orbit
from gala.units import galactic
from gala.potential import HarmonicOscillatorPotential, IsochronePotential
from .._genfunc import genfunc_3d


def sanders_nvecs(N_max, dx, dy, dz):
    from itertools import product
    NNx = range(-N_max, N_max+1, dx)
    NNy = range(-N_max, N_max+1, dy)
    NNz = range(-N_max, N_max+1, dz)
    n_vectors = np.array([[i, j, k] for (i, j, k) in product(NNx, NNy, NNz)
                          if (not (i == 0 and j == 0 and k == 0)        # exclude zero vector
                              and (k &gt; 0                                # northern hemisphere
                                   or (k == 0 and j &gt; 0)                # half of x-y plane
                                   or (k == 0 and j == 0 and i &gt; 0))    # half of x axis
                              and np.sqrt(i*i + j*j + k*k) &lt;= N_max)])  # inside sphere
    return n_vectors


def sanders_act_ang_freq(t, w, circ, N_max=6):
    w2 = w.copy()

    if np.any(circ):
        w2[3:] = (w2[3:]*u.kpc/u.Myr).to(u.km/u.s).value
        (act, ang, n_vec, toy_aa, pars), loop2 = genfunc_3d.find_actions(
            w2.T, t/1000., N_matrix=N_max, ifloop=True)
    else:
        (act, ang, n_vec, toy_aa, pars), loop2 = genfunc_3d.find_actions(
            w2.T, t, N_matrix=N_max, ifloop=True)

    actions = act[:3]
    angles = ang[:3]
    freqs = ang[3:6]

    if np.any(circ):
        toy_potential = IsochronePotential(m=pars[0]*1E11, b=pars[1], units=galactic)
        actions = (actions*u.kpc*u.km/u.s).to(u.kpc**2/u.Myr).value
        freqs = (freqs/u.Gyr).to(1/u.Myr).value
    else:
        toy_potential = HarmonicOscillatorPotential(omega=np.array(pars), units=galactic)

    return actions, angles, freqs, toy_potential


def _crazy_angle_loop(theta1, theta2, ax):
    cnt = 0
    ix1 = 0
    while True:
        cnt += 1

        for ix2 in range(ix1, ix1+1000):
            if ix2 &gt; len(theta1)-1:
                ix2 = len(theta1)-1
                break

            if theta1[ix2] &lt; theta1[ix1] or theta2[ix2] &lt; theta2[ix1]:
                ix2 -= 1
                break

        if theta1[ix2] != theta1[ix1:ix2+1].max() or theta2[ix2] != theta2[ix1:ix2+1].max():
            ix1 = ix2+1
            continue

        if cnt &gt; 100 or ix2 == len(theta1)-1:
            break

        if ix1 == ix2:
            ix1 = ix2+1
            continue

        ax.plot(theta1[ix1:ix2+1], theta2[ix1:ix2+1], alpha=0.5, marker='o', c='k')

        ix1 = ix2+1


def plot_angles(t, angles, freqs, subsample_factor=1000):
    theta = (angles[:, None] + freqs[:, None]*t[np.newaxis])
    subsample = theta.shape[1]//subsample_factor
#    subsample = 1
    theta = (theta[:, ::subsample] / np.pi) % 2.
    print(theta.shape)
    fig, axes = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(10, 5))
    # _crazy_angle_loop(theta[0], theta[1], axes[0])
    # _crazy_angle_loop(theta[0], theta[2], axes[1])
    axes[0].plot(theta[0], theta[1], ls='none')
    axes[0].plot(theta[0], theta[2], ls='none')

    axes[0].set_xlim(0, 2)
    axes[0].set_ylim(0, 2)
    return fig
    # axes[1].scatter(theta[0, ix], theta[2], alpha=0.5, marker='o', c=t)


def isotropic_w0(N=100):
    # positions
    d = np.random.lognormal(mean=np.log(25), sigma=0.5, size=N)
    phi = np.random.uniform(0, 2*np.pi, size=N)
    theta = np.arccos(np.random.uniform(size=N) - 0.5)

    vr = np.random.normal(150., 40., size=N)*u.km/u.s
    vt = np.random.normal(100., 40., size=N)
    vt = np.vstack((vt, np.zeros_like(vt))).T

    # rotate to be random position angle
    pa = np.random.uniform(0, 2*np.pi, size=N)
    M = np.array([[np.cos(pa), -np.sin(pa)], [np.sin(pa), np.cos(pa)]]).T
    vt = np.array([vv.dot(MM) for (vv, MM) in zip(vt, M)])*u.km/u.s
    vphi, vtheta = vt.T

    rep = coord.PhysicsSphericalRepresentation(r=d*u.dimensionless_unscaled,
                                               phi=phi*u.radian,
                                               theta=theta*u.radian)
    x = rep.represent_as(coord.CartesianRepresentation).xyz.T.value

    vr = vr.decompose(galactic).value * u.one
    vphi = vphi.decompose(galactic).value * u.one
    vtheta = vtheta.decompose(galactic).value * u.one

    vsph = coord.PhysicsSphericalDifferential(d_phi=vphi/(d*np.sin(theta)),
                                              d_theta=vtheta/d,
                                              d_r=vr)

    with u.set_enabled_equivalencies(u.dimensionless_angles()):
        v = vsph.represent_as(coord.CartesianDifferential,
                              base=rep).d_xyz.value.T

    return np.hstack((x, v)).T
</file>
    <file path="gala/dynamics/actionangle/tests/staeckel_helpers.py">
from collections.abc import Iterable

import astropy.coordinates as coord
import astropy.table as at
import astropy.units as u
import numpy as np

from gala.dynamics import Orbit

from ..actionangle_staeckel import get_staeckel_fudge_delta


__all__ = [&quot;galpy_find_actions_staeckel&quot;]


def galpy_find_actions_staeckel(
    potential, w, mean=True, delta=None, ro=None, vo=None
):
    &quot;&quot;&quot;
    Compute approximate actions, angles, and frequencies using the Staeckel
    Fudge as implemented in Galpy. If you use this function, please also cite
    Galpy in your work (Bovy 2015).

    Parameters
    ----------
    potential : potential-like
        A Gala potential instances.
    w : `~gala.dynamics.PhaseSpacePosition` or `~gala.dynamics.Orbit`
        Either a set of initial conditions / phase-space positions, or a set of
        orbits computed in the input potential.
    mean : bool (optional)
        If an `~gala.dynamics.Orbit` is passed in, take the mean over actions
        and frequencies.
    delta : numeric, array-like (optional)
        The focal length parameter, , used by the Staeckel fudge. This is
        computed if not provided.
    ro : quantity-like (optional)
    vo : quantity-like (optional)

    Returns
    -------
    aaf : `astropy.table.QTable`
        An Astropy table containing the actions, angles, and frequencies for
        each input phase-space position or orbit.

    &quot;&quot;&quot;
    from galpy.actionAngle import actionAngleStaeckel

    if delta is None:
        delta = get_staeckel_fudge_delta(potential, w)

    galpy_potential = potential.to_galpy_potential(ro, vo)
    if isinstance(galpy_potential, list):
        ro = galpy_potential[0]._ro * u.kpc
        vo = galpy_potential[0]._vo * u.km / u.s
    else:
        ro = galpy_potential._ro * u.kpc
        vo = galpy_potential._vo * u.km / u.s

    if not isinstance(w, Orbit):
        w = Orbit(w.pos[None], w.vel[None], t=[0.0] * potential.units[&quot;time&quot;])

    if w.norbits == 1:
        iter_ = [w]
    else:
        iter_ = w.orbit_gen()

    if isinstance(delta, u.Quantity):
        delta = np.atleast_1d(delta)

    if not isinstance(delta, Iterable):
        delta = [delta] * w.norbits

    if len(delta) != w.norbits:
        raise ValueError(
            &quot;Input delta must have same shape as the inputted number of orbits&quot;
        )

    rows = []
    for w_, delta_ in zip(iter_, delta):
        o = w_.to_galpy_orbit(ro, vo)
        aAS = actionAngleStaeckel(pot=galpy_potential, delta=delta_)

        aaf = aAS.actionsFreqsAngles(o)
        aaf = {
            &quot;actions&quot;: np.array(aaf[:3]).T * ro * vo,
            &quot;freqs&quot;: np.array(aaf[3:6]).T * vo / ro,
            &quot;angles&quot;: coord.Angle(np.array(aaf[6:]).T * u.rad),
        }
        if mean:
            aaf[&quot;actions&quot;] = np.nanmean(aaf[&quot;actions&quot;], axis=0)
            aaf[&quot;freqs&quot;] = np.nanmean(aaf[&quot;freqs&quot;], axis=0)
            aaf[&quot;angles&quot;] = aaf[&quot;angles&quot;][0]
        rows.append(aaf)
    return at.QTable(rows=rows)
</file>
    <file path="gala/dynamics/actionangle/tests/test_actionangle_o2gf.py">
&quot;&quot;&quot; Test action-angle stuff &quot;&quot;&quot;

# Standard library
import logging
import warnings

# Third-party
import astropy.units as u
import numpy as np
from gala.logging import logger
from scipy.linalg import solve
import pytest

# Project
from gala.integrate import DOPRI853Integrator
from gala.potential import (
    IsochronePotential,
    HarmonicOscillatorPotential,
    LeeSutoTriaxialNFWPotential,
    Hamiltonian,
)
from gala.units import galactic
from gala.dynamics.actionangle import (
    fit_isochrone,
    fit_harmonic_oscillator,
    fit_toy_potential,
    check_angle_sampling,
    find_actions_o2gf,
    generate_n_vectors,
)
from gala.dynamics.actionangle._genfunc import genfunc_3d, solver
from .helpers import sanders_nvecs, sanders_act_ang_freq, isotropic_w0

logger.setLevel(logging.DEBUG)


def test_generate_n_vectors():
    # test against Sanders' method
    nvecs = generate_n_vectors(N_max=6, dx=2, dy=2, dz=2)
    nvecs_sanders = sanders_nvecs(N_max=6, dx=2, dy=2, dz=2)
    assert np.all(nvecs == nvecs_sanders)

    nvecs = generate_n_vectors(N_max=6, dx=1, dy=1, dz=1)
    nvecs_sanders = sanders_nvecs(N_max=6, dx=1, dy=1, dz=1)
    assert np.all(nvecs == nvecs_sanders)


def test_fit_isochrone():
    # integrate orbit in Isochrone potential, then try to recover it
    true_m = 2.81e11
    true_b = 11.0
    potential = IsochronePotential(m=true_m, b=true_b, units=galactic)
    H = Hamiltonian(potential)
    orbit = H.integrate_orbit([15.0, 0, 0, 0, 0.2, 0], dt=2.0, n_steps=10000)

    fit_potential = fit_isochrone(orbit)
    m, b = (
        fit_potential.parameters[&quot;m&quot;].value,
        fit_potential.parameters[&quot;b&quot;].value,
    )
    assert np.allclose(m, true_m, rtol=1e-2)
    assert np.allclose(b, true_b, rtol=1e-2)


def test_fit_harmonic_oscillator():
    # integrate orbit in harmonic oscillator potential, then try to recover it
    true_omegas = np.array([0.011, 0.032, 0.045])
    potential = HarmonicOscillatorPotential(omega=true_omegas, units=galactic)
    H = Hamiltonian(potential)
    orbit = H.integrate_orbit([15.0, 1, 2, 0, 0, 0], dt=2.0, n_steps=10000)

    fit_potential = fit_harmonic_oscillator(orbit)
    omegas = fit_potential.parameters[&quot;omega&quot;].value
    assert np.allclose(omegas, true_omegas, rtol=1e-2)


def test_fit_toy_potential():
    # integrate orbit in both toy potentials, make sure correct one is chosen
    true_m = 2.81e11
    true_b = 11.0
    true_potential = IsochronePotential(m=true_m, b=true_b, units=galactic)
    H = Hamiltonian(true_potential)
    orbit = H.integrate_orbit([15.0, 0, 0, 0, 0.2, 0], dt=2.0, n_steps=10000)

    potential = fit_toy_potential(orbit)
    for k, v in true_potential.parameters.items():
        assert u.allclose(v, potential.parameters[k], rtol=1e-2)

    # -----------------------------------------------------------------
    true_omegas = np.array([0.011, 0.032, 0.045])
    true_potential = HarmonicOscillatorPotential(
        omega=true_omegas, units=galactic
    )
    H = Hamiltonian(true_potential)
    orbit = H.integrate_orbit([15.0, 1, 2, 0, 0, 0], dt=2.0, n_steps=10000)

    potential = fit_toy_potential(orbit)

    assert u.allclose(
        potential.parameters[&quot;omega&quot;],
        true_potential.parameters[&quot;omega&quot;],
        rtol=1e-2,
    )


def test_check_angle_sampling():

    # frequencies
    omegas = np.array([0.21, 0.3421, 0.4968])

    # integer vectors
    nvecs = generate_n_vectors(N_max=6)

    # loop over times with known failures:
    #   - first one fails needing longer integration time
    #   - second one fails needing finer sampling
    for i, t in enumerate(
        [np.linspace(0, 50, 500), np.linspace(0, 8000, 8000)]
    ):
        # periods = 2*np.pi/omegas
        # print(&quot;Periods:&quot;, periods)
        # print(&quot;N periods:&quot;, t.max() / periods)

        angles = t[np.newaxis] * omegas[:, np.newaxis]
        with warnings.catch_warnings():
            warnings.simplefilter(&quot;ignore&quot;, UserWarning)
            checks, failures = check_angle_sampling(nvecs, angles)

        assert np.all(failures == i)


class ActionsBase:

    def test_classify(self):
        # my classify
        orb_type = self.orbit.circulation()

        # compare to Sanders'
        for j in range(self.N):
            sdrs = genfunc_3d.assess_angmom(self.w[..., j].T)
            logger.debug(&quot;APW: {}, Sanders: {}&quot;.format(orb_type[:, j], sdrs))
            assert np.all(orb_type[:, j] == sdrs)

    def test_actions(self):
        # t = self.t[::10]
        t = self.t

        N_max = 6
        for n in range(self.N):
            print(&quot;\n\n&quot;)
            print(
                &quot;======================= Orbit {} =======================&quot;.format(
                    n
                )
            )
            # w = self.w[:, ::10, n]
            w = self.w[..., n]
            orb = self.orbit[:, n]
            circ = orb.circulation()

            # get values from Sanders' code
            print(&quot;Computing actions from genfunc...&quot;)
            s_actions, s_angles, s_freqs, toy_potential = sanders_act_ang_freq(
                t, w, circ, N_max=N_max
            )

            print(&quot;Computing actions with gala...&quot;)
            with warnings.catch_warnings():
                warnings.simplefilter(&quot;ignore&quot;, UserWarning)
                ret = find_actions_o2gf(
                    orb, N_max=N_max, toy_potential=toy_potential
                )
            actions = ret[&quot;actions&quot;]
            angles = ret[&quot;angles&quot;]
            freqs = ret[&quot;freqs&quot;]

            print(&quot;Action ratio: {}&quot;.format(actions / s_actions))
            print(&quot;Angle ratio: {}&quot;.format(angles / s_angles))
            print(&quot;Freq ratio: {}&quot;.format(freqs / s_freqs))

            assert np.allclose(actions.value, s_actions, rtol=1e-5)
            assert np.allclose(angles.value, s_angles, rtol=1e-5)
            assert np.allclose(freqs.value, s_freqs, rtol=1e-5)

            # logger.debug(&quot;Plotting orbit...&quot;)
            # fig = plot_orbits(w, marker='.', alpha=0.2, linestyle='none')
            # fig.savefig(str(self.plot_path.join(&quot;orbit_{}.png&quot;.format(n))))

            # fig = plot_angles(t, angles, freqs)
            # fig.savefig(str(self.plot_path.join(&quot;angles_{}.png&quot;.format(n))))

            # fig = plot_angles(t, s_angles, s_freqs)
            # fig.savefig(str(self.plot_path.join(&quot;angles_sanders_{}.png&quot;.format(n))))

            # plt.close('all')

            # print(&quot;Plots saved at:&quot;, self.plot_path)


class TestActions(ActionsBase):

    @pytest.fixture(autouse=True)
    def setup_method(self, tmpdir):
        self.plot_path = tmpdir.mkdir(&quot;normal&quot;)

        self.units = galactic
        self.potential = LeeSutoTriaxialNFWPotential(
            v_c=0.2, r_s=20.0, a=1.0, b=0.77, c=0.55, units=galactic
        )
        self.N = 8
        np.random.seed(42)
        w0 = isotropic_w0(N=self.N)
        n_steps = 20000

        # integrate orbits
        H = Hamiltonian(self.potential)
        orbit = H.integrate_orbit(
            w0, dt=2.0, n_steps=n_steps, Integrator=DOPRI853Integrator
        )
        self.orbit = orbit
        self.t = orbit.t.value
        self.w = orbit.w()


def test_compare_action_prepare():

    from gala.dynamics.actionangle.actionangle_o2gf import (
        _action_prepare, _angle_prepare)

    logger.setLevel(logging.ERROR)
    AA = np.random.uniform(0.0, 100.0, size=(1000, 6))
    t = np.linspace(0.0, 100.0, 1000)

    act_san, n_vectors = solver.solver(AA, N_max=6, symNx=2)
    A2, b2, n = _action_prepare(AA.T, N_max=6, dx=2, dy=2, dz=2)
    act_apw = np.array(solve(A2, b2))

    ang_san = solver.angle_solver(AA, t, N_max=6, symNx=2, sign=1)
    A2, b2, n = _angle_prepare(AA.T, t, N_max=6, dx=2, dy=2, dz=2)
    ang_apw = np.array(solve(A2, b2))

    assert np.allclose(act_apw, act_san)
    # assert np.allclose(ang_apw, ang_san)

    # TODO: this could be critical -- why don't our angles agree?


def test_regression_113():
    &quot;&quot;&quot;Test that fit_isochrone succeeds for a variety of orbits. See issue:
    https://github.com/adrn/gala/issues/113
    &quot;&quot;&quot;
    from gala.potential import MilkyWayPotential, Hamiltonian
    from gala.dynamics import PhaseSpacePosition

    pot = MilkyWayPotential()

    dt = 0.01
    n_steps = 50000

    rvec = [0.3, 0, 0] * u.kpc
    vinit = pot.circular_velocity(rvec)[0].to(u.km / u.s).value
    vvec = [0, vinit * np.cos(0.01), vinit * np.sin(0.01)] * u.km / u.s
    vvec = 0.999 * vvec

    ics = PhaseSpacePosition(pos=rvec, vel=vvec)
    H = Hamiltonian(pot)
    orbit = H.integrate_orbit(ics, dt=dt, n_steps=n_steps)
    toy_potential = fit_isochrone(orbit)

    assert u.allclose(toy_potential.energy(rvec), pot.energy(rvec), rtol=1e-2)
</file>
    <file path="gala/dynamics/actionangle/tests/test_actionangle_staeckel.py">
# Third-party
from astropy.constants import G
import astropy.units as u
import numpy as np
import pytest

# gala
from gala.dynamics import PhaseSpacePosition
from gala.dynamics.actionangle import (
    get_staeckel_fudge_delta,
    find_actions_o2gf
)
from gala.dynamics.actionangle.tests.staeckel_helpers import galpy_find_actions_staeckel
import gala.potential as gp
from gala.units import galactic
from gala.tests.optional_deps import HAS_GALPY


@pytest.mark.skipif(not HAS_GALPY,
                    reason=&quot;requires galpy to run this test&quot;)
def test_staeckel_fudge_delta():
    import galpy.potential as galpy_pot
    from galpy.actionAngle import estimateDeltaStaeckel

    ro = 8.1 * u.kpc
    vo = 229 * u.km/u.s

    paired_potentials = []

    # Miyamoto-Nagai
    potential = gp.MiyamotoNagaiPotential(
        m=6e10*u.Msun, a=3*u.kpc, b=0.3*u.kpc, units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['a'].to_value(ro)
    b = potential.parameters['b'].to_value(ro)
    galpy_potential = galpy_pot.MiyamotoNagaiPotential(amp=amp, a=a, b=b,
                                                       ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # Hernquist
    potential = gp.HernquistPotential(m=6e10*u.Msun, c=0.3*u.kpc,
                                      units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['c'].to_value(ro)
    galpy_potential = galpy_pot.HernquistPotential(amp=amp, a=a,
                                                   ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # NFW
    potential = gp.NFWPotential(m=6e11*u.Msun, r_s=15.6*u.kpc,
                                units=galactic)
    amp = (G * potential.parameters['m']).to_value(vo**2 * ro)
    a = potential.parameters['r_s'].to_value(ro)
    galpy_potential = galpy_pot.NFWPotential(amp=amp, a=a, ro=ro, vo=vo)
    paired_potentials.append((potential, galpy_potential))

    # TEST:
    # TODO: remove the randomness here
    N = 1024
    rnd = np.random.default_rng(42)
    w = PhaseSpacePosition(
        pos=rnd.uniform(-10, 10, size=(3, N)) * u.kpc,
        vel=rnd.uniform(-100, 100, size=(3, N)) * u.km/u.s
    )

    R = w.cylindrical.rho.to_value(ro)
    z = w.z.to_value(ro)

    for p, galpy_p in paired_potentials:
        galpy_deltas = estimateDeltaStaeckel(galpy_p, R, z,
                                             no_median=True)
        gala_deltas = get_staeckel_fudge_delta(p, w).value
        assert np.allclose(gala_deltas, galpy_deltas, atol=1e-5, rtol=1e-3)


@pytest.mark.skipif(not HAS_GALPY,
                    reason=&quot;requires galpy to run this test&quot;)
def test_find_actions_staeckel():
    &quot;&quot;&quot;
    This test function performs some unit test checks of the API
    &quot;&quot;&quot;
    disk = gp.MiyamotoNagaiPotential(5e10, 3.5, 0.3, units=galactic)
    halo = gp.NFWPotential.from_M200_c(1e12*u.Msun, 15, units=galactic)
    pot = disk + halo

    xyz = (np.zeros((3, 16)) + 1e-5) * u.kpc
    xyz[0] = np.linspace(4, 20, xyz.shape[1]) * u.kpc

    vxyz = np.zeros((3, 16)) * u.km/u.s
    vxyz[0] = 15 * u.km/u.s
    vxyz[1] = pot.circular_velocity(xyz)
    vxyz[2] = 15 * u.km/u.s

    w0_one = PhaseSpacePosition(xyz[:, 0], vxyz[:, 0])
    w0_many = PhaseSpacePosition(xyz, vxyz)
    orbit_one = pot.integrate_orbit(w0_one, dt=1., n_steps=1000)
    orbit_many = pot.integrate_orbit(w0_many, dt=1., n_steps=1000)

    inputs = [
        w0_one,
        w0_many,
        orbit_one,
        orbit_many
    ]
    shapes = [
        (1, 3),
        (xyz.shape[1], 3),
        (1, 3),
        (xyz.shape[1], 3)
    ]
    for w, colshape in zip(inputs, shapes):
        aaf = galpy_find_actions_staeckel(pot, w)

        for colname in ['actions', 'freqs']:
            assert aaf[colname].shape == colshape

    # Check that mean=False returns the right shape
    aaf = galpy_find_actions_staeckel(pot, orbit_one, mean=False)
    for colname in ['actions', 'freqs', 'angles']:
        assert aaf[colname].shape == (1, orbit_one.ntimes, 3)

    aaf = galpy_find_actions_staeckel(pot, orbit_many, mean=False)
    for colname in ['actions', 'freqs', 'angles']:
        assert aaf[colname].shape == (xyz.shape[1], orbit_one.ntimes, 3)


@pytest.mark.skipif(not HAS_GALPY,
                    reason=&quot;requires galpy to run this test&quot;)
def test_compare_staeckel_o2gf():
    &quot;&quot;&quot;
    This test function performs some comparisons between actions, angles,
    and frequencies solved from the staeckel fudge and O2GF.
    &quot;&quot;&quot;
    disk = gp.MiyamotoNagaiPotential(5e10, 3.5, 0.3, units=galactic)
    halo = gp.NFWPotential.from_M200_c(1e12*u.Msun, 15, units=galactic)
    pot = disk + halo

    xyz = (np.zeros((3, 16)) + 1e-5) * u.kpc
    xyz[0] = np.linspace(4, 20, xyz.shape[1]) * u.kpc

    vxyz = np.zeros((3, 16)) * u.km/u.s
    vxyz[0] = 15 * u.km/u.s
    vxyz[1] = pot.circular_velocity(xyz)
    vxyz[2] = 15 * u.km/u.s

    orbits = pot.integrate_orbit(
        PhaseSpacePosition(xyz, vxyz),
        dt=1., n_steps=20_000
    )

    aaf_staeckel = galpy_find_actions_staeckel(pot, orbits)
    aaf_o2gf = find_actions_o2gf(orbits, N_max=10)

    assert u.allclose(aaf_staeckel['actions'], aaf_o2gf['actions'], rtol=1e-3)
    with u.set_enabled_equivalencies(u.dimensionless_angles()):
        assert u.allclose(aaf_staeckel['freqs'], aaf_o2gf['freqs'], rtol=1e-3)
    assert u.allclose(aaf_staeckel['angles'], aaf_o2gf['angles'], rtol=1.5e-2)
</file>
    <file path="gala/dynamics/actionangle/tests/test_analyticactionangle.py">
# Third-party
import numpy as np
import astropy.units as u

# Project
from gala.dynamics.actionangle import (
    isochrone_xv_to_aa,
    isochrone_aa_to_xv,
    harmonic_oscillator_xv_to_aa,
)
from gala.logging import logger
from gala.potential import (
    IsochronePotential,
    HarmonicOscillatorPotential,
    Hamiltonian,
)
from gala.units import galactic
from gala.util import assert_angles_allclose
from gala.dynamics.actionangle._genfunc import toy_potentials
from gala.tests.optional_deps import HAS_TWOBODY


class TestIsochrone(object):
    def setup_method(self):
        logger.info(&quot;======== Isochrone ========&quot;)
        N = 100
        rng = np.random.default_rng(42)
        x = rng.uniform(-10.0, 10.0, size=(3, N))
        v = rng.uniform(-1.0, 1.0, size=(3, N)) / 33.0
        w0 = np.vstack((x, v))

        self.potential = IsochronePotential(units=galactic, m=1.0e11, b=5.0)
        H = Hamiltonian(self.potential)
        self.w = H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        self.w = self.w[::10]

    def test_single(self):
        n = 13  # MAGIC NUMBER to pick one orbit

        # First, check that value of the actions are stable
        actions, angles, freqs = isochrone_xv_to_aa(
            self.w[:, n], self.potential
        )
        for i in range(3):
            assert u.allclose(actions[i, 1:], actions[i, 0], rtol=1e-5)

        for slice_ in [slice(None), 0]:
            actions, angles, freqs = isochrone_xv_to_aa(
                self.w[slice_, n], self.potential
            )

            # Compare to genfunc
            x = self.w.xyz[:, slice_, n]
            v = self.w.v_xyz[:, slice_, n]
            m = self.potential.parameters[&quot;m&quot;].value / 1e11
            b = self.potential.parameters[&quot;b&quot;].value

            if x.ndim &gt; 1:
                s_w = np.vstack((
                    x.to_value(u.kpc),
                    v.to_value(u.km / u.s)
                ))

                aa = np.array(
                    [
                        toy_potentials.angact_iso(s_w[:, i].T, params=(m, b))
                        for i in range(s_w.shape[1])
                    ]
                )
                s_actions = aa[:, :3] * u.km / u.s * u.kpc
                s_angles = aa[:, 3:] * u.rad

            else:
                s_w = np.concatenate((
                    x.to_value(u.kpc),
                    v.to_value(u.km / u.s)
                ))

                aa = toy_potentials.angact_iso(s_w.T, params=(m, b))
                s_actions = aa[:3] * u.km / u.s * u.kpc
                s_angles = aa[3:] * u.rad

            assert u.allclose(actions, s_actions.T, rtol=1e-8)
            assert_angles_allclose(angles, s_angles.T, rtol=1e-8)

            # Test round-tripping
            if HAS_TWOBODY:
                w_rt = isochrone_aa_to_xv(actions, angles, self.potential)

                assert u.allclose(x, w_rt.xyz, atol=1E-10 * u.kpc)
                assert u.allclose(v, w_rt.v_xyz, atol=1E-10 * u.km/u.s)

    def test_many(self):
        actions, angles, freqs = isochrone_xv_to_aa(
            self.w, self.potential
        )

        # Compare first element of orbit to genfunc, for speed
        x = self.w.xyz
        v = self.w.v_xyz
        m = self.potential.parameters[&quot;m&quot;].value / 1e11
        b = self.potential.parameters[&quot;b&quot;].value

        s_w = np.vstack((
            x[:, 0].to_value(u.kpc),
            v[:, 0].to_value(u.km / u.s)
        ))

        aa = np.array(
            [
                toy_potentials.angact_iso(s_w[:, i].T, params=(m, b))
                for i in range(s_w.shape[1])
            ]
        )
        s_actions = aa[:, :3] * u.km / u.s * u.kpc
        s_angles = aa[:, 3:] * u.rad

        assert u.allclose(actions[:, 0], s_actions.T, rtol=1e-8)
        assert_angles_allclose(angles[:, 0], s_angles.T, rtol=1e-8)

        # Test round-tripping
        if HAS_TWOBODY:
            # Check round-tripping for full orbits:
            w_rt = isochrone_aa_to_xv(actions, angles, self.potential)

            assert u.allclose(x, w_rt.xyz, atol=1E-10 * u.kpc)
            assert u.allclose(v, w_rt.v_xyz, atol=1E-10 * u.km/u.s)


class TestHarmonicOscillator(object):
    def setup_method(self):
        logger.info(&quot;======== Harmonic Oscillator ========&quot;)
        self.N = 100
        np.random.seed(42)
        x = np.random.uniform(-10.0, 10.0, size=(3, self.N))
        v = np.random.uniform(-1.0, 1.0, size=(3, self.N)) / 33.0
        w0 = np.vstack((x, v))

        self.potential = HarmonicOscillatorPotential(
            omega=np.array([0.013, 0.02, 0.005]), units=galactic
        )
        H = Hamiltonian(self.potential)
        self.w = H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        self.w = self.w[::10]

    def test(self):
        &quot;&quot;&quot;
        !!!!! NOTE !!!!!
        For Harmonic Oscillator, Sanders' code works for the units I use...
        &quot;&quot;&quot;
        for n in range(self.N):
            logger.debug(&quot;Orbit {}&quot;.format(n))

            actions, angles, freq = harmonic_oscillator_xv_to_aa(
                self.w[:, n], self.potential
            )
            actions = actions.value
            angles = angles.value

            for i in range(3):
                assert np.allclose(actions[i, 1:], actions[i, 0], rtol=1e-5)

            # Compare to genfunc
            x = self.w.xyz.value[..., n]
            v = self.w.v_xyz.value[..., n]
            s_w = np.vstack((x, v))
            omega = self.potential.parameters[&quot;omega&quot;].value
            aa = np.array(
                [
                    toy_potentials.angact_ho(s_w[:, i].T, omega=omega)
                    for i in range(s_w.shape[1])
                ]
            )
            s_actions = aa[:, :3]
            s_angles = aa[:, 3:]

            assert np.allclose(actions, s_actions.T, rtol=1e-8)
            assert_angles_allclose(angles, s_angles.T, rtol=1e-8)

            # test roundtrip
            # x2, v2 = harmonic_oscillator_aa_to_xv(actions, angles, self.potential)
            # TODO: transform back??
</file>
    <file path="gala/dynamics/mockstream/tests/test_coord.py">
&quot;&quot;&quot;
Note:
    This is just a way to get pytest to call tests implemented in Cython!
    See _coord.pyx for the actual test functions.
&quot;&quot;&quot;

# Project
from .._coord import (_test_sat_rotation_matrix, _test_to_sat_coords_roundtrip,
                      _test_car_to_cyl_roundtrip, _test_cyl_to_car_roundtrip)


def test_sat_rotation_matrix():
    _test_sat_rotation_matrix()


def test_to_sat_coords_roundtrip():
    _test_to_sat_coords_roundtrip()


def test_car_to_cyl_roundtrip():
    _test_car_to_cyl_roundtrip()


def test_cyl_to_car_roundtrip():
    _test_cyl_to_car_roundtrip()
</file>
    <file path="gala/dynamics/mockstream/tests/test_df.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Custom
from ....integrate import DOPRI853Integrator
from ....potential import (
    ConstantRotatingFrame,
    Hamiltonian,
    HernquistPotential,
    MilkyWayPotential,
)
from ....units import galactic
from ...core import PhaseSpacePosition

# Project
from ..df import ChenStreamDF, FardalStreamDF, LagrangeCloudStreamDF, StreaklineStreamDF

_DF_CLASSES = [StreaklineStreamDF, FardalStreamDF, LagrangeCloudStreamDF, ChenStreamDF]
_DF_KWARGS = [{}, {&quot;gala_modified&quot;: True}, {&quot;v_disp&quot;: 1 * u.km / u.s}]
_TEST_POTENTIALS = [
    HernquistPotential(m=1e12, c=5, units=galactic),
    MilkyWayPotential(),
]


@pytest.mark.parametrize(&quot;DF, DF_kwargs&quot;, zip(_DF_CLASSES, _DF_KWARGS))
@pytest.mark.parametrize(&quot;pot&quot;, _TEST_POTENTIALS)
def test_init_sample(DF, DF_kwargs, pot):
    H = Hamiltonian(pot)

    orbit = H.integrate_orbit([10.0, 0, 0, 0, 0.2, 0], dt=1.0, n_steps=100)
    n_times = len(orbit.t)

    # Different ways to initialize successfully:
    df = DF(**DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == 2 * n_times

    df = DF(lead=False, **DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == n_times

    df = DF(trail=False, **DF_kwargs)
    o = df.sample(orbit, 1e4 * u.Msun)
    assert len(o.x) == n_times

    df1 = DF(random_state=np.random.RandomState(42), **DF_kwargs)
    o1 = df1.sample(orbit, 1e4 * u.Msun)
    df2 = DF(random_state=np.random.RandomState(42), **DF_kwargs)
    o2 = df2.sample(orbit, 1e4 * u.Msun)
    assert u.allclose(o1.xyz, o2.xyz)
    assert u.allclose(o1.v_xyz, o2.v_xyz)
    assert len(o1.x) == 2 * n_times


@pytest.mark.parametrize(&quot;DF, DF_kwargs&quot;, zip(_DF_CLASSES, _DF_KWARGS))
def test_expected_failure(DF, DF_kwargs):

    # Expected failure:
    with pytest.raises(ValueError):
        DF(lead=False, trail=False, **DF_kwargs)


def test_rotating_frame():
    DF = _DF_CLASSES[0]
    H_static = Hamiltonian(_TEST_POTENTIALS[0])

    w0 = PhaseSpacePosition(
        pos=[10.0, 0, 0] * u.kpc, vel=[0, 220, 0.0] * u.km / u.s, frame=H_static.frame
    )
    int_kwargs = dict(w0=w0, dt=1, n_steps=100, Integrator=DOPRI853Integrator)

    orbit_static = H_static.integrate_orbit(**int_kwargs)

    rframe = ConstantRotatingFrame([0, 0, -40] * u.km / u.s / u.kpc, units=galactic)
    H_rotating = Hamiltonian(_TEST_POTENTIALS[0], frame=rframe)
    orbit_rotating = H_rotating.integrate_orbit(**int_kwargs)

    _o = orbit_rotating.to_frame(H_static.frame)
    assert u.allclose(_o.xyz, orbit_static.xyz, atol=1e-13 * u.kpc)
    assert u.allclose(_o.v_xyz, orbit_static.v_xyz, atol=1e-13 * u.km / u.s)

    df_static = DF(trail=False)
    xvt_static = df_static.sample(orbit_static, 1e6 * u.Msun)

    df_rotating = DF(trail=False)
    xvt_rotating = df_rotating.sample(orbit_rotating, 1e6 * u.Msun)
    xvt_rotating_static = xvt_rotating.to_frame(
        H_static.frame, t=xvt_rotating.release_time
    )

    assert u.allclose(xvt_static.xyz, xvt_rotating_static.xyz, atol=1e-9 * u.kpc)
    assert u.allclose(
        xvt_static.v_xyz, xvt_rotating_static.v_xyz, atol=1e-9 * u.kpc / u.Myr
    )
</file>
    <file path="gala/dynamics/mockstream/tests/test_mockstream_class.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Custom
from ..core import MockStream


def test_init():

    xyz = np.random.random(size=(3, 100)) * u.kpc
    vxyz = np.random.random(size=(3, 100)) * u.km / u.s
    t1 = np.random.random(size=100) * u.Myr

    lead_trail = np.empty(100, dtype=&quot;U1&quot;)
    lead_trail[::2] = &quot;t&quot;
    lead_trail[1::2] = &quot;l&quot;

    stream = MockStream(xyz, vxyz)
    stream = MockStream(xyz, vxyz, release_time=t1)
    stream = MockStream(xyz, vxyz, lead_trail=lead_trail)  # noqa

    with pytest.raises(ValueError):
        MockStream(xyz, vxyz, release_time=t1[:-1])

    with pytest.raises(ValueError):
        MockStream(xyz, vxyz, lead_trail=lead_trail[:-1])


def test_one_burst():
    # Regression test: Tests a bug found by Helmer when putting all particles at
    # one timestep
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.dynamics import mockstream as ms
    from gala.units import galactic

    # NFW MW with v_c = 232.8 km/s @ r = 8.2 kpc
    pot = gp.NFWPotential.from_circular_velocity(
        v_c=232.8 * u.km / u.s, r_s=15 * u.kpc, r_ref=8.2 * u.kpc, units=galactic
    )

    H = gp.Hamiltonian(pot)

    prog_w0 = gd.PhaseSpacePosition(
        pos=[10, 0, 0.0] * u.kpc, vel=[0, 10, 0.0] * u.km / u.s
    )

    dt = 1 * u.Myr
    nsteps = 100
    orbit = H.integrate_orbit(prog_w0, dt=dt, n_steps=nsteps)

    r = orbit.spherical.distance

    n_array = np.zeros(orbit.t.size, dtype=int)
    argmin = r[0:150].argmin()
    n_array[argmin] = 1000

    df = ms.FardalStreamDF(gala_modified=True)

    dt = 1 * u.Myr
    prog_mass = 2.5e4 * u.Msun
    prog_pot = gp.PlummerPotential(m=prog_mass, b=4 * u.pc, units=galactic)

    gen = ms.MockStreamGenerator(df, H, progenitor_potential=prog_pot)

    stream, prog = gen.run(
        prog_w0, prog_mass, n_particles=n_array, dt=dt, n_steps=nsteps, progress=False
    )


def test_Fardal_vs_GalaModified():
    &quot;&quot;&quot;
    Regression test: Check that one can actually use the original Fardal parameter
    values, and that makes a different stream than the Gala-modified values:
    https://github.com/adrn/gala/pull/358
    &quot;&quot;&quot;
    import gala.dynamics as gd
    import gala.potential as gp
    from gala.dynamics import mockstream as ms
    from gala.units import galactic

    # NFW MW with v_c = 232.8 km/s @ r = 8.2 kpc
    pot = gp.NFWPotential.from_circular_velocity(
        v_c=232.8 * u.km / u.s, r_s=15 * u.kpc, r_ref=8.2 * u.kpc, units=galactic
    )

    H = gp.Hamiltonian(pot)

    prog_w0 = gd.PhaseSpacePosition(
        pos=[10, 0, 0.0] * u.kpc, vel=[0, 300, 20.0] * u.km / u.s
    )

    with pytest.warns(DeprecationWarning, match=&quot;Fardal&quot;):
        ms.FardalStreamDF()

    df_false = ms.FardalStreamDF(
        gala_modified=False, random_state=np.random.default_rng(seed=42)
    )
    df_true = ms.FardalStreamDF(
        gala_modified=True, random_state=np.random.default_rng(seed=42)
    )

    gen_false = ms.MockStreamGenerator(df_false, H)
    gen_true = ms.MockStreamGenerator(df_true, H)

    prog_mass = 2.5e4 * u.Msun
    stream_false, _ = gen_false.run(
        prog_w0, prog_mass, dt=1, n_steps=128, progress=False
    )
    stream_true, _ = gen_true.run(prog_w0, prog_mass, dt=1, n_steps=128, progress=False)

    assert not u.allclose(stream_false.xyz, stream_true.xyz)
</file>
    <file path="gala/dynamics/mockstream/tests/test_mockstream.py">
import itertools
import os

# Third-party
import astropy.units as u
import numpy as np
import pytest

from gala.tests.optional_deps import HAS_H5PY

from ....dynamics import Orbit, PhaseSpacePosition
from ....potential import (
    ConstantRotatingFrame,
    Hamiltonian,
    HernquistPotential,
    NFWPotential,
)
from ....units import galactic
from ...nbody import DirectNBody
from ..df import FardalStreamDF
from ..mockstream_generator import MockStreamGenerator


def test_init():
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    df = FardalStreamDF(gala_modified=True)

    with pytest.raises(TypeError):
        MockStreamGenerator(df=&quot;some df&quot;, hamiltonian=H)

    with pytest.raises(TypeError):
        MockStreamGenerator(df=df, hamiltonian=H, progenitor_potential=&quot;stuff&quot;)

    # Test validating the input nbody
    nbody_w0 = PhaseSpacePosition(
        pos=[25.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    potential2 = NFWPotential.from_circular_velocity(v_c=0.2, r_s=25.0, units=galactic)
    nbody = DirectNBody(
        w0=nbody_w0, external_potential=potential2, particle_potentials=[None]
    )
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    with pytest.raises(ValueError):
        gen._get_nbody(w0, nbody)

    frame2 = ConstantRotatingFrame([0, 0, 25.0] * u.km / u.s / u.kpc, units=galactic)
    nbody = DirectNBody(
        w0=nbody_w0,
        external_potential=potential,
        frame=frame2,
        particle_potentials=[None],
    )
    with pytest.raises(ValueError):
        gen._get_nbody(w0, nbody)

    # we expect success!
    nbody = DirectNBody(
        w0=nbody_w0, external_potential=potential, particle_potentials=[None]
    )
    new_nbody = gen._get_nbody(w0, nbody)  # noqa


def test_run():
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun
    prog_pot = HernquistPotential(mass, 4 * u.pc, units=galactic)

    # The basic run:
    df = FardalStreamDF(gala_modified=True)
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    stream1, _ = gen.run(w0, mass, dt=-1.0, n_steps=100)

    # Expected errors:
    with pytest.raises(TypeError):
        gen.run(w0, mass.value, dt=-1.0, n_steps=100)

    # With self-gravity
    gen = MockStreamGenerator(df=df, hamiltonian=H, progenitor_potential=prog_pot)
    stream2, _ = gen.run(w0, mass, dt=-1.0, n_steps=100)
    assert not u.allclose(stream1.xyz, stream2.xyz)

    # Skipping release steps:
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    stream3, _ = gen.run(w0, mass, dt=-1.0, n_steps=100, release_every=4, n_particles=4)
    assert stream3.shape == ((100 // 4 + 1) * 4 * 2,)

    # Custom n_particles:
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    n_particles = np.random.randint(0, 4, size=101)
    stream3, _ = gen.run(
        w0, mass, dt=-1.0, n_steps=100, release_every=1, n_particles=n_particles
    )
    assert stream3.shape[0] == 2 * n_particles.sum()


@pytest.mark.parametrize(&quot;dt&quot;, [1, -1])
@pytest.mark.parametrize(&quot;save_all&quot;, [True, False])
def test_mockstream_nbody_run(dt, save_all):
    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun
    df = FardalStreamDF(gala_modified=True)

    # Test passing custom N-body:
    nbody_w0 = PhaseSpacePosition([20, 0, 0] * u.kpc, [0, 100, 0] * u.km / u.s)
    nbody = DirectNBody(
        w0=nbody_w0,
        external_potential=potential,
        particle_potentials=[
            NFWPotential(m=1e8 * u.Msun, r_s=0.2 * u.kpc, units=galactic)
        ],
        save_all=save_all,
    )
    gen = MockStreamGenerator(df=df, hamiltonian=H)
    gen.run(w0, mass, dt=dt, n_steps=100, nbody=nbody)


@pytest.mark.parametrize(
    &quot;dt, nsteps, output_every, release_every, n_particles, trail&quot;,
    list(itertools.product([1, -1], [16, 17], [1, 2], [1, 4], [1, 4], [True, False])),
)
@pytest.mark.skipif(not HAS_H5PY, reason=&quot;h5py required for this test&quot;)
def test_animate(tmpdir, dt, nsteps, output_every, release_every, n_particles, trail):
    import h5py

    potential = NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.0, units=galactic)
    H = Hamiltonian(potential)
    w0 = PhaseSpacePosition(
        pos=[15.0, 0.0, 0] * u.kpc, vel=[0, 0, 0.13] * u.kpc / u.Myr
    )
    mass = 2.5e4 * u.Msun

    # The basic run:
    df = FardalStreamDF(gala_modified=True, trail=trail)
    gen = MockStreamGenerator(df=df, hamiltonian=H)

    filename = os.path.join(str(tmpdir), &quot;test.hdf5&quot;)
    stream, _ = gen.run(
        w0,
        mass,
        dt=dt,
        n_steps=nsteps,
        release_every=release_every,
        n_particles=n_particles,
        output_every=output_every,
        output_filename=filename,
        overwrite=True,
    )

    with h5py.File(filename, mode=&quot;r&quot;) as f:
        stream_orbits = Orbit.from_hdf5(f[&quot;stream&quot;])
        nbody_orbits = Orbit.from_hdf5(f[&quot;nbody&quot;])

    noutput_times = 1 + nsteps // output_every
    if nsteps % output_every != 0:
        noutput_times += 1

    tail_n_particles = (1 + int(trail)) * n_particles
    expected_shape = (noutput_times, tail_n_particles * (nsteps // release_every + 1))

    assert stream_orbits.shape == expected_shape
    assert np.isfinite(stream_orbits[:, 0].xyz).all()
    assert np.isfinite(stream_orbits[:, 0].v_xyz).all()

    assert u.allclose(nbody_orbits.t, stream_orbits.t)

    assert np.isfinite(nbody_orbits.xyz).all()
    assert np.isfinite(nbody_orbits.v_xyz).all()
    assert np.isfinite(nbody_orbits.t).all()
</file>
    <file path="gala/dynamics/mockstream/_coord.pyx">
# cython: boundscheck=False
# cython: debug=False
# cython: nonecheck=False
# cython: cdivision=True
# cython: wraparound=False
# cython: profile=False
# cython: language_level=3

&quot;&quot;&quot; Coordinate help for generating mock streams. &quot;&quot;&quot;

from libc.math cimport M_PI

cdef extern from &quot;math.h&quot;:
    double fabs(double x) nogil
    double sqrt(double x) nogil
    double cos(double x) nogil
    double sin(double x) nogil
    double atan2(double y, double x) nogil
    double fmod(double y, double x) nogil


cdef void cross(double *x, double *y, double *z):
    z[0] = x[1]*y[2] - x[2]*y[1]
    z[1] = -x[0]*y[2] + x[2]*y[0]
    z[2] = x[0]*y[1] - x[1]*y[0]


cdef double norm(double *x, int n):
    cdef:
        double val = 0.
        int i

    for i in range(n):
        val += x[i]**2

    return sqrt(val)


cdef void apply_3matrix(double[:, ::1] R, double *x, double *y,
                        int transpose):
    cdef int i
    if transpose == 0:
        for i in range(3):
            y[i] = R[i, 0] * x[0] + R[i, 1] * x[1] + R[i, 2] * x[2]
    else:
        for i in range(3):
            y[i] = R[0, i] * x[0] + R[1, i] * x[1] + R[2, i] * x[2]


cdef void sat_rotation_matrix(double *w, # in
                              double *R): # out
    cdef:
        double x1_norm, x2_norm, x3_norm = 0.
        unsigned int i
        double *x1 = [0., 0., 0.]
        double *x2 = [0., 0., 0.]
        double *x3 = [0., 0., 0.]

    x1[0] = w[0]
    x1[1] = w[1]
    x1[2] = w[2]

    x3[0] = x1[1]*w[2+3] - x1[2]*w[1+3]
    x3[1] = x1[2]*w[0+3] - x1[0]*w[2+3]
    x3[2] = x1[0]*w[1+3] - x1[1]*w[0+3]

    x2[0] = -x1[1]*x3[2] + x1[2]*x3[1]
    x2[1] = -x1[2]*x3[0] + x1[0]*x3[2]
    x2[2] = -x1[0]*x3[1] + x1[1]*x3[0]

    x1_norm = sqrt(x1[0]*x1[0] + x1[1]*x1[1] + x1[2]*x1[2])
    x2_norm = sqrt(x2[0]*x2[0] + x2[1]*x2[1] + x2[2]*x2[2])
    x3_norm = sqrt(x3[0]*x3[0] + x3[1]*x3[1] + x3[2]*x3[2])

    for i in range(3):
        x1[i] /= x1_norm
        x2[i] /= x2_norm
        x3[i] /= x3_norm

    R[0] = x1[0]
    R[1] = x1[1]
    R[2] = x1[2]
    R[3] = x2[0]
    R[4] = x2[1]
    R[5] = x2[2]
    R[6] = x3[0]
    R[7] = x3[1]
    R[8] = x3[2]

cdef void to_sat_coords(double *w, double *R, # in
                        double *w_prime): # out
    # Translate to be centered on progenitor
    cdef int i

    # Project into new basis
    w_prime[0] = w[0]*R[0] + w[1]*R[1] + w[2]*R[2]
    w_prime[1] = w[0]*R[3] + w[1]*R[4] + w[2]*R[5]
    w_prime[2] = w[0]*R[6] + w[1]*R[7] + w[2]*R[8]

    w_prime[3] = w[3]*R[0] + w[4]*R[1] + w[5]*R[2]
    w_prime[4] = w[3]*R[3] + w[4]*R[4] + w[5]*R[5]
    w_prime[5] = w[3]*R[6] + w[4]*R[7] + w[5]*R[8]

cdef void from_sat_coords(double *w_prime, double *R, # in
                          double *w): # out
    cdef int i

    # Project back from sat plane
    w[0] = w_prime[0]*R[0] + w_prime[1]*R[3] + w_prime[2]*R[6]
    w[1] = w_prime[0]*R[1] + w_prime[1]*R[4] + w_prime[2]*R[7]
    w[2] = w_prime[0]*R[2] + w_prime[1]*R[5] + w_prime[2]*R[8]

    w[3] = w_prime[3]*R[0] + w_prime[4]*R[3] + w_prime[5]*R[6]
    w[4] = w_prime[3]*R[1] + w_prime[4]*R[4] + w_prime[5]*R[7]
    w[5] = w_prime[3]*R[2] + w_prime[4]*R[5] + w_prime[5]*R[8]

# ---------------------------------------------------------------------

cdef void car_to_cyl(double *w, # in
                     double *cyl): # out
    cdef:
        double R = sqrt(w[0]*w[0] + w[1]*w[1])
        double phi = atan2(w[1], w[0])
        double vR = (w[0]*w[3] + w[1]*w[4]) / R
        double vphi = (w[0]*w[4] - w[3]*w[1]) / R

    cyl[0] = R
    if phi &lt; 0:
        phi = phi + 2*M_PI
    cyl[1] = phi
    cyl[2] = w[2]

    cyl[3] = vR
    cyl[4] = vphi
    cyl[5] = w[5]

cdef void cyl_to_car(double *cyl, # in
                     double *w): # out
    w[0] = cyl[0] * cos(cyl[1])
    w[1] = cyl[0] * sin(cyl[1])
    w[2] = cyl[2]

    w[3] = cyl[3] * cos(cyl[1]) - cyl[4] * sin(cyl[1])
    w[4] = cyl[3] * sin(cyl[1]) + cyl[4] * cos(cyl[1])
    w[5] = cyl[5]

# ---------------------------------------------------------------------
# Tests
#

cpdef _test_sat_rotation_matrix():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[::1] w = np.zeros(6)
        double[::1] wrot = np.zeros(6)
        double[::1] w2 = np.zeros(6)
        double[:, ::1] R = np.zeros((3, 3))
        unsigned int i, j

    for i in range(n):
        w = np.random.uniform(size=6)
        sat_rotation_matrix(&amp;w[0], &amp;R[0, 0])

        x = np.array(R).dot(np.array(w)[:3])
        assert x[0] &gt; 0
        assert np.allclose(x[1], 0)
        assert np.allclose(x[2], 0)

        v = np.array(R).dot(np.array(w)[3:])
        assert np.allclose(v[2], 0)
        for j in range(3):
            wrot[j] = x[j]
            wrot[j+3] = v[j]

        x2 = np.array(R.T).dot(np.array(wrot)[:3])
        v2 = np.array(R.T).dot(np.array(wrot)[3:])
        for j in range(3):
            w2[j] = x2[j]
            w2[j+3] = v2[j]

        for j in range(6):
            assert np.allclose(w[j], w2[j])

cpdef _test_to_sat_coords_roundtrip():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] w = np.random.uniform(size=(n, 6))
        double[:, ::1] w_sat = np.random.uniform(size=(n, 6))
        double[:, ::1] R = np.zeros((3, 3))

        double[::1] w_prime = np.zeros(6)
        double[::1] w2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        sat_rotation_matrix(&amp;w_sat[i, 0], &amp;R[0, 0])
        to_sat_coords(&amp;w[i, 0], &amp;R[0, 0], &amp;w_prime[0])
        from_sat_coords(&amp;w_prime[0], &amp;R[0, 0], &amp;w2[0])

        for j in range(6):
            assert np.allclose(w[i, j], w2[j])

cpdef _test_car_to_cyl_roundtrip():
    import numpy as np
    np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] w = np.random.uniform(-10, 10, size=(n, 6))
        double[::1] cyl = np.zeros(6)
        double[::1] w2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        car_to_cyl(&amp;w[i, 0], &amp;cyl[0])
        cyl_to_car(&amp;cyl[0], &amp;w2[0])
        for j in range(6):
            assert np.allclose(w[i, j], w2[j])

cpdef _test_cyl_to_car_roundtrip():
    import numpy as np
    # np.random.seed(42)
    n = 1024

    cdef:
        double[:, ::1] cyl = np.random.uniform(0, 2*np.pi, size=(n, 6))
        double[::1] w = np.zeros(6)
        double[::1] cyl2 = np.zeros(6)

        unsigned int i, j

    for i in range(n):
        cyl_to_car(&amp;cyl[i, 0], &amp;w[0])
        car_to_cyl(&amp;w[0], &amp;cyl2[0])
        for j in range(6):
            # assert np.allclose(cyl[i, j], cyl2[j])
            if not np.allclose(cyl[i, j], cyl2[j]):
                print(i, j, cyl[i, j], cyl2[j])

# cdef void car_to_sph(double *xyz, double *sph):
#     # TODO: note this isn't consistent with the velocity transform because of theta
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double phi = atan2(xyz[1], xyz[0])
#         double theta = acos(xyz[2] / d)

#     sph[0] = d
#     sph[1] = phi
#     sph[2] = theta

# cdef void sph_to_car(double *sph, double *xyz):
#     # TODO: note this isn't consistent with the velocity transform because of theta
#     # get out spherical components
#     xyz[0] = sph[0] * cos(sph[1]) * sin(sph[2])
#     xyz[1] = sph[0] * sin(sph[1]) * sin(sph[2])
#     xyz[2] = sph[0] * cos(sph[2])

# cdef void v_car_to_sph(double *xyz, double *vxyz, double *vsph):
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double dxy = sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1])

#         double vr = (xyz[0]*vxyz[0]+xyz[1]*vxyz[1]+xyz[2]*vxyz[2]) / d

#         double mu_lon = (xyz[0]*vxyz[1] - vxyz[0]*xyz[1]) / (dxy*dxy)
#         double vlon = mu_lon * dxy # cos(lat)

#         double mu_lat = (xyz[2]*(xyz[0]*vxyz[0] + xyz[1]*vxyz[1]) - dxy*dxy*vxyz[2]) / (d*d*dxy)
#         double vlat = -mu_lat * d

#     vsph[0] = vr
#     vsph[1] = vlon
#     vsph[2] = vlat

# cdef void v_sph_to_car(double *xyz, double *vsph, double *vxyz):
#     # get out spherical components
#     cdef:
#         double d = sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]+xyz[2]*xyz[2])
#         double dxy = sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1])

#     vxyz[0] = vsph[0]*xyz[0]/dxy*dxy/d - xyz[1]/dxy*vsph[1] - xyz[0]/dxy*xyz[2]/d*vsph[2]
#     vxyz[1] = vsph[0]*xyz[1]/dxy*dxy/d + xyz[0]/dxy*vsph[1] - xyz[1]/dxy*xyz[2]/d*vsph[2]
#     vxyz[2] = vsph[0]*xyz[2]/d + dxy/d*vsph[2]
</file>
    <file path="gala/dynamics/nbody/tests/test_nbody.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

from gala.dynamics import PhaseSpacePosition, combine
from gala.integrate import (
    DOPRI853Integrator,
    LeapfrogIntegrator,
    Ruth4Integrator,
)

# Custom
from gala.potential import (
    ConstantRotatingFrame,
    HernquistPotential,
    NFWPotential,
    NullPotential,
    StaticFrame,
)
from gala.units import UnitSystem, galactic

# Project
from ..core import DirectNBody


class TestDirectNBody:
    def setup_method(self):
        self.usys = UnitSystem(
            u.pc, u.Unit(1e-5 * u.Myr), u.Unit(1e6 * u.Msun), u.radian
        )
        pot_particle2 = HernquistPotential(
            m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys
        )
        vcirc = pot_particle2.circular_velocity([1, 0, 0.0] * u.pc).to(u.km / u.s)

        self.particle_potentials = [NullPotential(units=self.usys), pot_particle2]

        w0_2 = PhaseSpacePosition(pos=[10, 0, 0] * u.kpc, vel=[0, 83, 0] * u.km / u.s)
        w0_1 = PhaseSpacePosition(
            pos=w0_2.xyz + [1, 0, 0] * u.pc, vel=w0_2.v_xyz + [0, 1.0, 0] * vcirc
        )
        self.w0 = combine((w0_1, w0_2))

        self.ext_pot = NFWPotential(m=1e11, r_s=10, units=galactic)

    def test_directnbody_init(self):
        # another unit system for testing
        usys2 = UnitSystem(u.pc, u.Unit(1e-3 * u.Myr), u.Unit(1e6 * u.Msun), u.radian)

        particle_potentials_None = [None] + self.particle_potentials[1:]

        # Different VALID ways to initialize
        nbody = DirectNBody(self.w0, particle_potentials=self.particle_potentials)
        nbody = DirectNBody(self.w0, particle_potentials=particle_potentials_None)
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            external_potential=self.ext_pot,
        )
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            external_potential=self.ext_pot,
            units=usys2,
        )
        nbody = DirectNBody(self.w0, particle_potentials=[None, None], units=usys2)
        nbody = DirectNBody(
            self.w0,
            particle_potentials=[None, None],  # noqa
            external_potential=self.ext_pot,
        )

        # Different INVALID ways to initialize
        with pytest.raises(TypeError):
            DirectNBody(&quot;sdf&quot;, particle_potentials=self.particle_potentials)

        with pytest.raises(ValueError):
            DirectNBody(self.w0, particle_potentials=self.particle_potentials[:1])

        # MAX_NBODY1 = 65536+1
        # w0_max = combine([self.w0[0]]*MAX_NBODY1)
        # with pytest.raises(NotImplementedError):
        #     DirectNBody(w0_max, particle_potentials=[None]*MAX_NBODY1)

        with pytest.raises(ValueError):
            DirectNBody(self.w0, particle_potentials=[None, None])

    @pytest.mark.parametrize(
        &quot;Integrator&quot;, [DOPRI853Integrator, Ruth4Integrator, LeapfrogIntegrator]
    )
    def test_directnbody_integrate(self, Integrator):
        # TODO: this is really a unit test, but we should have some functional tests
        # that check that the orbit integration is making sense!

        # First, compare with/without mass with no external potential:
        nbody1 = DirectNBody(self.w0, particle_potentials=[None, None], units=self.usys)
        nbody2 = DirectNBody(
            self.w0, particle_potentials=self.particle_potentials, units=self.usys
        )

        orbits1 = nbody1.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        dx0 = orbits1[:, 0].xyz - orbits2[:, 0].xyz
        dx1 = orbits1[:, 1].xyz - orbits2[:, 1].xyz
        assert u.allclose(np.abs(dx1), 0 * u.pc, atol=1e-13 * u.pc)
        assert np.abs(dx0).max() &gt; 50 * u.pc

        # Now compare with/without mass with external potential:
        nbody1 = DirectNBody(
            self.w0,
            particle_potentials=[None, None],
            units=self.usys,
            external_potential=self.ext_pot,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
        )

        orbits1 = nbody1.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        dx0 = orbits1[:, 0].xyz - orbits2[:, 0].xyz
        dx1 = orbits1[:, 1].xyz - orbits2[:, 1].xyz
        assert u.allclose(np.abs(dx1), 0 * u.pc, atol=1e-13 * u.pc)
        assert np.abs(dx0).max() &gt; 50 * u.pc

    def test_directnbody_acceleration(self):
        pot1 = HernquistPotential(m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys)
        pot2 = HernquistPotential(m=1.6e6 * u.Msun, c=0.33 * u.pc, units=self.usys)

        nbody = DirectNBody(
            self.w0, particle_potentials=[pot1, pot2], external_potential=self.ext_pot
        )

        # Compute the acceleration we expect:
        _pot1 = HernquistPotential(
            m=1e6 * u.Msun, c=0.1 * u.pc, units=self.usys, origin=self.w0[0].xyz
        )
        _pot2 = HernquistPotential(
            m=1.6e6 * u.Msun, c=0.33 * u.pc, units=self.usys, origin=self.w0[1].xyz
        )
        exp_acc = np.zeros((3, 2)) * self.usys[&quot;acceleration&quot;]
        exp_acc[:, 0] = _pot2.acceleration(self.w0[0])[:, 0]
        exp_acc[:, 1] = _pot1.acceleration(self.w0[1])[:, 0]
        exp_acc += self.ext_pot.acceleration(self.w0)

        acc = nbody.acceleration()
        assert u.allclose(acc, exp_acc)

    @pytest.mark.parametrize(
        &quot;Integrator&quot;, [DOPRI853Integrator, Ruth4Integrator, LeapfrogIntegrator]
    )
    def test_directnbody_integrate_dontsaveall(self, Integrator):
        # If we set save_all = False, only return the final positions:
        nbody1 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            save_all=False,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            save_all=True,
        )

        w1 = nbody1.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits = nbody2.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        w2 = orbits[-1]
        assert u.allclose(w1.xyz, w2.xyz)
        assert u.allclose(w1.v_xyz, w2.v_xyz)

    @pytest.mark.parametrize(&quot;Integrator&quot;, [DOPRI853Integrator])
    def test_directnbody_integrate_rotframe(self, Integrator):
        # Now compare with/without mass with external potential:
        frame = ConstantRotatingFrame(
            Omega=[0, 0, 1] * self.w0[0].v_y / self.w0[0].x, units=self.usys
        )
        nbody = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
            frame=frame,
        )
        nbody2 = DirectNBody(
            self.w0,
            particle_potentials=self.particle_potentials,
            units=self.usys,
            external_potential=self.ext_pot,
        )

        orbits = nbody.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )
        orbits_static = orbits.to_frame(StaticFrame(self.usys))

        orbits2 = nbody2.integrate_orbit(
            dt=1 * self.usys[&quot;time&quot;], t1=0, t2=1 * u.Myr, Integrator=Integrator
        )

        assert u.allclose(orbits_static.xyz, orbits_static.xyz)
        assert u.allclose(orbits2.v_xyz, orbits2.v_xyz)

    @pytest.mark.parametrize(&quot;Integrator&quot;, [DOPRI853Integrator])
    def test_nbody_reorder(self, Integrator):
        N = 16
        rng = np.random.default_rng(seed=42)
        w0 = PhaseSpacePosition(
            pos=rng.normal(0, 5, size=(3, N)) * u.kpc,
            vel=rng.normal(0, 50, size=(3, N)) * u.km / u.s,
        )
        pots = [
            (
                HernquistPotential(1e9 * u.Msun, 1.0 * u.pc, units=galactic)
                if rng.uniform() &gt; 0.5
                else None
            )
            for _ in range(N)
        ]
        sim = DirectNBody(
            w0,
            pots,
            external_potential=HernquistPotential(1e12, 10, units=galactic),
            units=galactic,
        )
        orbits = sim.integrate_orbit(dt=1.0 * u.Myr, t1=0, t2=100 * u.Myr)
        assert np.allclose(orbits.pos[0].xyz, w0.pos.xyz)
</file>
    <file path="gala/dynamics/tests/test_core.py">
# Third-party
import astropy.coordinates as coord
import astropy.units as u
import numpy as np
import pytest
from astropy.coordinates import (
    CartesianDifferential,
    CartesianRepresentation,
    Galactic,
    SphericalCosLatDifferential,
    SphericalRepresentation,
)

from gala.tests.optional_deps import HAS_H5PY

from ...potential import Hamiltonian, HernquistPotential
from ...potential.frame import ConstantRotatingFrame, StaticFrame
from ...units import galactic, solarsystem

# Project
from ..core import PhaseSpacePosition


def test_initialize():
    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 8))
        PhaseSpacePosition(pos=x, vel=v)

    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.shape == (10,)

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.km / u.s
    o.data
    assert &quot;s&quot; in o.data.differentials

    # Not 3D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.ndim == 2

    o = PhaseSpacePosition(pos=x, vel=v, frame=StaticFrame(galactic))
    assert o.ndim == 2
    assert o.frame is not None
    assert isinstance(o.frame, StaticFrame)

    x = np.random.random(size=(4, 10))
    v = np.random.random(size=(4, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    assert o.ndim == 4

    # back to 3D
    pos = CartesianRepresentation(np.random.random(size=(3, 10)) * u.one)
    vel = CartesianDifferential(np.random.random(size=(3, 10)) * u.one)
    o = PhaseSpacePosition(pos=pos, vel=vel)
    assert hasattr(o, &quot;x&quot;)
    assert hasattr(o, &quot;y&quot;)
    assert hasattr(o, &quot;z&quot;)
    assert hasattr(o, &quot;v_x&quot;)
    assert hasattr(o, &quot;v_y&quot;)
    assert hasattr(o, &quot;v_z&quot;)

    # passing a representation with a differential attached
    pos = CartesianRepresentation(np.random.random(size=(3, 10)) * u.kpc)
    vel = CartesianDifferential(np.random.random(size=(3, 10)) * u.km / u.s)
    o = PhaseSpacePosition(pos.with_differentials({&quot;s&quot;: vel}))
    assert hasattr(o, &quot;x&quot;)
    assert hasattr(o, &quot;y&quot;)
    assert hasattr(o, &quot;z&quot;)
    assert hasattr(o, &quot;v_x&quot;)
    assert hasattr(o, &quot;v_y&quot;)
    assert hasattr(o, &quot;v_z&quot;)

    o = o.represent_as(SphericalRepresentation)
    assert hasattr(o, &quot;distance&quot;)
    assert hasattr(o, &quot;lat&quot;)
    assert hasattr(o, &quot;lon&quot;)
    assert hasattr(o, &quot;radial_velocity&quot;)
    assert hasattr(o, &quot;pm_lon&quot;)
    assert hasattr(o, &quot;pm_lat&quot;)

    with pytest.raises(TypeError):
        o = PhaseSpacePosition(pos=x, vel=v, frame=&quot;blah blah blah&quot;)


def test_from_w():
    w = np.random.random(size=(6, 10))
    o = PhaseSpacePosition.from_w(w, galactic)
    assert o.x.unit == u.kpc
    assert o.v_x.unit == u.kpc / u.Myr
    assert o.shape == (10,)


def test_slice():
    # simple
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5,)

    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5, 8)

    # 3d slice on 3d
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o[:5, :4]
    assert new_o.shape == (5, 4)

    # boolean array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix),)

    # integer array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    ix = np.array([0, 3, 5])
    new_o = o[ix]
    assert new_o.shape == (len(ix),)


def test_reshape():
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o.reshape((10, 1))
    assert new_o.shape == (10, 1)
    assert new_o.x.shape == (10, 1)


def test_represent_as():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    new_o = o.represent_as(SphericalRepresentation)
    o.spherical
    o.cylindrical
    o.cartesian

    assert new_o.pos.distance.unit == u.one
    assert new_o.vel.d_distance.unit == u.one

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)
    assert sph.pos.distance.unit == u.kpc

    sph2 = o.represent_as(&quot;spherical&quot;)
    for c in sph.pos.components:
        assert u.allclose(getattr(sph.pos, c), getattr(sph2.pos, c), rtol=1e-12)

    # doesn't work for 2D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.represent_as(SphericalRepresentation)


def test_represent_as_expected_attributes():
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)

    new_o = o.spherical
    assert hasattr(new_o, &quot;distance&quot;)
    assert hasattr(new_o, &quot;lat&quot;)
    assert hasattr(new_o, &quot;lon&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_lat&quot;)
    assert hasattr(new_o, &quot;pm_lon&quot;)

    new_o = o.represent_as(SphericalRepresentation, SphericalCosLatDifferential)
    assert hasattr(new_o, &quot;distance&quot;)
    assert hasattr(new_o, &quot;lat&quot;)
    assert hasattr(new_o, &quot;lon&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_lat&quot;)
    assert hasattr(new_o, &quot;pm_lon_coslat&quot;)

    new_o = o.physicsspherical
    assert hasattr(new_o, &quot;r&quot;)
    assert hasattr(new_o, &quot;phi&quot;)
    assert hasattr(new_o, &quot;theta&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_theta&quot;)
    assert hasattr(new_o, &quot;pm_phi&quot;)

    new_o = o.cylindrical
    assert hasattr(new_o, &quot;rho&quot;)
    assert hasattr(new_o, &quot;phi&quot;)
    assert hasattr(new_o, &quot;z&quot;)
    assert hasattr(new_o, &quot;v_rho&quot;)
    assert hasattr(new_o, &quot;pm_phi&quot;)
    assert hasattr(new_o, &quot;v_z&quot;)

    new_o = new_o.cartesian
    assert hasattr(new_o, &quot;x&quot;)
    assert hasattr(new_o, &quot;y&quot;)
    assert hasattr(new_o, &quot;z&quot;)
    assert hasattr(new_o, &quot;xyz&quot;)
    assert hasattr(new_o, &quot;v_x&quot;)
    assert hasattr(new_o, &quot;v_y&quot;)
    assert hasattr(new_o, &quot;v_z&quot;)
    assert hasattr(new_o, &quot;v_xyz&quot;)

    # Check that this works with the NDCartesian classes too
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    new_o = PhaseSpacePosition(pos=x, vel=v)

    assert hasattr(new_o, &quot;x1&quot;)
    assert hasattr(new_o, &quot;x2&quot;)
    assert hasattr(new_o, &quot;xyz&quot;)
    assert hasattr(new_o, &quot;v_x1&quot;)
    assert hasattr(new_o, &quot;v_x2&quot;)
    assert hasattr(new_o, &quot;v_xyz&quot;)


def test_to_coord_frame():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)

    with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
        with pytest.raises(u.UnitConversionError):
            o.to_coord_frame(Galactic())

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
        coo = o.to_coord_frame(Galactic())
    assert coo.name == &quot;galactic&quot;

    # doesn't work for 2D
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with coord.galactocentric_frame_defaults.set(&quot;v4.0&quot;):
        with pytest.raises(ValueError):
            o.to_coord_frame(Galactic())


def test_w():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 10)

    x = np.random.random(size=3)
    v = np.random.random(size=3)
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 1)

    # simple / unitless, 2D
    x = np.random.random(size=(2, 10))
    v = np.random.random(size=(2, 10))
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (4, 10)

    x = np.random.random(size=2)
    v = np.random.random(size=2)
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w()
    assert w.shape == (4, 1)

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.w()
    w = o.w(units=galactic)
    assert np.allclose(x.value, w[:3])
    assert np.allclose(v.value, (w[3:] * u.kpc / u.Myr).to(u.km / u.s).value)

    # simple / with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    w = o.w(p.units)
    assert np.allclose(x.value, w[:3])
    assert np.allclose(v.value, (w[3:] * u.kpc / u.Myr).to(u.km / u.s).value)

    w = o.w(units=solarsystem)
    assert np.allclose(x.value, (w[:3] * u.au).to(u.kpc).value)
    assert np.allclose(v.value, (w[3:] * u.au / u.yr).to(u.km / u.s).value)


# ------------------------------------------------------------------------
# Computed dynamical quantities
# ------------------------------------------------------------------------
def test_energy():  # noqa
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    KE = o.kinetic_energy()
    assert KE.unit == (o.v_x.unit) ** 2
    assert KE.shape == o.shape

    # with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    H = Hamiltonian(p)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = PhaseSpacePosition(pos=x, vel=v)
    PE = o.potential_energy(p)  # noqa
    E = o.energy(H)  # noqa


def test_angular_momentum():
    w = PhaseSpacePosition([1.0, 0.0, 0.0], [0.0, 0.0, 1.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [0.0, -1, 0] * u.one)

    w = PhaseSpacePosition([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [0.0, 0, 1] * u.one)

    w = PhaseSpacePosition([0.0, 1.0, 0.0], [0.0, 0.0, 1.0])
    assert u.allclose(np.squeeze(w.angular_momentum()), [1.0, 0, 0] * u.one)

    w = PhaseSpacePosition([1.0, 0, 0] * u.kpc, [0.0, 200.0, 0] * u.pc / u.Myr)
    assert u.allclose(
        np.squeeze(w.angular_momentum()), [0, 0, 0.2] * u.kpc**2 / u.Myr
    )

    # multiple - known
    q = np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0, 1.0, 0.0]]).T
    p = np.array([[0, 0, 1.0], [0, 1.0, 0.0], [0, 0, 1]]).T
    L = PhaseSpacePosition(q, p).angular_momentum()
    true_L = np.array([[0.0, -1, 0], [0.0, 0, 1], [1.0, 0, 0]]).T * u.one
    assert L.shape == (3, 3)
    assert u.allclose(L, true_L)

    # multiple - random
    q = np.random.uniform(size=(3, 128))
    p = np.random.uniform(size=(3, 128))
    L = PhaseSpacePosition(q, p).angular_momentum()
    assert L.shape == (3, 128)


def test_guiding_radius():  # noqa
    rng = np.random.default_rng(42)

    p = HernquistPotential(units=galactic, m=1e11, c=10.0)

    Rs = rng.uniform(4, 10, 128) * u.kpc
    xyz = Rs[None] * np.array([1.0, 0, 0])[:, None]

    vc = p.circular_velocity(xyz)
    vxyz = np.zeros((3, Rs.size)) * u.km / u.s
    vxyz[1] = rng.normal(vc.to_value(u.km / u.s), 15.0) * u.km / u.s

    w0 = PhaseSpacePosition(xyz, vxyz)
    Rgs = w0.guiding_radius(potential=p)
    assert np.all(Rgs &gt; 0) and np.all(Rgs &lt; 25 * u.kpc)


def test_frame_transform():
    static = StaticFrame(galactic)
    rotating = ConstantRotatingFrame(
        Omega=[0.53, 1.241, 0.9394] * u.rad / u.Myr, units=galactic
    )

    x = np.array([[10.0, -0.2, 0.3], [-0.232, 8.1, 0.1934]]).T * u.kpc
    v = np.array([[0.0034, 0.2, 0.0014], [0.0001, 0.002532, -0.2]]).T * u.kpc / u.Myr

    # no frame specified at init
    psp = PhaseSpacePosition(pos=x, vel=v)
    with pytest.raises(ValueError):
        psp.to_frame(rotating)

    psp.to_frame(rotating, current_frame=static, t=0.4 * u.Myr)

    # frame specified at init
    psp = PhaseSpacePosition(pos=x, vel=v, frame=static)
    psp.to_frame(rotating, t=0.4 * u.Myr)


@pytest.mark.parametrize(
    &quot;obj&quot;,
    [
        PhaseSpacePosition([1, 2, 3.0] * u.kpc, [1, 2, 3.0] * u.km / u.s),
        PhaseSpacePosition(
            [1, 2, 3.0] * u.kpc, [1, 2, 3.0] * u.km / u.s, StaticFrame(units=galactic)
        ),
        PhaseSpacePosition(
            [1, 2, 3.0] * u.kpc,
            [1, 2, 3.0] * u.km / u.s,
            ConstantRotatingFrame(Omega=[1.0, 0, 0] * u.rad / u.Myr, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_H5PY, reason=&quot;h5py required for this test&quot;)
def test_io(tmpdir, obj):
    import h5py

    filename = str(tmpdir.join(&quot;thing.hdf5&quot;))
    with h5py.File(filename, &quot;w&quot;) as f:
        obj.to_hdf5(f)

    obj2 = PhaseSpacePosition.from_hdf5(filename)
    assert u.allclose(obj.xyz, obj2.xyz)
    assert u.allclose(obj.v_xyz, obj2.v_xyz)
    assert obj.frame == obj2.frame
</file>
    <file path="gala/dynamics/tests/test_nonlinear.py">
# Third-party
import numpy as np

# Project
from ... import potential as gp
from ...potential import Hamiltonian
from ..nonlinear import lyapunov_max, fast_lyapunov_max, surface_of_section
from ...integrate import DOPRI853Integrator
from ...units import galactic


class TestForcedPendulum(object):
    def setup_method(self):
        def F(t, x, A, omega_d):
            q, p = x
            return np.array([p, -np.sin(q) + A * np.cos(omega_d * t)])

        # initial conditions and parameter choices for chaotic / regular pendulum
        self.regular_w0 = np.array([1.0, 0.0])
        self.regular_par = (0.055, 0.7)
        self.regular_integrator = DOPRI853Integrator(F, func_args=self.regular_par)

        self.chaotic_w0 = np.array([3.0, 0.0])
        self.chaotic_par = (0.07, 0.75)
        self.chaotic_integrator = DOPRI853Integrator(F, func_args=self.chaotic_par)

    def test_lyapunov_max(self, tmpdir):
        n_steps = 20000
        dt = 1.0
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        regular_LEs, regular_orbit = lyapunov_max(
            self.regular_w0,
            self.regular_integrator,
            dt=dt,
            n_steps=n_steps,
            d0=d0,
            n_steps_per_pullback=n_steps_per_pullback,
            noffset_orbits=noffset,
        )

        regular_LEs = np.mean(regular_LEs, axis=1)
        assert regular_LEs[-1] &lt; 1e-3

        chaotic_LEs, chaotic_orbit = lyapunov_max(
            self.chaotic_w0,
            self.chaotic_integrator,
            dt=dt,
            n_steps=n_steps,
            d0=d0,
            n_steps_per_pullback=n_steps_per_pullback,
            noffset_orbits=noffset,
        )
        chaotic_LEs = np.mean(chaotic_LEs, axis=1)
        assert chaotic_LEs[-1] &gt; 1e-2

        # pl.figure()
        # pl.loglog(regular_LEs, marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;pend_regular.png&quot;))

        # pl.figure()
        # pl.plot(t, regular_ws[:, 0], marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;pend_orbit_regular.png&quot;))

        # pl.figure()
        # pl.loglog(chaotic_LEs, marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;pend_chaotic.png&quot;))

        # pl.figure()
        # pl.plot(t, chaotic_ws[:, 0], marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;pend_orbit_chaotic.png&quot;))

        # pl.close('all')


# --------------------------------------------------------------------


class HenonHeilesBase(object):
    def potential(self, w, A, B, C, D):
        x, y = w[:2]
        term1 = 0.5 * (A * x**2 + B * y**2)
        term2 = D * x**2 * y - C / 3.0 * y**3
        return term1 + term2

    def acceleration(self, w, A, B, C, D):
        x, y = w[:2]
        ax = -(A * x + 2 * D * x * y)
        ay = -(B * y + D * x * x - C * y * y)
        return np.array([ax, ay])

    def jerk(self, w, A, B, C, D):
        x, y = w[:2]
        dx, dy = w[4:6]

        dax = -(A + 2 * D * y) * dx - 2 * D * x * dy
        day = -2 * D * x * dx - (B - 2 * C * y) * dy

        return np.array([dax, day])

    def F_max(self, t, w, *args):
        x, y, px, py = w
        term1 = np.array([px, py])
        term2 = self.acceleration(w, *args)
        return np.vstack((term1, term2))

    def setup_method(self):
        # parameter choices
        self.par = (1.0, 1.0, 1.0, 1.0)
        self.n_steps = 2000
        self.dt = 2.0

    def test_integrate_orbit(self, tmpdir):
        integrator = DOPRI853Integrator(self.F_max, func_args=self.par)
        orbit = integrator(self.w0, dt=self.dt, n_steps=self.n_steps)

    def test_lyapunov_max(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        integrator = DOPRI853Integrator(self.F_max, func_args=self.par)
        lyap, orbit = lyapunov_max(
            self.w0,
            integrator,
            dt=self.dt,
            n_steps=self.n_steps,
            d0=d0,
            noffset_orbits=noffset,
            n_steps_per_pullback=n_steps_per_pullback,
        )
        lyap = np.mean(lyap, axis=1)

        # pl.clf()
        # pl.loglog(lyap, marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;hh_lyap_max_{}.png&quot;.format(self.__class__.__name__)))

        # pl.clf()
        # pl.plot(ws[..., 0], ws[..., 1], marker='')
        # pl.savefig(os.path.join(str(tmpdir),&quot;hh_orbit_lyap_max_{}.png&quot;.format(self.__class__.__name__)))


# initial conditions from LP-VI documentation:
class TestHenonHeilesStablePeriodic(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.295456, 0.407308431, 0.0])
        self.check = lambda x: x &lt; 1e-3


class TestHenonHeilesStableQuasi1(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.483, 0.27898039, 0.0])
        self.check = lambda x: x &lt; 2e-3


class TestHenonHeilesStableQuasi2(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.46912, 0.291124891, 0.0])
        self.check = lambda x: x &lt; 2e-3


class TestHenonHeilesStableChaos1(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.509, 0.254624859, 0.0])
        self.check = lambda x: x &gt; 2e-3


class TestHenonHeilesStableChaos2(HenonHeilesBase):
    def setup_method(self):
        super().setup_method()
        self.w0 = np.array([0.0, 0.56, 0.164113781, 0.112])
        self.check = lambda x: x &gt; 1e-2


# --------------------------------------------------------------------


class TestLogarithmic(object):
    def setup_method(self):

        # set the potential
        potential = gp.LogarithmicPotential(
            v_c=np.sqrt(2), r_h=0.1, q1=1.0, q2=0.9, q3=1.0, units=galactic
        )
        self.hamiltonian = Hamiltonian(potential)

        # see figure 1 from Papaphillipou &amp; Laskar
        x0 = -0.01
        X0 = -0.2
        y0 = 0.0
        E0 = -0.4059
        Y0 = np.squeeze(np.sqrt(E0 - self.hamiltonian.potential.energy([x0, y0, 0.0]).value))
        chaotic_w0 = [x0, y0, 0.0, X0, Y0, 0.0]

        # initial conditions from LP-VI documentation:
        self.w0s = np.array(
            [[0.49, 0.0, 0.0, 1.3156, 0.4788, 0.0], chaotic_w0]  # regular
        )  # chaotic

        self.n_steps = 25000
        self.dt = 0.004

    def test_fast_lyapunov_max(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        for ii, w0 in enumerate(self.w0s):
            print(ii, w0)
            lyap, orbit = fast_lyapunov_max(
                w0,
                self.hamiltonian,
                dt=self.dt,
                n_steps=self.n_steps,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
            )
            lyap = np.mean(lyap, axis=1)

            # also just integrate the orbit to compare dE scaling
            orbit2 = self.hamiltonian.integrate_orbit(
                w0, dt=self.dt, n_steps=self.n_steps, Integrator=DOPRI853Integrator
            )

            # lyapunov exp
            # pl.figure()
            # pl.loglog(lyap, marker='')
            # pl.savefig(os.path.join(str(tmpdir),&quot;log_lyap_max_{}.png&quot;.format(ii)))

            # energy conservation
            E = orbit[:, 0].energy().value  # returns 3 orbits
            dE = np.abs(E[1:] - E[0])

            E = orbit2.energy().value
            dE_ww = np.abs(E[1:] - E[0])

            # import matplotlib.pyplot as plt
            # plt.semilogy(dE, marker='')
            # plt.semilogy(dE_ww, marker='')

            # fig, axes = plt.subplots(1, 2, figsize=(10, 5))
            # axes[0].plot(orbit.pos[0, :, 0], orbit.pos[1, :, 0], marker='') # ignore offset orbits
            # axes[1].plot(orbit2.pos[0], orbit2.pos[1], marker='')
            # fig.savefig(os.path.join(str(tmpdir),&quot;log_orbit_lyap_max_{}.png&quot;.format(ii)))

            # plt.show()

            assert np.allclose(dE_ww[-100:], dE[-100:], rtol=1e-1)

    def test_compare_fast(self, tmpdir):
        n_steps_per_pullback = 10
        d0 = 1e-5
        noffset = 2

        def F(t, w):
            w_T = np.ascontiguousarray(w.T)
            return self.hamiltonian._gradient(w_T, np.array([t])).T

        integrator = DOPRI853Integrator(F)
        for ii, w0 in enumerate(self.w0s):
            lyap1, orbit1 = fast_lyapunov_max(
                w0,
                self.hamiltonian,
                dt=self.dt,
                n_steps=self.n_steps // 8,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
            )
            lyap1 = np.mean(lyap1, axis=1)

            # check energy conservation
            E = orbit1.energy().value
            dE_fast = np.abs(E[1:] - E[0])
            assert np.all(dE_fast[:, 0] &lt; 1e-10)

            lyap2, orbit2 = lyapunov_max(
                w0.copy(),
                integrator,
                dt=self.dt,
                n_steps=self.n_steps // 8,
                d0=d0,
                noffset_orbits=noffset,
                n_steps_per_pullback=n_steps_per_pullback,
                units=self.hamiltonian.units,
            )
            lyap2 = np.mean(lyap2, axis=1)

            # check energy conservation
            E = orbit2.energy(self.hamiltonian).value
            dE_slow = np.abs(E[1:] - E[0])

            if not np.all(dE_slow[:, 0] &lt; 1e-10):
                import matplotlib.pyplot as plt

                plt.figure()
                plt.plot(orbit2.pos[0, -128:, 0], orbit2.pos[1, -128:, 0], marker=&quot;.&quot;)
                plt.plot(orbit2.pos[0, -128:, 0], orbit2.pos[2, -128:, 0], marker=&quot;.&quot;)

                plt.figure()
                plt.semilogy(dE_slow[:, 0], marker=&quot;.&quot;)

                plt.show()

            assert np.all(dE_slow[:, 0] &lt; 1e-10)

            # plots
            # import matplotlib.pyplot as plt

            # plt.figure()
            # plt.loglog(orbit1.t[1:-10:10], lyap1, marker='')
            # plt.loglog(orbit2.t[1:-10:10], lyap2, marker='')
            # plt.savefig(os.path.join(str(tmpdir),&quot;log_lyap_compare_{}.png&quot;.format(ii)))

            # plt.figure()
            # plt.semilogy(dE_fast[:, 0], marker='')
            # plt.semilogy(dE_slow[:, 0], marker='')
            # # plt.savefig(os.path.join(str(tmpdir),&quot;log_dE_{}.png&quot;.format(ii)))

            # fig, axes = plt.subplots(1, 2, figsize=(6, 6))
            # axes[0].plot(orbit1.pos[0, :, 0], orbit1.pos[1, :, 0],
            #              marker='.', linestyle='none', alpha=0.1)
            # axes[1].plot(orbit2.pos[0, :, 0], orbit2.pos[1, :, 0],
            #              marker='.', linestyle='none', alpha=0.1)
            # plt.savefig(os.path.join(str(tmpdir),&quot;log_orbit_lyap_max_{}.png&quot;.format(ii)))

            # plt.show()
            # plt.close('all')


def test_surface_of_section():
    from ...potential import LogarithmicPotential
    from ...units import galactic

    pot = LogarithmicPotential(v_c=1.0, r_h=1.0, q1=1.0, q2=0.9, q3=0.8, units=galactic)

    w0 = np.array([0.0, 0.8, 0.0, 1.0, 0.0, 0.0])
    orbit = Hamiltonian(pot).integrate_orbit(w0, dt=0.02, n_steps=100_000)
    sos = surface_of_section(orbit, constant_idx=1)
    sos_cyl = surface_of_section(orbit.cylindrical, constant_idx=1)
</file>
    <file path="gala/dynamics/tests/test_orbit.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest
import scipy.optimize as so
from astropy.coordinates import (
    Galactic,
    SphericalCosLatDifferential,
    SphericalRepresentation,
)

from gala.tests.optional_deps import HAS_GALPY, HAS_H5PY

from ...integrate import DOPRI853Integrator
from ...potential import (
    Hamiltonian,
    HernquistPotential,
    KeplerPotential,
    LogarithmicPotential,
    NFWPotential,
)
from ...potential.frame import ConstantRotatingFrame, StaticFrame
from ...units import galactic, solarsystem

# Project
from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..util import combine


# Tests below should be cleaned up a bit...
def test_initialize():
    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 8))
        Orbit(pos=x, vel=v)

    with pytest.raises(ValueError):
        x = np.random.random(size=(3, 10))
        v = np.random.random(size=(3, 10))
        t = np.arange(8)
        Orbit(pos=x, vel=v, t=t)

    # TODO: always?
    # x = np.random.random(size=(3, 10))
    # v = np.random.random(size=(3, 10))
    # o = Orbit(pos=x, vel=v)
    # assert o.ndim == 3

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.km / u.s

    # TODO: don't support &lt; 3 dim?
    # x = np.random.random(size=(2, 10))
    # v = np.random.random(size=(2, 10))
    # o = Orbit(pos=x, vel=v)
    # assert o.ndim == 2
    # assert o.hamiltonian is None

    # Check that passing in frame and potential or Hamiltonian works
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    frame = StaticFrame(galactic)
    potential = LogarithmicPotential(
        v_c=1.0, r_h=0.14, q1=1.0, q2=0.9, q3=1.0, units=galactic
    )

    o = Orbit(pos=x, vel=v, frame=frame)
    assert o.hamiltonian is None
    assert o.potential is None

    o = Orbit(pos=x, vel=v, potential=potential)
    assert o.hamiltonian is None
    assert o.frame is None

    o = Orbit(pos=x, vel=v, potential=potential, frame=frame)
    o = Orbit(pos=x, vel=v, hamiltonian=Hamiltonian(potential, frame=frame))
    assert isinstance(o.hamiltonian, Hamiltonian)
    assert isinstance(o.potential, LogarithmicPotential)
    assert isinstance(o.frame, StaticFrame)


def test_from_w():
    w = np.random.random(size=(6, 10))
    o = Orbit.from_w(w, galactic)
    assert o.xyz.unit == u.kpc
    assert o.v_x.unit == u.kpc / u.Myr


def test_slice():
    # simple
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    new_o = o[:5]
    assert new_o.shape == (5,)

    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.linspace(0, 10, 10)
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5]
    assert new_o.shape == (5,)

    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5]
    assert new_o.shape == (5, 8)
    assert new_o.t.shape == (5,)

    # pick a single orbit
    new_o = o[:, 0]
    assert isinstance(new_o, Orbit)
    assert new_o.shape == (10,)
    assert new_o.t.shape == (10,)

    # pick a single time
    new_o = o[3]
    assert isinstance(new_o, PhaseSpacePosition)
    assert new_o.shape == (8,)

    # REGRESSION TEST: numpy int64 is not an int()
    new_o = o[np.int64(3)]
    assert isinstance(new_o, PhaseSpacePosition)
    assert new_o.shape == (8,)

    # 3d slice on 3d
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o[:5, :4]
    assert new_o.shape == (5, 4)
    assert new_o.t.shape == (5,)

    # boolean array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix),)
    assert new_o.t.shape == (5,)

    # boolean array - 3D
    x = np.random.random(size=(3, 10, 4))
    v = np.random.random(size=(3, 10, 4))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]).astype(bool)
    new_o = o[ix]
    assert new_o.shape == (sum(ix), x.shape[-1])
    assert new_o.t.shape == (5,)

    # integer array
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    ix = np.array([0, 3, 5])
    new_o = o[ix]
    assert new_o.shape == (len(ix),)
    assert new_o.t.shape == (len(ix),)


def test_reshape():
    # 1d slice on 3d
    x = np.random.random(size=(3, 10, 8))
    v = np.random.random(size=(3, 10, 8))
    t = np.arange(x.shape[1])
    o = Orbit(pos=x, vel=v, t=t)
    new_o = o.reshape((10, 4, 2))
    assert new_o.shape == (10, 4, 2)
    assert new_o.x.shape == (10, 4, 2)


def test_represent_as():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)

    assert sph.pos.distance.unit == u.one
    assert sph.vel.d_distance.unit == u.one

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    sph = o.represent_as(SphericalRepresentation)
    assert sph.pos.distance.unit == u.kpc
    assert sph.vel.d_distance.unit == u.km / u.s


def test_represent_as_expected_attributes():
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)

    new_o = o.spherical
    assert hasattr(new_o, &quot;distance&quot;)
    assert hasattr(new_o, &quot;lat&quot;)
    assert hasattr(new_o, &quot;lon&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_lat&quot;)
    assert hasattr(new_o, &quot;pm_lon&quot;)
    assert new_o.norbits == o.norbits

    new_o = o.represent_as(SphericalRepresentation, SphericalCosLatDifferential)
    assert hasattr(new_o, &quot;distance&quot;)
    assert hasattr(new_o, &quot;lat&quot;)
    assert hasattr(new_o, &quot;lon&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_lat&quot;)
    assert hasattr(new_o, &quot;pm_lon_coslat&quot;)

    new_o = o.physicsspherical
    assert hasattr(new_o, &quot;r&quot;)
    assert hasattr(new_o, &quot;phi&quot;)
    assert hasattr(new_o, &quot;theta&quot;)
    assert hasattr(new_o, &quot;radial_velocity&quot;)
    assert hasattr(new_o, &quot;pm_theta&quot;)
    assert hasattr(new_o, &quot;pm_phi&quot;)
    assert new_o.norbits == o.norbits

    new_o = o.cylindrical
    assert hasattr(new_o, &quot;rho&quot;)
    assert hasattr(new_o, &quot;phi&quot;)
    assert hasattr(new_o, &quot;z&quot;)
    assert hasattr(new_o, &quot;v_rho&quot;)
    assert hasattr(new_o, &quot;pm_phi&quot;)
    assert hasattr(new_o, &quot;v_z&quot;)
    assert new_o.norbits == o.norbits

    new_o = new_o.cartesian
    assert hasattr(new_o, &quot;x&quot;)
    assert hasattr(new_o, &quot;y&quot;)
    assert hasattr(new_o, &quot;z&quot;)
    assert hasattr(new_o, &quot;xyz&quot;)
    assert hasattr(new_o, &quot;v_x&quot;)
    assert hasattr(new_o, &quot;v_y&quot;)
    assert hasattr(new_o, &quot;v_z&quot;)
    assert hasattr(new_o, &quot;v_xyz&quot;)

    # Check that this works with the NDCartesian classes too
    x = np.random.random(size=(2, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(2, 10)) * u.km / u.s
    new_o = Orbit(pos=x, vel=v)

    assert hasattr(new_o, &quot;x1&quot;)
    assert hasattr(new_o, &quot;x2&quot;)
    assert hasattr(new_o, &quot;xyz&quot;)
    assert hasattr(new_o, &quot;v_x1&quot;)
    assert hasattr(new_o, &quot;v_x2&quot;)
    assert hasattr(new_o, &quot;v_xyz&quot;)


def test_to_coord_frame():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)

    with pytest.raises(u.UnitConversionError):
        o.to_coord_frame(Galactic())

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    coo = o.to_coord_frame(Galactic())
    assert coo.name == &quot;galactic&quot;

    # simple / with units and time
    x = np.random.random(size=(3, 128, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 128, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    coo = o.to_coord_frame(Galactic())
    assert coo.name == &quot;galactic&quot;


def test_w():
    # simple / unitless
    x = np.random.random(size=(3, 10))
    v = np.random.random(size=(3, 10))
    o = Orbit(pos=x, vel=v)
    w = o.w()
    assert w.shape == (6, 10)

    # simple / with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    with pytest.raises(ValueError):
        o.w()
    w = o.w(units=galactic)
    assert np.allclose(x.value, w[:3, :])
    assert np.allclose(v.value, (w[3:, :] * u.kpc / u.Myr).to(u.km / u.s).value)

    # simple / with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v, potential=p, frame=StaticFrame(galactic))
    w = o.w()
    assert np.allclose(x.value, w[:3, :])
    assert np.allclose(v.value, (w[3:, :] * u.kpc / u.Myr).to(u.km / u.s).value)

    w = o.w(units=solarsystem)
    assert np.allclose(x.value, (w[:3, :] * u.au).to(u.kpc).value)
    assert np.allclose(v.value, (w[3:, :] * u.au / u.yr).to(u.km / u.s).value)


def test_energy():
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    KE = o.kinetic_energy()
    assert KE.unit == (o.v_x.unit) ** 2
    assert KE.shape == o.pos.shape

    # with units and potential
    p = HernquistPotential(units=galactic, m=1e11, c=0.25)
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v, potential=p, frame=StaticFrame(galactic))
    o.potential_energy()
    o.energy()


def test_angular_momentum():
    # with units
    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.normal(0.0, 100.0, size=(3, 10)) * u.km / u.s
    o = Orbit(pos=x, vel=v)
    L = o.angular_momentum()
    assert L.unit == (o.v_x.unit * o.x.unit)
    assert L.shape == ((3,) + o.shape)


def test_eccentricity():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 2 * np.pi, 0.0] * u.au / u.yr
    )
    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)
    e = w.eccentricity()
    assert np.abs(e) &lt; 1e-3


def test_guiding_radius():
    q = [10.0, 0, 0] * u.kpc
    pot = HernquistPotential(m=1e10, c=10.0, units=galactic)
    vc = pot.circular_velocity(q).to_value(u.km / u.s)
    w0 = PhaseSpacePosition(pos=q, vel=[0.0, 1.3, 0.0] * vc)
    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.5, n_steps=1000, Integrator=DOPRI853Integrator)
    w.guiding_radius()

    # Check that orbit in non-axisymmetric potential raises a warning
    pot = NFWPotential(m=1e10, r_s=10.0, b=0.95, units=galactic)
    vc = pot.circular_velocity(q).to_value(u.km / u.s)
    w0 = PhaseSpacePosition(pos=q, vel=[0.0, 1.3, 0.0] * vc)
    ham = Hamiltonian(pot)
    orbit = ham.integrate_orbit(w0, dt=0.5, n_steps=1000, Integrator=DOPRI853Integrator)

    with pytest.warns(RuntimeWarning):
        orbit.guiding_radius()


def test_apocenter_pericenter_period():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 1.5 * np.pi, 0.0] * u.au / u.yr
    )

    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)

    apo = w.apocenter()
    per = w.pericenter()
    zmax = w.zmax()
    assert apo.shape == ()
    assert per.shape == ()
    assert zmax.shape == ()

    assert apo.unit == u.au
    assert per.unit == u.au
    assert zmax.unit == u.au
    assert apo &gt; per

    # see if they're where we expect
    E = np.mean(w.energy()).decompose(pot.units).value
    L = (
        np.mean(np.sqrt(np.sum(w.angular_momentum() ** 2, axis=0)))
        .decompose(pot.units)
        .value
    )

    def func(r):
        val = 2 * (E - pot.energy([r, 0, 0]).value[0]) - L**2 / r**2
        return val

    pred_apo = so.brentq(func, 0.9, 1.0)
    pred_per = so.brentq(func, 0.3, 0.5)

    assert np.allclose(apo.value, pred_apo, rtol=1e-2)
    assert np.allclose(per.value, pred_per, rtol=1e-2)

    # Return all peris, apos
    apos = w.apocenter(func=None)
    pers = w.pericenter(func=None)
    zmax = w.zmax(func=None)
    T = w.estimate_period()  # noqa

    dapo = np.std(apos) / np.mean(apos)
    assert (dapo &gt; 0) and np.allclose(dapo, 0.0, atol=1e-4)

    dper = np.std(pers) / np.mean(pers)
    assert (dper &gt; 0) and np.allclose(dper, 0.0, atol=1e-4)

    # Now try for expected behavior when multiple orbits are integrated:
    w0 = PhaseSpacePosition(
        pos=([[1, 0, 0.0], [1.1, 0, 0]] * u.au).T,
        vel=([[0.0, 1.5 * np.pi, 0.0], [0.0, 1.5 * np.pi, 0.0]] * u.au / u.yr).T,
    )

    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000)

    per = w.pericenter(approximate=True)
    apo = w.apocenter(approximate=True)
    zmax = w.zmax(approximate=True)
    ecc = w.eccentricity(approximate=True)  # noqa


def test_estimate_period():
    ntimes = 16384
    for true_T_R in [1.0, 2.0, 4.123]:
        t = np.linspace(0, 10.0, ntimes)
        R = 0.25 * np.sin(2 * np.pi / true_T_R * t) + 1.0
        phi = (2 * np.pi * t) % (2 * np.pi)

        pos = np.zeros((3, ntimes))
        pos[0] = R * np.cos(phi)
        pos[1] = R * np.sin(phi)
        vel = np.zeros_like(pos)

        orb = Orbit(pos * u.kpc, vel * u.kpc / u.Myr, t=t * u.Gyr)
        T = orb.estimate_period()
        assert &quot;x&quot; in T.colnames and &quot;y&quot; in T.colnames and &quot;z&quot; in T.colnames

        T = orb.cylindrical.estimate_period()
        assert np.allclose(T[&quot;rho&quot;].value, true_T_R, rtol=1e-3)
        assert np.allclose(T[&quot;phi&quot;].value, 1.0, rtol=1e-3)

    # TODO: remove this in next version
    from gala.util import GalaDeprecationWarning

    with pytest.warns(GalaDeprecationWarning):
        orb.estimate_period(radial=True)


def test_estimate_period_regression():
    pot = KeplerPotential(m=1.0, units=solarsystem)
    w0 = PhaseSpacePosition(
        pos=[1, 0, 0.0] * u.au, vel=[0.0, 1.5 * np.pi, 0.0] * u.au / u.yr
    )
    w0 = combine((w0, w0, w0))

    ham = Hamiltonian(pot)
    w = ham.integrate_orbit(w0, dt=0.01, n_steps=10000, Integrator=DOPRI853Integrator)
    T = w.estimate_period()
    print(T)


def make_known_orbits(tmpdir, xs, vxs, potential, names):
    # See Binney &amp; Tremaine (2008) Figure 3.8 and 3.9
    E = -0.337
    y = 0.0

    ws = []
    for x, vx, name in zip(xs, vxs, names):
        vy = np.sqrt(2 * (E - potential.energy([x, y, 0.0]).value))[0]
        w = [x, y, 0.0, vx, vy, 0.0]
        ws.append(w)
    ws = np.array(ws).T

    ham = Hamiltonian(potential)
    orbit = ham.integrate_orbit(ws, dt=0.05, n_steps=10000)

    return orbit


def test_circulation(tmpdir):
    potential = LogarithmicPotential(
        v_c=1.0, r_h=0.14, q1=1.0, q2=0.9, q3=1.0, units=galactic
    )

    # individual
    ws = make_known_orbits(tmpdir, [0.5, 0], [0.0, 1.5], potential, [&quot;loop&quot;, &quot;box&quot;])

    w1 = ws[:, 0]
    circ = w1.circulation()
    assert circ.shape == (3,)
    assert circ.sum() == 1

    w2 = ws[:, 1]
    circ = w2.circulation()
    assert circ.shape == (3,)
    assert circ.sum() == 0

    # try also for both, together
    circ = ws.circulation()
    assert circ.shape == (3, 2)
    assert np.allclose(circ.sum(axis=0), [1, 0])


def test_align_circulation():
    t = np.linspace(0, 100, 1024)
    w = np.zeros((6, 1024, 4))

    # loop around x axis
    w[1, :, 0] = np.cos(t)
    w[2, :, 0] = np.sin(t)
    w[4, :, 0] = -np.sin(t)
    w[5, :, 0] = np.cos(t)

    # loop around y axis
    w[0, :, 1] = -np.cos(t)
    w[2, :, 1] = np.sin(t)
    w[3, :, 1] = np.sin(t)
    w[5, :, 1] = np.cos(t)

    # loop around z axis
    w[0, :, 2] = np.cos(t)
    w[1, :, 2] = np.sin(t)
    w[3, :, 2] = -np.sin(t)
    w[4, :, 2] = np.cos(t)

    # box
    w[0, :, 3] = np.cos(t)
    w[1, :, 3] = -np.cos(0.5 * t)
    w[2, :, 3] = np.cos(0.25 * t)
    w[3, :, 3] = -np.sin(t)
    w[4, :, 3] = 0.5 * np.sin(0.5 * t)
    w[5, :, 3] = -0.25 * np.sin(0.25 * t)

    # First, individually
    for i in range(w.shape[2]):
        orb = Orbit.from_w(w[..., i], units=galactic)
        new_orb = orb.align_circulation_with_z()
        circ = new_orb.circulation()

        if i == 3:
            assert np.sum(circ) == 0
        else:
            assert circ[2] == 1.0

    # all together now
    orb = Orbit.from_w(w, units=galactic)
    circ = orb.circulation()
    assert circ.shape == (3, 4)

    new_orb = orb.align_circulation_with_z()
    new_circ = new_orb.circulation()
    assert np.all(new_circ[2, :3] == 1.0)
    assert np.all(new_circ[:, 3] == 0.0)


def test_frame_transform():
    static = StaticFrame(galactic)
    rotating = ConstantRotatingFrame(
        Omega=[0.53, 1.241, 0.9394] * u.rad / u.Myr, units=galactic
    )

    x = np.random.random(size=(3, 10)) * u.kpc
    v = np.random.random(size=(3, 10)) * u.km / u.s
    t = np.linspace(0, 1, 10) * u.Myr

    # no frame specified at init
    o = Orbit(pos=x, vel=v, t=t)
    with pytest.raises(ValueError):
        o.to_frame(rotating)

    o.to_frame(rotating, current_frame=static, t=o.t)
    o.to_frame(rotating, current_frame=static)

    # frame specified at init
    o = Orbit(
        pos=x,
        vel=v,
        t=t,
        frame=static,
        potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
    )
    o.to_frame(rotating)
    o.to_frame(rotating, t=o.t)


_x = ([[1, 2, 3.0], [1, 2, 3.0]] * u.kpc).T
_v = ([[1, 2, 3.0], [1, 2, 3.0]] * u.km / u.s).T


@pytest.mark.parametrize(
    &quot;obj&quot;,
    [  # noqa
        Orbit(_x, _v),
        Orbit(_x, _v, t=[5, 99] * u.Myr),
        Orbit(_x, _v, t=[5, 99] * u.Myr, frame=StaticFrame(galactic)),
        Orbit(
            _x,
            _v,
            t=[5, 99] * u.Myr,
            frame=StaticFrame(galactic),
            potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_H5PY, reason=&quot;h5py required for this test&quot;)
def test_io(tmpdir, obj):
    import h5py

    filename = str(tmpdir.join(&quot;thing.hdf5&quot;))
    with h5py.File(filename, &quot;w&quot;) as f:
        obj.to_hdf5(f)

    obj2 = Orbit.from_hdf5(filename)
    assert u.allclose(obj.xyz, obj2.xyz)
    assert u.allclose(obj.v_xyz, obj2.v_xyz)
    if obj.t is not None:
        assert u.allclose(obj.t, obj2.t)

    assert obj.frame == obj2.frame
    assert obj.potential == obj2.potential


@pytest.mark.parametrize(
    &quot;obj&quot;,
    [
        Orbit(_x, _v),
        Orbit(_x, _v, t=[5, 99] * u.Myr),
        Orbit(_x, _v, t=[5, 99] * u.Myr, frame=StaticFrame(galactic)),
        Orbit(
            _x,
            _v,
            t=[5, 99] * u.Myr,
            frame=StaticFrame(galactic),
            potential=HernquistPotential(m=1e10, c=0.5, units=galactic),
        ),
    ],
)
@pytest.mark.skipif(not HAS_GALPY, reason=&quot;requires galpy to run this test&quot;)
def test_orbit_to_galpy(obj):
    o1 = obj.to_galpy_orbit()  # noqa
    o2 = obj.to_galpy_orbit(ro=8 * u.kpc)  # noqa
    o3 = obj.to_galpy_orbit(vo=220 * u.km / u.s)  # noqa
    o4 = obj.to_galpy_orbit(ro=8 * u.kpc, vo=220 * u.km / u.s)  # noqa


@pytest.mark.skipif(not HAS_GALPY, reason=&quot;requires galpy to run this test&quot;)
def test_orbit_from_galpy():
    import galpy.orbit as galpy_o
    import galpy.potential as galpy_p

    mp = galpy_p.MiyamotoNagaiPotential(a=0.5, b=0.0375, amp=1.0, normalize=1.0)
    galpy_orbit = galpy_o.Orbit([1.0, 0.1, 1.1, 0.0, 0.1, 1.0])
    ts = np.linspace(0, 100, 10000)
    galpy_orbit.integrate(ts, mp, method=&quot;odeint&quot;)
    gala_orbit = Orbit.from_galpy_orbit(galpy_orbit)

    assert len(gala_orbit.t) == len(ts)
</file>
    <file path="gala/dynamics/tests/test_plot.py">
&quot;&quot;&quot; Test dynamics plotting functions &quot;&quot;&quot;

import subprocess

import astropy.units as u
import numpy as np
import pytest

from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..plot import plot_projections


def pytest_generate_tests(metafunc):
    if &quot;obj&quot; not in metafunc.fixturenames:
        return

    object_list = []

    norbits = 16
    object_list.append(
        PhaseSpacePosition(pos=np.random.random(size=3), vel=np.random.random(size=3))
    )
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(3, norbits)),
            vel=np.random.random(size=(3, norbits)),
        )
    )
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(3, norbits)) * u.kpc,
            vel=np.random.random(size=(3, norbits)) * u.km / u.s,
        )
    )

    nsteps = 16
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps)),
            vel=np.random.random(size=(3, nsteps)),
            t=np.linspace(0, 1, nsteps),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps, 2)),
            vel=np.random.random(size=(3, nsteps, 2)),
            t=np.linspace(0, 1, nsteps),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(3, nsteps)) * u.kpc,
            vel=np.random.random(size=(3, nsteps)) * u.km / u.s,
            t=np.linspace(0, 1, nsteps) * u.Myr,
        )
    )

    # 2D
    object_list.append(
        PhaseSpacePosition(
            pos=np.random.random(size=(2, norbits)),
            vel=np.random.random(size=(2, norbits)),
        )
    )
    object_list.append(
        Orbit(
            pos=np.random.random(size=(2, nsteps)),
            vel=np.random.random(size=(2, nsteps)),
            t=np.linspace(0, 1, nsteps),
        )
    )

    test_names = [f&quot;{obj.__class__.__name__}{i}&quot; for i, obj in enumerate(object_list)]

    metafunc.parametrize([&quot;i&quot;, &quot;obj&quot;], list(enumerate(object_list)), ids=test_names)


def test_plot_projections(i, obj):
    import matplotlib.pyplot as plt

    # Try executing the method - unfortunately no test of the actual figure
    # drawn!
    obj.plot()

    # Try with just 2D projection, and passing in a bunch of inputs...
    x = obj.xyz.value
    fig, axes = plt.subplots(1, 2)
    fig = plot_projections(
        x[:2],
        autolim=True,
        axes=axes,  # noqa
        subplots_kwargs=dict(sharex=True),
        labels=[&quot;x&quot;, &quot;y&quot;],
        plot_function=plt.plot,
        marker=&quot;o&quot;,
        linestyle=&quot;--&quot;,
        color=&quot;r&quot;,
    )


def test_animate(tmpdir, i, obj):
    if not isinstance(obj, Orbit):
        pytest.skip()

    try:
        proc = subprocess.run(
            [&quot;ffmpeg -version&quot;], shell=True, check=True, capture_output=True
        )
    except subprocess.CalledProcessError:
        pytest.skip(reason=&quot;ffmpeg not installed&quot;)

    if proc.returncode &gt; 0:
        pytest.skip(reason=&quot;ffmpeg not installed&quot;)

    # Try executing the method - unfortunately no test of the actual figure
    # drawn!
    fig, anim = obj.animate(segment_nsteps=3)
    anim.save(tmpdir / f&quot;anim{i}.mp4&quot;)

    # test hiding the timestep label
    fig, anim = obj.animate(segment_nsteps=3, show_time=False)
    anim.save(tmpdir / f&quot;anim{i}_no_time.mp4&quot;)

    if obj.ndim == 3:
        # Also try cylindrical, and sub-selecting components:
        fig, anim = obj.cylindrical.animate(components=[&quot;rho&quot;, &quot;z&quot;])
        anim.save(tmpdir / f&quot;anim{i}_cyl.mp4&quot;)
</file>
    <file path="gala/dynamics/tests/test_representation_nd.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..representation_nd import (NDCartesianRepresentation,
                                 NDCartesianDifferential)


def test_init_repr():

    # Passing in x1, x2
    rep = NDCartesianRepresentation([1., 1.])
    assert rep.xyz.shape == (2,)

    # Passing in x1, x2
    rep = NDCartesianRepresentation(np.random.random(size=(2, 8)))
    assert rep.xyz.shape == (2, 8)
    rep[:1]

    for n in range(1, 6+1):
        print('N: '+str(n))

        xs = np.random.uniform(size=(n, 16)) * u.one
        rep = NDCartesianRepresentation(xs)
        for i in range(1, n+1):
            assert hasattr(rep, 'x'+str(i))

        xs2 = rep.xyz
        assert u.allclose(xs, xs2)

        rep2 = rep[:8]

        assert rep.shape == (16,)
        assert rep2.shape == (8,)


def test_init_diff():

    # Passing in x1, x2
    rep = NDCartesianDifferential([1., 1.])
    assert rep.d_xyz.shape == (2,)
    with pytest.raises(TypeError):
        rep[:1]

    # Passing in x1, x2
    rep = NDCartesianDifferential(np.random.random(size=(2, 8)))
    assert rep.d_xyz.shape == (2, 8)
    rep[:1]

    for n in range(1, 6+1):
        print('N: '+str(n))

        xs = np.random.uniform(size=(n, 16)) * u.one
        rep = NDCartesianDifferential(xs)
        for i in range(1, n+1):
            assert hasattr(rep, 'd_x'+str(i))

        xs2 = rep.d_xyz
        assert u.allclose(xs, xs2)

        rep2 = rep[:8]

        assert rep.shape == (16,)
        assert rep2.shape == (8,)
</file>
    <file path="gala/dynamics/tests/test_util.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..core import PhaseSpacePosition
from ..orbit import Orbit
from ..util import peak_to_peak_period, estimate_dt_n_steps, combine
from ...potential import Hamiltonian, NFWPotential
from ...potential.frame import StaticFrame
from ...units import galactic


def test_peak_to_peak_period():
    ntimes = 16384

    # trivial test
    for true_T in [1., 2., 4.123]:
        t = np.linspace(0, 10., ntimes)
        f = np.sin(2*np.pi/true_T * t)
        T = peak_to_peak_period(t, f)
        assert np.allclose(T, true_T, atol=1E-3)

    # modulated trivial test
    true_T = 2.
    t = np.linspace(0, 10., ntimes)
    f = np.sin(2*np.pi/true_T * t) + 0.1*np.cos(2*np.pi/(10*true_T) * t)
    T = peak_to_peak_period(t, f)
    assert np.allclose(T, true_T, atol=1E-3)


def test_estimate_dt_n_steps():
    nperiods = 128
    pot = NFWPotential.from_circular_velocity(v_c=1., r_s=10., units=galactic)
    w0 = [10., 0., 0., 0., 0.9, 0.]

    H = Hamiltonian(pot)
    dt, n_steps = estimate_dt_n_steps(w0, H, n_periods=nperiods,
                                      n_steps_per_period=256,
                                      func=np.nanmin)

    orbit = H.integrate_orbit(w0, dt=dt, n_steps=n_steps)
    T = orbit.physicsspherical.estimate_period()['r']
    assert int(np.round((orbit.t.max()/T).decompose().value)) == nperiods


class TestCombine(object):

    def setup_method(self):
        x = np.random.random(size=(3,))
        v = np.random.random(size=(3,))
        p1 = PhaseSpacePosition(pos=x, vel=v)
        p2 = PhaseSpacePosition(pos=x, vel=v, frame=StaticFrame(galactic))
        x = np.random.random(size=(3, 5))
        v = np.random.random(size=(3, 5))
        p3 = PhaseSpacePosition(pos=x, vel=v)
        p4 = PhaseSpacePosition(pos=x*u.kpc, vel=v*u.km/u.s)
        x = np.random.random(size=(2, 5))
        v = np.random.random(size=(2, 5))
        p5 = PhaseSpacePosition(pos=x, vel=v)
        self.psps = [p1, p2, p3, p4, p5]

        x = np.random.random(size=(3, 8))
        v = np.random.random(size=(3, 8))
        o1 = Orbit(pos=x, vel=v)
        o2 = Orbit(pos=x, vel=v, t=np.arange(8))

        pot = NFWPotential.from_circular_velocity(v_c=1., r_s=10.,
                                                  units=galactic)
        o3 = Orbit(pos=x*u.kpc, vel=v*u.km/u.s, t=np.arange(8)*u.Myr,
                   potential=pot, frame=StaticFrame(galactic))

        x = np.random.random(size=(2, 8))
        v = np.random.random(size=(2, 8))
        o4 = Orbit(pos=x, vel=v, t=np.arange(8))
        self.orbs = [o1, o2, o3, o4]

    def test_combine_fail(self):

        with pytest.raises(ValueError):
            combine([])

        with pytest.raises(ValueError):
            combine(self.psps[0])

        with pytest.raises(TypeError):
            combine([self.psps[0], self.orbs[0]])

        with pytest.raises(TypeError):
            combine([5, 5, 5])

        with pytest.raises(ValueError):
            combine(self.psps)

        with pytest.raises(ValueError):
            combine(self.orbs)

    def test_combine_psp(self):

        for psp in self.psps:
            psps = [psp] * 3
            new_psp = combine(psps)
            assert new_psp.ndim == psp.ndim

            if psp.pos.shape:
                shp = psp.pos.shape
            else:
                shp = (1,)

            assert new_psp.pos.shape == (3*shp[0],)
            assert new_psp.frame == psp.frame

    def test_combine_orb(self):

        for orb in self.orbs:
            orbs = [orb] * 4
            new_orb = combine(orbs)
            assert new_orb.ndim == orb.ndim

            shp = orb.shape
            if len(shp) &lt; 2:
                shp = shp + (4,)

            else:
                shp = shp[:-1] + (4*shp[-1],)

            assert new_orb.pos.shape == shp
            assert new_orb.frame == orb.frame
            assert new_orb.potential == orb.potential
</file>
    <file path="gala/integrate/tests/test_cyintegrators.py">
&quot;&quot;&quot;
    Test the Cython integrators.
&quot;&quot;&quot;

# Standard library
from itertools import product
import time

# Third-party
import numpy as np
import pytest

# Project
from ..pyintegrators.leapfrog import LeapfrogIntegrator
from ..cyintegrators.leapfrog import leapfrog_integrate_hamiltonian
from ..pyintegrators.dopri853 import DOPRI853Integrator
from ..cyintegrators.dop853 import dop853_integrate_hamiltonian
from ..pyintegrators.ruth4 import Ruth4Integrator
from ..cyintegrators.ruth4 import ruth4_integrate_hamiltonian
from ...potential import Hamiltonian, HernquistPotential
from ...units import galactic

integrator_list = [LeapfrogIntegrator, DOPRI853Integrator, Ruth4Integrator]
func_list = [
    leapfrog_integrate_hamiltonian,
    dop853_integrate_hamiltonian,
    ruth4_integrate_hamiltonian,
]

_list = []
for dt in [2, -2]:
    _list.extend([(x, y, dt) for x, y in zip(integrator_list, func_list)])


@pytest.mark.parametrize(
    [&quot;Integrator&quot;, &quot;integrate_func&quot;, &quot;dt&quot;],
    _list
)
def test_compare_to_py(Integrator, integrate_func, dt):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)
    H = Hamiltonian(potential=p)

    def F(t, w):
        w_T = np.ascontiguousarray(w.T)
        return H._gradient(w_T, np.array([0.0])).T

    cy_w0 = np.array(
        [
            [0.0, 10.0, 0.0, 0.2, 0.0, 0.0],
            [10.0, 0.0, 0.0, 0.0, 0.2, 0.0],
            [0.0, 10.0, 0.0, 0.0, 0.0, 0.2],
        ]
    )
    py_w0 = np.ascontiguousarray(cy_w0.T)

    n_steps = 1024
    t = np.linspace(0, dt * n_steps, n_steps + 1)

    cy_t, cy_w = integrate_func(H, cy_w0, t)
    cy_w = np.rollaxis(cy_w, -1)

    integrator = Integrator(F)
    orbit = integrator(py_w0, dt=dt, n_steps=n_steps)

    py_t = orbit.t.value
    py_w = orbit.w()

    assert py_w.shape == cy_w.shape
    assert np.allclose(cy_w[:, -1], py_w[:, -1])
    assert np.allclose(cy_t, py_t)


@pytest.mark.parametrize(
    [&quot;integrate_func&quot;, &quot;dt&quot;],
    product(func_list, [-2., 2])
)
def test_store_all(integrate_func, dt):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)
    H = Hamiltonian(potential=p)

    w0 = np.array(
        [
            [0.0, 10.0, 0.0, 0.2, 0.0, 0.0],
            [10.0, 0.0, 0.0, 0.0, 0.2, 0.0],
            [0.0, 10.0, 0.0, 0.0, 0.0, 0.2],
        ]
    )

    # 1024 steps
    t = np.linspace(0, dt * 1024, 1024 + 1)

    t_all, w_all = integrate_func(H, w0, t)
    t_f, w_f = integrate_func(H, w0, t, store_all=False)

    assert t_all[-1] == t_f[0]
    assert np.allclose(w_all[-1], w_f)


# TODO: move this to only run if a flag like --remote-data is passed, like
# --speed-scaling or something?
@pytest.mark.skipif(True, reason=&quot;Slow test - mainly for plotting locally&quot;)
@pytest.mark.parametrize(
    [&quot;Integrator&quot;, &quot;integrate_func&quot;],
    zip(integrator_list, func_list)
)
def test_scaling(tmpdir, Integrator, integrate_func):
    p = HernquistPotential(m=1e11, c=0.5, units=galactic)

    def F(t, w):
        dq = w[3:]
        dp = -p._gradient(w[:3], t=np.array([0.0]))
        return np.vstack((dq, dp))

    step_bins = np.logspace(2, np.log10(25000), 7)
    colors = [&quot;k&quot;, &quot;b&quot;, &quot;r&quot;]
    dt = 1.0

    for c, nparticles in zip(colors, [1, 100, 1000]):
        cy_w0 = np.array([[0.0, 10.0, 0.0, 0.2, 0.0, 0.0]] * nparticles)
        py_w0 = np.ascontiguousarray(cy_w0.T)

        x = []
        cy_times = []
        py_times = []
        for n_steps in step_bins:
            print(nparticles, n_steps)
            t = np.linspace(0, dt * n_steps, n_steps + 1)
            x.append(n_steps)

            # time the Cython integration
            t0 = time.time()
            integrate_func(p.c_instance, cy_w0, t)
            cy_times.append(time.time() - t0)

            # time the Python integration
            t0 = time.time()
            integrator = Integrator(F)
            orbit = integrator(py_w0, dt=dt, n_steps=n_steps)
            py_times.append(time.time() - t0)

    #     pl.loglog(x, cy_times, linestyle='-', lw=2., c=c, marker='',
    #               label=&quot;cy: {} orbits&quot;.format(nparticles))
    #     pl.loglog(x, py_times, linestyle='--', lw=2., c=c, marker='',
    #               label=&quot;py: {} orbits&quot;.format(nparticles))

    # pl.title(Integrator.__name__)
    # pl.legend(loc='upper left')
    # pl.xlim(90, 30000)
    # pl.xlabel(&quot;N steps&quot;)
    # pl.tight_layout()
    # # pl.show()
    # pl.savefig(os.path.join(tmpdir, &quot;integrate-scaling.png&quot;), dpi=300)
</file>
    <file path="gala/integrate/tests/test_pyintegrators.py">
&quot;&quot;&quot;
    Test the integrators.
&quot;&quot;&quot;
import os

# Third-party
import pytest
import numpy as np
from astropy.utils.exceptions import AstropyDeprecationWarning

# Project
from .. import (
    LeapfrogIntegrator,
    RK5Integrator,
    DOPRI853Integrator,
    Ruth4Integrator,
)
from gala.tests.optional_deps import HAS_TQDM

# Integrators to test
integrator_list = [
    RK5Integrator,
    DOPRI853Integrator,
    LeapfrogIntegrator,
    Ruth4Integrator,
]

# Gradient functions:
def sho_F(t, w, T):  # noqa
    &quot;&quot;&quot;Simple harmonic oscillator&quot;&quot;&quot;
    q, p = w
    wdot = np.zeros_like(w)
    wdot[0] = p
    wdot[1] = -((2 * np.pi / T) ** 2) * q
    return wdot


def forced_sho_F(t, w, A, omega_d):
    q, p = w
    wdot = np.zeros_like(w)
    wdot[0] = p
    wdot[1] = -np.sin(q) + A * np.cos(omega_d * t)
    return wdot


def lorenz_F(t, w, sigma, rho, beta):
    x, y, z, *_ = w
    wdot = np.zeros_like(w)
    wdot[0] = sigma * (y - x)
    wdot[1] = x * (rho - z) - y
    wdot[2] = x * y - beta * z
    return wdot


def ptmass_F(t, w):
    x, y, px, py = w
    a = -1.0 / (x * x + y * y) ** 1.5

    wdot = np.zeros_like(w)
    wdot[0] = px
    wdot[1] = py
    wdot[2] = x * a
    wdot[3] = y * a
    return wdot


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_sho_forward_backward(Integrator):
    integrator = Integrator(sho_F, func_args=(1.0,))

    dt = 1e-4
    n_steps = 10_000

    forw = integrator([0.0, 1.0], dt=dt, n_steps=n_steps)
    back = integrator([0.0, 1.0], dt=-dt, n_steps=n_steps)

    assert np.allclose(forw.w()[:, -1], back.w()[:, -1], atol=1e-6)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_deprecated_run_method(Integrator):
    &quot;&quot;&quot;Test the deprecated run method.&quot;&quot;&quot;
    integrator = Integrator(sho_F, func_args=(1.0,))

    dt = 1e-4
    n_steps = 10_000

    with pytest.warns(AstropyDeprecationWarning):
        run = integrator.run([0.0, 1.0], dt=dt, n_steps=n_steps)

    call = integrator([0.0, 1.0], dt=dt, n_steps=n_steps)

    assert np.allclose(run.w()[:, -1], call.w()[:, -1], atol=1e-6)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_point_mass(Integrator):
    q0 = np.array([1.0, 0.0])
    p0 = np.array([0.0, 1.0])

    integrator = Integrator(ptmass_F)
    orbit = integrator(np.append(q0, p0), t1=0.0, t2=2 * np.pi, n_steps=1e4)

    assert np.allclose(orbit.w()[:, 0], orbit.w()[:, -1], atol=1e-6)


@pytest.mark.skipif(not HAS_TQDM, reason=&quot;requires tqdm to run this test&quot;)
@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_progress(Integrator):
    q0 = np.array([1.0, 0.0])
    p0 = np.array([0.0, 1.0])

    integrator = Integrator(ptmass_F, progress=True)
    _ = integrator(np.append(q0, p0), t1=0.0, t2=2 * np.pi, n_steps=1e2)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_point_mass_multiple(Integrator):
    w0 = np.array(
        [[1.0, 0.0, 0.0, 1.0], [0.8, 0.0, 0.0, 1.1], [2.0, 1.0, -1.0, 1.1]]
    ).T

    integrator = Integrator(ptmass_F)
    _ = integrator(w0, dt=1e-3, n_steps=1e4)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_driven_pendulum(Integrator):
    integrator = Integrator(forced_sho_F, func_args=(0.07, 0.75))
    _ = integrator([3.0, 0.0], dt=1e-2, n_steps=1e4)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_lorenz(Integrator):
    sigma, rho, beta = 10.0, 28.0, 8 / 3.0
    integrator = Integrator(lorenz_F, func_args=(sigma, rho, beta))

    _ = integrator([0.5, 0.5, 0.5, 0, 0, 0], dt=1e-2, n_steps=1e4)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_memmap(tmpdir, Integrator):
    dt = 0.1
    n_steps = 1000
    nw0 = 10000

    filename = os.path.join(str(tmpdir), &quot;test_memmap.npy&quot;)
    mmap = np.memmap(filename, mode=&quot;w+&quot;, shape=(2, n_steps + 1, nw0))

    w0 = np.random.uniform(-1, 1, size=(2, nw0))

    integrator = Integrator(sho_F, func_args=(1.0,))

    _ = integrator(w0, dt=dt, n_steps=n_steps, mmap=mmap)


@pytest.mark.parametrize(&quot;Integrator&quot;, integrator_list)
def test_py_store_all(Integrator):
    integrator_all = Integrator(sho_F, func_args=(1.3,), store_all=True)
    integrator_final = Integrator(sho_F, func_args=(1.3,), store_all=False)

    dt = 1e-4
    n_steps = 10_000

    out_all = integrator_all([0.0, 1.0], dt=dt, n_steps=n_steps)
    out_final = integrator_final([0.0, 1.0], dt=dt, n_steps=n_steps)

    assert np.allclose(out_all.w()[:, -1], out_final.w()[:, 0])
</file>
    <file path="gala/integrate/tests/test_timespec.py">
&quot;&quot;&quot;
    Test the time specification parser.
&quot;&quot;&quot;

# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..timespec import parse_time_specification
from ...units import DimensionlessUnitSystem, galactic


def test_dt_n_steps():
    # dt, n_steps[, t1] : (numeric, int[, numeric])
    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, n_steps=100)
    np.testing.assert_allclose(np.min(t), 0.)
    np.testing.assert_allclose(np.max(t), 10.)
    assert len(t) == 101

    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, n_steps=100, t1=10.)
    np.testing.assert_allclose(np.min(t), 10.)
    np.testing.assert_allclose(np.max(t), 20.)
    assert len(t) == 101


def test_dt_t1_t2():
    # dt, t1, t2 : (numeric, numeric, numeric)
    t = parse_time_specification(DimensionlessUnitSystem(), dt=0.1, t1=10., t2=130.)
    np.testing.assert_allclose(np.min(t), 10.)
    np.testing.assert_allclose(np.max(t), 130.)

    t = parse_time_specification(DimensionlessUnitSystem(), dt=-0.1, t1=10., t2=-13.412)
    np.testing.assert_allclose(np.min(t), -13.412)
    np.testing.assert_allclose(np.max(t), 10.)

    with pytest.raises(ValueError):
        parse_time_specification(DimensionlessUnitSystem(), dt=-0.1, t1=10., t2=130.)

    with pytest.raises(ValueError):
        parse_time_specification(DimensionlessUnitSystem(), dt=0.1, t1=130., t2=-10.142)


def test_n_steps_t1_t2():
    # n_steps, t1, t2 : (int, numeric, numeric)
    t = parse_time_specification(DimensionlessUnitSystem(), n_steps=100, t1=24.124, t2=91.412)
    np.testing.assert_allclose(np.min(t), 24.124)
    np.testing.assert_allclose(np.max(t), 91.412)

    t = parse_time_specification(DimensionlessUnitSystem(), n_steps=100, t1=24.124, t2=-91.412)
    np.testing.assert_allclose(np.max(t), 24.124)
    np.testing.assert_allclose(np.min(t), -91.412)


def test_t():
    # t : array_like
    input = np.arange(0., 10., 0.1)
    t = parse_time_specification(DimensionlessUnitSystem(), t=input)
    assert (t == input).all()


def test_t_units():
    # t : array_like
    input = np.linspace(0., 10., 100)*u.Gyr
    t = parse_time_specification(galactic, t=input)

    assert np.allclose(t[-1], 10000.)
</file>
    <file path="gala/potential/frame/tests/test_builtin.py">
import pickle

# Third-party
import astropy.units as u
import pytest

# Project
from ..builtin import StaticFrame, ConstantRotatingFrame
from ....units import galactic, DimensionlessUnitSystem


class TestStaticFrame(object):

    def test_init(self):
        fr = StaticFrame()
        assert isinstance(fr.units, DimensionlessUnitSystem)

        fr = StaticFrame(galactic)

    def test_compare(self):
        fr1 = StaticFrame(galactic)
        fr2 = StaticFrame(galactic)
        assert fr1 == fr2

        fr2 = StaticFrame()
        assert fr1 != fr2

    def test_pickle(self, tmpdir):
        fr1 = StaticFrame(galactic)

        filename = tmpdir / 'static.pkl'
        with open(filename, 'wb') as f:
            pickle.dump(fr1, f)

        with open(filename, 'rb') as f:
            fr2 = pickle.load(f)

        assert fr1 == fr2


class TestConstantRotatingFrame(object):

    def test_init(self):
        fr = ConstantRotatingFrame(Omega=[1E-3, 0., 0.])
        assert isinstance(fr.units, DimensionlessUnitSystem)

        fr = ConstantRotatingFrame(Omega=1E-3)
        assert isinstance(fr.units, DimensionlessUnitSystem)

        with pytest.raises(ValueError):
            fr = ConstantRotatingFrame(Omega=[-13., 1., 40.]*u.km/u.s/u.kpc)

        with pytest.raises(ValueError):
            fr = ConstantRotatingFrame(Omega=40.*u.km/u.s/u.kpc)

        fr = ConstantRotatingFrame(Omega=[-13., 1., 40.]*u.km/u.s/u.kpc,
                                   units=galactic)
        fr = ConstantRotatingFrame(Omega=40.*u.km/u.s/u.kpc,
                                   units=galactic)
        fr = ConstantRotatingFrame([-13., 1., 40.]*u.km/u.s/u.kpc,
                                   units=galactic)

    def test_compare(self):
        # frame comparison
        fr1 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)
        fr2 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)
        fr3 = ConstantRotatingFrame(Omega=[2E-3, 0., 0.]/u.Myr, units=galactic)
        fr4 = ConstantRotatingFrame(Omega=[2E-3, 0., 0.])
        assert fr1 == fr2
        assert fr1 != fr3
        assert fr3 != fr4

        st_fr = StaticFrame(galactic)
        assert st_fr != fr1

        st_fr = StaticFrame(DimensionlessUnitSystem())
        assert st_fr != fr1

    def test_pickle(self, tmpdir):
        fr1 = ConstantRotatingFrame(Omega=[1E-3, 0., 0.]/u.Myr, units=galactic)

        filename = tmpdir / 'rotating.pkl'
        with open(filename, 'wb') as f:
            pickle.dump(fr1, f)

        with open(filename, 'rb') as f:
            fr2 = pickle.load(f)

        assert fr1 == fr2
</file>
    <file path="gala/potential/frame/tests/test_transformations.py">
# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from ..builtin import StaticFrame, ConstantRotatingFrame
from ..builtin.transformations import (static_to_constantrotating,
                                       constantrotating_to_static,
                                       rodrigues_axis_angle_rotate)
from ....dynamics import Orbit, PhaseSpacePosition
from ....units import galactic


def test_axis_angle_rotate():

    for x in [np.random.random(size=(3, 32)),
              np.random.random(size=(3, 32, 8))]:
        vec = np.random.random(size=(3, 32))
        theta = np.random.random(size=(32,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape

        vec = np.random.random(size=(3,))
        theta = np.random.random(size=(32,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape

        vec = np.random.random(size=(3,))
        theta = np.random.random(size=(1,))
        out = rodrigues_axis_angle_rotate(x, vec, theta)
        assert out.shape == x.shape


def _helper(fi, fr, w, t=None):

    pos_r, vel_r = static_to_constantrotating(fi, fr, w, t=t)
    if isinstance(w, Orbit):
        w2 = Orbit(pos=pos_r, vel=vel_r, t=t)
    else:
        w2 = PhaseSpacePosition(pos=pos_r, vel=vel_r)
    pos_i, vel_i = constantrotating_to_static(fr, fi, w2, t=t)

    assert u.allclose(pos_i, w.xyz)
    assert u.allclose(vel_i, w.v_xyz)

    pos_i, vel_i = constantrotating_to_static(fr, fi, w, t=t)
    if isinstance(w, Orbit):
        w2 = Orbit(pos=pos_i, vel=vel_i, t=t)
    else:
        w2 = PhaseSpacePosition(pos=pos_i, vel=vel_i)
    pos_r, vel_r = static_to_constantrotating(fi, fr, w2, t=t)

    assert u.allclose(pos_r, w.xyz)
    assert u.allclose(vel_r, w.v_xyz)


def test_frame_transforms_3d():
    frame_i = StaticFrame(units=galactic)
    frame_r = ConstantRotatingFrame(Omega=[0.112, 1.235, 0.8656]*u.rad/u.Myr,
                                    units=galactic)

    w = Orbit(pos=np.random.random(size=(3, 32))*u.kpc,
              vel=np.random.random(size=(3, 32))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = Orbit(pos=np.random.random(size=(3, 32, 8))*u.kpc,
              vel=np.random.random(size=(3, 32, 8))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = PhaseSpacePosition(pos=np.random.random(size=3)*u.kpc,
                           vel=np.random.random(size=3)*u.kpc/u.Myr)
    with pytest.raises(ValueError):
        _helper(frame_i, frame_r, w)
    _helper(frame_i, frame_r, w, t=0.*u.Myr)
    _helper(frame_i, frame_r, w, t=0.)


def test_frame_transforms_2d():
    frame_i = StaticFrame(units=galactic)
    frame_r = ConstantRotatingFrame(Omega=0.529*u.rad/u.Myr,
                                    units=galactic)

    w = Orbit(pos=np.random.random(size=(2, 32))*u.kpc,
              vel=np.random.random(size=(2, 32))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = Orbit(pos=np.random.random(size=(2, 32, 8))*u.kpc,
              vel=np.random.random(size=(2, 32, 8))*u.kpc/u.Myr,
              t=np.linspace(0, 1, 32)*u.Myr)
    _helper(frame_i, frame_r, w, t=w.t)

    w = PhaseSpacePosition(pos=np.random.random(size=2)*u.kpc,
                           vel=np.random.random(size=2)*u.kpc/u.Myr)
    with pytest.raises(ValueError):
        _helper(frame_i, frame_r, w)
    _helper(frame_i, frame_r, w, t=0.*u.Myr)
    _helper(frame_i, frame_r, w, t=0.)
</file>
    <file path="gala/potential/hamiltonian/tests/helpers.py">
# Third-party
import astropy.units as u
import numpy as np

# Project
from ....dynamics import PhaseSpacePosition, Orbit
from ....units import galactic
PSP = PhaseSpacePosition
ORB = Orbit


class _TestBase(object):
    use_half_ndim = False
    E_unit = u.erg/u.kg

    @classmethod
    def setup_class(cls):
        np.random.seed(42)

        ndim = 6
        r_ndim = ndim  # return ndim
        if cls.use_half_ndim:
            r_ndim = r_ndim // 2
        norbits = 16
        ntimes = 8

        # some position or phase-space position arrays we will test methods on:
        cls.w0s = []
        cls.energy_return_shapes = []
        cls.gradient_return_shapes = []
        cls.hessian_return_shapes = []

        # 1D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=ndim//2),
                           vel=np.random.random(size=ndim//2)))
        cls.w0s.append(PSP(pos=np.random.random(size=ndim//2)*u.kpc,
                           vel=np.random.random(size=ndim//2)*u.km/u.s))
        cls.energy_return_shapes += [(1,)]*2
        cls.gradient_return_shapes += [(r_ndim, 1)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, 1)]*2

        # 2D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits)),
                           vel=np.random.random(size=(ndim//2, norbits))))
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits))*u.kpc,
                           vel=np.random.random(size=(ndim//2, norbits))*u.km/u.s))
        cls.energy_return_shapes += [(norbits,)]*2
        cls.gradient_return_shapes += [(r_ndim, norbits)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, norbits)]*2

        # 3D - phase-space position
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits, ntimes)),
                           vel=np.random.random(size=(ndim//2, norbits, ntimes))))
        cls.w0s.append(PSP(pos=np.random.random(size=(ndim//2, norbits, ntimes))*u.kpc,
                           vel=np.random.random(size=(ndim//2, norbits, ntimes))*u.km/u.s))
        cls.energy_return_shapes += [(norbits, ntimes)]*2
        cls.gradient_return_shapes += [(r_ndim, norbits, ntimes)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, norbits, ntimes)]*2

        # 2D - orbit
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes)),
                           vel=np.random.random(size=(ndim//2, ntimes))))
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes))*u.kpc,
                           vel=np.random.random(size=(ndim//2, ntimes))*u.km/u.s))
        cls.energy_return_shapes += [(ntimes,)]*2
        cls.gradient_return_shapes += [(r_ndim, ntimes,)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, ntimes,)]*2

        # 3D - orbit
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes, norbits)),
                           vel=np.random.random(size=(ndim//2, ntimes, norbits))))
        cls.w0s.append(ORB(pos=np.random.random(size=(ndim//2, ntimes, norbits))*u.kpc,
                           vel=np.random.random(size=(ndim//2, ntimes, norbits))*u.km/u.s))
        cls.energy_return_shapes += [(ntimes, norbits)]*2
        cls.gradient_return_shapes += [(r_ndim, ntimes, norbits)]*2
        cls.hessian_return_shapes += [(r_ndim, r_ndim, ntimes, norbits)]*2

        _obj_w0s = cls.w0s[:]
        for w0, eshp, gshp, hshp in zip(_obj_w0s,
                                        cls.energy_return_shapes,
                                        cls.gradient_return_shapes,
                                        cls.hessian_return_shapes):
            cls.w0s.append(w0.w(galactic))
            cls.energy_return_shapes.append(eshp)
            cls.gradient_return_shapes.append(gshp)
            cls.hessian_return_shapes.append(hshp)

    def test_energy(self):
        for arr, shp in zip(self.w0s, self.energy_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            v = self.obj.energy(arr)
            assert v.shape == shp
            assert v.unit.is_equivalent(self.E_unit)

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            self.obj.energy(arr, t=0.1)
            self.obj.energy(arr, t=t)
            self.obj.energy(arr, t=0.1*self.obj.units['time'])

    def test_gradient(self):
        for arr, shp in zip(self.w0s, self.gradient_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            v = self.obj.gradient(arr)
            assert v.shape == shp
            # TODO: check return units

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            self.obj.gradient(arr, t=0.1)
            self.obj.gradient(arr, t=t)
            self.obj.gradient(arr, t=0.1*self.obj.units['time'])

    def test_hessian(self):
        for arr, shp in zip(self.w0s, self.hessian_return_shapes):
            if self.E_unit.is_equivalent(u.one) and hasattr(arr, 'pos') and \
                    not arr.xyz.unit.is_equivalent(u.one):
                continue

            g = self.obj.hessian(arr)
            assert g.shape == shp
            # TODO: check return units
</file>
    <file path="gala/potential/hamiltonian/tests/test_hamiltonian.py">
import pickle

# Third-party
import astropy.units as u
import pytest

# Project
from .. import Hamiltonian
from ...potential.builtin import KeplerPotential
from ...frame.builtin import StaticFrame, ConstantRotatingFrame
from ....units import solarsystem, galactic


def test_init():
    p = KeplerPotential(m=1.)
    f = StaticFrame()
    H = Hamiltonian(potential=p, frame=f)
    H2 = Hamiltonian(H)
    assert H2.potential is H.potential

    p = KeplerPotential(m=1., units=solarsystem)
    f = StaticFrame(units=solarsystem)
    H = Hamiltonian(potential=p, frame=f)
    H = Hamiltonian(potential=p)

    p = KeplerPotential(m=1.)
    f = StaticFrame(galactic)
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)

    p = KeplerPotential(m=1., units=solarsystem)
    f = StaticFrame()
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)

    p = KeplerPotential(m=1., units=solarsystem)
    f = ConstantRotatingFrame(Omega=1./u.yr, units=solarsystem)
    with pytest.raises(ValueError):
        H = Hamiltonian(potential=p, frame=f)


def test_pickle(tmpdir):
    filename = tmpdir / 'hamil.pkl'

    p = KeplerPotential(m=1., units=solarsystem)

    for fr in [StaticFrame(units=solarsystem),
               ConstantRotatingFrame(Omega=[0, 0, 1]/u.yr, units=solarsystem)]:
        H = Hamiltonian(potential=p, frame=fr)

        with open(filename, 'wb') as f:
            pickle.dump(H, f)

        with open(filename, 'rb') as f:
            H2 = pickle.load(f)
</file>
    <file path="gala/potential/hamiltonian/tests/test_with_frame_potential.py">
# Third-party
import astropy.units as u
import pytest
import numpy as np

# Project
from .helpers import _TestBase
from .. import Hamiltonian
from ...potential.builtin import NFWPotential, KeplerPotential, HernquistPotential
from ...frame.builtin import StaticFrame, ConstantRotatingFrame
from ....units import galactic, dimensionless
from ....dynamics import PhaseSpacePosition, Orbit
from ....integrate import DOPRI853Integrator

# ----------------------------------------------------------------------------


def to_rotating_frame(omega, w, t=None):
    &quot;&quot;&quot;
    TODO: figure out units shit for omega and t
    TODO: move this to be a ConstantRotatingFrame method
    &quot;&quot;&quot;

    if not hasattr(omega, 'unit'):
        raise TypeError(&quot;Input frequency vector must be a Quantity object.&quot;)

    try:
        omega = omega.to(u.rad/u.Myr, equivalencies=u.dimensionless_angles()).value
    except:  # noqa
        omega = omega.value

    if isinstance(w, Orbit) and t is not None:
        raise TypeError(&quot;If passing in an Orbit object, do not also specify &quot;
                        &quot;a time array, t.&quot;)

    elif not isinstance(w, Orbit) and t is None:
        raise TypeError(&quot;If not passing in an Orbit object, you must also specify &quot;
                        &quot;a time array, t.&quot;)

    elif t is not None and not hasattr(t, 'unit'):
        raise TypeError(&quot;Input time must be a Quantity object.&quot;)

    if t is not None:
        t = np.atleast_1d(t)  # works with Quantity's
    else:
        t = w.t

    try:
        t = t.to(u.Myr).value
    except:  # noqa
        t = t.value

    if isinstance(w, PhaseSpacePosition) or isinstance(w, Orbit):
        Cls = w.__class__
        x_shape = w.xyz.shape
        x_unit = w.x.unit
        v_unit = w.v_x.unit

        x = w.xyz.reshape(3, -1).value
        v = w.v_xyz.reshape(3, -1).value

    else:
        Cls = None
        ndim = w.shape[0]
        x_shape = (ndim//2,) + w.shape[1:]
        x = w[:ndim//2]
        v = w[ndim//2:]

        if hasattr(x, 'unit'):
            raise TypeError(&quot;If w is not an Orbit or PhaseSpacePosition, w &quot;
                            &quot;cannot have units!&quot;)

        x_unit = u.one
        v_unit = u.one

    # now need to compute rotation vector, ee, and angle, theta
    ee = omega / np.linalg.norm(omega)
    theta = (np.linalg.norm(omega) * t)[None]

    # we use Rodrigues' rotation formula to rotate the position
    x_rot = np.cos(theta)*x + np.sin(theta)*np.cross(ee, x, axisa=0, axisb=0, axisc=0) \
        + (1 - np.cos(theta)) * np.einsum(&quot;i, ij-&gt;j&quot;, ee, x) * ee[:, None]

    v_cor = np.cross(omega, x, axisa=0, axisb=0, axisc=0) * x_unit
    v_rot = v - v_cor.to(v_unit, u.dimensionless_angles()).value

    x_rot = x_rot.reshape(x_shape) * x_unit
    v_rot = v_rot.reshape(x_shape) * v_unit

    if Cls is None:
        return np.vstack((x_rot, v_rot))

    else:
        if issubclass(Cls, Orbit):
            return Cls(pos=x_rot, vel=v_rot, t=t)
        else:
            return Cls(pos=x_rot, vel=v_rot)

# ----------------------------------------------------------------------------


class TestWithPotentialStaticFrame(_TestBase):
    obj = Hamiltonian(NFWPotential.from_circular_velocity(v_c=0.2, r_s=20.,
                                                          units=galactic),
                      StaticFrame(units=galactic))

    @pytest.mark.skip(&quot;Not implemented&quot;)
    def test_hessian(self):
        pass


class TestKeplerRotatingFrame(_TestBase):
    Omega = [0., 0, 1.]*u.one
    E_unit = u.one
    obj = Hamiltonian(KeplerPotential(m=1., units=dimensionless),
                      ConstantRotatingFrame(Omega=Omega, units=dimensionless))

    @pytest.mark.skip(&quot;Not implemented&quot;)
    def test_hessian(self):
        pass

    def test_integrate(self):

        w0 = PhaseSpacePosition(pos=[1., 0, 0.], vel=[0, 1., 0.])

        for bl in [True, False]:
            orbit = self.obj.integrate_orbit(w0, dt=1., n_steps=1000,
                                             cython_if_possible=bl,
                                             Integrator=DOPRI853Integrator)

            assert np.allclose(orbit.x.value, 1., atol=1E-7)
            assert np.allclose(orbit.xyz.value[1:], 0., atol=1E-7)


class TestKepler2RotatingFrame(_TestBase):
    Omega = [1., 1., 1.]*u.one
    E_unit = u.one
    obj = Hamiltonian(KeplerPotential(m=1., units=dimensionless),
                      ConstantRotatingFrame(Omega=Omega, units=dimensionless))

    @pytest.mark.skip(&quot;Not implemented&quot;)
    def test_hessian(self):
        pass

    def test_integrate(self):

        # --------------------------------------------------------------
        # when Omega is off from orbital frequency
        #
        w0 = PhaseSpacePosition(pos=[1., 0, 0.], vel=[0, 1.1, 0.])

        for bl in [True, False]:
            orbit = self.obj.integrate_orbit(w0, dt=0.1, n_steps=10000,
                                             cython_if_possible=bl,
                                             Integrator=DOPRI853Integrator)

            L = orbit.angular_momentum()
            C = orbit.energy() - np.sum(self.Omega[:, None] * L, axis=0)
            dC = np.abs((C[1:]-C[0])/C[0])
            assert np.all(dC &lt; 1E-9)  # conserve Jacobi constant


@pytest.mark.parametrize(&quot;name, Omega, tol&quot;, [
    (&quot;z-aligned co-rotating&quot;, [0, 0, 1.]*u.one, 1E-12),
    (&quot;z-aligned&quot;, [0, 0, 1.5834]*u.one, 1E-12),
    (&quot;random&quot;, [0.95792653, 0.82760659, 0.66443135]*u.one, 1E-10),
])
def test_velocity_rot_frame(name, Omega, tol):
    # _i = inertial
    # _r = rotating

    r0 = 1.245246
    potential = HernquistPotential(m=1., c=0.2, units=dimensionless)
    vc = potential.circular_velocity([r0, 0, 0]).value[0]
    w0 = PhaseSpacePosition(pos=[r0, 0, 0.],
                            vel=[0, vc, 0.])
    Omega = Omega * [1., 1., vc/r0]

    H_r = Hamiltonian(potential, ConstantRotatingFrame(Omega=Omega, units=dimensionless))
    H = Hamiltonian(potential, StaticFrame(units=dimensionless))

    orbit_i = H.integrate_orbit(w0, dt=0.1, n_steps=1000, Integrator=DOPRI853Integrator)
    orbit_r = H_r.integrate_orbit(w0, dt=0.1, n_steps=1000, Integrator=DOPRI853Integrator)

    orbit_i2r = orbit_i.to_frame(ConstantRotatingFrame(Omega=Omega, units=dimensionless))
    orbit_r2i = orbit_r.to_frame(StaticFrame(units=dimensionless))

    assert u.allclose(orbit_i.xyz, orbit_r2i.xyz, atol=tol)
    assert u.allclose(orbit_i.v_xyz, orbit_r2i.v_xyz, atol=tol)

    assert u.allclose(orbit_r.xyz, orbit_i2r.xyz, atol=tol)
    assert u.allclose(orbit_r.v_xyz, orbit_i2r.v_xyz, atol=tol)
</file>
    <file path="gala/potential/potential/tests/ccomposite.yml">
type: composite
class: CCompositePotential
components:
- class: KeplerPotential
  name: halo
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      m: 100000000000.0
      m_unit: ''
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: IsochronePotential
  name: bulge
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      b: 0.76
      b_unit: ''
      m: 100000000000.0
      m_unit: ''
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
</file>
    <file path="gala/potential/potential/tests/Composite.yml">
type: composite
class: CompositePotential
components:
  -
    class: PlummerPotential
    name: halo
    parameters:
      b: 0.26
      m: 100000000000.0
    units:
      angle: rad
      angular speed: mas / yr
      length: kpc
      mass: solMass
      speed: km / s
      time: Myr
  -
    class: MiyamotoNagaiPotential
    name: disk
    parameters:
      a: 6.5
      b: 0.26
      m: 100000000000.0
    units:
      angle: rad
      angular speed: mas / yr
      length: kpc
      mass: solMass
      speed: km / s
      time: Myr
</file>
    <file path="gala/potential/potential/tests/generate_agama.py">
import pathlib
import astropy.table as at
import astropy.units as u
import numpy as np

this_path = pathlib.Path(__file__).absolute().parent


def main():
    # For pytest:
    import agama

    agama.setUnits(mass=1, length=1, time=1)

    # Shared by Ana Bonaca
    agama_pot = agama.Potential(file=str(this_path / 'pot_disk_506151.pot'))

    # Generate a grid of points to evaluate at:
    test_R = np.linspace(0, 150, 128)
    test_z = np.linspace(-100, 100, 128)
    test_Rz = np.stack(list(map(np.ravel, np.meshgrid(test_R, test_z))))
    test_xyz = np.zeros((3, test_Rz.shape[1]))
    test_xyz[0] = test_Rz[0]
    test_xyz[2] = test_Rz[1]

    pot = agama_pot.potential(test_xyz.T)[:, None]
    acc = agama_pot.force(test_xyz.T)

    tbl = at.QTable()
    tbl['xyz'] = test_xyz.T * u.kpc
    tbl['pot'] = pot * (u.km/u.s)**2
    tbl['acc'] = acc * (u.km/u.s)**2 / u.kpc

    tbl.write(this_path / 'agama_cylspline_test.fits')


if __name__ == '__main__':
    main()
</file>
    <file path="gala/potential/potential/tests/HarmonicOscillator1D.yml">
class: HarmonicOscillatorPotential
parameters:
  omega: 1.0
</file>
    <file path="gala/potential/potential/tests/helpers.py">
# Standard library
import copy
import pickle
import time

# Third-party
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
from scipy.misc import derivative
import pytest

# Project
from ..io import load
from ...frame import StaticFrame
from ...hamiltonian import Hamiltonian
from ....units import UnitSystem, DimensionlessUnitSystem
from ....dynamics import PhaseSpacePosition
from gala.tests.optional_deps import HAS_SYMPY


def partial_derivative(func, point, dim_ix=0, **kwargs):
    xyz = np.array(point, copy=True)

    def wraps(a):
        xyz[dim_ix] = a
        return func(xyz)

    return derivative(wraps, point[dim_ix], **kwargs)


class PotentialTestBase:
    name = None
    potential = None  # MUST SET THIS
    frame = None
    tol = 1e-5
    show_plots = False

    sympy_hessian = True
    sympy_density = True
    check_finite_at_origin = True

    def setup_method(self):
        # set up hamiltonian
        if self.frame is None:
            self.frame = StaticFrame(units=self.potential.units)
        self.H = Hamiltonian(self.potential, self.frame)
        self.rnd = np.random.default_rng(seed=42)

        cls = self.__class__
        if cls.name is None:
            cls.name = cls.__name__[4:]  # removes &quot;Test&quot;
        print(f&quot;Testing potential: {cls.name}&quot;)
        self.w0 = np.array(self.w0)
        self.ndim = self.w0.size // 2

        # TODO: need to test also quantity objects and phasespacepositions!

        # these are arrays we will test the methods on:
        w0_2d = np.repeat(self.w0[:, None], axis=1, repeats=16)
        w0_3d = np.repeat(w0_2d[..., None], axis=2, repeats=8)
        w0_list = list(self.w0)
        w0_slice = w0_2d[:, :4]
        self.w0s = [self.w0, w0_2d, w0_3d, w0_list, w0_slice]
        self._grad_return_shapes = [
            self.w0[: self.ndim].shape + (1,),
            w0_2d[: self.ndim].shape,
            w0_3d[: self.ndim].shape,
            self.w0[: self.ndim].shape + (1,),
            w0_slice[: self.ndim].shape,
        ]
        self._hess_return_shapes = [
            (self.ndim,) + self.w0[: self.ndim].shape + (1,),
            (self.ndim,) + w0_2d[: self.ndim].shape,
            (self.ndim,) + w0_3d[: self.ndim].shape,
            (self.ndim,) + self.w0[: self.ndim].shape + (1,),
            (self.ndim,) + w0_slice[: self.ndim].shape,
        ]
        self._valu_return_shapes = [x[1:] for x in self._grad_return_shapes]

    def test_unitsystem(self):
        assert isinstance(self.potential.units, UnitSystem)

        if isinstance(self.potential.units, DimensionlessUnitSystem):
            # Don't do a replace_units test for dimensionless potentials
            return

        # check that we can replace the units as expected
        usys = UnitSystem([u.pc, u.Gyr, u.radian, u.Msun])
        pot = copy.deepcopy(self.potential)

        pot2 = pot.replace_units(usys)
        assert pot2.units == usys
        assert pot.units == self.potential.units

    def test_energy(self):
        assert self.ndim == self.potential.ndim

        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            v = self.potential.energy(arr[: self.ndim])
            assert v.shape == shp

            g = self.potential.energy(arr[: self.ndim], t=0.1)
            g = self.potential.energy(
                arr[: self.ndim], t=0.1 * self.potential.units[&quot;time&quot;]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.energy(arr[: self.ndim], t=t)
            g = self.potential.energy(
                arr[: self.ndim], t=t * self.potential.units[&quot;time&quot;]
            )

        if self.check_finite_at_origin:
            val = self.potential.energy([0.0, 0, 0])
            assert np.isfinite(val)

    def test_gradient(self):
        for arr, shp in zip(self.w0s, self._grad_return_shapes):
            g = self.potential.gradient(arr[: self.ndim])
            assert g.shape == shp

            g = self.potential.gradient(arr[: self.ndim], t=0.1)
            g = self.potential.gradient(
                arr[: self.ndim], t=0.1 * self.potential.units[&quot;time&quot;]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.gradient(arr[: self.ndim], t=t)
            g = self.potential.gradient(
                arr[: self.ndim], t=t * self.potential.units[&quot;time&quot;]
            )

    def test_hessian(self):
        for arr, shp in zip(self.w0s, self._hess_return_shapes):
            g = self.potential.hessian(arr[: self.ndim])
            assert g.shape == shp

            g = self.potential.hessian(arr[: self.ndim], t=0.1)
            g = self.potential.hessian(
                arr[: self.ndim], t=0.1 * self.potential.units[&quot;time&quot;]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.hessian(arr[: self.ndim], t=t)
            g = self.potential.hessian(
                arr[: self.ndim], t=t * self.potential.units[&quot;time&quot;]
            )

    def test_mass_enclosed(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.mass_enclosed(arr[: self.ndim])
            assert g.shape == shp
            assert np.all(g &gt; 0.0)

            g = self.potential.mass_enclosed(arr[: self.ndim], t=0.1)
            g = self.potential.mass_enclosed(
                arr[: self.ndim], t=0.1 * self.potential.units[&quot;time&quot;]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.mass_enclosed(arr[: self.ndim], t=t)
            g = self.potential.mass_enclosed(
                arr[: self.ndim], t=t * self.potential.units[&quot;time&quot;]
            )

    def test_circular_velocity(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.circular_velocity(arr[: self.ndim])
            assert g.shape == shp
            assert np.all(g &gt; 0.0)

            g = self.potential.circular_velocity(arr[: self.ndim], t=0.1)
            g = self.potential.circular_velocity(
                arr[: self.ndim], t=0.1 * self.potential.units[&quot;time&quot;]
            )

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.circular_velocity(arr[: self.ndim], t=t)
            g = self.potential.circular_velocity(
                arr[: self.ndim], t=t * self.potential.units[&quot;time&quot;]
            )

    def test_repr(self):
        pot_repr = repr(self.potential)
        if isinstance(self.potential.units, DimensionlessUnitSystem):
            assert &quot;dimensionless&quot; in pot_repr
        else:
            assert str(self.potential.units[&quot;length&quot;]) in pot_repr
            assert str(self.potential.units[&quot;time&quot;]) in pot_repr
            assert str(self.potential.units[&quot;mass&quot;]) in pot_repr

        for k in self.potential.parameters.keys():
            assert &quot;{}=&quot;.format(k) in pot_repr

    def test_compare(self):
        # skip if composite potentials
        if len(self.potential.parameters) == 0:
            return

        other = self.potential.__class__(
            units=self.potential.units, **self.potential.parameters
        )
        assert other == self.potential

        pars = self.potential.parameters.copy()
        for k in pars.keys():
            if k != 0:
                pars[k] = 1.1 * pars[k]
        other = self.potential.__class__(units=self.potential.units, **pars)
        assert other != self.potential

        # check that comparing to non-potentials works
        assert not self.potential == &quot;sup&quot;
        assert self.potential is not None

    def test_plot(self):
        p = self.potential

        f = p.plot_contours(
            grid=(np.linspace(-10.0, 10.0, 100), 0.0, 0.0), labels=[&quot;X&quot;]
        )

        f = p.plot_contours(
            grid=(
                np.linspace(-10.0, 10.0, 100),
                np.linspace(-10.0, 10.0, 100),
                0.0,
            ),
            cmap=&quot;Blues&quot;,
        )

        f = p.plot_contours(
            grid=(
                np.linspace(-10.0, 10.0, 100),
                1.0,
                np.linspace(-10.0, 10.0, 100),
            ),
            cmap=&quot;Blues&quot;,
            labels=[&quot;X&quot;, &quot;Z&quot;],
        )

        f, a = p.plot_rotation_curve(R_grid=np.linspace(0.1, 10.0, 100))

        plt.close(&quot;all&quot;)

        if self.show_plots:
            plt.show()

    def test_save_load(self, tmpdir):
        &quot;&quot;&quot;
        Test writing to a YAML file, and reading back in
        &quot;&quot;&quot;
        fn = str(tmpdir.join(&quot;{}.yml&quot;.format(self.name)))
        self.potential.save(fn)
        p = load(fn)
        p.energy(self.w0[: self.w0.size // 2])
        p.gradient(self.w0[: self.w0.size // 2])

    def test_numerical_gradient_vs_gradient(self):
        &quot;&quot;&quot;
        Check that the value of the implemented gradient function is close to a
        numerically estimated value. This is to check the coded-up version.
        &quot;&quot;&quot;

        dx = 1e-3 * np.sqrt(np.sum(self.w0[: self.w0.size // 2] ** 2))
        max_x = np.sqrt(np.sum([x ** 2 for x in self.w0[: self.w0.size // 2]]))

        grid = np.linspace(-max_x, max_x, 8)
        grid = grid[grid != 0.0]
        grids = [grid for i in range(self.w0.size // 2)]
        xyz = np.ascontiguousarray(
            np.vstack(list(map(np.ravel, np.meshgrid(*grids)))).T
        )

        def energy_wrap(xyz):
            xyz = np.ascontiguousarray(xyz[None])
            return self.potential._energy(xyz, t=np.array([0.0]))[0]

        num_grad = np.zeros_like(xyz)
        for i in range(xyz.shape[0]):
            num_grad[i] = np.squeeze(
                [
                    partial_derivative(
                        energy_wrap, xyz[i], dim_ix=dim_ix, n=1, dx=dx, order=5
                    )
                    for dim_ix in range(self.w0.size // 2)
                ]
            )
        grad = self.potential._gradient(xyz, t=np.array([0.0]))
        assert np.allclose(num_grad, grad, rtol=self.tol)

    def test_orbit_integration(self):
        &quot;&quot;&quot;
        Make sure we can integrate an orbit in this potential
        &quot;&quot;&quot;
        w0 = self.w0
        w0 = np.vstack((w0, w0, w0)).T

        t1 = time.time()
        orbit = self.H.integrate_orbit(w0, dt=0.1, n_steps=10000)
        print(&quot;Integration time (10000 steps): {}&quot;.format(time.time() - t1))

        if self.show_plots:
            f = orbit.plot()
            f.suptitle(&quot;Vector w0&quot;)
            plt.show()
            plt.close(f)

        us = self.potential.units
        w0 = PhaseSpacePosition(
            pos=w0[: self.ndim] * us[&quot;length&quot;],
            vel=w0[self.ndim :] * us[&quot;length&quot;] / us[&quot;time&quot;],
        )
        orbit = self.H.integrate_orbit(w0, dt=0.1, n_steps=10000)

        if self.show_plots:
            f = orbit.plot()
            f.suptitle(&quot;Object w0&quot;)
            plt.show()
            plt.close(f)

    def test_pickle(self, tmpdir):
        fn = str(tmpdir.join(&quot;{}.pickle&quot;.format(self.name)))
        with open(fn, &quot;wb&quot;) as f:
            pickle.dump(self.potential, f)

        with open(fn, &quot;rb&quot;) as f:
            p = pickle.load(f)

        p.energy(self.w0[: self.w0.size // 2])

    @pytest.mark.skipif(not HAS_SYMPY, reason=&quot;requires sympy to run this test&quot;)
    def test_against_sympy(self):
        # TODO: should really split this into separate tests for each check...

        import sympy as sy
        from sympy import Q

        # compare Gala gradient, hessian, and density to sympy values

        pot = self.potential
        Phi, v, p = pot.to_sympy()

        # Derive sympy gradient and hessian functions to evaluate:
        from scipy.special import gamma, gammainc

        def lowergamma(a, x):  # noqa
            # Differences between scipy and sympy lower gamma
            return gammainc(a, x) * gamma(a)

        modules = [
            {
                &quot;atan&quot;: np.arctan,
                # &quot;lowergamma&quot;: lowergamma,
                &quot;gamma&quot;: gamma,
                &quot;re&quot;: np.real,
                &quot;im&quot;: np.imag,
            },
            &quot;numpy&quot;,
            &quot;scipy&quot;,
            &quot;sympy&quot;,
        ]

        vars_ = list(p.values()) + list(v.values())
        assums = np.bitwise_and.reduce([Q.real(x) for x in vars_])
        # Phi = sy.refine(Phi, assums)
        e_func = sy.lambdify(vars_, Phi, modules=modules)

        if self.sympy_density:
            dens_tmp = sum([sy.diff(Phi, var, 2) for var in v.values()]) / (
                4 * sy.pi * p[&quot;G&quot;]
            )
            # dens_tmp = sy.refine(dens_tmp, assums)
            dens_func = sy.lambdify(vars_, dens_tmp, modules=modules)

        grad = sy.derive_by_array(Phi, list(v.values()))
        # grad = sy.refine(grad, assums)
        grad_func = sy.lambdify(vars_, grad, modules=modules)

        if self.sympy_hessian:
            Hess = sy.hessian(Phi, list(v.values()))
            # Hess = sy.refine(Hess, assums)
            Hess_func = sy.lambdify(vars_, Hess, modules=modules)

        # Make a dict of potential parameter values without units:
        par_vals = {}
        for k, v in pot.parameters.items():
            par_vals[k] = v.value

        N = 64  # MAGIC NUMBER:
        trial_x = self.rnd.uniform(-10.0, 10.0, size=(pot.ndim, N))
        x_dict = {k: v for k, v in zip([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], trial_x)}

        f_gala = pot.energy(trial_x).value
        f_sympy = e_func(G=pot.G, **par_vals, **x_dict)
        e_close = np.allclose(f_gala, f_sympy)
        test_cases = [e_close]
        vals = [(f_gala, f_sympy)]

        if self.sympy_density:
            d_gala = pot.density(trial_x).value
            d_sympy = dens_func(G=pot.G, **par_vals, **x_dict)
            d_close = np.allclose(d_gala, d_sympy)
            test_cases.append(d_close)
            vals.append((d_gala, d_sympy))

        G_gala = pot.gradient(trial_x).value
        G_sympy = grad_func(G=pot.G, **par_vals, **x_dict)
        g_close = np.allclose(G_gala, G_sympy)
        test_cases.append(g_close)
        vals.append((G_gala, G_sympy))

        if self.sympy_hessian:
            H_gala = pot.hessian(trial_x).value
            H_sympy = Hess_func(G=pot.G, **par_vals, **x_dict)
            h_close = np.allclose(H_gala, H_sympy)
            test_cases.append(h_close)
            vals.append((H_gala, H_sympy))

        if not all(test_cases):
            names = [&quot;energy&quot;, &quot;density&quot;, &quot;gradient&quot;, &quot;hessian&quot;]
            for name, (val1, val2), test in zip(names, vals, test_cases):
                if not test:
                    print(trial_x)
                    print(f&quot;{pot}: {name}\nGala:{val1}\nSympy:{val2}&quot;)

        assert all(test_cases)

    def test_regression_165(self):
        if self.potential.ndim == 1:
            # Skip!
            return

        with pytest.raises(ValueError):
            self.potential.energy(8.0)

        with pytest.raises(ValueError):
            self.potential.gradient(8.0)

        with pytest.raises(ValueError):
            self.potential.circular_velocity(8.0)


class CompositePotentialTestBase(PotentialTestBase):
    @pytest.mark.skip(reason=&quot;Skip composite potential repr test&quot;)
    def test_repr(self):
        pass

    @pytest.mark.skip(reason=&quot;Skip composite potential compare test&quot;)
    def test_compare(self):
        pass

    @pytest.mark.skip(reason=&quot;to_sympy() not implemented yet&quot;)
    def test_against_sympy(self):
        pass
</file>
    <file path="gala/potential/potential/tests/lm10.yml">
class: LM10Potential
type: custom
components:
- class: MiyamotoNagaiPotential
  name: disk
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      a: 10.
      a_unit: kpc
      b: 0.26
      b_unit: kpc
      m: 150000.
      m_unit: solMass
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: HernquistPotential
  name: bulge
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      c: 0.7
      c_unit: kpc
      m: 34000000000.0
      m_unit: solMass
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
- class: LogarithmicPotential
  name: halo
  parameters: !!python/object/apply:collections.OrderedDict
    dictitems:
      phi: 1.6929693744344996
      phi_unit: rad
      q1: 1.38
      q1_unit: ''
      q2: 1.0
      q2_unit: ''
      q3: 1.36
      q3_unit: ''
      r_h: 12.0
      r_h_unit: kpc
      v_c: 0.17624729719037474
      v_c_unit: kpc / Myr
  units:
    angle: rad
    angular speed: mas / yr
    length: kpc
    mass: solMass
    speed: km / s
    time: Myr
</file>
    <file path="gala/potential/potential/tests/Plummer.yml">
class: PlummerPotential
parameters:
  b: 0.26
  b_unit: kpc
  m: 100000000000.0
units:
  angle: rad
  angular speed: mas / yr
  length: kpc
  mass: solMass
  speed: km / s
  time: Myr
</file>
    <file path="gala/potential/potential/tests/test_all_builtin.py">
&quot;&quot;&quot;
    Test the builtin CPotential classes
&quot;&quot;&quot;

# Third-party
import numpy as np
import astropy.table as at
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import pytest
from scipy.spatial.transform import Rotation

# This project
from ..core import CompositePotential
from ..ccompositepotential import CCompositePotential
from .. import builtin as p
from ...frame import ConstantRotatingFrame
from ....units import solarsystem, galactic, DimensionlessUnitSystem
from .helpers import PotentialTestBase, CompositePotentialTestBase
from gala._cconfig import GSL_ENABLED
from gala.tests.optional_deps import HAS_SYMPY

##############################################################################
# Python
##############################################################################


class TestHarmonicOscillator1D(PotentialTestBase):
    potential = p.HarmonicOscillatorPotential(omega=1.)
    w0 = [1., 0.1]
    sympy_density = False
    check_finite_at_origin = False

    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass


class TestHarmonicOscillator2D(PotentialTestBase):
    potential = p.HarmonicOscillatorPotential(omega=[1., 2])
    w0 = [1., 0.5, 0., 0.1]
    sympy_density = False
    check_finite_at_origin = False

    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass

    @pytest.mark.skip(reason=&quot;to_sympy() won't support multi-dim HO&quot;)
    def test_against_sympy(self):
        pass

##############################################################################
# Cython
##############################################################################


class TestNull(PotentialTestBase):
    potential = p.NullPotential()
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]

    def test_mass_enclosed(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.mass_enclosed(arr[:self.ndim])
            assert g.shape == shp
            assert np.all(g == 0.)

            g = self.potential.mass_enclosed(arr[:self.ndim], t=0.1)
            g = self.potential.mass_enclosed(arr[:self.ndim], t=0.1*self.potential.units['time'])

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.mass_enclosed(arr[:self.ndim], t=t)
            g = self.potential.mass_enclosed(arr[:self.ndim], t=t*self.potential.units['time'])

    def test_circular_velocity(self):
        for arr, shp in zip(self.w0s, self._valu_return_shapes):
            g = self.potential.circular_velocity(arr[:self.ndim])
            assert g.shape == shp
            assert np.all(g == 0.)

            g = self.potential.circular_velocity(arr[:self.ndim], t=0.1)
            g = self.potential.circular_velocity(arr[:self.ndim],
                                                 t=0.1*self.potential.units['time'])

            t = np.zeros(np.array(arr).shape[1:]) + 0.1
            g = self.potential.circular_velocity(arr[:self.ndim], t=t)
            g = self.potential.circular_velocity(arr[:self.ndim], t=t*self.potential.units['time'])

    @pytest.mark.skip(reason=&quot;Nothing to compare to for Null potential!&quot;)
    def test_against_sympy(self):
        pass


class TestHenonHeiles(PotentialTestBase):
    potential = p.HenonHeilesPotential()
    w0 = [1., 0., 0., 2*np.pi]
    sympy_density = False
    check_finite_at_origin = False

    @pytest.mark.skip(reason=&quot;Not relevant&quot;)
    def test_plot(self):
        pass


class TestKepler(PotentialTestBase):
    potential = p.KeplerPotential(units=solarsystem, m=1.)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]
    # show_plots = True
    check_finite_at_origin = False


class TestKeplerUnitInput(PotentialTestBase):
    potential = p.KeplerPotential(units=solarsystem, m=(1*u.Msun).to(u.Mjup))
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]
    check_finite_at_origin = False


class TestIsochrone(PotentialTestBase):
    potential = p.IsochronePotential(units=solarsystem, m=1., b=0.1)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]


class TestIsochroneDimensionless(PotentialTestBase):
    potential = p.IsochronePotential(units=DimensionlessUnitSystem(),
                                     m=1., b=0.1)
    w0 = [1., 0., 0., 0., 2*np.pi, 0.]


class TestHernquist(PotentialTestBase):
    potential = p.HernquistPotential(units=galactic, m=1.E11, c=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestPlummer(PotentialTestBase):
    potential = p.PlummerPotential(units=galactic, m=1.E11, b=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestJaffe(PotentialTestBase):
    check_finite_at_origin = False
    potential = p.JaffePotential(units=galactic, m=1.E11, c=0.26)
    w0 = [1., 0., 0., 0., 0.1, 0.1]


class TestMiyamotoNagai(PotentialTestBase):
    potential = p.MiyamotoNagaiPotential(units=galactic, m=1.E11, a=6.5, b=0.26)
    w0 = [8., 0., 0., 0., 0.22, 0.1]

    @pytest.mark.skipif(not HAS_SYMPY,
                        reason=&quot;requires sympy to run this test&quot;)
    def test_hessian_analytic(self):
        from astropy.constants import G
        from sympy import symbols
        import sympy as sy

        x, y, z = symbols('x y z')

        usys = self.potential.units
        GM = (G * self.potential.parameters['m']).decompose(usys).value
        a = self.potential.parameters['a'].decompose(usys).value
        b = self.potential.parameters['b'].decompose(usys).value
        Phi = -GM / sy.sqrt(x**2 + y**2 + (a + sy.sqrt(z**2 + b**2))**2)

        d2Phi_dx2 = sy.lambdify((x, y, z), sy.diff(Phi, x, 2))
        d2Phi_dy2 = sy.lambdify((x, y, z), sy.diff(Phi, y, 2))
        d2Phi_dz2 = sy.lambdify((x, y, z), sy.diff(Phi, z, 2))

        d2Phi_dxdy = sy.lambdify((x, y, z), sy.diff(Phi, x, y))
        d2Phi_dxdz = sy.lambdify((x, y, z), sy.diff(Phi, x, z))
        d2Phi_dydz = sy.lambdify((x, y, z), sy.diff(Phi, y, z))

        rnd = np.random.default_rng(42)
        xyz = rnd.normal(0, 25, size=(3, 64))

        H1 = self.potential.hessian(xyz).decompose(usys).value

        H2 = np.zeros((3, 3, xyz.shape[1]))
        H2[0, 0] = d2Phi_dx2(*xyz)
        H2[1, 1] = d2Phi_dy2(*xyz)
        H2[2, 2] = d2Phi_dz2(*xyz)

        H2[0, 1] = H2[1, 0] = d2Phi_dxdy(*xyz)
        H2[0, 2] = H2[2, 0] = d2Phi_dxdz(*xyz)
        H2[1, 2] = H2[2, 1] = d2Phi_dydz(*xyz)

        assert np.allclose(H1, H2)


class TestMN3(PotentialTestBase):
    potential = p.MN3ExponentialDiskPotential(
        units=galactic, m=1.E11, h_R=3.5, h_z=0.26
    )
    w0 = [8., 0., 0., 0., 0.22, 0.1]

    # TODO:
    @pytest.mark.skip(reason=&quot;to_sympy() not implemented yet&quot;)
    def test_against_sympy(self):
        pass

    def test_get_three(self):
        pots = self.potential.get_three_potentials()
        assert len(pots) == 3


class TestSatoh(PotentialTestBase):
    potential = p.SatohPotential(units=galactic, m=1.E11, a=6.5, b=0.26)
    w0 = [8., 0., 0., 0., 0.22, 0.1]


class TestKuzmin(PotentialTestBase):
    potential = p.KuzminPotential(units=galactic, m=1.E11, a=3.5)
    w0 = [8., 0., 0., 0., 0.22, 0.1]
    sympy_hessian = False
    sympy_density = False


class TestStone(PotentialTestBase):
    potential = p.StonePotential(units=galactic, m=1E11, r_c=0.1, r_h=10.)
    w0 = [8., 0., 0., 0., 0.18, 0.1]


@pytest.mark.skipif(not GSL_ENABLED,
                    reason=&quot;requires GSL to run this test&quot;)
class TestPowerLawCutoff(PotentialTestBase):
    w0 = [8., 0., 0., 0., 0.1, 0.1]
    atol = 1e-3
    sympy_density = False  # weird underflow issues??
    check_finite_at_origin = False

    def setup_method(self):
        self.potential = p.PowerLawCutoffPotential(units=galactic,
                                                   m=1E10, r_c=1., alpha=1.8)
        super().setup_method()


class TestSphericalNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12.)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestFlattenedNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12., c=0.7)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]
    sympy_density = False  # not defined

    def test_against_spherical(self):
        &quot;&quot;&quot;
        Note: This is a regression test for Issue #254
        &quot;&quot;&quot;

        sph = p.NFWPotential(units=galactic, m=1E11, r_s=12.)
        assert not u.allclose(self.potential.gradient(self.w0[:3]),
                              sph.gradient(self.w0[:3]))


class TestTriaxialNFW(PotentialTestBase):
    potential = p.NFWPotential(units=galactic, m=1E11, r_s=12.,
                               a=1., b=0.95, c=0.9)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]
    sympy_density = False  # not defined


class TestSphericalNFWFromCircVel(PotentialTestBase):
    potential = p.NFWPotential.from_circular_velocity(
        v_c=220.*u.km/u.s,
        r_s=20*u.kpc,
        r_ref=8.*u.kpc,
        units=galactic)
    w0 = [19.0, 2.7, -0.9, 0.00352238, -0.165134, 0.0075]

    def test_circ_vel(self):
        for r_ref in [3., 8., 21.7234]:
            pot = p.NFWPotential.from_circular_velocity(
                v_c=220.*u.km/u.s, r_s=20*u.kpc,
                r_ref=r_ref*u.kpc, units=galactic)
            vc = pot.circular_velocity([r_ref, 0, 0]*u.kpc)  # at ref. velocity
            assert u.allclose(vc, 220*u.km/u.s)

    def test_against_triaxial(self):
        this = p.NFWPotential.from_circular_velocity(
            v_c=220.*u.km/u.s, r_s=20*u.kpc, units=galactic)
        other = p.LeeSutoTriaxialNFWPotential(
            units=galactic,
            v_c=220.*u.km/u.s, r_s=20.*u.kpc,
            a=1., b=1., c=1.)

        v1 = this.energy(self.w0[:3])
        v2 = other.energy(self.w0[:3])
        assert u.allclose(v1, v2)

        a1 = this.gradient(self.w0[:3])
        a2 = other.gradient(self.w0[:3])
        assert u.allclose(a1, a2)

        d1 = this.density(self.w0[:3])
        d2 = other.density(self.w0[:3])
        assert u.allclose(d1, d2)

    def test_mass_enclosed(self):

        # true mass profile
        m = self.potential.parameters['m'].value
        rs = self.potential.parameters['r_s'].value

        r = np.linspace(1., 400, 100)
        fac = np.log(1 + r/rs) - (r/rs) / (1 + (r/rs))
        true_mprof = m * fac

        R = np.zeros((3, len(r)))
        R[0, :] = r
        esti_mprof = self.potential.mass_enclosed(R)

        assert np.allclose(true_mprof, esti_mprof.value, rtol=1E-6)


class TestNFW(PotentialTestBase):
    potential = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, a=1., b=0.9, c=0.75,
                               units=galactic)
    w0 = [19.0, 2.7, -0.9, 0.00352238, -0.15134, 0.0075]
    sympy_density = False  # like triaxial case

    def test_compare(self):

        sph = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, units=galactic)
        fla = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, c=0.8, units=galactic)
        tri = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, b=0.9, c=0.8, units=galactic)

        xyz = np.zeros((3, 128))
        xyz[0] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.energy(xyz), tri.energy(xyz))

        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))
        assert u.allclose(sph.gradient(xyz), tri.gradient(xyz))

        # assert u.allclose(sph.density(xyz), fla.density(xyz)) # TODO: fla density not implemented
        # assert u.allclose(sph.density(xyz), tri.density(xyz)) # TODO: tri density not implemented

        # ---

        tri = p.NFWPotential(m=6E11*u.Msun, r_s=20*u.kpc, a=0.9, c=0.8, units=galactic)

        xyz = np.zeros((3, 128))
        xyz[1] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.energy(xyz), tri.energy(xyz))

        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))
        assert u.allclose(sph.gradient(xyz), tri.gradient(xyz))

        # assert u.allclose(sph.density(xyz), fla.density(xyz)) # TODO: fla density not implemented
        # assert u.allclose(sph.density(xyz), tri.density(xyz)) # TODO: tri density not implemented

        # ---

        xyz = np.zeros((3, 128))
        xyz[0] = np.logspace(-1., 3, xyz.shape[1])
        xyz[1] = np.logspace(-1., 3, xyz.shape[1])

        assert u.allclose(sph.energy(xyz), fla.energy(xyz))
        assert u.allclose(sph.gradient(xyz), fla.gradient(xyz))


class TestLeeSutoTriaxialNFW(PotentialTestBase):
    potential = p.LeeSutoTriaxialNFWPotential(units=galactic, v_c=0.35, r_s=12.,
                                              a=1.3, b=1., c=0.8)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]

    @pytest.mark.skip(reason=&quot;to_sympy() not implemented yet&quot;)
    def test_against_sympy(self):
        pass


class TestLogarithmic(PotentialTestBase):
    potential = p.LogarithmicPotential(units=galactic, v_c=0.17, r_h=10.,
                                       q1=1.2, q2=1., q3=0.8)
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestLongMuraliBar(PotentialTestBase):
    potential = p.LongMuraliBarPotential(units=galactic, m=1E11,
                                         a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]


class TestLongMuraliBarRotate(PotentialTestBase):
    potential = p.LongMuraliBarPotential(
        units=galactic, m=1E11,
        a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc,
        R=np.array([[0.63302222, 0.75440651, 0.17364818],
                    [-0.76604444, 0.64278761, 0.],
                    [-0.1116189, -0.13302222, 0.98480775]]))
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    def test_hessian(self):
        # TODO: when hessian for rotated potentials implemented, remove this
        with pytest.raises(NotImplementedError):
            self.potential.hessian([1., 2., 3.])

    @pytest.mark.skip(reason=&quot;Not implemented for rotated potentials&quot;)
    def test_against_sympy(self):
        pass


class TestLongMuraliBarRotationScipy(PotentialTestBase):
    potential = p.LongMuraliBarPotential(
        units=galactic, m=1E11,
        a=4.*u.kpc, b=1*u.kpc, c=1.*u.kpc,
        R=Rotation.from_euler('zxz', [90., 0, 0.], degrees=True))
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    def test_hessian(self):
        # TODO: when hessian for rotated potentials implemented, remove this
        with pytest.raises(NotImplementedError):
            self.potential.hessian([1., 2., 3.])

    @pytest.mark.skip(reason=&quot;Not implemented for rotated potentials&quot;)
    def test_against_sympy(self):
        pass


class TestComposite(CompositePotentialTestBase):
    p1 = p.LogarithmicPotential(units=galactic,
                                v_c=0.17, r_h=10.,
                                q1=1.2, q2=1., q3=0.8)
    p2 = p.MiyamotoNagaiPotential(units=galactic,
                                  m=1.E11, a=6.5, b=0.26)
    potential = CompositePotential()
    potential['disk'] = p2
    potential['halo'] = p1
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestCComposite(CompositePotentialTestBase):
    p1 = p.LogarithmicPotential(units=galactic,
                                v_c=0.17, r_h=10.,
                                q1=1.2, q2=1., q3=0.8)
    p2 = p.MiyamotoNagaiPotential(units=galactic,
                                  m=1.E11, a=6.5, b=0.26)
    potential = CCompositePotential()
    potential['disk'] = p2
    potential['halo'] = p1
    w0 = [19.0, 2.7, -6.9, 0.0352238, -0.03579493, 0.075]


class TestKepler3Body(CompositePotentialTestBase):
    &quot;&quot;&quot; This implicitly tests the origin shift &quot;&quot;&quot;
    mu = 1/11.
    x1 = -mu
    m1 = 1-mu
    x2 = 1-mu
    m2 = mu
    potential = CCompositePotential()
    potential['m1'] = p.KeplerPotential(m=m1, origin=[x1, 0, 0.])
    potential['m2'] = p.KeplerPotential(m=m2, origin=[x2, 0, 0.])

    Omega = np.array([0, 0, 1.])
    frame = ConstantRotatingFrame(Omega=Omega)
    w0 = [0.5, 0, 0, 0., 1.05800316, 0.]


@pytest.mark.skipif(not GSL_ENABLED,
                    reason=&quot;requires GSL to run this test&quot;)
class TestMultipoleInner(CompositePotentialTestBase):
    potential_1 = p.NFWPotential(m=1E12, r_s=15., units=galactic)
    potential = potential_1 + p.MultipolePotential(
        units=galactic, m=1E10, r_s=15., inner=True,
        lmax=2, S10=1., S21=0.5)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]

    @pytest.mark.skip(reason=&quot;Not implemented for multipole potentials&quot;)
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason=&quot;Not implemented for multipole potentials&quot;)
    def test_against_sympy(self):
        pass


@pytest.mark.skipif(not GSL_ENABLED,
                    reason=&quot;requires GSL to run this test&quot;)
class TestMultipoleOuter(CompositePotentialTestBase):
    potential_1 = p.NFWPotential(m=1E12, r_s=15., units=galactic)
    potential = potential_1 + p.MultipolePotential(
        units=galactic, m=1E10, r_s=15., inner=False,
        lmax=2, S10=1., S21=0.5)
    vc = potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic).value[0]
    w0 = [19.0, 0.2, -0.9, 0., vc, 0.]
    check_finite_at_origin = False

    @pytest.mark.skip(reason=&quot;Not implemented for multipole potentials&quot;)
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason=&quot;Not implemented for multipole potentials&quot;)
    def test_against_sympy(self):
        pass


@pytest.mark.skipif(not GSL_ENABLED,
                    reason=&quot;requires GSL to run this test&quot;)
class TestCylspline(PotentialTestBase):
    check_finite_at_origin = True

    def setup_method(self):
        self.potential = p.CylSplinePotential.from_file(
            get_pkg_data_filename('pot_disk_506151.pot'),
            units=galactic
        )
        vc = self.potential.circular_velocity([19., 0, 0]*u.kpc).decompose(galactic)
        self.w0 = [19.0, 0.2, -0.9, 0., vc.value[0], 0.]
        super().setup_method()

    @pytest.mark.skip(reason=&quot;Not implemented for cylspline potentials&quot;)
    def test_density(self):
        pass

    @pytest.mark.skip(reason=&quot;Not implemented for cylspline potentials&quot;)
    def test_hessian(self):
        pass

    @pytest.mark.skip(reason=&quot;Not implemented for cylspline potentials&quot;)
    def test_against_sympy(self):
        pass

    def test_against_agama(self):
        agama_tbl = at.QTable.read(get_pkg_data_filename('agama_cylspline_test.fits'))

        gala_ene = self.potential.energy(agama_tbl['xyz'].T)
        gala_acc = self.potential.acceleration(agama_tbl['xyz'].T)

        assert u.allclose(gala_ene, agama_tbl['pot'][:, 0], rtol=1e-3)
        for i in range(3):
            assert u.allclose(gala_acc[i], agama_tbl['acc'][:, i], rtol=1e-2)


class TestBurkert(PotentialTestBase):
    potential = p.BurkertPotential(units=galactic, rho=5e-25 * u.g / u.cm ** 3, r0=12 * u.kpc)
    w0 = [1., 0., 0., 0., 0.1, 0.1]

    check_finite_at_origin = False

    @pytest.mark.skip(reason=&quot;Not implemented for Burkert potentials&quot;)
    def test_against_sympy(self):
        pass

    @pytest.mark.skip(reason=&quot;Hessian not implemented for Burkert potential&quot;)
    def test_hessian(self):
        pass

    def test_from_r0(self):
        # Test against values from Zhu+2023
        pot = p.BurkertPotential.from_r0(r0=11.87 * u.kpc, units=galactic)

        rho = pot.parameters['rho'].to(u.g / u.cm ** 3)
        rho_check = 5.93e-25 * u.g / u.cm ** 3

        # Check a 1% tolerance on inferred density against published values
        assert abs(rho - rho_check) / rho_check &lt; 0.01
</file>
    <file path="gala/potential/potential/tests/test_composite.py">
# Third party
import astropy.units as u
import pytest
import numpy as np

# This project
from ..core import PotentialBase, CompositePotential
from ...common import PotentialParameter
from ..builtin import (KeplerPotential, HernquistPotential,
                       HenonHeilesPotential)

from ..ccompositepotential import CCompositePotential
from ...hamiltonian import Hamiltonian
from ....integrate import LeapfrogIntegrator, DOPRI853Integrator
from ....units import solarsystem, galactic


class CompositeHelper:

    def setup_method(self):
        self.units = solarsystem
        self.p1 = KeplerPotential(m=1.*u.Msun, units=self.units)
        self.p2 = HernquistPotential(m=0.5*u.Msun, c=0.1*u.au,
                                     units=self.units)

    def test_shit(self):
        potential = self.Cls(one=self.p1, two=self.p2)

        q = np.ascontiguousarray(np.array([[1.1, 0, 0]]).T)
        print(&quot;val&quot;, potential.energy(q))

        q = np.ascontiguousarray(np.array([[1.1, 0, 0]]).T)
        print(&quot;grad&quot;, potential.gradient(q))

    def test_composite_create(self):
        potential = self.Cls()

        # Add a point mass with same unit system
        potential[&quot;one&quot;] = KeplerPotential(units=self.units, m=1.)

        with pytest.raises(TypeError):
            potential[&quot;two&quot;] = &quot;derp&quot;

        assert &quot;one&quot; in potential.parameters
        assert &quot;m&quot; in potential.parameters[&quot;one&quot;]
        with pytest.raises(TypeError):
            potential.parameters[&quot;m&quot;] = &quot;derp&quot;

    def test_plot_composite(self):
        # TODO: do image comparison or something to compare?

        potential = self.Cls()

        # Add a kepler potential and a harmonic oscillator
        potential[&quot;one&quot;] = self.p1
        potential[&quot;two&quot;] = self.p2

        grid = np.linspace(-5., 5)
        potential.plot_contours(grid=(grid, 0., 0.))
        # fig.savefig(os.path.join(plot_path, &quot;composite_kepler_sho_1d.png&quot;))

        potential.plot_contours(grid=(grid, grid, 0.))
        # fig.savefig(os.path.join(plot_path, &quot;composite_kepler_sho_2d.png&quot;))

    def test_integrate(self):
        potential = self.Cls()
        potential[&quot;one&quot;] = self.p1
        potential[&quot;two&quot;] = self.p2

        for Integrator in [DOPRI853Integrator, LeapfrogIntegrator]:
            H = Hamiltonian(potential)
            w_cy = H.integrate_orbit([1., 0, 0, 0, 2*np.pi, 0], dt=0.01,
                                     n_steps=1000,
                                     Integrator=Integrator,
                                     cython_if_possible=True)
            w_py = H.integrate_orbit([1., 0, 0, 0, 2*np.pi, 0], dt=0.01,
                                     n_steps=1000,
                                     Integrator=Integrator,
                                     cython_if_possible=False)

            assert np.allclose(w_cy.xyz.value, w_py.xyz.value)
            assert np.allclose(w_cy.v_xyz.value, w_py.v_xyz.value)

# ------------------------------------------------------------------------


class TestComposite(CompositeHelper):
    Cls = CompositePotential


class TestCComposite(CompositeHelper):
    Cls = CCompositePotential


def test_failures():
    p = CCompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    with pytest.raises(ValueError):
        p['jnsdfn'] = HenonHeilesPotential(units=solarsystem)


def test_lock():
    p = CompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    p.lock = True
    with pytest.raises(ValueError):  # try adding potential after lock
        p['herp'] = KeplerPotential(m=2.*u.Msun, units=solarsystem)

    p = CCompositePotential()
    p['derp'] = KeplerPotential(m=1.*u.Msun, units=solarsystem)
    p.lock = True
    with pytest.raises(ValueError):  # try adding potential after lock
        p['herp'] = KeplerPotential(m=2.*u.Msun, units=solarsystem)


class MyPotential(PotentialBase):
    m = PotentialParameter('m', physical_type='mass')
    x0 = PotentialParameter('x0', physical_type='length')

    def _energy(self, x, t):
        m = self.parameters['m']
        x0 = self.parameters['x0']
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return -m/r

    def _gradient(self, x, t):
        m = self.parameters['m']
        x0 = self.parameters['x0']
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return m*(x-x0[None])/r**3


def test_add():
    &quot;&quot;&quot; Test adding potentials to get a composite &quot;&quot;&quot;
    p1 = KeplerPotential(units=galactic, m=1*u.Msun)
    p2 = HernquistPotential(units=galactic,
                            m=1.E11, c=0.26)

    comp1 = CompositePotential()
    comp1['0'] = p1
    comp1['1'] = p2

    py_p1 = MyPotential(m=1., x0=[1., 0., 0.], units=galactic)
    py_p2 = MyPotential(m=4., x0=[-1., 0., 0.], units=galactic)

    # python + python
    new_p = py_p1 + py_p2
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # python + python + python
    new_p = py_p1 + py_p2 + py_p2
    assert isinstance(new_p, CompositePotential)
    assert len(new_p.keys()) == 3

    # cython + cython
    new_p = p1 + p2
    assert isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # cython + python
    new_p = py_p1 + p2
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 2

    # cython + cython + python
    new_p = p1 + p2 + py_p1
    assert isinstance(new_p, CompositePotential)
    assert not isinstance(new_p, CCompositePotential)
    assert len(new_p.keys()) == 3
</file>
    <file path="gala/potential/potential/tests/test_core.py">
&quot;&quot;&quot;
    Test the core Potential classes
&quot;&quot;&quot;

# Third party
import pytest
import numpy as np
from astropy.constants import G
import astropy.units as u
from matplotlib import cm

# This package
from ..core import PotentialBase, CompositePotential
from ...common import PotentialParameter
from ....units import UnitSystem

units = [u.kpc, u.Myr, u.Msun, u.radian]
usys = UnitSystem(u.au, u.yr, u.Msun, u.radian)
G = G.decompose(units)


def test_new_simple():

    class MyPotential(PotentialBase):
        ndim = 1

        def _energy(self, r, t=0.):
            return -1/r

        def _gradient(self, r, t=0.):
            return r**-2

    p = MyPotential()
    assert p(0.5) == -2.
    assert p.energy(0.5) == -2.
    assert p.acceleration(0.5) == -4.

    p(np.arange(0.5, 11.5, 0.5).reshape(1, -1))
    p.energy(np.arange(0.5, 11.5, 0.5).reshape(1, -1))
    p.acceleration(np.arange(0.5, 11.5, 0.5).reshape(1, -1))


class MyPotential(PotentialBase):
    m = PotentialParameter('m', 'mass')
    x0 = PotentialParameter('x0', 'length')

    def _energy(self, x, t):
        m = self.parameters['m'].value
        x0 = self.parameters['x0'].value
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return -m/r

    def _gradient(self, x, t):
        m = self.parameters['m'].value
        x0 = self.parameters['x0'].value
        r = np.sqrt(np.sum((x-x0[None])**2, axis=1))
        return m*(x-x0[None])/r**3


def test_init_potential():
    MyPotential(1.5, 1)
    MyPotential(1.5, x0=1)
    MyPotential(m=1.5, x0=1)
    MyPotential(1.5*u.Msun, 1*u.au, units=usys)
    MyPotential(1.5*u.Msun, x0=1*u.au, units=usys)
    MyPotential(m=1.5*u.Msun, x0=1*u.au, units=usys)


def test_repr():
    p = MyPotential(m=1.E10*u.Msun, x0=0., units=usys)
    _repr = p.__repr__()
    assert _repr.startswith(&quot;&lt;MyPotential: m=&quot;)
    assert &quot;m=1&quot; in _repr
    assert &quot;x0=0&quot; in _repr
    assert _repr.endswith(&quot;(AU,yr,solMass,rad)&gt;&quot;)
    # assert p.__repr__() == &quot;&lt;MyPotential: m=1.00e+10, x0=0.00e+00 (AU, yr, solMass, rad)&gt;&quot;


def test_plot():
    p = MyPotential(m=1, x0=[1., 3., 0.], units=usys)
    f = p.plot_contours(grid=(np.linspace(-10., 10., 100), 0., 0.),
                        labels=[&quot;X&quot;])
    # f.suptitle(&quot;slice off from 0., won't have cusp&quot;)
    # f.savefig(os.path.join(plot_path, &quot;contour_x.png&quot;))

    f = p.plot_contours(grid=(np.linspace(-10., 10., 100),  # noqa
                              np.linspace(-10., 10., 100),
                              0.),
                        cmap=cm.Blues)
    # f.savefig(os.path.join(plot_path, &quot;contour_xy.png&quot;))

    f = p.plot_contours(grid=(np.linspace(-10., 10., 100), # noqa
                              1.,
                              np.linspace(-10., 10., 100)),
                        cmap=cm.Blues, labels=[&quot;X&quot;, &quot;Z&quot;])
    # f.savefig(os.path.join(plot_path, &quot;contour_xz.png&quot;))


def test_composite():
    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=usys)

    p = CompositePotential(one=p1, two=p2)
    assert u.allclose(p.energy([0., 0., 0.]), -2*usys['energy']/usys['mass'])
    assert u.allclose(p.acceleration([0., 0., 0.]), 0.*usys['acceleration'])

    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=[u.kpc, u.yr, u.Msun, u.radian])
    with pytest.raises(ValueError):
        p = CompositePotential(one=p1, two=p2)

    p1 = MyPotential(m=1., x0=[1., 0., 0.], units=usys)
    p2 = MyPotential(m=1., x0=[-1., 0., 0.], units=usys)
    p = CompositePotential(one=p1, two=p2)
    assert u.au in p.units
    assert u.yr in p.units
    assert u.Msun in p.units


def test_replace_units():
    usys1 = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    usys2 = UnitSystem([u.pc, u.Myr, u.Msun, u.degree])

    p = MyPotential(m=1.E10*u.Msun, x0=0., units=usys1)
    assert p.parameters['m'].unit == usys1['mass']

    p2 = p.replace_units(usys2)
    assert p2.parameters['m'].unit == usys2['mass']
    assert p.units == usys1
    assert p2.units == usys2


def test_replicate():
    usys = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    R = np.diag(np.arange(3))
    p1 = MyPotential(m=1.E10*u.Msun, x0=0., units=usys, R=R)
    p2 = p1.replicate(m=2e10*u.Msun, R=None)

    assert p2.R is None
    assert np.isclose(p2.parameters['m'].value, 2e10)
    assert np.isclose(p2.parameters['x0'].value, p1.parameters['x0'].value)
</file>
    <file path="gala/potential/potential/tests/test_cpotential.py">
# Third party
import astropy.units as u

# This package
from ..builtin import HernquistPotential
from ....units import UnitSystem


def test_replace_units():
    usys1 = UnitSystem([u.kpc, u.Gyr, u.Msun, u.radian])
    usys2 = UnitSystem([u.pc, u.Myr, u.Msun, u.degree])

    p = HernquistPotential(m=1E10*u.Msun, c=1.*u.kpc, units=usys1)
    assert p.parameters['m'].unit == usys1['mass']
    assert p.parameters['c'].unit == usys1['length']

    p2 = p.replace_units(usys2)
    assert p2.parameters['m'].unit == usys2['mass']
    assert p2.parameters['c'].unit == usys2['length']
    assert p.units == usys1
    assert p2.units == usys2
</file>
    <file path="gala/potential/potential/tests/test_interop_agama.py">
&quot;&quot;&quot;
Test converting the builtin Potential classes to Agama
&quot;&quot;&quot;

# Third-party
import astropy.units as u
import numpy as np
import pytest

# This project
from gala.potential import JaffePotential, LogarithmicPotential, MiyamotoNagaiPotential
from gala.tests.optional_deps import HAS_AGAMA
from gala.units import galactic

if HAS_AGAMA:
    from gala.potential.potential.interop import _gala_to_agama


def pytest_generate_tests(metafunc):
    # Some magic, semi-random numbers below!
    gala_pots = []
    other_pots = []

    if not HAS_AGAMA:
        return

    # Test the Gala -&gt; Agama direction
    for Potential in _gala_to_agama.keys():
        init = {}
        len_scale = 1.0
        for k, par in Potential._parameters.items():
            if k == &quot;m&quot;:
                val = 1.43e10 * u.Msun
            elif par.physical_type == &quot;length&quot;:
                val = 5.12 * u.kpc * len_scale
                len_scale *= 0.5
            elif par.physical_type == &quot;dimensionless&quot;:
                val = 1.0
            elif par.physical_type == &quot;speed&quot;:
                val = 201.41 * u.km / u.s
            else:
                continue

            init[k] = val

        pot = Potential(**init, units=galactic)
        other_pot = pot.as_interop(&quot;agama&quot;)

        gala_pots.append(pot)
        other_pots.append(other_pot)

    # Make a composite potential too:
    gala_pots.append(gala_pots[0] + gala_pots[1])
    other_pots.append(gala_pots[-1].as_interop(&quot;agama&quot;))

    test_names = [
        f&quot;{g1.__class__.__name__}:{g2.__class__.__name__}&quot;
        for g1, g2 in zip(gala_pots, other_pots)
    ]

    metafunc.parametrize(
        [&quot;gala_pot&quot;, &quot;other_pot&quot;], list(zip(gala_pots, other_pots)), ids=test_names
    )


@pytest.mark.skipif(
    not HAS_AGAMA, reason=&quot;must have agama installed to run these tests&quot;
)
class TestAgamaInterop:
    def setup_method(self):
        # Test points:
        rng = np.random.default_rng(42)
        ntest = 4

        xyz = rng.uniform(-25, 25, size=(3, ntest)) * u.kpc
        self.xyz = xyz.copy()

    def test_density(self, gala_pot, other_pot):
        gala_val = gala_pot.density(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.density(self.xyz.decompose(gala_pot.units).value.T)
        assert np.allclose(gala_val, other_val)

    def test_energy(self, gala_pot, other_pot):
        if isinstance(gala_pot, LogarithmicPotential):
            # TODO: Agama has an inconsistency with Gala's log potential energy
            pytest.skip()
        gala_val = gala_pot.energy(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.potential(self.xyz.decompose(gala_pot.units).value.T)
        assert np.allclose(gala_val, other_val)

    def test_acc(self, gala_pot, other_pot):
        gala_val = gala_pot.acceleration(self.xyz).decompose(gala_pot.units).value
        other_val = other_pot.force(self.xyz.decompose(gala_pot.units).value.T).T
        assert np.allclose(gala_val, other_val)

    def test_Menc(self, gala_pot, other_pot):
        if isinstance(
            gala_pot, (LogarithmicPotential, JaffePotential, MiyamotoNagaiPotential)
        ):
            # TODO: Agama has an inconsistency with Gala's log potential energy
            pytest.skip()

        grid = np.zeros((3, 128))
        grid[0] = np.geomspace(1e-3, 100.0, 128)

        gala_val = gala_pot.mass_enclosed(grid).value
        agama_val = other_pot.enclosedMass(grid[0])
        assert np.allclose(gala_val, agama_val)
</file>
    <file path="gala/potential/potential/tests/test_interop_galpy.py">
&quot;&quot;&quot;
Test converting the builtin Potential classes to other packages
&quot;&quot;&quot;

# Third-party
import astropy.units as u
import numpy as np
import pytest
from astropy.coordinates import CylindricalRepresentation

# This project
import gala.potential as gp
from gala.potential.potential.interop import galpy_to_gala_potential
from gala.tests.optional_deps import HAS_GALPY
from gala.units import galactic

# Set these globally!
ro = 8.122 * u.kpc
vo = 245 * u.km / u.s

if HAS_GALPY:
    import galpy.potential as galpy_gp

    from gala.potential.potential.interop import _gala_to_galpy, _galpy_to_gala


def pytest_generate_tests(metafunc):
    # Some magic, semi-random numbers below!
    gala_pots = []
    galpy_pots = []

    if not HAS_GALPY:
        return

    # Test the Gala -&gt; Galpy direction
    for Potential in _gala_to_galpy.keys():
        init = {}
        len_scale = 1.0
        for k, par in Potential._parameters.items():
            if k == &quot;m&quot;:
                val = 1.43e10 * u.Msun
            elif par.physical_type == &quot;length&quot;:
                val = 5.12 * u.kpc * len_scale
                len_scale *= 0.5
            elif par.physical_type == &quot;dimensionless&quot;:
                val = 1.0
            elif par.physical_type == &quot;speed&quot;:
                val = 201.41 * u.km / u.s
            else:
                continue

            init[k] = val

        pot = Potential(**init, units=galactic)
        galpy_pot = pot.as_interop(&quot;galpy&quot;, ro=ro, vo=vo)

        gala_pots.append(pot)
        galpy_pots.append(galpy_pot)

        # Custom settings in the MN3 potential:
        if isinstance(pot, gp.MN3ExponentialDiskPotential):
            pot = Potential(**init, units=galactic, sech2_z=False)
            galpy_pot = pot.to_galpy_potential(ro=ro, vo=vo)
            gala_pots.append(pot)
            galpy_pots.append(galpy_pot)

    # Make a composite potential too:
    gala_pots.append(gala_pots[0] + gala_pots[1])
    galpy_pots.append([galpy_pots[0], galpy_pots[1]])

    # Test the Galpy -&gt; Gala direction
    for Potential in _galpy_to_gala.keys():
        galpy_pot = Potential(ro=ro, vo=vo)  # use defaults

        if isinstance(galpy_pot, galpy_gp.MN3ExponentialDiskPotential):
            with pytest.warns():
                pot = galpy_to_gala_potential(galpy_pot, ro=ro, vo=vo)
        else:
            pot = galpy_to_gala_potential(galpy_pot, ro=ro, vo=vo)

        gala_pots.append(pot)
        galpy_pots.append(galpy_pot)

    test_names = [
        f&quot;{g1.__class__.__name__}:{g2.__class__.__name__}&quot;
        for g1, g2 in zip(gala_pots, galpy_pots)
    ]

    metafunc.parametrize(
        [&quot;gala_pot&quot;, &quot;galpy_pot&quot;], list(zip(gala_pots, galpy_pots)), ids=test_names
    )


@pytest.mark.skipif(
    not HAS_GALPY, reason=&quot;must have galpy installed to run these tests&quot;
)
class TestGalpy:
    def setup_method(self):
        # Test points:
        rng = np.random.default_rng(42)
        ntest = 4

        Rs = rng.uniform(1, 15, size=ntest) * u.kpc
        phis = rng.uniform(0, 2 * np.pi, size=ntest) * u.radian
        zs = rng.uniform(1, 15, size=ntest) * u.kpc

        cyl = CylindricalRepresentation(Rs, phis, zs)
        xyz = cyl.to_cartesian().xyz

        self.Rs = Rs.to_value(ro)
        self.phis = phis.to_value(u.rad)
        self.zs = zs.to_value(ro)
        self.Rpz_iter = np.array(list(zip(self.Rs, self.phis, self.zs))).copy()

        self.xyz = xyz.copy()

        Jac = np.zeros((len(cyl), 3, 3))
        Jac[:, 0, 0] = xyz[0] / cyl.rho
        Jac[:, 0, 1] = xyz[1] / cyl.rho
        Jac[:, 1, 0] = (-xyz[1] / cyl.rho**2).to_value(1 / ro)
        Jac[:, 1, 1] = (xyz[0] / cyl.rho**2).to_value(1 / ro)
        Jac[:, 2, 2] = 1.0
        self.Jac = Jac

    def test_density(self, gala_pot, galpy_pot):
        if isinstance(gala_pot, gp.LogarithmicPotential):
            pytest.skip()

        gala_val = gala_pot.density(self.xyz).to_value(u.Msun / u.pc**3)
        galpy_val = np.array(
            [
                galpy_gp.evaluateDensities(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        assert np.allclose(gala_val, galpy_val)

    def test_energy(self, gala_pot, galpy_pot):
        gala_val = gala_pot.energy(self.xyz).to_value(u.km**2 / u.s**2)
        galpy_val = np.array(
            [
                galpy_gp.evaluatePotentials(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )

        if isinstance(gala_pot, gp.LogarithmicPotential):
            # Logarithms are weird
            gala_val -= (
                0.5 * gala_pot.parameters[&quot;v_c&quot;] ** 2 * np.log(ro.value**2)
            ).to_value((u.km / u.s) ** 2)

        assert np.allclose(gala_val, galpy_val)

    def test_gradient(self, gala_pot, galpy_pot):
        gala_grad = gala_pot.gradient(self.xyz)
        gala_grad = gala_grad.to_value(u.km / u.s / u.Myr)

        # TODO: Starting with galpy 1.7, this has been failing because of a
        # units issue with dPhi/dphi
        if isinstance(gala_pot, gp.LongMuraliBarPotential):
            pytest.skip()

        galpy_dR = np.array(
            [
                -galpy_gp.evaluateRforces(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dp = np.array(
            [
                -galpy_gp.evaluatephitorques(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dp = (galpy_dp * (u.km / u.s) ** 2).to_value(vo**2)

        galpy_dz = np.array(
            [
                -galpy_gp.evaluatezforces(galpy_pot, R=RR, z=zz, phi=pp)
                for RR, pp, zz in self.Rpz_iter
            ]
        )
        galpy_dRpz = np.stack((galpy_dR, galpy_dp, galpy_dz), axis=1)

        galpy_grad = np.einsum(&quot;nij,ni-&gt;nj&quot;, self.Jac, galpy_dRpz).T

        assert np.allclose(gala_grad, galpy_grad)

    def test_vcirc(self, gala_pot, galpy_pot):
        tmp = self.xyz.copy()
        tmp[2] = 0.0

        if not hasattr(galpy_pot, &quot;vcirc&quot;) or isinstance(
            gala_pot, gp.LongMuraliBarPotential
        ):
            pytest.skip()

        gala_vcirc = gala_pot.circular_velocity(tmp).to_value(u.km / u.s)
        galpy_vcirc = np.array([galpy_pot.vcirc(R=RR) for RR, *_ in self.Rpz_iter])
        assert np.allclose(gala_vcirc, galpy_vcirc)
</file>
    <file path="gala/potential/potential/tests/test_io.py">
&quot;&quot;&quot; test reading/writing potentials to files &quot;&quot;&quot;

# Third-party
import astropy.units as u
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# Project
from ..io import load, save
from ..core import CompositePotential
from ..ccompositepotential import CCompositePotential
from ..builtin import IsochronePotential, KeplerPotential
from ..builtin.special import LM10Potential
from ...scf import SCFPotential
from ....units import DimensionlessUnitSystem, galactic
from gala._cconfig import GSL_ENABLED


def test_read_plummer():
    potential = load(get_pkg_data_filename('Plummer.yml'))
    assert np.allclose(potential.parameters['m'].value, 100000000000.)
    assert np.allclose(potential.parameters['b'].value, 0.26)
    assert potential.parameters['b'].unit == u.kpc


def test_read_harmonic_oscillator():
    potential = load(get_pkg_data_filename('HarmonicOscillator1D.yml'))
    assert isinstance(potential.units, DimensionlessUnitSystem)


def test_read_composite():
    potential = load(get_pkg_data_filename('Composite.yml'))
    assert 'halo' in potential.keys()
    assert 'disk' in potential.keys()
    assert str(potential) == &quot;CompositePotential&quot;
    assert potential.units['length'] == u.kpc
    assert potential.units['speed'] == u.km/u.s


def test_read_lm10():
    potential = load(get_pkg_data_filename('lm10.yml'))
    assert 'halo' in potential.keys()
    assert 'disk' in potential.keys()
    assert str(potential) == &quot;LM10Potential&quot;
    assert np.allclose(potential['disk'].parameters['a'].value, 10)
    assert np.allclose(potential['disk'].parameters['b'].value, 0.26)
    assert np.allclose(potential['disk'].parameters['m'].value, 150000.)


def test_write_isochrone(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # try a simple potential
    potential = IsochronePotential(m=1E11, b=0.76, units=galactic)

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_isochrone_units(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # try a simple potential with units
    potential = IsochronePotential(m=1E11*u.Msun, b=0.76*u.kpc, units=galactic)

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_lm10(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # more complex
    potential = LM10Potential(disk=dict(m=5E12*u.Msun))
    potential_default = LM10Potential()
    v1 = potential.energy([4., 0, 0])
    v2 = potential_default.energy([4., 0, 0])

    with open(tmp_filename, 'w') as f:
        save(potential, f)

    save(potential, tmp_filename)
    p = load(tmp_filename)
    assert u.allclose(p['disk'].parameters['m'], 5E12*u.Msun)
    assert u.allclose(v1, p.energy([4., 0, 0]))
    assert not u.allclose(v2, p.energy([4., 0, 0]))


def test_write_composite(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))
    print(tmp_filename)

    # composite potential
    potential = CompositePotential(halo=KeplerPotential(m=1E11, units=galactic),
                                   bulge=IsochronePotential(m=1E11, b=0.76, units=galactic))
    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_write_ccomposite(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # composite potential
    potential = CCompositePotential(halo=KeplerPotential(m=1E11, units=galactic),
                                    bulge=IsochronePotential(m=1E11, b=0.76, units=galactic))
    save(potential, tmp_filename)
    p = load(tmp_filename)


def test_units(tmpdir):
    import astropy.units as u

    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # try a simple potential
    potential = KeplerPotential(m=1E11, units=[u.kpc, u.Gyr, u.Msun, u.radian])
    save(potential, tmp_filename)
    p = load(tmp_filename)


@pytest.mark.skipif(not GSL_ENABLED,
                    reason=&quot;requires GSL to run this test&quot;)
def test_read_write_SCF(tmpdir):
    tmp_filename = str(tmpdir.join(&quot;potential.yml&quot;))

    # try a basic SCF potential
    potential = SCFPotential(100, 1, np.zeros((4, 3, 2)), np.zeros((4, 3, 2)))
    save(potential, tmp_filename)
    p = load(tmp_filename)
</file>
    <file path="gala/potential/potential/tests/test_special.py">
&quot;&quot;&quot;
    Test the special potentials...
&quot;&quot;&quot;

# Third-party
import astropy.units as u
import pytest

from ...._cconfig import GSL_ENABLED
from ..builtin.special import (
    BovyMWPotential2014,
    LM10Potential,
    MilkyWayPotential,
    MilkyWayPotential2022,
)

# This project
from .helpers import CompositePotentialTestBase


class TestLM10Potential(CompositePotentialTestBase):
    potential = LM10Potential()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestLM10Potential2(CompositePotentialTestBase):
    potential = LM10Potential(disk={&quot;m&quot;: 5e10 * u.Msun}, bulge={&quot;m&quot;: 5e10 * u.Msun})
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestMilkyWayPotential(CompositePotentialTestBase):
    potential = MilkyWayPotential()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


class TestMilkyWayPotential2022(CompositePotentialTestBase):
    potential = MilkyWayPotential2022()
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]


@pytest.mark.skipif(not GSL_ENABLED, reason=&quot;requires GSL to run this test&quot;)
class TestBovyMWPotential2014(CompositePotentialTestBase):
    w0 = [8.0, 0.0, 0.0, 0.0, 0.22, 0.1]
    check_finite_at_origin = False

    def setup_method(self):
        self.potential = BovyMWPotential2014()
        super().setup_method()

    check_finite_at_origin = False
</file>
    <file path="gala/potential/potential/tests/test_util.py">
import pytest

# This project
from ..util import from_equation
from .helpers import PotentialTestBase
from gala.tests.optional_deps import HAS_SYMPY


class EquationBase(PotentialTestBase):
    def test_plot(self):
        # Skip for now because contour plotting assumes 3D
        pass

    def test_pickle(self):
        # Skip for now because these are not picklable
        pass

    def test_save_load(self):
        # Skip for now because these can't be written to YAML
        pass


if HAS_SYMPY:
    class TestHarmonicOscillatorFromEquation(EquationBase):
        check_finite_at_origin = False

        Potential = from_equation(&quot;1/2*k*x**2&quot;, vars=&quot;x&quot;, pars=&quot;k&quot;,
                                  name='HarmonicOscillator',
                                  hessian=True)
        potential = Potential(k=1.)
        w0 = [1., 0.]

        def test_derp(self):
            import numpy as np
            self.potential.gradient(np.random.random(size=(1, 13)))

        @pytest.mark.skip(reason=&quot;to_sympy() not implemented&quot;)
        def test_against_sympy(self):
            pass


# class TestHarmonicOscillatorFromEquationUnits(EquationBase):
#     Potential = from_equation(&quot;1/2*k*x**2&quot;, vars=&quot;x&quot;, pars=&quot;k&quot;,
#                               name='HarmonicOscillator',
#                               hessian=True)
#     potential = Potential(k=1., units=solarsystem)
#     w0 = [1., 0.]

# class TestKeplerFromEquation(EquationBase):
#     Potential = from_equation(&quot;-G*M/sqrt(x**2+y**2+z**2)&quot;, vars=[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;],
#                               pars=[&quot;G&quot;,&quot;M&quot;], name='Kepler',
#                               hessian=True)
#     potential = Potential(G=1., M=1., units=solarsystem)
#     w0 = [1., 0., 0., 0., 6.28, 0.]
</file>
    <file path="gala/potential/scf/tests/data/README.md">
Note: the data in here was generated using the scripts in https://github.com/adrn/biff
</file>
    <file path="gala/potential/scf/tests/test_bfe_interp.py">
# coding: utf-8

# Third-party
import astropy.units as u
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from gala.units import galactic
from gala.potential.scf import SCFPotential, SCFInterpolatedPotential

if not GSL_ENABLED:
    pytest.skip(&quot;skipping SCF tests: they depend on GSL&quot;,
                allow_module_level=True)


@pytest.mark.parametrize('func_name', ['energy', 'density', 'gradient'])
def test_simple_compare_noninterp(func_name):
    &quot;&quot;&quot;
    Compare the interpolated to time-invariant versions for a trivial case
    &quot;&quot;&quot;
    rng = np.random.default_rng(42)
    nmax = 5
    lmax = 3

    Snlm = rng.uniform(size=(nmax+1, lmax+1, lmax+1))
    Tnlm = np.zeros_like(Snlm)

    tj = np.linspace(0, 1000, 16)
    Sjnlm = np.repeat(Snlm[None], len(tj), axis=0)
    Tjnlm = np.repeat(Tnlm[None], len(tj), axis=0)

    m = 1e9
    r_s = 10.

    pot_static = SCFPotential(m=m, r_s=r_s, Snlm=Snlm, Tnlm=Tnlm, units=galactic)
    pot_t = SCFInterpolatedPotential(
        m=m, r_s=r_s, tj=tj, Sjnlm=Sjnlm, Tjnlm=Tjnlm, units=galactic,
        com_xj=np.zeros((3, len(tj))), com_vj=np.zeros((3, len(tj)))
    )

    test_xyz = rng.uniform(-10, 10, size=(3, 10))
    test_t = rng.uniform(0, 1000, size=16)
    for t in test_t:
        t_val = getattr(pot_t, func_name)(test_xyz, t=t)
        static_val = getattr(pot_static, func_name)(test_xyz, t=t)
        assert u.allclose(t_val, static_val)
</file>
    <file path="gala/potential/scf/tests/test_computecoeff_fortran.py">
# coding: utf-8

# Standard library
import os
from math import factorial as _factorial

# Third-party
from astropy.utils.data import get_pkg_data_filename
import numpy as np
import pytest

# Project
from gala._cconfig import GSL_ENABLED
from ..core import compute_coeffs_discrete

if not GSL_ENABLED:
    pytest.skip(&quot;skipping SCF tests: they depend on GSL&quot;,
                allow_module_level=True)

# Compare coefficients computed with Fortran to Biff


def factorial(x):
    return _factorial(int(x))


@pytest.mark.parametrize(&quot;basename&quot;, [
    'hernquist'
])
def test_coeff(basename):
    nmax = 6
    lmax = 10  # HACK: these are hard-set in Fortran

    pos_path = os.path.abspath(get_pkg_data_filename('data/{}-samples.dat.gz'.format(basename)))
    coeff_path = os.path.abspath(get_pkg_data_filename('data/computed-{0}.coeff'.format(basename)))
    coeff = np.atleast_2d(np.loadtxt(coeff_path))

    xyz = np.ascontiguousarray(np.loadtxt(pos_path, skiprows=1))
    S, T = compute_coeffs_discrete(xyz, mass=np.zeros(xyz.shape[0])+1./xyz.shape[0],
                                   nmax=nmax, lmax=lmax, r_s=1.)

    S_f77 = np.zeros((nmax+1, lmax+1, lmax+1))
    T_f77 = np.zeros((nmax+1, lmax+1, lmax+1))
    for row in coeff:
        n, l, m, cc, sc = row

        # transform from H&amp;O 1992 coefficients to Lowing 2011 coefficients
        if l != 0:
            fac = np.sqrt(4*np.pi) * np.sqrt((2*l+1) / (4*np.pi) * factorial(l-m) / factorial(l+m))
            cc /= fac
            sc /= fac

        S_f77[int(n), int(l), int(m)] = -cc
        T_f77[int(n), int(l), int(m)] = -sc

    assert np.allclose(S_f77, S)
</file>
    <file path="gala/tests/setup_package.py">
def get_package_data():
    return {'gala.tests': ['coveragerc']}
</file>
    <file path="gala/tests/test_util.py">
# Third-party
import pytest

# Project
from ..util import ImmutableDict


def test_immutabledict():
    a = dict(a=5, c=6)
    b = ImmutableDict(**a)

    with pytest.raises(TypeError):
        b['test'] = 5
</file>
    <file path="gala/dynamics/__init__.py">
from .core import PhaseSpacePosition
from .orbit import Orbit
from .actionangle import *
from .nonlinear import *
from .plot import *
from .util import *
from .representation_nd import *
from .nbody import *
from .mockstream import *
</file>
    <file path="gala/potential/__init__.py">
from .potential import *
from .hamiltonian import *
from .frame import *
from .scf import SCFPotential
from .common import PotentialParameter
</file>
    <file path="gala/potential/scf/__init__.py">
&quot;&quot;&quot;
Implementation of the Self-Consistent Field (SCF) expansion method.
&quot;&quot;&quot;

from .core import compute_coeffs, compute_coeffs_discrete
from ._bfe_class import SCFPotential, SCFInterpolatedPotential
</file>
    <file path="gala/integrate/__init__.py">
from .pyintegrators import *
from .timespec import *
</file>
  </repository_files>
</compressed_repository>
